(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var a,o,s=e[0],l=e[1],d=e[2],u=0,p=[];u<s.length;u++)o=s[u],Object.prototype.hasOwnProperty.call(r,o)&&r[o]&&p.push(r[o][0]),r[o]=0;for(a in l)Object.prototype.hasOwnProperty.call(l,a)&&(n[a]=l[a]);for(c&&c(e);p.length;)p.shift()();return i.push.apply(i,d||[]),t()}function t(){for(var n,e=0;e<i.length;e++){for(var t=i[e],a=!0,s=1;s<t.length;s++){var l=t[s];0!==r[l]&&(a=!1)}a&&(i.splice(e--,1),n=o(o.s=t[0]))}return n}var a={},r={1:0},i=[];function o(e){if(a[e])return a[e].exports;var t=a[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,o),t.l=!0,t.exports}o.e=function(n){var e=[],t=r[n];if(0!==t)if(t)e.push(t[2]);else{var a=new Promise((function(e,a){t=r[n]=[e,a]}));e.push(t[2]=a);var i,s=document.createElement("script");s.charset="utf-8",s.timeout=120,o.nc&&s.setAttribute("nonce",o.nc),s.src=function(n){return o.p+"assets/js/"+({}[n]||n)+"."+{2:"97c812e5",3:"7d266351",4:"09b1f7c3",5:"6a04feac",6:"d98d2c99",7:"86e2c1e6",8:"d2f34832",9:"92df87ca",10:"9853697e",11:"ca2d9138",12:"d198d965",13:"da453c0a",14:"c14eca74",15:"32b2ad78",16:"75fcf71a",17:"71a633a4",18:"4a6b0db1",19:"f30de5fd",20:"7709575c",21:"1cfaae26",22:"b58e6b46",23:"9c60b848",24:"1d075c58",25:"1be14388",26:"19dbb7c1",27:"9fc53195",28:"a4704f8e",29:"a2b8607e",30:"e2275638",31:"c142eca4",32:"6814e86e",33:"f0b7a965",34:"a5cb6e04",35:"536324b2",36:"0b2095dd",37:"a402f608",38:"abdf153a",39:"cd5cc109",40:"53baf323",41:"e49e3fc0",42:"77e56532",43:"61a5352b",44:"46a3c642",45:"eafa64f4",46:"f0dc3926",47:"e494de78",48:"0373df91",49:"e7774c6a",50:"a6781050",51:"70a3a19a",52:"8e0b7557",53:"b0417839",54:"61dc4790",55:"b0e6ae59",56:"9fea1b8a",57:"e4afc64c",58:"29677321",59:"6623e7af",60:"9f760fb5",61:"e6204801",62:"03c6f5b6",63:"40339666",64:"c142834d",65:"126d0a00",66:"90429673",67:"8fe86fe8",68:"eb26265b",69:"d2440866",70:"d2dd4b4c",71:"5210473e",72:"573b98b1",73:"c704b6ba",74:"867db1db",75:"0afd0bf2",76:"18cb57e1",77:"d95ae80f",78:"5d35626a",79:"63b87827",80:"47e3a6e0",81:"a6b7187c",82:"34b18b3f",83:"cf3851ea",84:"44b5e0ef",85:"4aea7124",86:"99a1305e",87:"f3de639d",88:"f6ae2ad3",89:"375ecf68",90:"5950faae",91:"34df8e58",92:"5584b174",93:"58410f95",94:"1232b4c6",95:"564b34f8",96:"3cec45e6",97:"5c57b252",98:"29b42bc5",99:"59822fb9",100:"21225358",101:"d9ab2d05",102:"3cd48b78",103:"c09ea1aa",104:"c8c02af6",105:"52cd29f6",106:"5cb7da13",107:"df23df45",108:"f20b0f30",109:"9bb67054",110:"111a638b",111:"8f8afc83",112:"757a4959",113:"a2cecbc5",114:"ad25d1ea",115:"ddbdaf6c",116:"6be5b96e",117:"8a4694bf",118:"b270dcbf",119:"f47e4efd",120:"345367df",121:"fd0f7b5b",122:"3c95f079",123:"7a4d0a3f",124:"bf9de739",125:"d981f47a",126:"cc2bfbf1",127:"82423d10",128:"cfee57ab",129:"8d6122c9",130:"56e42370",131:"8e1549cd",132:"7290c22c",133:"9dded9ab",134:"e63f8b73",135:"636d5537",136:"01d27ae9",137:"69c34a56",138:"6345cd27",139:"46753d5a",140:"79f4ed99",141:"1f4ce18d",142:"c7d76756",143:"94182c42",144:"a755b388",145:"2edc35bd",146:"0a5d59a2",147:"a2aa583c",148:"60ffd3b6",149:"0c5ef55d",150:"b690afe0",151:"2dab8d21",152:"fb5fa4d0",153:"f06002cb",154:"064f36c7",155:"c7001a89",156:"79f04fed",157:"ccb2c1c9",158:"6986b953",159:"5eabcbfb",160:"fde71339",161:"2c07fb78",162:"4a6e0b88",163:"5a4849a2",164:"7ca57bcb",165:"3c937478",166:"d4453e35",167:"1b60b2dc",168:"082ba541",169:"badb1975",170:"20036ad5",171:"dcb7154d",172:"8f6e4a7a",173:"c50451e7",174:"a0589591",175:"3d37226e",176:"6fc2b0ba",177:"7b97a175",178:"1b3db9d2",179:"0d9659e4",180:"c441d278",181:"de2bc72d",182:"fe9bfb45",183:"5179649d",184:"80a4653c",185:"e8401828",186:"fc26e9ef",187:"f4f727d0",188:"802d5121",189:"7c9a8e1e",190:"919a8214",191:"58780618",192:"b70a4a5f",193:"8498ffb4",194:"7ab729d4",195:"2523ba72",196:"5b5d8710",197:"54b87d27",198:"f56aa135",199:"50826853",200:"fb62437e",201:"238916e7",202:"cf0cab65",203:"6da8dbe5",204:"0ed977a9",205:"78269c54",206:"5e063cd9",207:"5f7ffc25",208:"1eea42e3",209:"8bb03325",210:"67e4f4cc",211:"5ac8f691",212:"5fbad23e",213:"ece73b89",214:"bf56b7a7",215:"5719300a",216:"bff094af",217:"896869a4",218:"c23e6bd0",219:"fa250dc0",220:"0783c24d",221:"d78aa47d",222:"c4dcf0c2",223:"1bb52663",224:"8a9df787",225:"b56c7d6b",226:"5dfe1b55",227:"a34eec50",228:"80ea352d",229:"59cc0f7d",230:"95b6dcaf",231:"5cb355eb",232:"33b37602",233:"6b2ae1ff",234:"8ff52c50",235:"4fbe8694",236:"2b3f3a29",237:"697787df",238:"882aa66e",239:"96d4fcb6",240:"cbe259e8",241:"8d3e5ce3",242:"c9755bdf",243:"e92ecaf3",244:"b3806484",245:"ffdd9b21",246:"ef343e66",247:"881a3223",248:"2e4c8492",249:"b3cc5789",250:"443b42d1",251:"8d4b2a00",252:"57a5c804",253:"177fa502",254:"90d7804e",255:"dac7cc2d",256:"a092897d",257:"e128698f",258:"cabcce3d",259:"2ff039ec",260:"9f8892a7",261:"9938e34c",262:"a80df374",263:"1db84dca",264:"36961f97",265:"3708f799",266:"c33807bd",267:"852cdf16",268:"8846123e",269:"b4865a21",270:"df790185",271:"5eb37442",272:"e261f33f",273:"6868ec2a",274:"eb1268b6",275:"1872e1df",276:"da4aa1d8",277:"155b85c0",278:"b37bafb6",279:"8a44b9bd",280:"50722df2",281:"3541c8e5",282:"dcb10c56",283:"7fec3174",284:"58548b11",285:"f290a488",286:"8ab5339c",287:"94133544",288:"92c8f343",289:"1b59ed06",290:"d3bbc877",291:"c2db96cf",292:"cd41a584",293:"18e2954f",294:"af5db796",295:"9a1442e9",296:"d9a4f04d",297:"22fe7d43",298:"d6b4557b",299:"4333aae3",300:"a8fb7021",301:"9b0918a6",302:"b3c9b228",303:"43e31dd1",304:"e4edeab1",305:"c6ad990c",306:"55eca61c",307:"0ef8cd67",308:"2ef613b1",309:"23ad01a5",310:"cc769eb0",311:"4e20e7b5",312:"c022440c",313:"1e6a56b1",314:"1bcbd956",315:"3f2b058d",316:"a71d9c9d",317:"3499dcec"}[n]+".js"}(n);var l=new Error;i=function(e){s.onerror=s.onload=null,clearTimeout(d);var t=r[n];if(0!==t){if(t){var a=e&&("load"===e.type?"missing":e.type),i=e&&e.target&&e.target.src;l.message="Loading chunk "+n+" failed.\n("+a+": "+i+")",l.name="ChunkLoadError",l.type=a,l.request=i,t[1](l)}r[n]=void 0}};var d=setTimeout((function(){i({type:"timeout",target:s})}),12e4);s.onerror=s.onload=i,document.head.appendChild(s)}return Promise.all(e)},o.m=n,o.c=a,o.d=function(n,e,t){o.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},o.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},o.t=function(n,e){if(1&e&&(n=o(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(o.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var a in n)o.d(t,a,function(e){return n[e]}.bind(null,a));return t},o.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return o.d(e,"a",e),e},o.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},o.p="/",o.oe=function(n){throw console.error(n),n};var s=window.webpackJsonp=window.webpackJsonp||[],l=s.push.bind(s);s.push=e,s=s.slice();for(var d=0;d<s.length;d++)e(s[d]);var c=l;i.push([103,0]),t()}([function(n,e,t){var a=t(55),r=a.all;n.exports=a.IS_HTMLDDA?function(n){return"function"==typeof n||n===r}:function(n){return"function"==typeof n}},function(n,e,t){var a=t(27),r=Function.prototype,i=r.call,o=a&&r.bind.bind(i,i);n.exports=a?o:function(n){return function(){return i.apply(n,arguments)}}},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e){var t=function(n){return n&&n.Math==Math&&n};n.exports=t("object"==typeof globalThis&&globalThis)||t("object"==typeof window&&window)||t("object"==typeof self&&self)||t("object"==typeof global&&global)||function(){return this}()||Function("return this")()},function(n,e,t){var a=t(2);n.exports=!a((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var a=t(69),r="object"==typeof self&&self&&self.Object===Object&&self,i=a||r||Function("return this")();n.exports=i},function(n,e,t){"use strict";function a(n,e,t,a,r,i,o,s){var l,d="function"==typeof n?n.options:n;if(e&&(d.render=e,d.staticRenderFns=t,d._compiled=!0),a&&(d.functional=!0),i&&(d._scopeId="data-v-"+i),o?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),r&&r.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(o)},d._ssrRegister=l):r&&(l=s?function(){r.call(this,(d.functional?this.parent:this).$root.$options.shadowRoot)}:r),l)if(d.functional){d._injectStyles=l;var c=d.render;d.render=function(n,e){return l.call(e),c(n,e)}}else{var u=d.beforeCreate;d.beforeCreate=u?[].concat(u,l):[l]}return{exports:n,options:d}}t.d(e,"a",(function(){return a}))},function(n,e,t){var a=t(1),r=t(31),i=a({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return i(r(n),e)}},function(n,e,t){var a=t(0),r=t(55),i=r.all;n.exports=r.IS_HTMLDDA?function(n){return"object"==typeof n?null!==n:a(n)||n===i}:function(n){return"object"==typeof n?null!==n:a(n)}},function(n,e,t){var a=t(162),r=t(165);n.exports=function(n,e){var t=r(n,e);return a(t)?t:void 0}},function(n,e,t){"use strict";t.d(e,"e",(function(){return a})),t.d(e,"b",(function(){return i})),t.d(e,"j",(function(){return o})),t.d(e,"g",(function(){return l})),t.d(e,"h",(function(){return d})),t.d(e,"i",(function(){return c})),t.d(e,"c",(function(){return u})),t.d(e,"f",(function(){return p})),t.d(e,"l",(function(){return m})),t.d(e,"m",(function(){return h})),t.d(e,"d",(function(){return f})),t.d(e,"k",(function(){return b})),t.d(e,"n",(function(){return v})),t.d(e,"a",(function(){return k}));t(16);const a=/#.*$/,r=/\.(md|html)$/,i=/\/$/,o=/^[a-z]+:/i;function s(n){return decodeURI(n).replace(a,"").replace(r,"")}function l(n){return o.test(n)}function d(n){return/^mailto:/.test(n)}function c(n){return/^tel:/.test(n)}function u(n){if(l(n))return n;if(!n)return"404";const e=n.match(a),t=e?e[0]:"",r=s(n);return i.test(r)?n:r+".html"+t}function p(n,e){const t=n.hash,r=function(n){const e=n&&n.match(a);if(e)return e[0]}(e);if(r&&t!==r)return!1;return s(n.path)===s(e)}function m(n,e,t){if(l(e))return{type:"external",path:e};t&&(e=function(n,e,t){const a=n.charAt(0);if("/"===a)return n;if("?"===a||"#"===a)return e+n;const r=e.split("/");t&&r[r.length-1]||r.pop();const i=n.replace(/^\//,"").split("/");for(let n=0;n<i.length;n++){const e=i[n];".."===e?r.pop():"."!==e&&r.push(e)}""!==r[0]&&r.unshift("");return r.join("/")}(e,t));const a=s(e);for(let e=0;e<n.length;e++)if(s(n[e].regularPath)===a)return Object.assign({},n[e],{type:"page",path:u(n[e].path)});return console.error(`[vuepress] No matching page found for sidebar item "${e}"`),{}}function h(n,e,t,a){const{pages:r,themeConfig:i}=t,o=a&&i.locales&&i.locales[a]||i;if("auto"===(n.frontmatter.sidebar||o.sidebar||i.sidebar))return g(n);const s=o.sidebar||i.sidebar;if(s){const{base:t,config:a}=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(const a in e)if(0===(t=n,/(\.html|\/)$/.test(t)?t:t+"/").indexOf(encodeURI(a)))return{base:a,config:e[a]};var t;return{}}(e,s);return"auto"===a?g(n):a?a.map(n=>function n(e,t,a,r=1){if("string"==typeof e)return m(t,e,a);if(Array.isArray(e))return Object.assign(m(t,e[0],a),{title:e[1]});{r>3&&console.error("[vuepress] detected a too deep nested sidebar group.");const i=e.children||[];return 0===i.length&&e.path?Object.assign(m(t,e.path,a),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,initialOpenGroupIndex:e.initialOpenGroupIndex,children:i.map(e=>n(e,t,a,r+1)),collapsable:!1!==e.collapsable}}}(n,r,t)):[]}return[]}function g(n){const e=f(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map(e=>({type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}))}]}function f(n){let e;return(n=n.map(n=>Object.assign({},n))).forEach(n=>{2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)}),n.filter(n=>2===n.level)}function b(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function v(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function y(n){let e=n.frontmatter.date||n.lastUpdated||new Date,t=new Date(e);return"Invalid Date"==t&&e&&(t=new Date(e.replace(/-/g,"/"))),t.getTime()}function k(n,e){return y(e)-y(n)}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){var a=t(15),r=t(147),i=t(148),o=a?a.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":o&&o in Object(n)?r(n):i(n)}},function(n,e,t){var a=t(4),r=t(17),i=t(34);n.exports=a?function(n,e,t){return r.f(n,e,i(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){var a=t(6).Symbol;n.exports=a},function(n,e,t){"use strict";var a=t(26),r=t(31),i=t(32),o=t(128),s=t(130);a({target:"Array",proto:!0,arity:1,forced:t(2)((function(){return 4294967297!==[].push.call({length:4294967296},1)}))||!function(){try{Object.defineProperty([],"length",{writable:!1}).push()}catch(n){return n instanceof TypeError}}()},{push:function(n){var e=r(this),t=i(e),a=arguments.length;s(t+a);for(var l=0;l<a;l++)e[t]=arguments[l],t++;return o(e,t),t}})},function(n,e,t){var a=t(4),r=t(64),i=t(98),o=t(25),s=t(54),l=TypeError,d=Object.defineProperty,c=Object.getOwnPropertyDescriptor;e.f=a?i?function(n,e,t){if(o(n),e=s(e),o(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var a=c(n,e);a&&a.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:a.configurable,enumerable:"enumerable"in t?t.enumerable:a.enumerable,writable:!1})}return d(n,e,t)}:d:function(n,e,t){if(o(n),e=s(e),o(t),r)try{return d(n,e,t)}catch(n){}if("get"in t||"set"in t)throw l("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var a=t(1),r=a({}.toString),i=a("".slice);n.exports=function(n){return i(r(n),8,-1)}},function(n,e,t){var a=t(152),r=t(153),i=t(154),o=t(155),s=t(156);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}l.prototype.clear=a,l.prototype.delete=r,l.prototype.get=i,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e,t){var a=t(71);n.exports=function(n,e){for(var t=n.length;t--;)if(a(n[t][0],e))return t;return-1}},function(n,e,t){var a=t(10)(Object,"create");n.exports=a},function(n,e,t){var a=t(174);n.exports=function(n,e){var t=n.__data__;return a(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var a=t(44);n.exports=function(n){if("string"==typeof n||a(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){var a,r;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(r="function"==typeof(a=function(){var n,e,t={version:"0.2.0"},a=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function r(n,e,t){return n<e?e:n>t?t:n}function i(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(a[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=r(n,a.minimum,1),t.status=1===n?null:n;var l=t.render(!e),d=l.querySelector(a.barSelector),c=a.speed,u=a.easing;return l.offsetWidth,o((function(e){""===a.positionUsing&&(a.positionUsing=t.getPositioningCSS()),s(d,function(n,e,t){var r;return(r="translate3d"===a.positionUsing?{transform:"translate3d("+i(n)+"%,0,0)"}:"translate"===a.positionUsing?{transform:"translate("+i(n)+"%,0)"}:{"margin-left":i(n)+"%"}).transition="all "+e+"ms "+t,r}(n,c,u)),1===n?(s(l,{transition:"none",opacity:1}),l.offsetWidth,setTimeout((function(){s(l,{transition:"all "+c+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),c)}),c)):setTimeout(e,c)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),a.trickleSpeed)};return a.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*r(Math.random()*e,.1,.95)),e=r(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*a.trickleRate)},n=0,e=0,t.promise=function(a){return a&&"resolved"!==a.state()?(0===e&&t.start(),n++,e++,a.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");d(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=a.template;var r,o=e.querySelector(a.barSelector),l=n?"-100":i(t.status||0),c=document.querySelector(a.parent);return s(o,{transition:"all 0 linear",transform:"translate3d("+l+"%,0,0)"}),a.showSpinner||(r=e.querySelector(a.spinnerSelector))&&p(r),c!=document.body&&d(c,"nprogress-custom-parent"),c.appendChild(e),e},t.remove=function(){c(document.documentElement,"nprogress-busy"),c(document.querySelector(a.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&p(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var o=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),s=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var a,r=n.length,i=e.charAt(0).toUpperCase()+e.slice(1);r--;)if((a=n[r]+i)in t)return a;return e}(t))}function a(n,e,a){e=t(e),n.style[e]=a}return function(n,e){var t,r,i=arguments;if(2==i.length)for(t in e)void 0!==(r=e[t])&&e.hasOwnProperty(t)&&a(n,t,r);else a(n,i[1],i[2])}}();function l(n,e){return("string"==typeof n?n:u(n)).indexOf(" "+e+" ")>=0}function d(n,e){var t=u(n),a=t+e;l(t,e)||(n.className=a.substring(1))}function c(n,e){var t,a=u(n);l(n,e)&&(t=a.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function u(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function p(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?a.call(e,t,e,n):a)||(n.exports=r)},function(n,e,t){var a=t(9),r=String,i=TypeError;n.exports=function(n){if(a(n))return n;throw i(r(n)+" is not an object")}},function(n,e,t){var a=t(3),r=t(51).f,i=t(14),o=t(111),s=t(36),l=t(65),d=t(124);n.exports=function(n,e){var t,c,u,p,m,h=n.target,g=n.global,f=n.stat;if(t=g?a:f?a[h]||s(h,{}):(a[h]||{}).prototype)for(c in e){if(p=e[c],u=n.dontCallGetSet?(m=r(t,c))&&m.value:t[c],!d(g?c:h+(f?".":"#")+c,n.forced)&&void 0!==u){if(typeof p==typeof u)continue;l(p,u)}(n.sham||u&&u.sham)&&i(p,"sham",!0),o(t,c,p,n)}}},function(n,e,t){var a=t(2);n.exports=!a((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){var a=t(46),r=t(52);n.exports=function(n){return a(r(n))}},function(n,e,t){var a=t(3),r=t(0),i=function(n){return r(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?i(a[n]):a[n]&&a[n][e]}},function(n,e,t){var a=t(3),r=t(61),i=t(8),o=t(63),s=t(59),l=t(58),d=a.Symbol,c=r("wks"),u=l?d.for||d:d&&d.withoutSetter||o;n.exports=function(n){return i(c,n)||(c[n]=s&&i(d,n)?d[n]:u("Symbol."+n)),c[n]}},function(n,e,t){var a=t(52),r=Object;n.exports=function(n){return r(a(n))}},function(n,e,t){var a=t(122);n.exports=function(n){return a(n.length)}},function(n,e,t){var a=t(27),r=Function.prototype.call;n.exports=a?r.bind(r):function(){return r.apply(r,arguments)}},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){var a=t(3),r=t(36),i=a["__core-js_shared__"]||r("__core-js_shared__",{});n.exports=i},function(n,e,t){var a=t(3),r=Object.defineProperty;n.exports=function(n,e){try{r(a,n,{value:e,configurable:!0,writable:!0})}catch(t){a[n]=e}return e}},function(n,e,t){var a=t(146),r=t(12),i=Object.prototype,o=i.hasOwnProperty,s=i.propertyIsEnumerable,l=a(function(){return arguments}())?a:function(n){return r(n)&&o.call(n,"callee")&&!s.call(n,"callee")};n.exports=l},function(n,e,t){var a=t(10)(t(6),"Map");n.exports=a},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var a=t(166),r=t(173),i=t(175),o=t(176),s=t(177);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}l.prototype.clear=a,l.prototype.delete=r,l.prototype.get=i,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var a=t(5),r=t(44),i=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,o=/^\w*$/;n.exports=function(n,e){if(a(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!r(n))||(o.test(n)||!i.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var a=t(13),r=t(12);n.exports=function(n){return"symbol"==typeof n||r(n)&&"[object Symbol]"==a(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){var a=t(1),r=t(2),i=t(18),o=Object,s=a("".split);n.exports=r((function(){return!o("z").propertyIsEnumerable(0)}))?function(n){return"String"==i(n)?s(n,""):o(n)}:o},function(n,e,t){var a=t(0),r=t(109),i=TypeError;n.exports=function(n){if(a(n))return n;throw i(r(n)+" is not a function")}},function(n,e){n.exports={}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e){var t=/^\s+|\s+$/g,a=/^[-+]0x[0-9a-f]+$/i,r=/^0b[01]+$/i,i=/^0o[0-7]+$/i,o=parseInt,s="object"==typeof global&&global&&global.Object===Object&&global,l="object"==typeof self&&self&&self.Object===Object&&self,d=s||l||Function("return this")(),c=Object.prototype.toString,u=Math.max,p=Math.min,m=function(){return d.Date.now()};function h(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function g(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==c.call(n)}(n))return NaN;if(h(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=h(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var s=r.test(n);return s||i.test(n)?o(n.slice(2),s?2:8):a.test(n)?NaN:+n}n.exports=function(n,e,t){var a,r,i,o,s,l,d=0,c=!1,f=!1,b=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function v(e){var t=a,i=r;return a=r=void 0,d=e,o=n.apply(i,t)}function y(n){return d=n,s=setTimeout(x,e),c?v(n):o}function k(n){var t=n-l;return void 0===l||t>=e||t<0||f&&n-d>=i}function x(){var n=m();if(k(n))return w(n);s=setTimeout(x,function(n){var t=e-(n-l);return f?p(t,i-(n-d)):t}(n))}function w(n){return s=void 0,b&&a?v(n):(a=r=void 0,o)}function C(){var n=m(),t=k(n);if(a=arguments,r=this,l=n,t){if(void 0===s)return y(l);if(f)return s=setTimeout(x,e),v(l)}return void 0===s&&(s=setTimeout(x,e)),o}return e=g(e)||0,h(t)&&(c=!!t.leading,i=(f="maxWait"in t)?u(g(t.maxWait)||0,e):i,b="trailing"in t?!!t.trailing:b),C.cancel=function(){void 0!==s&&clearTimeout(s),d=0,a=l=r=s=void 0},C.flush=function(){return void 0===s?o:w(m())},C}},function(n,e,t){var a=t(4),r=t(33),i=t(105),o=t(34),s=t(28),l=t(54),d=t(8),c=t(64),u=Object.getOwnPropertyDescriptor;e.f=a?u:function(n,e){if(n=s(n),e=l(e),c)try{return u(n,e)}catch(n){}if(d(n,e))return o(!r(i.f,n,e),n[e])}},function(n,e,t){var a=t(53),r=TypeError;n.exports=function(n){if(a(n))throw r("Can't call method on "+n);return n}},function(n,e){n.exports=function(n){return null==n}},function(n,e,t){var a=t(106),r=t(56);n.exports=function(n){var e=a(n,"string");return r(e)?e:e+""}},function(n,e){var t="object"==typeof document&&document.all,a=void 0===t&&void 0!==t;n.exports={all:t,IS_HTMLDDA:a}},function(n,e,t){var a=t(29),r=t(0),i=t(57),o=t(58),s=Object;n.exports=o?function(n){return"symbol"==typeof n}:function(n){var e=a("Symbol");return r(e)&&i(e.prototype,s(n))}},function(n,e,t){var a=t(1);n.exports=a({}.isPrototypeOf)},function(n,e,t){var a=t(59);n.exports=a&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){var a=t(60),r=t(2);n.exports=!!Object.getOwnPropertySymbols&&!r((function(){var n=Symbol();return!String(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&a&&a<41}))},function(n,e,t){var a,r,i=t(3),o=t(107),s=i.process,l=i.Deno,d=s&&s.versions||l&&l.version,c=d&&d.v8;c&&(r=(a=c.split("."))[0]>0&&a[0]<4?1:+(a[0]+a[1])),!r&&o&&(!(a=o.match(/Edge\/(\d+)/))||a[1]>=74)&&(a=o.match(/Chrome\/(\d+)/))&&(r=+a[1]),n.exports=r},function(n,e,t){var a=t(62),r=t(35);(n.exports=function(n,e){return r[n]||(r[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.27.2",mode:a?"pure":"global",copyright:"© 2014-2023 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.27.2/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e){n.exports=!1},function(n,e,t){var a=t(1),r=0,i=Math.random(),o=a(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+o(++r+i,36)}},function(n,e,t){var a=t(4),r=t(2),i=t(97);n.exports=!a&&!r((function(){return 7!=Object.defineProperty(i("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){var a=t(8),r=t(117),i=t(51),o=t(17);n.exports=function(n,e,t){for(var s=r(e),l=o.f,d=i.f,c=0;c<s.length;c++){var u=s[c];a(n,u)||t&&a(t,u)||l(n,u,d(e,u))}}},function(n,e,t){var a=t(121);n.exports=function(n){var e=+n;return e!=e||0===e?0:a(e)}},function(n,e,t){var a=t(1),r=t(25),i=t(133);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=a(Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set))(t,[]),e=t instanceof Array}catch(n){}return function(t,a){return r(t),i(a),e?n(t,a):t.__proto__=a,t}}():void 0)},function(n,e){n.exports=function(n,e){for(var t=-1,a=e.length,r=n.length;++t<a;)n[r+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var a=t(19),r=t(157),i=t(158),o=t(159),s=t(160),l=t(161);function d(n){var e=this.__data__=new a(n);this.size=e.size}d.prototype.clear=r,d.prototype.delete=i,d.prototype.get=o,d.prototype.has=s,d.prototype.set=l,n.exports=d},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var a=t(13),r=t(39);n.exports=function(n){if(!r(n))return!1;var e=a(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var a=t(178),r=t(12);n.exports=function n(e,t,i,o,s){return e===t||(null==e||null==t||!r(e)&&!r(t)?e!=e&&t!=t:a(e,t,i,o,n,s))}},function(n,e,t){var a=t(76),r=t(181),i=t(77);n.exports=function(n,e,t,o,s,l){var d=1&t,c=n.length,u=e.length;if(c!=u&&!(d&&u>c))return!1;var p=l.get(n),m=l.get(e);if(p&&m)return p==e&&m==n;var h=-1,g=!0,f=2&t?new a:void 0;for(l.set(n,e),l.set(e,n);++h<c;){var b=n[h],v=e[h];if(o)var y=d?o(v,b,h,e,n,l):o(b,v,h,n,e,l);if(void 0!==y){if(y)continue;g=!1;break}if(f){if(!r(e,(function(n,e){if(!i(f,e)&&(b===n||s(b,n,t,o,l)))return f.push(e)}))){g=!1;break}}else if(b!==v&&!s(b,v,t,o,l)){g=!1;break}}return l.delete(n),l.delete(e),g}},function(n,e,t){var a=t(40),r=t(179),i=t(180);function o(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new a;++e<t;)this.add(n[e])}o.prototype.add=o.prototype.push=r,o.prototype.has=i,n.exports=o},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var a=t(191),r=t(197),i=t(82);n.exports=function(n){return i(n)?a(n):r(n)}},function(n,e,t){(function(n){var a=t(6),r=t(193),i=e&&!e.nodeType&&e,o=i&&"object"==typeof n&&n&&!n.nodeType&&n,s=o&&o.exports===i?a.Buffer:void 0,l=(s?s.isBuffer:void 0)||r;n.exports=l}).call(this,t(49)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var a=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==a||"symbol"!=a&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var a=t(194),r=t(195),i=t(196),o=i&&i.isTypedArray,s=o?r(o):a;n.exports=s},function(n,e,t){var a=t(72),r=t(42);n.exports=function(n){return null!=n&&r(n.length)&&!a(n)}},function(n,e,t){var a=t(10)(t(6),"Set");n.exports=a},function(n,e,t){var a=t(39);n.exports=function(n){return n==n&&!a(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var a=t(87),r=t(23);n.exports=function(n,e){for(var t=0,i=(e=a(e,n)).length;null!=n&&t<i;)n=n[r(e[t++])];return t&&t==i?n:void 0}},function(n,e,t){var a=t(5),r=t(43),i=t(208),o=t(211);n.exports=function(n,e){return a(n)?n:r(n,e)?[n]:i(o(n))}},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){var a=t(144),r=t(149),i=t(220),o=t(228),s=t(237),l=t(102),d=i((function(n){var e=l(n);return s(e)&&(e=void 0),o(a(n,1,s,!0),r(e,2))}));n.exports=d},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var a=/["'&<>]/;n.exports=function(n){var e,t=""+n,r=a.exec(t);if(!r)return t;var i="",o=0,s=0;for(o=r.index;o<t.length;o++){switch(t.charCodeAt(o)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}s!==o&&(i+=t.substring(s,o)),s=o+1,i+=e}return s!==o?i+t.substring(s,o):i}},function(n,e,t){"use strict";t.r(e);var a={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},r=(t(240),t(7)),i=Object(r.a)(a,(function(){return(0,this._self._c)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"4f1e9d0c",null);e.default=i.exports},function(n,e,t){"use strict";t.r(e);var a={name:"CodeGroup",data:()=>({codeTabs:[],activeCodeTabIndex:-1}),watch:{activeCodeTabIndex(n){this.codeTabs.forEach(n=>{n.elm.classList.remove("theme-code-block__active")}),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted(){this.codeTabs=(this.$slots.default||[]).filter(n=>Boolean(n.componentOptions)).map((n,e)=>(""===n.componentOptions.propsData.active&&(this.activeCodeTabIndex=e),{title:n.componentOptions.propsData.title,elm:n.elm})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab(n){this.activeCodeTabIndex=n}}},r=(t(241),t(7)),i=Object(r.a)(a,(function(){var n=this,e=n._self._c;return e("div",{staticClass:"theme-code-group"},[e("div",{staticClass:"theme-code-group__nav"},[e("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(t,a){return e("li",{key:t.title,staticClass:"theme-code-group__li"},[e("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":a===n.activeCodeTabIndex},on:{click:function(e){return n.changeCodeTab(a)}}},[n._v("\n            "+n._s(t.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?e("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"2f5f1757",null);e.default=i.exports},function(n,e){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){var a=t(3),r=t(9),i=a.document,o=r(i)&&r(i.createElement);n.exports=function(n){return o?i.createElement(n):{}}},function(n,e,t){var a=t(4),r=t(2);n.exports=a&&r((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){var a=t(61),r=t(63),i=a("keys");n.exports=function(n){return i[n]||(i[n]=r(n))}},function(n,e,t){var a=t(1),r=t(8),i=t(28),o=t(119).indexOf,s=t(48),l=a([].push);n.exports=function(n,e){var t,a=i(n),d=0,c=[];for(t in a)!r(s,t)&&r(a,t)&&l(c,t);for(;e.length>d;)r(a,t=e[d++])&&(~o(c,t)||l(c,t));return c}},function(n,e,t){var a=t(26),r=t(3),i=t(131),o=t(132),s=r.WebAssembly,l=7!==Error("e",{cause:7}).cause,d=function(n,e){var t={};t[n]=o(n,e,l),a({global:!0,constructor:!0,arity:1,forced:l},t)},c=function(n,e){if(s&&s[n]){var t={};t[n]=o("WebAssembly."+n,e,l),a({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:l},t)}};d("Error",(function(n){return function(e){return i(n,this,arguments)}})),d("EvalError",(function(n){return function(e){return i(n,this,arguments)}})),d("RangeError",(function(n){return function(e){return i(n,this,arguments)}})),d("ReferenceError",(function(n){return function(e){return i(n,this,arguments)}})),d("SyntaxError",(function(n){return function(e){return i(n,this,arguments)}})),d("TypeError",(function(n){return function(e){return i(n,this,arguments)}})),d("URIError",(function(n){return function(e){return i(n,this,arguments)}})),c("CompileError",(function(n){return function(e){return i(n,this,arguments)}})),c("LinkError",(function(n){return function(e){return i(n,this,arguments)}})),c("RuntimeError",(function(n){return function(e){return i(n,this,arguments)}}))},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){n.exports=t(246)},function(n,e,t){"use strict";var a=t(26),r=t(125).left,i=t(126),o=t(60);a({target:"Array",proto:!0,forced:!t(127)&&o>79&&o<83||!i("reduce")},{reduce:function(n){var e=arguments.length;return r(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var a={}.propertyIsEnumerable,r=Object.getOwnPropertyDescriptor,i=r&&!a.call({1:2},1);e.f=i?function(n){var e=r(this,n);return!!e&&e.enumerable}:a},function(n,e,t){var a=t(33),r=t(9),i=t(56),o=t(108),s=t(110),l=t(30),d=TypeError,c=l("toPrimitive");n.exports=function(n,e){if(!r(n)||i(n))return n;var t,l=o(n,c);if(l){if(void 0===e&&(e="default"),t=a(l,n,e),!r(t)||i(t))return t;throw d("Can't convert object to primitive value")}return void 0===e&&(e="number"),s(n,e)}},function(n,e){n.exports="undefined"!=typeof navigator&&String(navigator.userAgent)||""},function(n,e,t){var a=t(47),r=t(53);n.exports=function(n,e){var t=n[e];return r(t)?void 0:a(t)}},function(n,e){var t=String;n.exports=function(n){try{return t(n)}catch(n){return"Object"}}},function(n,e,t){var a=t(33),r=t(0),i=t(9),o=TypeError;n.exports=function(n,e){var t,s;if("string"===e&&r(t=n.toString)&&!i(s=a(t,n)))return s;if(r(t=n.valueOf)&&!i(s=a(t,n)))return s;if("string"!==e&&r(t=n.toString)&&!i(s=a(t,n)))return s;throw o("Can't convert object to primitive value")}},function(n,e,t){var a=t(0),r=t(17),i=t(112),o=t(36);n.exports=function(n,e,t,s){s||(s={});var l=s.enumerable,d=void 0!==s.name?s.name:e;if(a(t)&&i(t,d,s),s.global)l?n[e]=t:o(e,t);else{try{s.unsafe?n[e]&&(l=!0):delete n[e]}catch(n){}l?n[e]=t:r.f(n,e,{value:t,enumerable:!1,configurable:!s.nonConfigurable,writable:!s.nonWritable})}return n}},function(n,e,t){var a=t(1),r=t(2),i=t(0),o=t(8),s=t(4),l=t(113).CONFIGURABLE,d=t(114),c=t(115),u=c.enforce,p=c.get,m=String,h=Object.defineProperty,g=a("".slice),f=a("".replace),b=a([].join),v=s&&!r((function(){return 8!==h((function(){}),"length",{value:8}).length})),y=String(String).split("String"),k=n.exports=function(n,e,t){"Symbol("===g(m(e),0,7)&&(e="["+f(m(e),/^Symbol\(([^)]*)\)/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!o(n,"name")||l&&n.name!==e)&&(s?h(n,"name",{value:e,configurable:!0}):n.name=e),v&&t&&o(t,"arity")&&n.length!==t.arity&&h(n,"length",{value:t.arity});try{t&&o(t,"constructor")&&t.constructor?s&&h(n,"prototype",{writable:!1}):n.prototype&&(n.prototype=void 0)}catch(n){}var a=u(n);return o(a,"source")||(a.source=b(y,"string"==typeof e?e:"")),n};Function.prototype.toString=k((function(){return i(this)&&p(this).source||d(this)}),"toString")},function(n,e,t){var a=t(4),r=t(8),i=Function.prototype,o=a&&Object.getOwnPropertyDescriptor,s=r(i,"name"),l=s&&"something"===function(){}.name,d=s&&(!a||a&&o(i,"name").configurable);n.exports={EXISTS:s,PROPER:l,CONFIGURABLE:d}},function(n,e,t){var a=t(1),r=t(0),i=t(35),o=a(Function.toString);r(i.inspectSource)||(i.inspectSource=function(n){return o(n)}),n.exports=i.inspectSource},function(n,e,t){var a,r,i,o=t(116),s=t(3),l=t(9),d=t(14),c=t(8),u=t(35),p=t(99),m=t(48),h=s.TypeError,g=s.WeakMap;if(o||u.state){var f=u.state||(u.state=new g);f.get=f.get,f.has=f.has,f.set=f.set,a=function(n,e){if(f.has(n))throw h("Object already initialized");return e.facade=n,f.set(n,e),e},r=function(n){return f.get(n)||{}},i=function(n){return f.has(n)}}else{var b=p("state");m[b]=!0,a=function(n,e){if(c(n,b))throw h("Object already initialized");return e.facade=n,d(n,b,e),e},r=function(n){return c(n,b)?n[b]:{}},i=function(n){return c(n,b)}}n.exports={set:a,get:r,has:i,enforce:function(n){return i(n)?r(n):a(n,{})},getterFor:function(n){return function(e){var t;if(!l(e)||(t=r(e)).type!==n)throw h("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){var a=t(3),r=t(0),i=a.WeakMap;n.exports=r(i)&&/native code/.test(String(i))},function(n,e,t){var a=t(29),r=t(1),i=t(118),o=t(123),s=t(25),l=r([].concat);n.exports=a("Reflect","ownKeys")||function(n){var e=i.f(s(n)),t=o.f;return t?l(e,t(n)):e}},function(n,e,t){var a=t(100),r=t(96).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return a(n,r)}},function(n,e,t){var a=t(28),r=t(120),i=t(32),o=function(n){return function(e,t,o){var s,l=a(e),d=i(l),c=r(o,d);if(n&&t!=t){for(;d>c;)if((s=l[c++])!=s)return!0}else for(;d>c;c++)if((n||c in l)&&l[c]===t)return n||c||0;return!n&&-1}};n.exports={includes:o(!0),indexOf:o(!1)}},function(n,e,t){var a=t(66),r=Math.max,i=Math.min;n.exports=function(n,e){var t=a(n);return t<0?r(t+e,0):i(t,e)}},function(n,e){var t=Math.ceil,a=Math.floor;n.exports=Math.trunc||function(n){var e=+n;return(e>0?a:t)(e)}},function(n,e,t){var a=t(66),r=Math.min;n.exports=function(n){return n>0?r(a(n),9007199254740991):0}},function(n,e){e.f=Object.getOwnPropertySymbols},function(n,e,t){var a=t(2),r=t(0),i=/#|\.prototype\./,o=function(n,e){var t=l[s(n)];return t==c||t!=d&&(r(e)?a(e):!!e)},s=o.normalize=function(n){return String(n).replace(i,".").toLowerCase()},l=o.data={},d=o.NATIVE="N",c=o.POLYFILL="P";n.exports=o},function(n,e,t){var a=t(47),r=t(31),i=t(46),o=t(32),s=TypeError,l=function(n){return function(e,t,l,d){a(t);var c=r(e),u=i(c),p=o(c),m=n?p-1:0,h=n?-1:1;if(l<2)for(;;){if(m in u){d=u[m],m+=h;break}if(m+=h,n?m<0:p<=m)throw s("Reduce of empty array with no initial value")}for(;n?m>=0:p>m;m+=h)m in u&&(d=t(d,u[m],m,c));return d}};n.exports={left:l(!1),right:l(!0)}},function(n,e,t){"use strict";var a=t(2);n.exports=function(n,e){var t=[][n];return!!t&&a((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){var a=t(18);n.exports="undefined"!=typeof process&&"process"==a(process)},function(n,e,t){"use strict";var a=t(4),r=t(129),i=TypeError,o=Object.getOwnPropertyDescriptor,s=a&&!function(){if(void 0!==this)return!0;try{Object.defineProperty([],"length",{writable:!1}).length=1}catch(n){return n instanceof TypeError}}();n.exports=s?function(n,e){if(r(n)&&!o(n,"length").writable)throw i("Cannot set read only .length");return n.length=e}:function(n,e){return n.length=e}},function(n,e,t){var a=t(18);n.exports=Array.isArray||function(n){return"Array"==a(n)}},function(n,e){var t=TypeError;n.exports=function(n){if(n>9007199254740991)throw t("Maximum allowed index exceeded");return n}},function(n,e,t){var a=t(27),r=Function.prototype,i=r.apply,o=r.call;n.exports="object"==typeof Reflect&&Reflect.apply||(a?o.bind(i):function(){return o.apply(i,arguments)})},function(n,e,t){"use strict";var a=t(29),r=t(8),i=t(14),o=t(57),s=t(67),l=t(65),d=t(134),c=t(135),u=t(136),p=t(140),m=t(141),h=t(4),g=t(62);n.exports=function(n,e,t,f){var b=f?2:1,v=n.split("."),y=v[v.length-1],k=a.apply(null,v);if(k){var x=k.prototype;if(!g&&r(x,"cause")&&delete x.cause,!t)return k;var w=a("Error"),C=e((function(n,e){var t=u(f?e:n,void 0),a=f?new k(n):new k;return void 0!==t&&i(a,"message",t),m(a,C,a.stack,2),this&&o(x,this)&&c(a,this,C),arguments.length>b&&p(a,arguments[b]),a}));if(C.prototype=x,"Error"!==y?s?s(C,w):l(C,w,{name:!0}):h&&"stackTraceLimit"in k&&(d(C,k,"stackTraceLimit"),d(C,k,"prepareStackTrace")),l(C,k),!g)try{x.name!==y&&i(x,"name",y),x.constructor=C}catch(n){}return C}}},function(n,e,t){var a=t(0),r=String,i=TypeError;n.exports=function(n){if("object"==typeof n||a(n))return n;throw i("Can't set "+r(n)+" as a prototype")}},function(n,e,t){var a=t(17).f;n.exports=function(n,e,t){t in n||a(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){var a=t(0),r=t(9),i=t(67);n.exports=function(n,e,t){var o,s;return i&&a(o=e.constructor)&&o!==t&&r(s=o.prototype)&&s!==t.prototype&&i(n,s),n}},function(n,e,t){var a=t(137);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:a(n)}},function(n,e,t){var a=t(138),r=String;n.exports=function(n){if("Symbol"===a(n))throw TypeError("Cannot convert a Symbol value to a string");return r(n)}},function(n,e,t){var a=t(139),r=t(0),i=t(18),o=t(30)("toStringTag"),s=Object,l="Arguments"==i(function(){return arguments}());n.exports=a?i:function(n){var e,t,a;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=s(n),o))?t:l?i(e):"Object"==(a=i(e))&&r(e.callee)?"Arguments":a}},function(n,e,t){var a={};a[t(30)("toStringTag")]="z",n.exports="[object z]"===String(a)},function(n,e,t){var a=t(9),r=t(14);n.exports=function(n,e){a(e)&&"cause"in e&&r(n,"cause",e.cause)}},function(n,e,t){var a=t(14),r=t(142),i=t(143),o=Error.captureStackTrace;n.exports=function(n,e,t,s){i&&(o?o(n,e):a(n,"stack",r(t,s)))}},function(n,e,t){var a=t(1),r=Error,i=a("".replace),o=String(r("zxcasd").stack),s=/\n\s*at [^:]*:[^\n]*/,l=s.test(o);n.exports=function(n,e){if(l&&"string"==typeof n&&!r.prepareStackTrace)for(;e--;)n=i(n,s,"");return n}},function(n,e,t){var a=t(2),r=t(34);n.exports=!a((function(){var n=Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",r(1,7)),7!==n.stack)}))},function(n,e,t){var a=t(68),r=t(145);n.exports=function n(e,t,i,o,s){var l=-1,d=e.length;for(i||(i=r),s||(s=[]);++l<d;){var c=e[l];t>0&&i(c)?t>1?n(c,t-1,i,o,s):a(s,c):o||(s[s.length]=c)}return s}},function(n,e,t){var a=t(15),r=t(37),i=t(5),o=a?a.isConcatSpreadable:void 0;n.exports=function(n){return i(n)||r(n)||!!(o&&n&&n[o])}},function(n,e,t){var a=t(13),r=t(12);n.exports=function(n){return r(n)&&"[object Arguments]"==a(n)}},function(n,e,t){var a=t(15),r=Object.prototype,i=r.hasOwnProperty,o=r.toString,s=a?a.toStringTag:void 0;n.exports=function(n){var e=i.call(n,s),t=n[s];try{n[s]=void 0;var a=!0}catch(n){}var r=o.call(n);return a&&(e?n[s]=t:delete n[s]),r}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var a=t(150),r=t(206),i=t(45),o=t(5),s=t(217);n.exports=function(n){return"function"==typeof n?n:null==n?i:"object"==typeof n?o(n)?r(n[0],n[1]):a(n):s(n)}},function(n,e,t){var a=t(151),r=t(205),i=t(85);n.exports=function(n){var e=r(n);return 1==e.length&&e[0][2]?i(e[0][0],e[0][1]):function(t){return t===n||a(t,n,e)}}},function(n,e,t){var a=t(70),r=t(74);n.exports=function(n,e,t,i){var o=t.length,s=o,l=!i;if(null==n)return!s;for(n=Object(n);o--;){var d=t[o];if(l&&d[2]?d[1]!==n[d[0]]:!(d[0]in n))return!1}for(;++o<s;){var c=(d=t[o])[0],u=n[c],p=d[1];if(l&&d[2]){if(void 0===u&&!(c in n))return!1}else{var m=new a;if(i)var h=i(u,p,c,n,e,m);if(!(void 0===h?r(p,u,3,i,m):h))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var a=t(20),r=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=a(e,n);return!(t<0)&&(t==e.length-1?e.pop():r.call(e,t,1),--this.size,!0)}},function(n,e,t){var a=t(20);n.exports=function(n){var e=this.__data__,t=a(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var a=t(20);n.exports=function(n){return a(this.__data__,n)>-1}},function(n,e,t){var a=t(20);n.exports=function(n,e){var t=this.__data__,r=a(t,n);return r<0?(++this.size,t.push([n,e])):t[r][1]=e,this}},function(n,e,t){var a=t(19);n.exports=function(){this.__data__=new a,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var a=t(19),r=t(38),i=t(40);n.exports=function(n,e){var t=this.__data__;if(t instanceof a){var o=t.__data__;if(!r||o.length<199)return o.push([n,e]),this.size=++t.size,this;t=this.__data__=new i(o)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var a=t(72),r=t(163),i=t(39),o=t(73),s=/^\[object .+?Constructor\]$/,l=Function.prototype,d=Object.prototype,c=l.toString,u=d.hasOwnProperty,p=RegExp("^"+c.call(u).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!i(n)||r(n))&&(a(n)?p:s).test(o(n))}},function(n,e,t){var a,r=t(164),i=(a=/[^.]+$/.exec(r&&r.keys&&r.keys.IE_PROTO||""))?"Symbol(src)_1."+a:"";n.exports=function(n){return!!i&&i in n}},function(n,e,t){var a=t(6)["__core-js_shared__"];n.exports=a},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var a=t(167),r=t(19),i=t(38);n.exports=function(){this.size=0,this.__data__={hash:new a,map:new(i||r),string:new a}}},function(n,e,t){var a=t(168),r=t(169),i=t(170),o=t(171),s=t(172);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}l.prototype.clear=a,l.prototype.delete=r,l.prototype.get=i,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e,t){var a=t(21);n.exports=function(){this.__data__=a?a(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var a=t(21),r=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(a){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return r.call(e,n)?e[n]:void 0}},function(n,e,t){var a=t(21),r=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return a?void 0!==e[n]:r.call(e,n)}},function(n,e,t){var a=t(21);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=a&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var a=t(22);n.exports=function(n){var e=a(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var a=t(22);n.exports=function(n){return a(this,n).get(n)}},function(n,e,t){var a=t(22);n.exports=function(n){return a(this,n).has(n)}},function(n,e,t){var a=t(22);n.exports=function(n,e){var t=a(this,n),r=t.size;return t.set(n,e),this.size+=t.size==r?0:1,this}},function(n,e,t){var a=t(70),r=t(75),i=t(182),o=t(185),s=t(201),l=t(5),d=t(79),c=t(81),u="[object Object]",p=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,m,h,g){var f=l(n),b=l(e),v=f?"[object Array]":s(n),y=b?"[object Array]":s(e),k=(v="[object Arguments]"==v?u:v)==u,x=(y="[object Arguments]"==y?u:y)==u,w=v==y;if(w&&d(n)){if(!d(e))return!1;f=!0,k=!1}if(w&&!k)return g||(g=new a),f||c(n)?r(n,e,t,m,h,g):i(n,e,v,t,m,h,g);if(!(1&t)){var C=k&&p.call(n,"__wrapped__"),E=x&&p.call(e,"__wrapped__");if(C||E){var L=C?n.value():n,T=E?e.value():e;return g||(g=new a),h(L,T,t,m,g)}}return!!w&&(g||(g=new a),o(n,e,t,m,h,g))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length;++t<a;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var a=t(15),r=t(183),i=t(71),o=t(75),s=t(184),l=t(41),d=a?a.prototype:void 0,c=d?d.valueOf:void 0;n.exports=function(n,e,t,a,d,u,p){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!u(new r(n),new r(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return i(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var m=s;case"[object Set]":var h=1&a;if(m||(m=l),n.size!=e.size&&!h)return!1;var g=p.get(n);if(g)return g==e;a|=2,p.set(n,e);var f=o(m(n),m(e),a,d,u,p);return p.delete(n),f;case"[object Symbol]":if(c)return c.call(n)==c.call(e)}return!1}},function(n,e,t){var a=t(6).Uint8Array;n.exports=a},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,a){t[++e]=[a,n]})),t}},function(n,e,t){var a=t(186),r=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,i,o,s){var l=1&t,d=a(n),c=d.length;if(c!=a(e).length&&!l)return!1;for(var u=c;u--;){var p=d[u];if(!(l?p in e:r.call(e,p)))return!1}var m=s.get(n),h=s.get(e);if(m&&h)return m==e&&h==n;var g=!0;s.set(n,e),s.set(e,n);for(var f=l;++u<c;){var b=n[p=d[u]],v=e[p];if(i)var y=l?i(v,b,p,e,n,s):i(b,v,p,n,e,s);if(!(void 0===y?b===v||o(b,v,t,i,s):y)){g=!1;break}f||(f="constructor"==p)}if(g&&!f){var k=n.constructor,x=e.constructor;k==x||!("constructor"in n)||!("constructor"in e)||"function"==typeof k&&k instanceof k&&"function"==typeof x&&x instanceof x||(g=!1)}return s.delete(n),s.delete(e),g}},function(n,e,t){var a=t(187),r=t(188),i=t(78);n.exports=function(n){return a(n,i,r)}},function(n,e,t){var a=t(68),r=t(5);n.exports=function(n,e,t){var i=e(n);return r(n)?i:a(i,t(n))}},function(n,e,t){var a=t(189),r=t(190),i=Object.prototype.propertyIsEnumerable,o=Object.getOwnPropertySymbols,s=o?function(n){return null==n?[]:(n=Object(n),a(o(n),(function(e){return i.call(n,e)})))}:r;n.exports=s},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length,r=0,i=[];++t<a;){var o=n[t];e(o,t,n)&&(i[r++]=o)}return i}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var a=t(192),r=t(37),i=t(5),o=t(79),s=t(80),l=t(81),d=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=i(n),c=!t&&r(n),u=!t&&!c&&o(n),p=!t&&!c&&!u&&l(n),m=t||c||u||p,h=m?a(n.length,String):[],g=h.length;for(var f in n)!e&&!d.call(n,f)||m&&("length"==f||u&&("offset"==f||"parent"==f)||p&&("buffer"==f||"byteLength"==f||"byteOffset"==f)||s(f,g))||h.push(f);return h}},function(n,e){n.exports=function(n,e){for(var t=-1,a=Array(n);++t<n;)a[t]=e(t);return a}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var a=t(13),r=t(42),i=t(12),o={};o["[object Float32Array]"]=o["[object Float64Array]"]=o["[object Int8Array]"]=o["[object Int16Array]"]=o["[object Int32Array]"]=o["[object Uint8Array]"]=o["[object Uint8ClampedArray]"]=o["[object Uint16Array]"]=o["[object Uint32Array]"]=!0,o["[object Arguments]"]=o["[object Array]"]=o["[object ArrayBuffer]"]=o["[object Boolean]"]=o["[object DataView]"]=o["[object Date]"]=o["[object Error]"]=o["[object Function]"]=o["[object Map]"]=o["[object Number]"]=o["[object Object]"]=o["[object RegExp]"]=o["[object Set]"]=o["[object String]"]=o["[object WeakMap]"]=!1,n.exports=function(n){return i(n)&&r(n.length)&&!!o[a(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var a=t(69),r=e&&!e.nodeType&&e,i=r&&"object"==typeof n&&n&&!n.nodeType&&n,o=i&&i.exports===r&&a.process,s=function(){try{var n=i&&i.require&&i.require("util").types;return n||o&&o.binding&&o.binding("util")}catch(n){}}();n.exports=s}).call(this,t(49)(n))},function(n,e,t){var a=t(198),r=t(199),i=Object.prototype.hasOwnProperty;n.exports=function(n){if(!a(n))return r(n);var e=[];for(var t in Object(n))i.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var a=t(200)(Object.keys,Object);n.exports=a},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var a=t(202),r=t(38),i=t(203),o=t(83),s=t(204),l=t(13),d=t(73),c=d(a),u=d(r),p=d(i),m=d(o),h=d(s),g=l;(a&&"[object DataView]"!=g(new a(new ArrayBuffer(1)))||r&&"[object Map]"!=g(new r)||i&&"[object Promise]"!=g(i.resolve())||o&&"[object Set]"!=g(new o)||s&&"[object WeakMap]"!=g(new s))&&(g=function(n){var e=l(n),t="[object Object]"==e?n.constructor:void 0,a=t?d(t):"";if(a)switch(a){case c:return"[object DataView]";case u:return"[object Map]";case p:return"[object Promise]";case m:return"[object Set]";case h:return"[object WeakMap]"}return e}),n.exports=g},function(n,e,t){var a=t(10)(t(6),"DataView");n.exports=a},function(n,e,t){var a=t(10)(t(6),"Promise");n.exports=a},function(n,e,t){var a=t(10)(t(6),"WeakMap");n.exports=a},function(n,e,t){var a=t(84),r=t(78);n.exports=function(n){for(var e=r(n),t=e.length;t--;){var i=e[t],o=n[i];e[t]=[i,o,a(o)]}return e}},function(n,e,t){var a=t(74),r=t(207),i=t(214),o=t(43),s=t(84),l=t(85),d=t(23);n.exports=function(n,e){return o(n)&&s(e)?l(d(n),e):function(t){var o=r(t,n);return void 0===o&&o===e?i(t,n):a(e,o,3)}}},function(n,e,t){var a=t(86);n.exports=function(n,e,t){var r=null==n?void 0:a(n,e);return void 0===r?t:r}},function(n,e,t){var a=t(209),r=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,i=/\\(\\)?/g,o=a((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(r,(function(n,t,a,r){e.push(a?r.replace(i,"$1"):t||n)})),e}));n.exports=o},function(n,e,t){var a=t(210);n.exports=function(n){var e=a(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var a=t(40);function r(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var a=arguments,r=e?e.apply(this,a):a[0],i=t.cache;if(i.has(r))return i.get(r);var o=n.apply(this,a);return t.cache=i.set(r,o)||i,o};return t.cache=new(r.Cache||a),t}r.Cache=a,n.exports=r},function(n,e,t){var a=t(212);n.exports=function(n){return null==n?"":a(n)}},function(n,e,t){var a=t(15),r=t(213),i=t(5),o=t(44),s=a?a.prototype:void 0,l=s?s.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(i(e))return r(e,n)+"";if(o(e))return l?l.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length,r=Array(a);++t<a;)r[t]=e(n[t],t,n);return r}},function(n,e,t){var a=t(215),r=t(216);n.exports=function(n,e){return null!=n&&r(n,e,a)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var a=t(87),r=t(37),i=t(5),o=t(80),s=t(42),l=t(23);n.exports=function(n,e,t){for(var d=-1,c=(e=a(e,n)).length,u=!1;++d<c;){var p=l(e[d]);if(!(u=null!=n&&t(n,p)))break;n=n[p]}return u||++d!=c?u:!!(c=null==n?0:n.length)&&s(c)&&o(p,c)&&(i(n)||r(n))}},function(n,e,t){var a=t(218),r=t(219),i=t(43),o=t(23);n.exports=function(n){return i(n)?a(o(n)):r(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var a=t(86);n.exports=function(n){return function(e){return a(e,n)}}},function(n,e,t){var a=t(45),r=t(221),i=t(223);n.exports=function(n,e){return i(r(n,e,a),n+"")}},function(n,e,t){var a=t(222),r=Math.max;n.exports=function(n,e,t){return e=r(void 0===e?n.length-1:e,0),function(){for(var i=arguments,o=-1,s=r(i.length-e,0),l=Array(s);++o<s;)l[o]=i[e+o];o=-1;for(var d=Array(e+1);++o<e;)d[o]=i[o];return d[e]=t(l),a(n,this,d)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var a=t(224),r=t(227)(a);n.exports=r},function(n,e,t){var a=t(225),r=t(226),i=t(45),o=r?function(n,e){return r(n,"toString",{configurable:!0,enumerable:!1,value:a(e),writable:!0})}:i;n.exports=o},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var a=t(10),r=function(){try{var n=a(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=r},function(n,e){var t=Date.now;n.exports=function(n){var e=0,a=0;return function(){var r=t(),i=16-(r-a);if(a=r,i>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var a=t(76),r=t(229),i=t(234),o=t(77),s=t(235),l=t(41);n.exports=function(n,e,t){var d=-1,c=r,u=n.length,p=!0,m=[],h=m;if(t)p=!1,c=i;else if(u>=200){var g=e?null:s(n);if(g)return l(g);p=!1,c=o,h=new a}else h=e?[]:m;n:for(;++d<u;){var f=n[d],b=e?e(f):f;if(f=t||0!==f?f:0,p&&b==b){for(var v=h.length;v--;)if(h[v]===b)continue n;e&&h.push(b),m.push(f)}else c(h,b,t)||(h!==m&&h.push(b),m.push(f))}return m}},function(n,e,t){var a=t(230);n.exports=function(n,e){return!!(null==n?0:n.length)&&a(n,e,0)>-1}},function(n,e,t){var a=t(231),r=t(232),i=t(233);n.exports=function(n,e,t){return e==e?i(n,e,t):a(n,r,t)}},function(n,e){n.exports=function(n,e,t,a){for(var r=n.length,i=t+(a?1:-1);a?i--:++i<r;)if(e(n[i],i,n))return i;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var a=t-1,r=n.length;++a<r;)if(n[a]===e)return a;return-1}},function(n,e){n.exports=function(n,e,t){for(var a=-1,r=null==n?0:n.length;++a<r;)if(t(e,n[a]))return!0;return!1}},function(n,e,t){var a=t(83),r=t(236),i=t(41),o=a&&1/i(new a([,-0]))[1]==1/0?function(n){return new a(n)}:r;n.exports=o},function(n,e){n.exports=function(){}},function(n,e,t){var a=t(82),r=t(12);n.exports=function(n){return r(n)&&a(n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(88)},function(n,e,t){"use strict";t(89)},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(90)},function(n,e,t){"use strict";t(91)},function(n,e,t){"use strict";t.r(e);
/*!
 * Vue.js v2.7.14
 * (c) 2014-2022 Evan You
 * Released under the MIT License.
 */
var a=Object.freeze({}),r=Array.isArray;function i(n){return null==n}function o(n){return null!=n}function s(n){return!0===n}function l(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function d(n){return"function"==typeof n}function c(n){return null!==n&&"object"==typeof n}var u=Object.prototype.toString;function p(n){return"[object Object]"===u.call(n)}function m(n){return"[object RegExp]"===u.call(n)}function h(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function g(n){return o(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function f(n){return null==n?"":Array.isArray(n)||p(n)&&n.toString===u?JSON.stringify(n,null,2):String(n)}function b(n){var e=parseFloat(n);return isNaN(e)?n:e}function v(n,e){for(var t=Object.create(null),a=n.split(","),r=0;r<a.length;r++)t[a[r]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}v("slot,component",!0);var y=v("key,ref,slot,slot-scope,is");function k(n,e){var t=n.length;if(t){if(e===n[t-1])return void(n.length=t-1);var a=n.indexOf(e);if(a>-1)return n.splice(a,1)}}var x=Object.prototype.hasOwnProperty;function w(n,e){return x.call(n,e)}function C(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var E=/-(\w)/g,L=C((function(n){return n.replace(E,(function(n,e){return e?e.toUpperCase():""}))})),T=C((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),j=/\B([A-Z])/g,S=C((function(n){return n.replace(j,"-$1").toLowerCase()}));var A=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var a=arguments.length;return a?a>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function P(n,e){e=e||0;for(var t=n.length-e,a=new Array(t);t--;)a[t]=n[t+e];return a}function _(n,e){for(var t in e)n[t]=e[t];return n}function B(n){for(var e={},t=0;t<n.length;t++)n[t]&&_(e,n[t]);return e}function z(n,e,t){}var I=function(n,e,t){return!1},O=function(n){return n};function M(n,e){if(n===e)return!0;var t=c(n),a=c(e);if(!t||!a)return!t&&!a&&String(n)===String(e);try{var r=Array.isArray(n),i=Array.isArray(e);if(r&&i)return n.length===e.length&&n.every((function(n,t){return M(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(r||i)return!1;var o=Object.keys(n),s=Object.keys(e);return o.length===s.length&&o.every((function(t){return M(n[t],e[t])}))}catch(n){return!1}}function J(n,e){for(var t=0;t<n.length;t++)if(M(n[t],e))return t;return-1}function D(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}function N(n,e){return n===e?0===n&&1/n!=1/e:n==n||e==e}var F=["component","directive","filter"],U=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],q={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:I,isReservedAttr:I,isUnknownElement:I,getTagNamespace:z,parsePlatformTagName:O,mustUseProp:I,async:!0,_lifecycleHooks:U},R=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function V(n){var e=(n+"").charCodeAt(0);return 36===e||95===e}function Z(n,e,t,a){Object.defineProperty(n,e,{value:t,enumerable:!!a,writable:!0,configurable:!0})}var H=new RegExp("[^".concat(R.source,".$_\\d]"));var $="__proto__"in{},W="undefined"!=typeof window,K=W&&window.navigator.userAgent.toLowerCase(),Q=K&&/msie|trident/.test(K),G=K&&K.indexOf("msie 9.0")>0,X=K&&K.indexOf("edge/")>0;K&&K.indexOf("android");var Y=K&&/iphone|ipad|ipod|ios/.test(K);K&&/chrome\/\d+/.test(K),K&&/phantomjs/.test(K);var nn,en=K&&K.match(/firefox\/(\d+)/),tn={}.watch,an=!1;if(W)try{var rn={};Object.defineProperty(rn,"passive",{get:function(){an=!0}}),window.addEventListener("test-passive",null,rn)}catch(n){}var on=function(){return void 0===nn&&(nn=!W&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),nn},sn=W&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function ln(n){return"function"==typeof n&&/native code/.test(n.toString())}var dn,cn="undefined"!=typeof Symbol&&ln(Symbol)&&"undefined"!=typeof Reflect&&ln(Reflect.ownKeys);dn="undefined"!=typeof Set&&ln(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var un=null;function pn(n){void 0===n&&(n=null),n||un&&un._scope.off(),un=n,n&&n._scope.on()}var mn=function(){function n(n,e,t,a,r,i,o,s){this.tag=n,this.data=e,this.children=t,this.text=a,this.elm=r,this.ns=void 0,this.context=i,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=o,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(n.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),n}(),hn=function(n){void 0===n&&(n="");var e=new mn;return e.text=n,e.isComment=!0,e};function gn(n){return new mn(void 0,void 0,void 0,String(n))}function fn(n){var e=new mn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var bn=0,vn=[],yn=function(){function n(){this._pending=!1,this.id=bn++,this.subs=[]}return n.prototype.addSub=function(n){this.subs.push(n)},n.prototype.removeSub=function(n){this.subs[this.subs.indexOf(n)]=null,this._pending||(this._pending=!0,vn.push(this))},n.prototype.depend=function(e){n.target&&n.target.addDep(this)},n.prototype.notify=function(n){var e=this.subs.filter((function(n){return n}));for(var t=0,a=e.length;t<a;t++){0,e[t].update()}},n}();yn.target=null;var kn=[];function xn(n){kn.push(n),yn.target=n}function wn(){kn.pop(),yn.target=kn[kn.length-1]}var Cn=Array.prototype,En=Object.create(Cn);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=Cn[n];Z(En,n,(function(){for(var t=[],a=0;a<arguments.length;a++)t[a]=arguments[a];var r,i=e.apply(this,t),o=this.__ob__;switch(n){case"push":case"unshift":r=t;break;case"splice":r=t.slice(2)}return r&&o.observeArray(r),o.dep.notify(),i}))}));var Ln=Object.getOwnPropertyNames(En),Tn={},jn=!0;function Sn(n){jn=n}var An={notify:z,depend:z,addSub:z,removeSub:z},Pn=function(){function n(n,e,t){if(void 0===e&&(e=!1),void 0===t&&(t=!1),this.value=n,this.shallow=e,this.mock=t,this.dep=t?An:new yn,this.vmCount=0,Z(n,"__ob__",this),r(n)){if(!t)if($)n.__proto__=En;else for(var a=0,i=Ln.length;a<i;a++){Z(n,s=Ln[a],En[s])}e||this.observeArray(n)}else{var o=Object.keys(n);for(a=0;a<o.length;a++){var s;Bn(n,s=o[a],Tn,void 0,e,t)}}}return n.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)_n(n[e],!1,this.mock)},n}();function _n(n,e,t){return n&&w(n,"__ob__")&&n.__ob__ instanceof Pn?n.__ob__:!jn||!t&&on()||!r(n)&&!p(n)||!Object.isExtensible(n)||n.__v_skip||Nn(n)||n instanceof mn?void 0:new Pn(n,e,t)}function Bn(n,e,t,a,i,o){var s=new yn,l=Object.getOwnPropertyDescriptor(n,e);if(!l||!1!==l.configurable){var d=l&&l.get,c=l&&l.set;d&&!c||t!==Tn&&2!==arguments.length||(t=n[e]);var u=!i&&_n(t,!1,o);return Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=d?d.call(n):t;return yn.target&&(s.depend(),u&&(u.dep.depend(),r(e)&&On(e))),Nn(e)&&!i?e.value:e},set:function(e){var a=d?d.call(n):t;if(N(a,e)){if(c)c.call(n,e);else{if(d)return;if(!i&&Nn(a)&&!Nn(e))return void(a.value=e);t=e}u=!i&&_n(e,!1,o),s.notify()}}}),s}}function zn(n,e,t){if(!Dn(n)){var a=n.__ob__;return r(n)&&h(e)?(n.length=Math.max(n.length,e),n.splice(e,1,t),a&&!a.shallow&&a.mock&&_n(t,!1,!0),t):e in n&&!(e in Object.prototype)?(n[e]=t,t):n._isVue||a&&a.vmCount?t:a?(Bn(a.value,e,t,void 0,a.shallow,a.mock),a.dep.notify(),t):(n[e]=t,t)}}function In(n,e){if(r(n)&&h(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||Dn(n)||w(n,e)&&(delete n[e],t&&t.dep.notify())}}function On(n){for(var e=void 0,t=0,a=n.length;t<a;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),r(e)&&On(e)}function Mn(n){return Jn(n,!0),Z(n,"__v_isShallow",!0),n}function Jn(n,e){if(!Dn(n)){_n(n,e,on());0}}function Dn(n){return!(!n||!n.__v_isReadonly)}function Nn(n){return!(!n||!0!==n.__v_isRef)}function Fn(n,e,t){Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get:function(){var n=e[t];if(Nn(n))return n.value;var a=n&&n.__ob__;return a&&a.dep.depend(),n},set:function(n){var a=e[t];Nn(a)&&!Nn(n)?a.value=n:e[t]=n}})}"".concat("watcher"," callback"),"".concat("watcher"," getter"),"".concat("watcher"," cleanup");var Un;var qn=function(){function n(n){void 0===n&&(n=!1),this.detached=n,this.active=!0,this.effects=[],this.cleanups=[],this.parent=Un,!n&&Un&&(this.index=(Un.scopes||(Un.scopes=[])).push(this)-1)}return n.prototype.run=function(n){if(this.active){var e=Un;try{return Un=this,n()}finally{Un=e}}else 0},n.prototype.on=function(){Un=this},n.prototype.off=function(){Un=this.parent},n.prototype.stop=function(n){if(this.active){var e=void 0,t=void 0;for(e=0,t=this.effects.length;e<t;e++)this.effects[e].teardown();for(e=0,t=this.cleanups.length;e<t;e++)this.cleanups[e]();if(this.scopes)for(e=0,t=this.scopes.length;e<t;e++)this.scopes[e].stop(!0);if(!this.detached&&this.parent&&!n){var a=this.parent.scopes.pop();a&&a!==this&&(this.parent.scopes[this.index]=a,a.index=this.index)}this.parent=void 0,this.active=!1}},n}();function Rn(n){var e=n._provided,t=n.$parent&&n.$parent._provided;return t===e?n._provided=Object.create(t):e}var Vn=C((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),a="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=a?n.slice(1):n,once:t,capture:a,passive:e}}));function Zn(n,e){function t(){var n=t.fns;if(!r(n))return je(n,null,arguments,e,"v-on handler");for(var a=n.slice(),i=0;i<a.length;i++)je(a[i],null,arguments,e,"v-on handler")}return t.fns=n,t}function Hn(n,e,t,a,r,o){var l,d,c,u;for(l in n)d=n[l],c=e[l],u=Vn(l),i(d)||(i(c)?(i(d.fns)&&(d=n[l]=Zn(d,o)),s(u.once)&&(d=n[l]=r(u.name,d,u.capture)),t(u.name,d,u.capture,u.passive,u.params)):d!==c&&(c.fns=d,n[l]=c));for(l in e)i(n[l])&&a((u=Vn(l)).name,e[l],u.capture)}function $n(n,e,t){var a;n instanceof mn&&(n=n.data.hook||(n.data.hook={}));var r=n[e];function l(){t.apply(this,arguments),k(a.fns,l)}i(r)?a=Zn([l]):o(r.fns)&&s(r.merged)?(a=r).fns.push(l):a=Zn([r,l]),a.merged=!0,n[e]=a}function Wn(n,e,t,a,r){if(o(e)){if(w(e,t))return n[t]=e[t],r||delete e[t],!0;if(w(e,a))return n[t]=e[a],r||delete e[a],!0}return!1}function Kn(n){return l(n)?[gn(n)]:r(n)?function n(e,t){var a,d,c,u,p=[];for(a=0;a<e.length;a++)i(d=e[a])||"boolean"==typeof d||(c=p.length-1,u=p[c],r(d)?d.length>0&&(Qn((d=n(d,"".concat(t||"","_").concat(a)))[0])&&Qn(u)&&(p[c]=gn(u.text+d[0].text),d.shift()),p.push.apply(p,d)):l(d)?Qn(u)?p[c]=gn(u.text+d):""!==d&&p.push(gn(d)):Qn(d)&&Qn(u)?p[c]=gn(u.text+d.text):(s(e._isVList)&&o(d.tag)&&i(d.key)&&o(t)&&(d.key="__vlist".concat(t,"_").concat(a,"__")),p.push(d)));return p}(n):void 0}function Qn(n){return o(n)&&o(n.text)&&!1===n.isComment}function Gn(n,e){var t,a,i,s,l=null;if(r(n)||"string"==typeof n)for(l=new Array(n.length),t=0,a=n.length;t<a;t++)l[t]=e(n[t],t);else if("number"==typeof n)for(l=new Array(n),t=0;t<n;t++)l[t]=e(t+1,t);else if(c(n))if(cn&&n[Symbol.iterator]){l=[];for(var d=n[Symbol.iterator](),u=d.next();!u.done;)l.push(e(u.value,l.length)),u=d.next()}else for(i=Object.keys(n),l=new Array(i.length),t=0,a=i.length;t<a;t++)s=i[t],l[t]=e(n[s],s,t);return o(l)||(l=[]),l._isVList=!0,l}function Xn(n,e,t,a){var r,i=this.$scopedSlots[n];i?(t=t||{},a&&(t=_(_({},a),t)),r=i(t)||(d(e)?e():e)):r=this.$slots[n]||(d(e)?e():e);var o=t&&t.slot;return o?this.$createElement("template",{slot:o},r):r}function Yn(n){return Pt(this.$options,"filters",n,!0)||O}function ne(n,e){return r(n)?-1===n.indexOf(e):n!==e}function ee(n,e,t,a,r){var i=q.keyCodes[e]||t;return r&&a&&!q.keyCodes[e]?ne(r,a):i?ne(i,n):a?S(a)!==e:void 0===n}function te(n,e,t,a,i){if(t)if(c(t)){r(t)&&(t=B(t));var o=void 0,s=function(r){if("class"===r||"style"===r||y(r))o=n;else{var s=n.attrs&&n.attrs.type;o=a||q.mustUseProp(e,s,r)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var l=L(r),d=S(r);l in o||d in o||(o[r]=t[r],i&&((n.on||(n.on={}))["update:".concat(r)]=function(n){t[r]=n}))};for(var l in t)s(l)}else;return n}function ae(n,e){var t=this._staticTrees||(this._staticTrees=[]),a=t[n];return a&&!e||ie(a=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,this._c,this),"__static__".concat(n),!1),a}function re(n,e,t){return ie(n,"__once__".concat(e).concat(t?"_".concat(t):""),!0),n}function ie(n,e,t){if(r(n))for(var a=0;a<n.length;a++)n[a]&&"string"!=typeof n[a]&&oe(n[a],"".concat(e,"_").concat(a),t);else oe(n,e,t)}function oe(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function se(n,e){if(e)if(p(e)){var t=n.on=n.on?_({},n.on):{};for(var a in e){var r=t[a],i=e[a];t[a]=r?[].concat(r,i):i}}else;return n}function le(n,e,t,a){e=e||{$stable:!t};for(var i=0;i<n.length;i++){var o=n[i];r(o)?le(o,e,t):o&&(o.proxy&&(o.fn.proxy=!0),e[o.key]=o.fn)}return a&&(e.$key=a),e}function de(n,e){for(var t=0;t<e.length;t+=2){var a=e[t];"string"==typeof a&&a&&(n[e[t]]=e[t+1])}return n}function ce(n,e){return"string"==typeof n?e+n:n}function ue(n){n._o=re,n._n=b,n._s=f,n._l=Gn,n._t=Xn,n._q=M,n._i=J,n._m=ae,n._f=Yn,n._k=ee,n._b=te,n._v=gn,n._e=hn,n._u=le,n._g=se,n._d=de,n._p=ce}function pe(n,e){if(!n||!n.length)return{};for(var t={},a=0,r=n.length;a<r;a++){var i=n[a],o=i.data;if(o&&o.attrs&&o.attrs.slot&&delete o.attrs.slot,i.context!==e&&i.fnContext!==e||!o||null==o.slot)(t.default||(t.default=[])).push(i);else{var s=o.slot,l=t[s]||(t[s]=[]);"template"===i.tag?l.push.apply(l,i.children||[]):l.push(i)}}for(var d in t)t[d].every(me)&&delete t[d];return t}function me(n){return n.isComment&&!n.asyncFactory||" "===n.text}function he(n){return n.isComment&&n.asyncFactory}function ge(n,e,t,r){var i,o=Object.keys(t).length>0,s=e?!!e.$stable:!o,l=e&&e.$key;if(e){if(e._normalized)return e._normalized;if(s&&r&&r!==a&&l===r.$key&&!o&&!r.$hasNormal)return r;for(var d in i={},e)e[d]&&"$"!==d[0]&&(i[d]=fe(n,t,d,e[d]))}else i={};for(var c in t)c in i||(i[c]=be(t,c));return e&&Object.isExtensible(e)&&(e._normalized=i),Z(i,"$stable",s),Z(i,"$key",l),Z(i,"$hasNormal",o),i}function fe(n,e,t,a){var i=function(){var e=un;pn(n);var t=arguments.length?a.apply(null,arguments):a({}),i=(t=t&&"object"==typeof t&&!r(t)?[t]:Kn(t))&&t[0];return pn(e),t&&(!i||1===t.length&&i.isComment&&!he(i))?void 0:t};return a.proxy&&Object.defineProperty(e,t,{get:i,enumerable:!0,configurable:!0}),i}function be(n,e){return function(){return n[e]}}function ve(n){return{get attrs(){if(!n._attrsProxy){var e=n._attrsProxy={};Z(e,"_v_attr_proxy",!0),ye(e,n.$attrs,a,n,"$attrs")}return n._attrsProxy},get listeners(){n._listenersProxy||ye(n._listenersProxy={},n.$listeners,a,n,"$listeners");return n._listenersProxy},get slots(){return function(n){n._slotsProxy||xe(n._slotsProxy={},n.$scopedSlots);return n._slotsProxy}(n)},emit:A(n.$emit,n),expose:function(e){e&&Object.keys(e).forEach((function(t){return Fn(n,e,t)}))}}}function ye(n,e,t,a,r){var i=!1;for(var o in e)o in n?e[o]!==t[o]&&(i=!0):(i=!0,ke(n,o,a,r));for(var o in n)o in e||(i=!0,delete n[o]);return i}function ke(n,e,t,a){Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){return t[a][e]}})}function xe(n,e){for(var t in e)n[t]=e[t];for(var t in n)t in e||delete n[t]}var we=null;function Ce(n,e){return(n.__esModule||cn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),c(n)?e.extend(n):n}function Ee(n){if(r(n))for(var e=0;e<n.length;e++){var t=n[e];if(o(t)&&(o(t.componentOptions)||he(t)))return t}}function Le(n,e,t,a,u,p){return(r(t)||l(t))&&(u=a,a=t,t=void 0),s(p)&&(u=2),function(n,e,t,a,l){if(o(t)&&o(t.__ob__))return hn();o(t)&&o(t.is)&&(e=t.is);if(!e)return hn();0;r(a)&&d(a[0])&&((t=t||{}).scopedSlots={default:a[0]},a.length=0);2===l?a=Kn(a):1===l&&(a=function(n){for(var e=0;e<n.length;e++)if(r(n[e]))return Array.prototype.concat.apply([],n);return n}(a));var u,p;if("string"==typeof e){var m=void 0;p=n.$vnode&&n.$vnode.ns||q.getTagNamespace(e),u=q.isReservedTag(e)?new mn(q.parsePlatformTagName(e),t,a,void 0,void 0,n):t&&t.pre||!o(m=Pt(n.$options,"components",e))?new mn(e,t,a,void 0,void 0,n):kt(m,t,n,a,e)}else u=kt(e,t,n,a);return r(u)?u:o(u)?(o(p)&&function n(e,t,a){e.ns=t,"foreignObject"===e.tag&&(t=void 0,a=!0);if(o(e.children))for(var r=0,l=e.children.length;r<l;r++){var d=e.children[r];o(d.tag)&&(i(d.ns)||s(a)&&"svg"!==d.tag)&&n(d,t,a)}}(u,p),o(t)&&function(n){c(n.style)&&qe(n.style);c(n.class)&&qe(n.class)}(t),u):hn()}(n,e,t,a,u)}function Te(n,e,t){xn();try{if(e)for(var a=e;a=a.$parent;){var r=a.$options.errorCaptured;if(r)for(var i=0;i<r.length;i++)try{if(!1===r[i].call(a,n,e,t))return}catch(n){Se(n,a,"errorCaptured hook")}}Se(n,e,t)}finally{wn()}}function je(n,e,t,a,r){var i;try{(i=t?n.apply(e,t):n.call(e))&&!i._isVue&&g(i)&&!i._handled&&(i.catch((function(n){return Te(n,a,r+" (Promise/async)")})),i._handled=!0)}catch(n){Te(n,a,r)}return i}function Se(n,e,t){if(q.errorHandler)try{return q.errorHandler.call(null,n,e,t)}catch(e){e!==n&&Ae(e,null,"config.errorHandler")}Ae(n,e,t)}function Ae(n,e,t){if(!W||"undefined"==typeof console)throw n;console.error(n)}var Pe,_e=!1,Be=[],ze=!1;function Ie(){ze=!1;var n=Be.slice(0);Be.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&ln(Promise)){var Oe=Promise.resolve();Pe=function(){Oe.then(Ie),Y&&setTimeout(z)},_e=!0}else if(Q||"undefined"==typeof MutationObserver||!ln(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Pe="undefined"!=typeof setImmediate&&ln(setImmediate)?function(){setImmediate(Ie)}:function(){setTimeout(Ie,0)};else{var Me=1,Je=new MutationObserver(Ie),De=document.createTextNode(String(Me));Je.observe(De,{characterData:!0}),Pe=function(){Me=(Me+1)%2,De.data=String(Me)},_e=!0}function Ne(n,e){var t;if(Be.push((function(){if(n)try{n.call(e)}catch(n){Te(n,e,"nextTick")}else t&&t(e)})),ze||(ze=!0,Pe()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}function Fe(n){return function(e,t){if(void 0===t&&(t=un),t)return function(n,e,t){var a=n.$options;a[e]=Tt(a[e],t)}(t,n,e)}}Fe("beforeMount"),Fe("mounted"),Fe("beforeUpdate"),Fe("updated"),Fe("beforeDestroy"),Fe("destroyed"),Fe("activated"),Fe("deactivated"),Fe("serverPrefetch"),Fe("renderTracked"),Fe("renderTriggered"),Fe("errorCaptured");var Ue=new dn;function qe(n){return function n(e,t){var a,i,o=r(e);if(!o&&!c(e)||e.__v_skip||Object.isFrozen(e)||e instanceof mn)return;if(e.__ob__){var s=e.__ob__.dep.id;if(t.has(s))return;t.add(s)}if(o)for(a=e.length;a--;)n(e[a],t);else if(Nn(e))n(e.value,t);else for(i=Object.keys(e),a=i.length;a--;)n(e[i[a]],t)}(n,Ue),Ue.clear(),n}var Re,Ve=0,Ze=function(){function n(n,e,t,a,r){var i,o;i=this,void 0===(o=Un&&!Un._vm?Un:n?n._scope:void 0)&&(o=Un),o&&o.active&&o.effects.push(i),(this.vm=n)&&r&&(n._watcher=this),a?(this.deep=!!a.deep,this.user=!!a.user,this.lazy=!!a.lazy,this.sync=!!a.sync,this.before=a.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++Ve,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new dn,this.newDepIds=new dn,this.expression="",d(e)?this.getter=e:(this.getter=function(n){if(!H.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=z)),this.value=this.lazy?void 0:this.get()}return n.prototype.get=function(){var n;xn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;Te(n,e,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&qe(n),wn(),this.cleanupDeps()}return n},n.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},n.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},n.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():pt(this)},n.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||c(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'.concat(this.expression,'"');je(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},n.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},n.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},n.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&k(this.vm._scope.effects,this),this.active){for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},n}();function He(n,e){Re.$on(n,e)}function $e(n,e){Re.$off(n,e)}function We(n,e){var t=Re;return function a(){var r=e.apply(null,arguments);null!==r&&t.$off(n,a)}}function Ke(n,e,t){Re=n,Hn(e,t||{},He,$e,We,n),Re=void 0}var Qe=null;function Ge(n){var e=Qe;return Qe=n,function(){Qe=e}}function Xe(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function Ye(n,e){if(e){if(n._directInactive=!1,Xe(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)Ye(n.$children[t]);nt(n,"activated")}}function nt(n,e,t,a){void 0===a&&(a=!0),xn();var r=un;a&&pn(n);var i=n.$options[e],o="".concat(e," hook");if(i)for(var s=0,l=i.length;s<l;s++)je(i[s],n,t||null,n,o);n._hasHookEvent&&n.$emit("hook:"+e),a&&pn(r),wn()}var et=[],tt=[],at={},rt=!1,it=!1,ot=0;var st=0,lt=Date.now;if(W&&!Q){var dt=window.performance;dt&&"function"==typeof dt.now&&lt()>document.createEvent("Event").timeStamp&&(lt=function(){return dt.now()})}var ct=function(n,e){if(n.post){if(!e.post)return 1}else if(e.post)return-1;return n.id-e.id};function ut(){var n,e;for(st=lt(),it=!0,et.sort(ct),ot=0;ot<et.length;ot++)(n=et[ot]).before&&n.before(),e=n.id,at[e]=null,n.run();var t=tt.slice(),a=et.slice();ot=et.length=tt.length=0,at={},rt=it=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,Ye(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],a=t.vm;a&&a._watcher===t&&a._isMounted&&!a._isDestroyed&&nt(a,"updated")}}(a),function(){for(var n=0;n<vn.length;n++){var e=vn[n];e.subs=e.subs.filter((function(n){return n})),e._pending=!1}vn.length=0}(),sn&&q.devtools&&sn.emit("flush")}function pt(n){var e=n.id;if(null==at[e]&&(n!==yn.target||!n.noRecurse)){if(at[e]=!0,it){for(var t=et.length-1;t>ot&&et[t].id>n.id;)t--;et.splice(t+1,0,n)}else et.push(n);rt||(rt=!0,Ne(ut))}}function mt(n,e){if(n){for(var t=Object.create(null),a=cn?Reflect.ownKeys(n):Object.keys(n),r=0;r<a.length;r++){var i=a[r];if("__ob__"!==i){var o=n[i].from;if(o in e._provided)t[i]=e._provided[o];else if("default"in n[i]){var s=n[i].default;t[i]=d(s)?s.call(e):s}else 0}}return t}}function ht(n,e,t,i,o){var l,d=this,c=o.options;w(i,"_uid")?(l=Object.create(i))._original=i:(l=i,i=i._original);var u=s(c._compiled),p=!u;this.data=n,this.props=e,this.children=t,this.parent=i,this.listeners=n.on||a,this.injections=mt(c.inject,i),this.slots=function(){return d.$slots||ge(i,n.scopedSlots,d.$slots=pe(t,i)),d.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return ge(i,n.scopedSlots,this.slots())}}),u&&(this.$options=c,this.$slots=this.slots(),this.$scopedSlots=ge(i,n.scopedSlots,this.$slots)),c._scopeId?this._c=function(n,e,t,a){var o=Le(l,n,e,t,a,p);return o&&!r(o)&&(o.fnScopeId=c._scopeId,o.fnContext=i),o}:this._c=function(n,e,t,a){return Le(l,n,e,t,a,p)}}function gt(n,e,t,a,r){var i=fn(n);return i.fnContext=t,i.fnOptions=a,e.slot&&((i.data||(i.data={})).slot=e.slot),i}function ft(n,e){for(var t in e)n[L(t)]=e[t]}function bt(n){return n.name||n.__name||n._componentTag}ue(ht.prototype);var vt={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;vt.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},a=n.data.inlineTemplate;o(a)&&(t.render=a.render,t.staticRenderFns=a.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Qe)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,r,i){var o=r.data.scopedSlots,s=n.$scopedSlots,l=!!(o&&!o.$stable||s!==a&&!s.$stable||o&&n.$scopedSlots.$key!==o.$key||!o&&n.$scopedSlots.$key),d=!!(i||n.$options._renderChildren||l),c=n.$vnode;n.$options._parentVnode=r,n.$vnode=r,n._vnode&&(n._vnode.parent=r),n.$options._renderChildren=i;var u=r.data.attrs||a;n._attrsProxy&&ye(n._attrsProxy,u,c.data&&c.data.attrs||a,n,"$attrs")&&(d=!0),n.$attrs=u,t=t||a;var p=n.$options._parentListeners;if(n._listenersProxy&&ye(n._listenersProxy,t,p||a,n,"$listeners"),n.$listeners=n.$options._parentListeners=t,Ke(n,t,p),e&&n.$options.props){Sn(!1);for(var m=n._props,h=n.$options._propKeys||[],g=0;g<h.length;g++){var f=h[g],b=n.$options.props;m[f]=_t(f,b,e,n)}Sn(!0),n.$options.propsData=e}d&&(n.$slots=pe(i,r.context),n.$forceUpdate())}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,a=n.componentInstance;a._isMounted||(a._isMounted=!0,nt(a,"mounted")),n.data.keepAlive&&(t._isMounted?((e=a)._inactive=!1,tt.push(e)):Ye(a,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(!(t&&(e._directInactive=!0,Xe(e))||e._inactive)){e._inactive=!0;for(var a=0;a<e.$children.length;a++)n(e.$children[a]);nt(e,"deactivated")}}(e,!0):e.$destroy())}},yt=Object.keys(vt);function kt(n,e,t,l,d){if(!i(n)){var u=t.$options._base;if(c(n)&&(n=u.extend(n)),"function"==typeof n){var p;if(i(n.cid)&&void 0===(n=function(n,e){if(s(n.error)&&o(n.errorComp))return n.errorComp;if(o(n.resolved))return n.resolved;var t=we;if(t&&o(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t),s(n.loading)&&o(n.loadingComp))return n.loadingComp;if(t&&!o(n.owners)){var a=n.owners=[t],r=!0,l=null,d=null;t.$on("hook:destroyed",(function(){return k(a,t)}));var u=function(n){for(var e=0,t=a.length;e<t;e++)a[e].$forceUpdate();n&&(a.length=0,null!==l&&(clearTimeout(l),l=null),null!==d&&(clearTimeout(d),d=null))},p=D((function(t){n.resolved=Ce(t,e),r?a.length=0:u(!0)})),m=D((function(e){o(n.errorComp)&&(n.error=!0,u(!0))})),h=n(p,m);return c(h)&&(g(h)?i(n.resolved)&&h.then(p,m):g(h.component)&&(h.component.then(p,m),o(h.error)&&(n.errorComp=Ce(h.error,e)),o(h.loading)&&(n.loadingComp=Ce(h.loading,e),0===h.delay?n.loading=!0:l=setTimeout((function(){l=null,i(n.resolved)&&i(n.error)&&(n.loading=!0,u(!1))}),h.delay||200)),o(h.timeout)&&(d=setTimeout((function(){d=null,i(n.resolved)&&m(null)}),h.timeout)))),r=!1,n.loading?n.loadingComp:n.resolved}}(p=n,u)))return function(n,e,t,a,r){var i=hn();return i.asyncFactory=n,i.asyncMeta={data:e,context:t,children:a,tag:r},i}(p,e,t,l,d);e=e||{},Zt(n),o(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",a=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var i=e.on||(e.on={}),s=i[a],l=e.model.callback;o(s)?(r(s)?-1===s.indexOf(l):s!==l)&&(i[a]=[l].concat(s)):i[a]=l}(n.options,e);var m=function(n,e,t){var a=e.options.props;if(!i(a)){var r={},s=n.attrs,l=n.props;if(o(s)||o(l))for(var d in a){var c=S(d);Wn(r,l,d,c,!0)||Wn(r,s,d,c,!1)}return r}}(e,n);if(s(n.options.functional))return function(n,e,t,i,s){var l=n.options,d={},c=l.props;if(o(c))for(var u in c)d[u]=_t(u,c,e||a);else o(t.attrs)&&ft(d,t.attrs),o(t.props)&&ft(d,t.props);var p=new ht(t,d,s,i,n),m=l.render.call(null,p._c,p);if(m instanceof mn)return gt(m,t,p.parent,l,p);if(r(m)){for(var h=Kn(m)||[],g=new Array(h.length),f=0;f<h.length;f++)g[f]=gt(h[f],t,p.parent,l,p);return g}}(n,m,e,t,l);var h=e.on;if(e.on=e.nativeOn,s(n.options.abstract)){var f=e.slot;e={},f&&(e.slot=f)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<yt.length;t++){var a=yt[t],r=e[a],i=vt[a];r===i||r&&r._merged||(e[a]=r?xt(i,r):i)}}(e);var b=bt(n.options)||d;return new mn("vue-component-".concat(n.cid).concat(b?"-".concat(b):""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:m,listeners:h,tag:d,children:l},p)}}}function xt(n,e){var t=function(t,a){n(t,a),e(t,a)};return t._merged=!0,t}var wt=z,Ct=q.optionMergeStrategies;function Et(n,e,t){if(void 0===t&&(t=!0),!e)return n;for(var a,r,i,o=cn?Reflect.ownKeys(e):Object.keys(e),s=0;s<o.length;s++)"__ob__"!==(a=o[s])&&(r=n[a],i=e[a],t&&w(n,a)?r!==i&&p(r)&&p(i)&&Et(r,i):zn(n,a,i));return n}function Lt(n,e,t){return t?function(){var a=d(e)?e.call(t,t):e,r=d(n)?n.call(t,t):n;return a?Et(a,r):r}:e?n?function(){return Et(d(e)?e.call(this,this):e,d(n)?n.call(this,this):n)}:e:n}function Tt(n,e){var t=e?n?n.concat(e):r(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function jt(n,e,t,a){var r=Object.create(n||null);return e?_(r,e):r}Ct.data=function(n,e,t){return t?Lt(n,e,t):e&&"function"!=typeof e?n:Lt(n,e)},U.forEach((function(n){Ct[n]=Tt})),F.forEach((function(n){Ct[n+"s"]=jt})),Ct.watch=function(n,e,t,a){if(n===tn&&(n=void 0),e===tn&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var i={};for(var o in _(i,n),e){var s=i[o],l=e[o];s&&!r(s)&&(s=[s]),i[o]=s?s.concat(l):r(l)?l:[l]}return i},Ct.props=Ct.methods=Ct.inject=Ct.computed=function(n,e,t,a){if(!n)return e;var r=Object.create(null);return _(r,n),e&&_(r,e),r},Ct.provide=function(n,e){return n?function(){var t=Object.create(null);return Et(t,d(n)?n.call(this):n),e&&Et(t,d(e)?e.call(this):e,!1),t}:e};var St=function(n,e){return void 0===e?n:e};function At(n,e,t){if(d(e)&&(e=e.options),function(n,e){var t=n.props;if(t){var a,i,o={};if(r(t))for(a=t.length;a--;)"string"==typeof(i=t[a])&&(o[L(i)]={type:null});else if(p(t))for(var s in t)i=t[s],o[L(s)]=p(i)?i:{type:i};else 0;n.props=o}}(e),function(n,e){var t=n.inject;if(t){var a=n.inject={};if(r(t))for(var i=0;i<t.length;i++)a[t[i]]={from:t[i]};else if(p(t))for(var o in t){var s=t[o];a[o]=p(s)?_({from:o},s):{from:s}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var a=e[t];d(a)&&(e[t]={bind:a,update:a})}}(e),!e._base&&(e.extends&&(n=At(n,e.extends,t)),e.mixins))for(var a=0,i=e.mixins.length;a<i;a++)n=At(n,e.mixins[a],t);var o,s={};for(o in n)l(o);for(o in e)w(n,o)||l(o);function l(a){var r=Ct[a]||St;s[a]=r(n[a],e[a],t,a)}return s}function Pt(n,e,t,a){if("string"==typeof t){var r=n[e];if(w(r,t))return r[t];var i=L(t);if(w(r,i))return r[i];var o=T(i);return w(r,o)?r[o]:r[t]||r[i]||r[o]}}function _t(n,e,t,a){var r=e[n],i=!w(t,n),o=t[n],s=Ot(Boolean,r.type);if(s>-1)if(i&&!w(r,"default"))o=!1;else if(""===o||o===S(n)){var l=Ot(String,r.type);(l<0||s<l)&&(o=!0)}if(void 0===o){o=function(n,e,t){if(!w(e,"default"))return;var a=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return d(a)&&"Function"!==zt(e.type)?a.call(n):a}(a,r,n);var c=jn;Sn(!0),_n(o),Sn(c)}return o}var Bt=/^\s*function (\w+)/;function zt(n){var e=n&&n.toString().match(Bt);return e?e[1]:""}function It(n,e){return zt(n)===zt(e)}function Ot(n,e){if(!r(e))return It(e,n)?0:-1;for(var t=0,a=e.length;t<a;t++)if(It(e[t],n))return t;return-1}var Mt={enumerable:!0,configurable:!0,get:z,set:z};function Jt(n,e,t){Mt.get=function(){return this[e][t]},Mt.set=function(n){this[e][t]=n},Object.defineProperty(n,t,Mt)}function Dt(n){var e=n.$options;if(e.props&&function(n,e){var t=n.$options.propsData||{},a=n._props=Mn({}),r=n.$options._propKeys=[];n.$parent&&Sn(!1);var i=function(i){r.push(i);var o=_t(i,e,t,n);Bn(a,i,o),i in n||Jt(n,"_props",i)};for(var o in e)i(o);Sn(!0)}(n,e.props),function(n){var e=n.$options,t=e.setup;if(t){var a=n._setupContext=ve(n);pn(n),xn();var r=je(t,null,[n._props||Mn({}),a],n,"setup");if(wn(),pn(),d(r))e.render=r;else if(c(r))if(n._setupState=r,r.__sfc){var i=n._setupProxy={};for(var o in r)"__sfc"!==o&&Fn(i,r,o)}else for(var o in r)V(o)||Fn(n,r,o);else 0}}(n),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?z:A(e[t],n)}(n,e.methods),e.data)!function(n){var e=n.$options.data;p(e=n._data=d(e)?function(n,e){xn();try{return n.call(e,e)}catch(n){return Te(n,e,"data()"),{}}finally{wn()}}(e,n):e||{})||(e={});var t=Object.keys(e),a=n.$options.props,r=(n.$options.methods,t.length);for(;r--;){var i=t[r];0,a&&w(a,i)||V(i)||Jt(n,"_data",i)}var o=_n(e);o&&o.vmCount++}(n);else{var t=_n(n._data={});t&&t.vmCount++}e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),a=on();for(var r in e){var i=e[r],o=d(i)?i:i.get;0,a||(t[r]=new Ze(n,o||z,z,Nt)),r in n||Ft(n,r,i)}}(n,e.computed),e.watch&&e.watch!==tn&&function(n,e){for(var t in e){var a=e[t];if(r(a))for(var i=0;i<a.length;i++)Rt(n,t,a[i]);else Rt(n,t,a)}}(n,e.watch)}var Nt={lazy:!0};function Ft(n,e,t){var a=!on();d(t)?(Mt.get=a?Ut(e):qt(t),Mt.set=z):(Mt.get=t.get?a&&!1!==t.cache?Ut(e):qt(t.get):z,Mt.set=t.set||z),Object.defineProperty(n,e,Mt)}function Ut(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),yn.target&&e.depend(),e.value}}function qt(n){return function(){return n.call(this,this)}}function Rt(n,e,t,a){return p(t)&&(a=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,a)}var Vt=0;function Zt(n){var e=n.options;if(n.super){var t=Zt(n.super);if(t!==n.superOptions){n.superOptions=t;var a=function(n){var e,t=n.options,a=n.sealedOptions;for(var r in t)t[r]!==a[r]&&(e||(e={}),e[r]=t[r]);return e}(n);a&&_(n.extendOptions,a),(e=n.options=At(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function Ht(n){this._init(n)}function $t(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,a=t.cid,r=n._Ctor||(n._Ctor={});if(r[a])return r[a];var i=bt(n)||bt(t.options);var o=function(n){this._init(n)};return(o.prototype=Object.create(t.prototype)).constructor=o,o.cid=e++,o.options=At(t.options,n),o.super=t,o.options.props&&function(n){var e=n.options.props;for(var t in e)Jt(n.prototype,"_props",t)}(o),o.options.computed&&function(n){var e=n.options.computed;for(var t in e)Ft(n.prototype,t,e[t])}(o),o.extend=t.extend,o.mixin=t.mixin,o.use=t.use,F.forEach((function(n){o[n]=t[n]})),i&&(o.options.components[i]=o),o.superOptions=t.options,o.extendOptions=n,o.sealedOptions=_({},o.options),r[a]=o,o}}function Wt(n){return n&&(bt(n.Ctor.options)||n.tag)}function Kt(n,e){return r(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!m(n)&&n.test(e)}function Qt(n,e){var t=n.cache,a=n.keys,r=n._vnode;for(var i in t){var o=t[i];if(o){var s=o.name;s&&!e(s)&&Gt(t,i,a,r)}}}function Gt(n,e,t,a){var r=n[e];!r||a&&r.tag===a.tag||r.componentInstance.$destroy(),n[e]=null,k(t,e)}!function(n){n.prototype._init=function(n){var e=this;e._uid=Vt++,e._isVue=!0,e.__v_skip=!0,e._scope=new qn(!0),e._scope._vm=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),a=e._parentVnode;t.parent=e.parent,t._parentVnode=a;var r=a.componentOptions;t.propsData=r.propsData,t._parentListeners=r.listeners,t._renderChildren=r.children,t._componentTag=r.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=At(Zt(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._provided=t?t._provided:Object.create(null),n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Ke(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,r=t&&t.context;n.$slots=pe(e._renderChildren,r),n.$scopedSlots=t?ge(n.$parent,t.data.scopedSlots,n.$slots):a,n._c=function(e,t,a,r){return Le(n,e,t,a,r,!1)},n.$createElement=function(e,t,a,r){return Le(n,e,t,a,r,!0)};var i=t&&t.data;Bn(n,"$attrs",i&&i.attrs||a,null,!0),Bn(n,"$listeners",e._parentListeners||a,null,!0)}(e),nt(e,"beforeCreate",void 0,!1),function(n){var e=mt(n.$options.inject,n);e&&(Sn(!1),Object.keys(e).forEach((function(t){Bn(n,t,e[t])})),Sn(!0))}(e),Dt(e),function(n){var e=n.$options.provide;if(e){var t=d(e)?e.call(n):e;if(!c(t))return;for(var a=Rn(n),r=cn?Reflect.ownKeys(t):Object.keys(t),i=0;i<r.length;i++){var o=r[i];Object.defineProperty(a,o,Object.getOwnPropertyDescriptor(t,o))}}}(e),nt(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}(Ht),function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=zn,n.prototype.$delete=In,n.prototype.$watch=function(n,e,t){if(p(e))return Rt(this,n,e,t);(t=t||{}).user=!0;var a=new Ze(this,n,e,t);if(t.immediate){var r='callback for immediate watcher "'.concat(a.expression,'"');xn(),je(e,this,[a.value],this,r),wn()}return function(){a.teardown()}}}(Ht),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var a=this;if(r(n))for(var i=0,o=n.length;i<o;i++)a.$on(n[i],t);else(a._events[n]||(a._events[n]=[])).push(t),e.test(n)&&(a._hasHookEvent=!0);return a},n.prototype.$once=function(n,e){var t=this;function a(){t.$off(n,a),e.apply(t,arguments)}return a.fn=e,t.$on(n,a),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(r(n)){for(var a=0,i=n.length;a<i;a++)t.$off(n[a],e);return t}var o,s=t._events[n];if(!s)return t;if(!e)return t._events[n]=null,t;for(var l=s.length;l--;)if((o=s[l])===e||o.fn===e){s.splice(l,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?P(t):t;for(var a=P(arguments,1),r='event handler for "'.concat(n,'"'),i=0,o=t.length;i<o;i++)je(t[i],e,a,e,r)}return e}}(Ht),function(n){n.prototype._update=function(n,e){var t=this,a=t.$el,r=t._vnode,i=Ge(t);t._vnode=n,t.$el=r?t.__patch__(r,n):t.__patch__(t.$el,n,e,!1),i(),a&&(a.__vue__=null),t.$el&&(t.$el.__vue__=t);for(var o=t;o&&o.$vnode&&o.$parent&&o.$vnode===o.$parent._vnode;)o.$parent.$el=o.$el,o=o.$parent},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){nt(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||k(e.$children,n),n._scope.stop(),n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),nt(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(Ht),function(n){ue(n.prototype),n.prototype.$nextTick=function(n){return Ne(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,a=t.render,i=t._parentVnode;i&&e._isMounted&&(e.$scopedSlots=ge(e.$parent,i.data.scopedSlots,e.$slots,e.$scopedSlots),e._slotsProxy&&xe(e._slotsProxy,e.$scopedSlots)),e.$vnode=i;try{pn(e),we=e,n=a.call(e._renderProxy,e.$createElement)}catch(t){Te(t,e,"render"),n=e._vnode}finally{we=null,pn()}return r(n)&&1===n.length&&(n=n[0]),n instanceof mn||(n=hn()),n.parent=i,n}}(Ht);var Xt=[String,RegExp,Array],Yt={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Xt,exclude:Xt,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,a=this.keyToCache;if(t){var r=t.tag,i=t.componentInstance,o=t.componentOptions;n[a]={name:Wt(o),tag:r,componentInstance:i},e.push(a),this.max&&e.length>parseInt(this.max)&&Gt(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)Gt(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){Qt(n,(function(n){return Kt(e,n)}))})),this.$watch("exclude",(function(e){Qt(n,(function(n){return!Kt(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=Ee(n),t=e&&e.componentOptions;if(t){var a=Wt(t),r=this.include,i=this.exclude;if(r&&(!a||!Kt(r,a))||i&&a&&Kt(i,a))return e;var o=this.cache,s=this.keys,l=null==e.key?t.Ctor.cid+(t.tag?"::".concat(t.tag):""):e.key;o[l]?(e.componentInstance=o[l].componentInstance,k(s,l),s.push(l)):(this.vnodeToCache=e,this.keyToCache=l),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return q}};Object.defineProperty(n,"config",e),n.util={warn:wt,extend:_,mergeOptions:At,defineReactive:Bn},n.set=zn,n.delete=In,n.nextTick=Ne,n.observable=function(n){return _n(n),n},n.options=Object.create(null),F.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,_(n.options.components,Yt),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=P(arguments,1);return t.unshift(this),d(n.install)?n.install.apply(n,t):d(n)&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=At(this.options,n),this}}(n),$t(n),function(n){F.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&p(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&d(t)&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(Ht),Object.defineProperty(Ht.prototype,"$isServer",{get:on}),Object.defineProperty(Ht.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Ht,"FunctionalRenderContext",{value:ht}),Ht.version="2.7.14";var na=v("style,class"),ea=v("input,textarea,option,select,progress"),ta=v("contenteditable,draggable,spellcheck"),aa=v("events,caret,typing,plaintext-only"),ra=v("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),ia="http://www.w3.org/1999/xlink",oa=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},sa=function(n){return oa(n)?n.slice(6,n.length):""},la=function(n){return null==n||!1===n};function da(n){for(var e=n.data,t=n,a=n;o(a.componentInstance);)(a=a.componentInstance._vnode)&&a.data&&(e=ca(a.data,e));for(;o(t=t.parent);)t&&t.data&&(e=ca(e,t.data));return function(n,e){if(o(n)||o(e))return ua(n,pa(e));return""}(e.staticClass,e.class)}function ca(n,e){return{staticClass:ua(n.staticClass,e.staticClass),class:o(n.class)?[n.class,e.class]:e.class}}function ua(n,e){return n?e?n+" "+e:n:e||""}function pa(n){return Array.isArray(n)?function(n){for(var e,t="",a=0,r=n.length;a<r;a++)o(e=pa(n[a]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):c(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var ma={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},ha=v("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),ga=v("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),fa=function(n){return ha(n)||ga(n)};var ba=Object.create(null);var va=v("text,number,password,search,email,tel,url");var ya=Object.freeze({__proto__:null,createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(ma[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),ka={create:function(n,e){xa(e)},update:function(n,e){n.data.ref!==e.data.ref&&(xa(n,!0),xa(e))},destroy:function(n){xa(n,!0)}};function xa(n,e){var t=n.data.ref;if(o(t)){var a=n.context,i=n.componentInstance||n.elm,s=e?null:i,l=e?void 0:i;if(d(t))je(t,a,[s],a,"template ref function");else{var c=n.data.refInFor,u="string"==typeof t||"number"==typeof t,p=Nn(t),m=a.$refs;if(u||p)if(c){var h=u?m[t]:t.value;e?r(h)&&k(h,i):r(h)?h.includes(i)||h.push(i):u?(m[t]=[i],wa(a,t,m[t])):t.value=[i]}else if(u){if(e&&m[t]!==i)return;m[t]=l,wa(a,t,s)}else if(p){if(e&&t.value!==i)return;t.value=s}else 0}}}function wa(n,e,t){var a=n._setupState;a&&w(a,e)&&(Nn(a[e])?a[e].value=t:a[e]=t)}var Ca=new mn("",{},[]),Ea=["create","activate","update","remove","destroy"];function La(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&o(n.data)===o(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,a=o(t=n.data)&&o(t=t.attrs)&&t.type,r=o(t=e.data)&&o(t=t.attrs)&&t.type;return a===r||va(a)&&va(r)}(n,e)||s(n.isAsyncPlaceholder)&&i(e.asyncFactory.error))}function Ta(n,e,t){var a,r,i={};for(a=e;a<=t;++a)o(r=n[a].key)&&(i[r]=a);return i}var ja={create:Sa,update:Sa,destroy:function(n){Sa(n,Ca)}};function Sa(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,a,r,i=n===Ca,o=e===Ca,s=Pa(n.data.directives,n.context),l=Pa(e.data.directives,e.context),d=[],c=[];for(t in l)a=s[t],r=l[t],a?(r.oldValue=a.value,r.oldArg=a.arg,Ba(r,"update",e,n),r.def&&r.def.componentUpdated&&c.push(r)):(Ba(r,"bind",e,n),r.def&&r.def.inserted&&d.push(r));if(d.length){var u=function(){for(var t=0;t<d.length;t++)Ba(d[t],"inserted",e,n)};i?$n(e,"insert",u):u()}c.length&&$n(e,"postpatch",(function(){for(var t=0;t<c.length;t++)Ba(c[t],"componentUpdated",e,n)}));if(!i)for(t in s)l[t]||Ba(s[t],"unbind",n,n,o)}(n,e)}var Aa=Object.create(null);function Pa(n,e){var t,a,r=Object.create(null);if(!n)return r;for(t=0;t<n.length;t++){if((a=n[t]).modifiers||(a.modifiers=Aa),r[_a(a)]=a,e._setupState&&e._setupState.__sfc){var i=a.def||Pt(e,"_setupState","v-"+a.name);a.def="function"==typeof i?{bind:i,update:i}:i}a.def=a.def||Pt(e.$options,"directives",a.name)}return r}function _a(n){return n.rawName||"".concat(n.name,".").concat(Object.keys(n.modifiers||{}).join("."))}function Ba(n,e,t,a,r){var i=n.def&&n.def[e];if(i)try{i(t.elm,n,t,a,r)}catch(a){Te(a,t.context,"directive ".concat(n.name," ").concat(e," hook"))}}var za=[ka,ja];function Ia(n,e){var t=e.componentOptions;if(!(o(t)&&!1===t.Ctor.options.inheritAttrs||i(n.data.attrs)&&i(e.data.attrs))){var a,r,l=e.elm,d=n.data.attrs||{},c=e.data.attrs||{};for(a in(o(c.__ob__)||s(c._v_attr_proxy))&&(c=e.data.attrs=_({},c)),c)r=c[a],d[a]!==r&&Oa(l,a,r,e.data.pre);for(a in(Q||X)&&c.value!==d.value&&Oa(l,"value",c.value),d)i(c[a])&&(oa(a)?l.removeAttributeNS(ia,sa(a)):ta(a)||l.removeAttribute(a))}}function Oa(n,e,t,a){a||n.tagName.indexOf("-")>-1?Ma(n,e,t):ra(e)?la(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):ta(e)?n.setAttribute(e,function(n,e){return la(e)||"false"===e?"false":"contenteditable"===n&&aa(e)?e:"true"}(e,t)):oa(e)?la(t)?n.removeAttributeNS(ia,sa(e)):n.setAttributeNS(ia,e,t):Ma(n,e,t)}function Ma(n,e,t){if(la(t))n.removeAttribute(e);else{if(Q&&!G&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var a=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",a)};n.addEventListener("input",a),n.__ieph=!0}n.setAttribute(e,t)}}var Ja={create:Ia,update:Ia};function Da(n,e){var t=e.elm,a=e.data,r=n.data;if(!(i(a.staticClass)&&i(a.class)&&(i(r)||i(r.staticClass)&&i(r.class)))){var s=da(e),l=t._transitionClasses;o(l)&&(s=ua(s,pa(l))),s!==t._prevClass&&(t.setAttribute("class",s),t._prevClass=s)}}var Na,Fa={create:Da,update:Da};function Ua(n,e,t){var a=Na;return function r(){var i=e.apply(null,arguments);null!==i&&Va(n,r,t,a)}}var qa=_e&&!(en&&Number(en[1])<=53);function Ra(n,e,t,a){if(qa){var r=st,i=e;e=i._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=r||n.timeStamp<=0||n.target.ownerDocument!==document)return i.apply(this,arguments)}}Na.addEventListener(n,e,an?{capture:t,passive:a}:t)}function Va(n,e,t,a){(a||Na).removeEventListener(n,e._wrapper||e,t)}function Za(n,e){if(!i(n.data.on)||!i(e.data.on)){var t=e.data.on||{},a=n.data.on||{};Na=e.elm||n.elm,function(n){if(o(n.__r)){var e=Q?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}o(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),Hn(t,a,Ra,Va,Ua,e.context),Na=void 0}}var Ha,$a={create:Za,update:Za,destroy:function(n){return Za(n,Ca)}};function Wa(n,e){if(!i(n.data.domProps)||!i(e.data.domProps)){var t,a,r=e.elm,l=n.data.domProps||{},d=e.data.domProps||{};for(t in(o(d.__ob__)||s(d._v_attr_proxy))&&(d=e.data.domProps=_({},d)),l)t in d||(r[t]="");for(t in d){if(a=d[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),a===l[t])continue;1===r.childNodes.length&&r.removeChild(r.childNodes[0])}if("value"===t&&"PROGRESS"!==r.tagName){r._value=a;var c=i(a)?"":String(a);Ka(r,c)&&(r.value=c)}else if("innerHTML"===t&&ga(r.tagName)&&i(r.innerHTML)){(Ha=Ha||document.createElement("div")).innerHTML="<svg>".concat(a,"</svg>");for(var u=Ha.firstChild;r.firstChild;)r.removeChild(r.firstChild);for(;u.firstChild;)r.appendChild(u.firstChild)}else if(a!==l[t])try{r[t]=a}catch(n){}}}}function Ka(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,a=n._vModifiers;if(o(a)){if(a.number)return b(t)!==b(e);if(a.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Qa={create:Wa,update:Wa},Ga=C((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var a=n.split(t);a.length>1&&(e[a[0].trim()]=a[1].trim())}})),e}));function Xa(n){var e=Ya(n.style);return n.staticStyle?_(n.staticStyle,e):e}function Ya(n){return Array.isArray(n)?B(n):"string"==typeof n?Ga(n):n}var nr,er=/^--/,tr=/\s*!important$/,ar=function(n,e,t){if(er.test(e))n.style.setProperty(e,t);else if(tr.test(t))n.style.setProperty(S(e),t.replace(tr,""),"important");else{var a=ir(e);if(Array.isArray(t))for(var r=0,i=t.length;r<i;r++)n.style[a]=t[r];else n.style[a]=t}},rr=["Webkit","Moz","ms"],ir=C((function(n){if(nr=nr||document.createElement("div").style,"filter"!==(n=L(n))&&n in nr)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<rr.length;t++){var a=rr[t]+e;if(a in nr)return a}}));function or(n,e){var t=e.data,a=n.data;if(!(i(t.staticStyle)&&i(t.style)&&i(a.staticStyle)&&i(a.style))){var r,s,l=e.elm,d=a.staticStyle,c=a.normalizedStyle||a.style||{},u=d||c,p=Ya(e.data.style)||{};e.data.normalizedStyle=o(p.__ob__)?_({},p):p;var m=function(n,e){var t,a={};if(e)for(var r=n;r.componentInstance;)(r=r.componentInstance._vnode)&&r.data&&(t=Xa(r.data))&&_(a,t);(t=Xa(n.data))&&_(a,t);for(var i=n;i=i.parent;)i.data&&(t=Xa(i.data))&&_(a,t);return a}(e,!0);for(s in u)i(m[s])&&ar(l,s,"");for(s in m)(r=m[s])!==u[s]&&ar(l,s,null==r?"":r)}}var sr={create:or,update:or},lr=/\s+/;function dr(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(lr).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" ".concat(n.getAttribute("class")||""," ");t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function cr(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(lr).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" ".concat(n.getAttribute("class")||""," "),a=" "+e+" ";t.indexOf(a)>=0;)t=t.replace(a," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function ur(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&_(e,pr(n.name||"v")),_(e,n),e}return"string"==typeof n?pr(n):void 0}}var pr=C((function(n){return{enterClass:"".concat(n,"-enter"),enterToClass:"".concat(n,"-enter-to"),enterActiveClass:"".concat(n,"-enter-active"),leaveClass:"".concat(n,"-leave"),leaveToClass:"".concat(n,"-leave-to"),leaveActiveClass:"".concat(n,"-leave-active")}})),mr=W&&!G,hr="transition",gr="transitionend",fr="animation",br="animationend";mr&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(hr="WebkitTransition",gr="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(fr="WebkitAnimation",br="webkitAnimationEnd"));var vr=W?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function yr(n){vr((function(){vr(n)}))}function kr(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),dr(n,e))}function xr(n,e){n._transitionClasses&&k(n._transitionClasses,e),cr(n,e)}function wr(n,e,t){var a=Er(n,e),r=a.type,i=a.timeout,o=a.propCount;if(!r)return t();var s="transition"===r?gr:br,l=0,d=function(){n.removeEventListener(s,c),t()},c=function(e){e.target===n&&++l>=o&&d()};setTimeout((function(){l<o&&d()}),i+1),n.addEventListener(s,c)}var Cr=/\b(transform|all)(,|$)/;function Er(n,e){var t,a=window.getComputedStyle(n),r=(a[hr+"Delay"]||"").split(", "),i=(a[hr+"Duration"]||"").split(", "),o=Lr(r,i),s=(a[fr+"Delay"]||"").split(", "),l=(a[fr+"Duration"]||"").split(", "),d=Lr(s,l),c=0,u=0;return"transition"===e?o>0&&(t="transition",c=o,u=i.length):"animation"===e?d>0&&(t="animation",c=d,u=l.length):u=(t=(c=Math.max(o,d))>0?o>d?"transition":"animation":null)?"transition"===t?i.length:l.length:0,{type:t,timeout:c,propCount:u,hasTransform:"transition"===t&&Cr.test(a[hr+"Property"])}}function Lr(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return Tr(e)+Tr(n[t])})))}function Tr(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function jr(n,e){var t=n.elm;o(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var a=ur(n.data.transition);if(!i(a)&&!o(t._enterCb)&&1===t.nodeType){for(var r=a.css,s=a.type,l=a.enterClass,u=a.enterToClass,p=a.enterActiveClass,m=a.appearClass,h=a.appearToClass,g=a.appearActiveClass,f=a.beforeEnter,v=a.enter,y=a.afterEnter,k=a.enterCancelled,x=a.beforeAppear,w=a.appear,C=a.afterAppear,E=a.appearCancelled,L=a.duration,T=Qe,j=Qe.$vnode;j&&j.parent;)T=j.context,j=j.parent;var S=!T._isMounted||!n.isRootInsert;if(!S||w||""===w){var A=S&&m?m:l,P=S&&g?g:p,_=S&&h?h:u,B=S&&x||f,z=S&&d(w)?w:v,I=S&&C||y,O=S&&E||k,M=b(c(L)?L.enter:L);0;var J=!1!==r&&!G,N=Pr(z),F=t._enterCb=D((function(){J&&(xr(t,_),xr(t,P)),F.cancelled?(J&&xr(t,A),O&&O(t)):I&&I(t),t._enterCb=null}));n.data.show||$n(n,"insert",(function(){var e=t.parentNode,a=e&&e._pending&&e._pending[n.key];a&&a.tag===n.tag&&a.elm._leaveCb&&a.elm._leaveCb(),z&&z(t,F)})),B&&B(t),J&&(kr(t,A),kr(t,P),yr((function(){xr(t,A),F.cancelled||(kr(t,_),N||(Ar(M)?setTimeout(F,M):wr(t,s,F)))}))),n.data.show&&(e&&e(),z&&z(t,F)),J||N||F()}}}function Sr(n,e){var t=n.elm;o(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var a=ur(n.data.transition);if(i(a)||1!==t.nodeType)return e();if(!o(t._leaveCb)){var r=a.css,s=a.type,l=a.leaveClass,d=a.leaveToClass,u=a.leaveActiveClass,p=a.beforeLeave,m=a.leave,h=a.afterLeave,g=a.leaveCancelled,f=a.delayLeave,v=a.duration,y=!1!==r&&!G,k=Pr(m),x=b(c(v)?v.leave:v);0;var w=t._leaveCb=D((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),y&&(xr(t,d),xr(t,u)),w.cancelled?(y&&xr(t,l),g&&g(t)):(e(),h&&h(t)),t._leaveCb=null}));f?f(C):C()}function C(){w.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),p&&p(t),y&&(kr(t,l),kr(t,u),yr((function(){xr(t,l),w.cancelled||(kr(t,d),k||(Ar(x)?setTimeout(w,x):wr(t,s,w)))}))),m&&m(t,w),y||k||w())}}function Ar(n){return"number"==typeof n&&!isNaN(n)}function Pr(n){if(i(n))return!1;var e=n.fns;return o(e)?Pr(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function _r(n,e){!0!==e.data.show&&jr(e)}var Br=function(n){var e,t,a={},d=n.modules,c=n.nodeOps;for(e=0;e<Ea.length;++e)for(a[Ea[e]]=[],t=0;t<d.length;++t)o(d[t][Ea[e]])&&a[Ea[e]].push(d[t][Ea[e]]);function u(n){var e=c.parentNode(n);o(e)&&c.removeChild(e,n)}function p(n,e,t,r,i,l,d){if(o(n.elm)&&o(l)&&(n=l[d]=fn(n)),n.isRootInsert=!i,!function(n,e,t,r){var i=n.data;if(o(i)){var l=o(n.componentInstance)&&i.keepAlive;if(o(i=i.hook)&&o(i=i.init)&&i(n,!1),o(n.componentInstance))return m(n,e),h(t,n.elm,r),s(l)&&function(n,e,t,r){var i,s=n;for(;s.componentInstance;)if(s=s.componentInstance._vnode,o(i=s.data)&&o(i=i.transition)){for(i=0;i<a.activate.length;++i)a.activate[i](Ca,s);e.push(s);break}h(t,n.elm,r)}(n,e,t,r),!0}}(n,e,t,r)){var u=n.data,p=n.children,f=n.tag;o(f)?(n.elm=n.ns?c.createElementNS(n.ns,f):c.createElement(f,n),y(n),g(n,p,e),o(u)&&b(n,e),h(t,n.elm,r)):s(n.isComment)?(n.elm=c.createComment(n.text),h(t,n.elm,r)):(n.elm=c.createTextNode(n.text),h(t,n.elm,r))}}function m(n,e){o(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,f(n)?(b(n,e),y(n)):(xa(n),e.push(n))}function h(n,e,t){o(n)&&(o(t)?c.parentNode(t)===n&&c.insertBefore(n,e,t):c.appendChild(n,e))}function g(n,e,t){if(r(e)){0;for(var a=0;a<e.length;++a)p(e[a],t,n.elm,null,!0,e,a)}else l(n.text)&&c.appendChild(n.elm,c.createTextNode(String(n.text)))}function f(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return o(n.tag)}function b(n,t){for(var r=0;r<a.create.length;++r)a.create[r](Ca,n);o(e=n.data.hook)&&(o(e.create)&&e.create(Ca,n),o(e.insert)&&t.push(n))}function y(n){var e;if(o(e=n.fnScopeId))c.setStyleScope(n.elm,e);else for(var t=n;t;)o(e=t.context)&&o(e=e.$options._scopeId)&&c.setStyleScope(n.elm,e),t=t.parent;o(e=Qe)&&e!==n.context&&e!==n.fnContext&&o(e=e.$options._scopeId)&&c.setStyleScope(n.elm,e)}function k(n,e,t,a,r,i){for(;a<=r;++a)p(t[a],i,n,e,!1,t,a)}function x(n){var e,t,r=n.data;if(o(r))for(o(e=r.hook)&&o(e=e.destroy)&&e(n),e=0;e<a.destroy.length;++e)a.destroy[e](n);if(o(e=n.children))for(t=0;t<n.children.length;++t)x(n.children[t])}function w(n,e,t){for(;e<=t;++e){var a=n[e];o(a)&&(o(a.tag)?(C(a),x(a)):u(a.elm))}}function C(n,e){if(o(e)||o(n.data)){var t,r=a.remove.length+1;for(o(e)?e.listeners+=r:e=function(n,e){function t(){0==--t.listeners&&u(n)}return t.listeners=e,t}(n.elm,r),o(t=n.componentInstance)&&o(t=t._vnode)&&o(t.data)&&C(t,e),t=0;t<a.remove.length;++t)a.remove[t](n,e);o(t=n.data.hook)&&o(t=t.remove)?t(n,e):e()}else u(n.elm)}function E(n,e,t,a){for(var r=t;r<a;r++){var i=e[r];if(o(i)&&La(n,i))return r}}function L(n,e,t,r,l,d){if(n!==e){o(e.elm)&&o(r)&&(e=r[l]=fn(e));var u=e.elm=n.elm;if(s(n.isAsyncPlaceholder))o(e.asyncFactory.resolved)?S(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(s(e.isStatic)&&s(n.isStatic)&&e.key===n.key&&(s(e.isCloned)||s(e.isOnce)))e.componentInstance=n.componentInstance;else{var m,h=e.data;o(h)&&o(m=h.hook)&&o(m=m.prepatch)&&m(n,e);var g=n.children,b=e.children;if(o(h)&&f(e)){for(m=0;m<a.update.length;++m)a.update[m](n,e);o(m=h.hook)&&o(m=m.update)&&m(n,e)}i(e.text)?o(g)&&o(b)?g!==b&&function(n,e,t,a,r){var s,l,d,u=0,m=0,h=e.length-1,g=e[0],f=e[h],b=t.length-1,v=t[0],y=t[b],x=!r;for(0;u<=h&&m<=b;)i(g)?g=e[++u]:i(f)?f=e[--h]:La(g,v)?(L(g,v,a,t,m),g=e[++u],v=t[++m]):La(f,y)?(L(f,y,a,t,b),f=e[--h],y=t[--b]):La(g,y)?(L(g,y,a,t,b),x&&c.insertBefore(n,g.elm,c.nextSibling(f.elm)),g=e[++u],y=t[--b]):La(f,v)?(L(f,v,a,t,m),x&&c.insertBefore(n,f.elm,g.elm),f=e[--h],v=t[++m]):(i(s)&&(s=Ta(e,u,h)),i(l=o(v.key)?s[v.key]:E(v,e,u,h))?p(v,a,n,g.elm,!1,t,m):La(d=e[l],v)?(L(d,v,a,t,m),e[l]=void 0,x&&c.insertBefore(n,d.elm,g.elm)):p(v,a,n,g.elm,!1,t,m),v=t[++m]);u>h?k(n,i(t[b+1])?null:t[b+1].elm,t,m,b,a):m>b&&w(e,u,h)}(u,g,b,t,d):o(b)?(o(n.text)&&c.setTextContent(u,""),k(u,null,b,0,b.length-1,t)):o(g)?w(g,0,g.length-1):o(n.text)&&c.setTextContent(u,""):n.text!==e.text&&c.setTextContent(u,e.text),o(h)&&o(m=h.hook)&&o(m=m.postpatch)&&m(n,e)}}}function T(n,e,t){if(s(t)&&o(n.parent))n.parent.data.pendingInsert=e;else for(var a=0;a<e.length;++a)e[a].data.hook.insert(e[a])}var j=v("attrs,class,staticClass,staticStyle,key");function S(n,e,t,a){var r,i=e.tag,l=e.data,d=e.children;if(a=a||l&&l.pre,e.elm=n,s(e.isComment)&&o(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(o(l)&&(o(r=l.hook)&&o(r=r.init)&&r(e,!0),o(r=e.componentInstance)))return m(e,t),!0;if(o(i)){if(o(d))if(n.hasChildNodes())if(o(r=l)&&o(r=r.domProps)&&o(r=r.innerHTML)){if(r!==n.innerHTML)return!1}else{for(var c=!0,u=n.firstChild,p=0;p<d.length;p++){if(!u||!S(u,d[p],t,a)){c=!1;break}u=u.nextSibling}if(!c||u)return!1}else g(e,d,t);if(o(l)){var h=!1;for(var f in l)if(!j(f)){h=!0,b(e,t);break}!h&&l.class&&qe(l.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,r){if(!i(e)){var l,d=!1,u=[];if(i(n))d=!0,p(e,u);else{var m=o(n.nodeType);if(!m&&La(n,e))L(n,e,u,null,null,r);else{if(m){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),s(t)&&S(n,e,u))return T(e,u,!0),n;l=n,n=new mn(c.tagName(l).toLowerCase(),{},[],void 0,l)}var h=n.elm,g=c.parentNode(h);if(p(e,u,h._leaveCb?null:g,c.nextSibling(h)),o(e.parent))for(var b=e.parent,v=f(e);b;){for(var y=0;y<a.destroy.length;++y)a.destroy[y](b);if(b.elm=e.elm,v){for(var k=0;k<a.create.length;++k)a.create[k](Ca,b);var C=b.data.hook.insert;if(C.merged)for(var E=1;E<C.fns.length;E++)C.fns[E]()}else xa(b);b=b.parent}o(g)?w([n],0,0):o(n.tag)&&x(n)}}return T(e,u,d),e.elm}o(n)&&x(n)}}({nodeOps:ya,modules:[Ja,Fa,$a,Qa,sr,W?{create:_r,activate:_r,remove:function(n,e){!0!==n.data.show?Sr(n,e):e()}}:{}].concat(za)});G&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&Fr(n,"input")}));var zr={inserted:function(n,e,t,a){"select"===t.tag?(a.elm&&!a.elm._vOptions?$n(t,"postpatch",(function(){zr.componentUpdated(n,e,t)})):Ir(n,e,t.context),n._vOptions=[].map.call(n.options,Jr)):("textarea"===t.tag||va(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",Dr),n.addEventListener("compositionend",Nr),n.addEventListener("change",Nr),G&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){Ir(n,e,t.context);var a=n._vOptions,r=n._vOptions=[].map.call(n.options,Jr);if(r.some((function(n,e){return!M(n,a[e])})))(n.multiple?e.value.some((function(n){return Mr(n,r)})):e.value!==e.oldValue&&Mr(e.value,r))&&Fr(n,"change")}}};function Ir(n,e,t){Or(n,e,t),(Q||X)&&setTimeout((function(){Or(n,e,t)}),0)}function Or(n,e,t){var a=e.value,r=n.multiple;if(!r||Array.isArray(a)){for(var i,o,s=0,l=n.options.length;s<l;s++)if(o=n.options[s],r)i=J(a,Jr(o))>-1,o.selected!==i&&(o.selected=i);else if(M(Jr(o),a))return void(n.selectedIndex!==s&&(n.selectedIndex=s));r||(n.selectedIndex=-1)}}function Mr(n,e){return e.every((function(e){return!M(e,n)}))}function Jr(n){return"_value"in n?n._value:n.value}function Dr(n){n.target.composing=!0}function Nr(n){n.target.composing&&(n.target.composing=!1,Fr(n.target,"input"))}function Fr(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function Ur(n){return!n.componentInstance||n.data&&n.data.transition?n:Ur(n.componentInstance._vnode)}var qr={model:zr,show:{bind:function(n,e,t){var a=e.value,r=(t=Ur(t)).data&&t.data.transition,i=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;a&&r?(t.data.show=!0,jr(t,(function(){n.style.display=i}))):n.style.display=a?i:"none"},update:function(n,e,t){var a=e.value;!a!=!e.oldValue&&((t=Ur(t)).data&&t.data.transition?(t.data.show=!0,a?jr(t,(function(){n.style.display=n.__vOriginalDisplay})):Sr(t,(function(){n.style.display="none"}))):n.style.display=a?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,a,r){r||(n.style.display=n.__vOriginalDisplay)}}},Rr={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function Vr(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?Vr(Ee(e.children)):n}function Zr(n){var e={},t=n.$options;for(var a in t.propsData)e[a]=n[a];var r=t._parentListeners;for(var a in r)e[L(a)]=r[a];return e}function Hr(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var $r=function(n){return n.tag||he(n)},Wr=function(n){return"show"===n.name},Kr={name:"transition",props:Rr,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter($r)).length){0;var a=this.mode;0;var r=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return r;var i=Vr(r);if(!i)return r;if(this._leaving)return Hr(n,r);var o="__transition-".concat(this._uid,"-");i.key=null==i.key?i.isComment?o+"comment":o+i.tag:l(i.key)?0===String(i.key).indexOf(o)?i.key:o+i.key:i.key;var s=(i.data||(i.data={})).transition=Zr(this),d=this._vnode,c=Vr(d);if(i.data.directives&&i.data.directives.some(Wr)&&(i.data.show=!0),c&&c.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(i,c)&&!he(c)&&(!c.componentInstance||!c.componentInstance._vnode.isComment)){var u=c.data.transition=_({},s);if("out-in"===a)return this._leaving=!0,$n(u,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),Hr(n,r);if("in-out"===a){if(he(i))return d;var p,m=function(){p()};$n(s,"afterEnter",m),$n(s,"enterCancelled",m),$n(u,"delayLeave",(function(n){p=n}))}}return r}}},Qr=_({tag:String,moveClass:String},Rr);function Gr(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Xr(n){n.data.newPos=n.elm.getBoundingClientRect()}function Yr(n){var e=n.data.pos,t=n.data.newPos,a=e.left-t.left,r=e.top-t.top;if(a||r){n.data.moved=!0;var i=n.elm.style;i.transform=i.WebkitTransform="translate(".concat(a,"px,").concat(r,"px)"),i.transitionDuration="0s"}}delete Qr.mode;var ni={Transition:Kr,TransitionGroup:{props:Qr,beforeMount:function(){var n=this,e=this._update;this._update=function(t,a){var r=Ge(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,r(),e.call(n,t,a)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),a=this.prevChildren=this.children,r=this.$slots.default||[],i=this.children=[],o=Zr(this),s=0;s<r.length;s++){if((c=r[s]).tag)if(null!=c.key&&0!==String(c.key).indexOf("__vlist"))i.push(c),t[c.key]=c,(c.data||(c.data={})).transition=o;else;}if(a){var l=[],d=[];for(s=0;s<a.length;s++){var c;(c=a[s]).data.transition=o,c.data.pos=c.elm.getBoundingClientRect(),t[c.key]?l.push(c):d.push(c)}this.kept=n(e,null,l),this.removed=d}return n(e,null,i)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Gr),n.forEach(Xr),n.forEach(Yr),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,a=t.style;kr(t,e),a.transform=a.WebkitTransform=a.transitionDuration="",t.addEventListener(gr,t._moveCb=function n(a){a&&a.target!==t||a&&!/transform$/.test(a.propertyName)||(t.removeEventListener(gr,n),t._moveCb=null,xr(t,e))})}})))},methods:{hasMove:function(n,e){if(!mr)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){cr(t,n)})),dr(t,e),t.style.display="none",this.$el.appendChild(t);var a=Er(t);return this.$el.removeChild(t),this._hasMove=a.hasTransform}}}};function ei(n,e){for(var t in e)n[t]=e[t];return n}Ht.config.mustUseProp=function(n,e,t){return"value"===t&&ea(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},Ht.config.isReservedTag=fa,Ht.config.isReservedAttr=na,Ht.config.getTagNamespace=function(n){return ga(n)?"svg":"math"===n?"math":void 0},Ht.config.isUnknownElement=function(n){if(!W)return!0;if(fa(n))return!1;if(n=n.toLowerCase(),null!=ba[n])return ba[n];var e=document.createElement(n);return n.indexOf("-")>-1?ba[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:ba[n]=/HTMLUnknownElement/.test(e.toString())},_(Ht.options.directives,qr),_(Ht.options.components,ni),Ht.prototype.__patch__=W?Br:z,Ht.prototype.$mount=function(n,e){return function(n,e,t){var a;n.$el=e,n.$options.render||(n.$options.render=hn),nt(n,"beforeMount"),a=function(){n._update(n._render(),t)},new Ze(n,a,z,{before:function(){n._isMounted&&!n._isDestroyed&&nt(n,"beforeUpdate")}},!0),t=!1;var r=n._preWatchers;if(r)for(var i=0;i<r.length;i++)r[i].run();return null==n.$vnode&&(n._isMounted=!0,nt(n,"mounted")),n}(this,n=n&&W?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},W&&setTimeout((function(){q.devtools&&sn&&sn.emit("init",Ht)}),0);var ti=/[!'()*]/g,ai=function(n){return"%"+n.charCodeAt(0).toString(16)},ri=/%2C/g,ii=function(n){return encodeURIComponent(n).replace(ti,ai).replace(ri,",")};function oi(n){try{return decodeURIComponent(n)}catch(n){0}return n}var si=function(n){return null==n||"object"==typeof n?n:String(n)};function li(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),a=oi(t.shift()),r=t.length>0?oi(t.join("=")):null;void 0===e[a]?e[a]=r:Array.isArray(e[a])?e[a].push(r):e[a]=[e[a],r]})),e):e}function di(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return ii(e);if(Array.isArray(t)){var a=[];return t.forEach((function(n){void 0!==n&&(null===n?a.push(ii(e)):a.push(ii(e)+"="+ii(n)))})),a.join("&")}return ii(e)+"="+ii(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var ci=/\/?$/;function ui(n,e,t,a){var r=a&&a.options.stringifyQuery,i=e.query||{};try{i=pi(i)}catch(n){}var o={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:i,params:e.params||{},fullPath:gi(e,r),matched:n?hi(n):[]};return t&&(o.redirectedFrom=gi(t,r)),Object.freeze(o)}function pi(n){if(Array.isArray(n))return n.map(pi);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=pi(n[t]);return e}return n}var mi=ui(null,{path:"/"});function hi(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function gi(n,e){var t=n.path,a=n.query;void 0===a&&(a={});var r=n.hash;return void 0===r&&(r=""),(t||"/")+(e||di)(a)+r}function fi(n,e,t){return e===mi?n===e:!!e&&(n.path&&e.path?n.path.replace(ci,"")===e.path.replace(ci,"")&&(t||n.hash===e.hash&&bi(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&bi(n.query,e.query)&&bi(n.params,e.params))))}function bi(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),a=Object.keys(e).sort();return t.length===a.length&&t.every((function(t,r){var i=n[t];if(a[r]!==t)return!1;var o=e[t];return null==i||null==o?i===o:"object"==typeof i&&"object"==typeof o?bi(i,o):String(i)===String(o)}))}function vi(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var a in t.instances){var r=t.instances[a],i=t.enteredCbs[a];if(r&&i){delete t.enteredCbs[a];for(var o=0;o<i.length;o++)r._isBeingDestroyed||i[o](r)}}}}var yi={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,a=e.children,r=e.parent,i=e.data;i.routerView=!0;for(var o=r.$createElement,s=t.name,l=r.$route,d=r._routerViewCache||(r._routerViewCache={}),c=0,u=!1;r&&r._routerRoot!==r;){var p=r.$vnode?r.$vnode.data:{};p.routerView&&c++,p.keepAlive&&r._directInactive&&r._inactive&&(u=!0),r=r.$parent}if(i.routerViewDepth=c,u){var m=d[s],h=m&&m.component;return h?(m.configProps&&ki(h,i,m.route,m.configProps),o(h,i,a)):o()}var g=l.matched[c],f=g&&g.components[s];if(!g||!f)return d[s]=null,o();d[s]={component:f},i.registerRouteInstance=function(n,e){var t=g.instances[s];(e&&t!==n||!e&&t===n)&&(g.instances[s]=e)},(i.hook||(i.hook={})).prepatch=function(n,e){g.instances[s]=e.componentInstance},i.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==g.instances[s]&&(g.instances[s]=n.componentInstance),vi(l)};var b=g.props&&g.props[s];return b&&(ei(d[s],{route:l,configProps:b}),ki(f,i,l,b)),o(f,i,a)}};function ki(n,e,t,a){var r=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,a);if(r){r=e.props=ei({},r);var i=e.attrs=e.attrs||{};for(var o in r)n.props&&o in n.props||(i[o]=r[o],delete r[o])}}function xi(n,e,t){var a=n.charAt(0);if("/"===a)return n;if("?"===a||"#"===a)return e+n;var r=e.split("/");t&&r[r.length-1]||r.pop();for(var i=n.replace(/^\//,"").split("/"),o=0;o<i.length;o++){var s=i[o];".."===s?r.pop():"."!==s&&r.push(s)}return""!==r[0]&&r.unshift(""),r.join("/")}function wi(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var Ci=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},Ei=Di,Li=Pi,Ti=function(n,e){return Bi(Pi(n,e),e)},ji=Bi,Si=Ji,Ai=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function Pi(n,e){for(var t,a=[],r=0,i=0,o="",s=e&&e.delimiter||"/";null!=(t=Ai.exec(n));){var l=t[0],d=t[1],c=t.index;if(o+=n.slice(i,c),i=c+l.length,d)o+=d[1];else{var u=n[i],p=t[2],m=t[3],h=t[4],g=t[5],f=t[6],b=t[7];o&&(a.push(o),o="");var v=null!=p&&null!=u&&u!==p,y="+"===f||"*"===f,k="?"===f||"*"===f,x=t[2]||s,w=h||g;a.push({name:m||r++,prefix:p||"",delimiter:x,optional:k,repeat:y,partial:v,asterisk:!!b,pattern:w?Ii(w):b?".*":"[^"+zi(x)+"]+?"})}}return i<n.length&&(o+=n.substr(i)),o&&a.push(o),a}function _i(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function Bi(n,e){for(var t=new Array(n.length),a=0;a<n.length;a++)"object"==typeof n[a]&&(t[a]=new RegExp("^(?:"+n[a].pattern+")$",Mi(e)));return function(e,a){for(var r="",i=e||{},o=(a||{}).pretty?_i:encodeURIComponent,s=0;s<n.length;s++){var l=n[s];if("string"!=typeof l){var d,c=i[l.name];if(null==c){if(l.optional){l.partial&&(r+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(Ci(c)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(c)+"`");if(0===c.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var u=0;u<c.length;u++){if(d=o(c[u]),!t[s].test(d))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(d)+"`");r+=(0===u?l.prefix:l.delimiter)+d}}else{if(d=l.asterisk?encodeURI(c).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):o(c),!t[s].test(d))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+d+'"');r+=l.prefix+d}}else r+=l}return r}}function zi(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function Ii(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function Oi(n,e){return n.keys=e,n}function Mi(n){return n&&n.sensitive?"":"i"}function Ji(n,e,t){Ci(e)||(t=e||t,e=[]);for(var a=(t=t||{}).strict,r=!1!==t.end,i="",o=0;o<n.length;o++){var s=n[o];if("string"==typeof s)i+=zi(s);else{var l=zi(s.prefix),d="(?:"+s.pattern+")";e.push(s),s.repeat&&(d+="(?:"+l+d+")*"),i+=d=s.optional?s.partial?l+"("+d+")?":"(?:"+l+"("+d+"))?":l+"("+d+")"}}var c=zi(t.delimiter||"/"),u=i.slice(-c.length)===c;return a||(i=(u?i.slice(0,-c.length):i)+"(?:"+c+"(?=$))?"),i+=r?"$":a&&u?"":"(?="+c+"|$)",Oi(new RegExp("^"+i,Mi(t)),e)}function Di(n,e,t){return Ci(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var a=0;a<t.length;a++)e.push({name:a,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return Oi(n,e)}(n,e):Ci(n)?function(n,e,t){for(var a=[],r=0;r<n.length;r++)a.push(Di(n[r],e,t).source);return Oi(new RegExp("(?:"+a.join("|")+")",Mi(t)),e)}(n,e,t):function(n,e,t){return Ji(Pi(n,t),e,t)}(n,e,t)}Ei.parse=Li,Ei.compile=Ti,Ei.tokensToFunction=ji,Ei.tokensToRegExp=Si;var Ni=Object.create(null);function Fi(n,e,t){e=e||{};try{var a=Ni[n]||(Ni[n]=Ei.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),a(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function Ui(n,e,t,a){var r="string"==typeof n?{path:n}:n;if(r._normalized)return r;if(r.name){var i=(r=ei({},n)).params;return i&&"object"==typeof i&&(r.params=ei({},i)),r}if(!r.path&&r.params&&e){(r=ei({},r))._normalized=!0;var o=ei(ei({},e.params),r.params);if(e.name)r.name=e.name,r.params=o;else if(e.matched.length){var s=e.matched[e.matched.length-1].path;r.path=Fi(s,o,e.path)}else 0;return r}var l=function(n){var e="",t="",a=n.indexOf("#");a>=0&&(e=n.slice(a),n=n.slice(0,a));var r=n.indexOf("?");return r>=0&&(t=n.slice(r+1),n=n.slice(0,r)),{path:n,query:t,hash:e}}(r.path||""),d=e&&e.path||"/",c=l.path?xi(l.path,d,t||r.append):d,u=function(n,e,t){void 0===e&&(e={});var a,r=t||li;try{a=r(n||"")}catch(n){a={}}for(var i in e){var o=e[i];a[i]=Array.isArray(o)?o.map(si):si(o)}return a}(l.query,r.query,a&&a.options.parseQuery),p=r.hash||l.hash;return p&&"#"!==p.charAt(0)&&(p="#"+p),{_normalized:!0,path:c,query:u,hash:p}}var qi,Ri=function(){},Vi={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,a=this.$route,r=t.resolve(this.to,a,this.append),i=r.location,o=r.route,s=r.href,l={},d=t.options.linkActiveClass,c=t.options.linkExactActiveClass,u=null==d?"router-link-active":d,p=null==c?"router-link-exact-active":c,m=null==this.activeClass?u:this.activeClass,h=null==this.exactActiveClass?p:this.exactActiveClass,g=o.redirectedFrom?ui(null,Ui(o.redirectedFrom),null,t):o;l[h]=fi(a,g,this.exactPath),l[m]=this.exact||this.exactPath?l[h]:function(n,e){return 0===n.path.replace(ci,"/").indexOf(e.path.replace(ci,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(a,g);var f=l[h]?this.ariaCurrentValue:null,b=function(n){Zi(n)&&(e.replace?t.replace(i,Ri):t.push(i,Ri))},v={click:Zi};Array.isArray(this.event)?this.event.forEach((function(n){v[n]=b})):v[this.event]=b;var y={class:l},k=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:s,route:o,navigate:b,isActive:l[m],isExactActive:l[h]});if(k){if(1===k.length)return k[0];if(k.length>1||!k.length)return 0===k.length?n():n("span",{},k)}if("a"===this.tag)y.on=v,y.attrs={href:s,"aria-current":f};else{var x=function n(e){var t;if(e)for(var a=0;a<e.length;a++){if("a"===(t=e[a]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(x){x.isStatic=!1;var w=x.data=ei({},x.data);for(var C in w.on=w.on||{},w.on){var E=w.on[C];C in v&&(w.on[C]=Array.isArray(E)?E:[E])}for(var L in v)L in w.on?w.on[L].push(v[L]):w.on[L]=b;var T=x.data.attrs=ei({},x.data.attrs);T.href=s,T["aria-current"]=f}else y.on=v}return n(this.tag,y,this.$slots.default)}};function Zi(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var Hi="undefined"!=typeof window;function $i(n,e,t,a,r){var i=e||[],o=t||Object.create(null),s=a||Object.create(null);n.forEach((function(n){!function n(e,t,a,r,i,o){var s=r.path,l=r.name;0;var d=r.pathToRegexpOptions||{},c=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return wi(e.path+"/"+n)}(s,i,d.strict);"boolean"==typeof r.caseSensitive&&(d.sensitive=r.caseSensitive);var u={path:c,regex:Wi(c,d),components:r.components||{default:r.component},alias:r.alias?"string"==typeof r.alias?[r.alias]:r.alias:[],instances:{},enteredCbs:{},name:l,parent:i,matchAs:o,redirect:r.redirect,beforeEnter:r.beforeEnter,meta:r.meta||{},props:null==r.props?{}:r.components?r.props:{default:r.props}};r.children&&r.children.forEach((function(r){var i=o?wi(o+"/"+r.path):void 0;n(e,t,a,r,u,i)}));t[u.path]||(e.push(u.path),t[u.path]=u);if(void 0!==r.alias)for(var p=Array.isArray(r.alias)?r.alias:[r.alias],m=0;m<p.length;++m){0;var h={path:p[m],children:r.children};n(e,t,a,h,i,u.path||"/")}l&&(a[l]||(a[l]=u))}(i,o,s,n,r)}));for(var l=0,d=i.length;l<d;l++)"*"===i[l]&&(i.push(i.splice(l,1)[0]),d--,l--);return{pathList:i,pathMap:o,nameMap:s}}function Wi(n,e){return Ei(n,[],e)}function Ki(n,e){var t=$i(n),a=t.pathList,r=t.pathMap,i=t.nameMap;function o(n,t,o){var s=Ui(n,t,!1,e),d=s.name;if(d){var c=i[d];if(!c)return l(null,s);var u=c.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof s.params&&(s.params={}),t&&"object"==typeof t.params)for(var p in t.params)!(p in s.params)&&u.indexOf(p)>-1&&(s.params[p]=t.params[p]);return s.path=Fi(c.path,s.params),l(c,s,o)}if(s.path){s.params={};for(var m=0;m<a.length;m++){var h=a[m],g=r[h];if(Qi(g.regex,s.path,s.params))return l(g,s,o)}}return l(null,s)}function s(n,t){var a=n.redirect,r="function"==typeof a?a(ui(n,t,null,e)):a;if("string"==typeof r&&(r={path:r}),!r||"object"!=typeof r)return l(null,t);var s=r,d=s.name,c=s.path,u=t.query,p=t.hash,m=t.params;if(u=s.hasOwnProperty("query")?s.query:u,p=s.hasOwnProperty("hash")?s.hash:p,m=s.hasOwnProperty("params")?s.params:m,d){i[d];return o({_normalized:!0,name:d,query:u,hash:p,params:m},void 0,t)}if(c){var h=function(n,e){return xi(n,e.parent?e.parent.path:"/",!0)}(c,n);return o({_normalized:!0,path:Fi(h,m),query:u,hash:p},void 0,t)}return l(null,t)}function l(n,t,a){return n&&n.redirect?s(n,a||t):n&&n.matchAs?function(n,e,t){var a=o({_normalized:!0,path:Fi(t,e.params)});if(a){var r=a.matched,i=r[r.length-1];return e.params=a.params,l(i,e)}return l(null,e)}(0,t,n.matchAs):ui(n,t,a,e)}return{match:o,addRoute:function(n,e){var t="object"!=typeof n?i[n]:void 0;$i([e||n],a,r,i,t),t&&t.alias.length&&$i(t.alias.map((function(n){return{path:n,children:[e]}})),a,r,i,t)},getRoutes:function(){return a.map((function(n){return r[n]}))},addRoutes:function(n){$i(n,a,r,i)}}}function Qi(n,e,t){var a=e.match(n);if(!a)return!1;if(!t)return!0;for(var r=1,i=a.length;r<i;++r){var o=n.keys[r-1];o&&(t[o.name||"pathMatch"]="string"==typeof a[r]?oi(a[r]):a[r])}return!0}var Gi=Hi&&window.performance&&window.performance.now?window.performance:Date;function Xi(){return Gi.now().toFixed(3)}var Yi=Xi();function no(){return Yi}function eo(n){return Yi=n}var to=Object.create(null);function ao(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=ei({},window.history.state);return t.key=no(),window.history.replaceState(t,"",e),window.addEventListener("popstate",oo),function(){window.removeEventListener("popstate",oo)}}function ro(n,e,t,a){if(n.app){var r=n.options.scrollBehavior;r&&n.app.$nextTick((function(){var i=function(){var n=no();if(n)return to[n]}(),o=r.call(n,e,t,a?i:null);o&&("function"==typeof o.then?o.then((function(n){po(n,i)})).catch((function(n){0})):po(o,i))}))}}function io(){var n=no();n&&(to[n]={x:window.pageXOffset,y:window.pageYOffset})}function oo(n){io(),n.state&&n.state.key&&eo(n.state.key)}function so(n){return co(n.x)||co(n.y)}function lo(n){return{x:co(n.x)?n.x:window.pageXOffset,y:co(n.y)?n.y:window.pageYOffset}}function co(n){return"number"==typeof n}var uo=/^#\d/;function po(n,e){var t,a="object"==typeof n;if(a&&"string"==typeof n.selector){var r=uo.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(r){var i=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),a=n.getBoundingClientRect();return{x:a.left-t.left-e.x,y:a.top-t.top-e.y}}(r,i={x:co((t=i).x)?t.x:0,y:co(t.y)?t.y:0})}else so(n)&&(e=lo(n))}else a&&so(n)&&(e=lo(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var mo,ho=Hi&&((-1===(mo=window.navigator.userAgent).indexOf("Android 2.")&&-1===mo.indexOf("Android 4.0")||-1===mo.indexOf("Mobile Safari")||-1!==mo.indexOf("Chrome")||-1!==mo.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function go(n,e){io();var t=window.history;try{if(e){var a=ei({},t.state);a.key=no(),t.replaceState(a,"",n)}else t.pushState({key:eo(Xi())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function fo(n){go(n,!0)}var bo={redirected:2,aborted:4,cancelled:8,duplicated:16};function vo(n,e){return ko(n,e,bo.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return xo.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function yo(n,e){return ko(n,e,bo.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function ko(n,e,t,a){var r=new Error(a);return r._isRouter=!0,r.from=n,r.to=e,r.type=t,r}var xo=["params","query","hash"];function wo(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function Co(n,e){return wo(n)&&n._isRouter&&(null==e||n.type===e)}function Eo(n,e,t){var a=function(r){r>=n.length?t():n[r]?e(n[r],(function(){a(r+1)})):a(r+1)};a(0)}function Lo(n){return function(e,t,a){var r=!1,i=0,o=null;To(n,(function(n,e,t,s){if("function"==typeof n&&void 0===n.cid){r=!0,i++;var l,d=Ao((function(e){var r;((r=e).__esModule||So&&"Module"===r[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:qi.extend(e),t.components[s]=e,--i<=0&&a()})),c=Ao((function(n){var e="Failed to resolve async component "+s+": "+n;o||(o=wo(n)?n:new Error(e),a(o))}));try{l=n(d,c)}catch(n){c(n)}if(l)if("function"==typeof l.then)l.then(d,c);else{var u=l.component;u&&"function"==typeof u.then&&u.then(d,c)}}})),r||a()}}function To(n,e){return jo(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function jo(n){return Array.prototype.concat.apply([],n)}var So="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function Ao(n){var e=!1;return function(){for(var t=[],a=arguments.length;a--;)t[a]=arguments[a];if(!e)return e=!0,n.apply(this,t)}}var Po=function(n,e){this.router=n,this.base=function(n){if(!n)if(Hi){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=mi,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function _o(n,e,t,a){var r=To(n,(function(n,a,r,i){var o=function(n,e){"function"!=typeof n&&(n=qi.extend(n));return n.options[e]}(n,e);if(o)return Array.isArray(o)?o.map((function(n){return t(n,a,r,i)})):t(o,a,r,i)}));return jo(a?r.reverse():r)}function Bo(n,e){if(e)return function(){return n.apply(e,arguments)}}Po.prototype.listen=function(n){this.cb=n},Po.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},Po.prototype.onError=function(n){this.errorCbs.push(n)},Po.prototype.transitionTo=function(n,e,t){var a,r=this;try{a=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var i=this.current;this.confirmTransition(a,(function(){r.updateRoute(a),e&&e(a),r.ensureURL(),r.router.afterHooks.forEach((function(n){n&&n(a,i)})),r.ready||(r.ready=!0,r.readyCbs.forEach((function(n){n(a)})))}),(function(n){t&&t(n),n&&!r.ready&&(Co(n,bo.redirected)&&i===mi||(r.ready=!0,r.readyErrorCbs.forEach((function(e){e(n)}))))}))},Po.prototype.confirmTransition=function(n,e,t){var a=this,r=this.current;this.pending=n;var i,o,s=function(n){!Co(n)&&wo(n)&&(a.errorCbs.length?a.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},l=n.matched.length-1,d=r.matched.length-1;if(fi(n,r)&&l===d&&n.matched[l]===r.matched[d])return this.ensureURL(),n.hash&&ro(this.router,r,n,!1),s(((o=ko(i=r,n,bo.duplicated,'Avoided redundant navigation to current location: "'+i.fullPath+'".')).name="NavigationDuplicated",o));var c=function(n,e){var t,a=Math.max(n.length,e.length);for(t=0;t<a&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),u=c.updated,p=c.deactivated,m=c.activated,h=[].concat(function(n){return _o(n,"beforeRouteLeave",Bo,!0)}(p),this.router.beforeHooks,function(n){return _o(n,"beforeRouteUpdate",Bo)}(u),m.map((function(n){return n.beforeEnter})),Lo(m)),g=function(e,t){if(a.pending!==n)return s(yo(r,n));try{e(n,r,(function(e){!1===e?(a.ensureURL(!0),s(function(n,e){return ko(n,e,bo.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(r,n))):wo(e)?(a.ensureURL(!0),s(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(s(vo(r,n)),"object"==typeof e&&e.replace?a.replace(e):a.push(e)):t(e)}))}catch(n){s(n)}};Eo(h,g,(function(){Eo(function(n){return _o(n,"beforeRouteEnter",(function(n,e,t,a){return function(n,e,t){return function(a,r,i){return n(a,r,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),i(n)}))}}(n,t,a)}))}(m).concat(a.router.resolveHooks),g,(function(){if(a.pending!==n)return s(yo(r,n));a.pending=null,e(n),a.router.app&&a.router.app.$nextTick((function(){vi(n)}))}))}))},Po.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},Po.prototype.setupListeners=function(){},Po.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=mi,this.pending=null};var zo=function(n){function e(e,t){n.call(this,e,t),this._startLocation=Io(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,a=ho&&t;a&&this.listeners.push(ao());var r=function(){var t=n.current,r=Io(n.base);n.current===mi&&r===n._startLocation||n.transitionTo(r,(function(n){a&&ro(e,n,t,!0)}))};window.addEventListener("popstate",r),this.listeners.push((function(){window.removeEventListener("popstate",r)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var a=this,r=this.current;this.transitionTo(n,(function(n){go(wi(a.base+n.fullPath)),ro(a.router,n,r,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this,r=this.current;this.transitionTo(n,(function(n){fo(wi(a.base+n.fullPath)),ro(a.router,n,r,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(Io(this.base)!==this.current.fullPath){var e=wi(this.base+this.current.fullPath);n?go(e):fo(e)}},e.prototype.getCurrentLocation=function(){return Io(this.base)},e}(Po);function Io(n){var e=window.location.pathname,t=e.toLowerCase(),a=n.toLowerCase();return!n||t!==a&&0!==t.indexOf(wi(a+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var Oo=function(n){function e(e,t,a){n.call(this,e,t),a&&function(n){var e=Io(n);if(!/^\/#/.test(e))return window.location.replace(wi(n+"/#"+e)),!0}(this.base)||Mo()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=ho&&e;t&&this.listeners.push(ao());var a=function(){var e=n.current;Mo()&&n.transitionTo(Jo(),(function(a){t&&ro(n.router,a,e,!0),ho||Fo(a.fullPath)}))},r=ho?"popstate":"hashchange";window.addEventListener(r,a),this.listeners.push((function(){window.removeEventListener(r,a)}))}},e.prototype.push=function(n,e,t){var a=this,r=this.current;this.transitionTo(n,(function(n){No(n.fullPath),ro(a.router,n,r,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this,r=this.current;this.transitionTo(n,(function(n){Fo(n.fullPath),ro(a.router,n,r,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;Jo()!==e&&(n?No(e):Fo(e))},e.prototype.getCurrentLocation=function(){return Jo()},e}(Po);function Mo(){var n=Jo();return"/"===n.charAt(0)||(Fo("/"+n),!1)}function Jo(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function Do(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function No(n){ho?go(Do(n)):window.location.hash=n}function Fo(n){ho?fo(Do(n)):window.location.replace(Do(n))}var Uo=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var a=this;this.transitionTo(n,(function(n){a.stack=a.stack.slice(0,a.index+1).concat(n),a.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this;this.transitionTo(n,(function(n){a.stack=a.stack.slice(0,a.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var a=this.stack[t];this.confirmTransition(a,(function(){var n=e.current;e.index=t,e.updateRoute(a),e.router.afterHooks.forEach((function(e){e&&e(a,n)}))}),(function(n){Co(n,bo.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(Po),qo=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Ki(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!ho&&!1!==n.fallback,this.fallback&&(e="hash"),Hi||(e="abstract"),this.mode=e,e){case"history":this.history=new zo(this,n.base);break;case"hash":this.history=new Oo(this,n.base,this.fallback);break;case"abstract":this.history=new Uo(this,n.base);break;default:0}},Ro={currentRoute:{configurable:!0}};qo.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},Ro.currentRoute.get=function(){return this.history&&this.history.current},qo.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof zo||t instanceof Oo){var a=function(n){t.setupListeners(),function(n){var a=t.current,r=e.options.scrollBehavior;ho&&r&&"fullPath"in n&&ro(e,n,a,!1)}(n)};t.transitionTo(t.getCurrentLocation(),a,a)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},qo.prototype.beforeEach=function(n){return Zo(this.beforeHooks,n)},qo.prototype.beforeResolve=function(n){return Zo(this.resolveHooks,n)},qo.prototype.afterEach=function(n){return Zo(this.afterHooks,n)},qo.prototype.onReady=function(n,e){this.history.onReady(n,e)},qo.prototype.onError=function(n){this.history.onError(n)},qo.prototype.push=function(n,e,t){var a=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){a.history.push(n,e,t)}));this.history.push(n,e,t)},qo.prototype.replace=function(n,e,t){var a=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){a.history.replace(n,e,t)}));this.history.replace(n,e,t)},qo.prototype.go=function(n){this.history.go(n)},qo.prototype.back=function(){this.go(-1)},qo.prototype.forward=function(){this.go(1)},qo.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},qo.prototype.resolve=function(n,e,t){var a=Ui(n,e=e||this.history.current,t,this),r=this.match(a,e),i=r.redirectedFrom||r.fullPath;return{location:a,route:r,href:function(n,e,t){var a="hash"===t?"#"+e:e;return n?wi(n+"/"+a):a}(this.history.base,i,this.mode),normalizedTo:a,resolved:r}},qo.prototype.getRoutes=function(){return this.matcher.getRoutes()},qo.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==mi&&this.history.transitionTo(this.history.getCurrentLocation())},qo.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==mi&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(qo.prototype,Ro);var Vo=qo;function Zo(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}qo.install=function n(e){if(!n.installed||qi!==e){n.installed=!0,qi=e;var t=function(n){return void 0!==n},a=function(n,e){var a=n.$options._parentVnode;t(a)&&t(a=a.data)&&t(a=a.registerRouteInstance)&&a(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,a(this,this)},destroyed:function(){a(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",yi),e.component("RouterLink",Vi);var r=e.config.optionMergeStrategies;r.beforeRouteEnter=r.beforeRouteLeave=r.beforeRouteUpdate=r.created}},qo.version="3.6.5",qo.isNavigationFailure=Co,qo.NavigationFailureType=bo,qo.START_LOCATION=mi,Hi&&window.Vue&&window.Vue.use(qo);t(104);t(16),t(101);var Ho={NotFound:()=>Promise.all([t.e(0),t.e(5)]).then(t.bind(null,332)),Layout:()=>Promise.all([t.e(0),t.e(2)]).then(t.bind(null,330))},$o={"v-177c102a":()=>t.e(7).then(t.bind(null,334)),"v-2d7fd9fc":()=>t.e(9).then(t.bind(null,335)),"v-0c96d161":()=>t.e(8).then(t.bind(null,336)),"v-6b386ebf":()=>t.e(10).then(t.bind(null,337)),"v-2f72ba66":()=>t.e(11).then(t.bind(null,338)),"v-6950b4e9":()=>t.e(12).then(t.bind(null,339)),"v-3b417cdd":()=>t.e(13).then(t.bind(null,340)),"v-3676674e":()=>t.e(14).then(t.bind(null,341)),"v-49bdbdb9":()=>t.e(15).then(t.bind(null,342)),"v-45d73e1d":()=>t.e(16).then(t.bind(null,343)),"v-8c545382":()=>t.e(17).then(t.bind(null,344)),"v-76f6c282":()=>t.e(18).then(t.bind(null,345)),"v-975bc690":()=>t.e(19).then(t.bind(null,346)),"v-074d5d6d":()=>t.e(20).then(t.bind(null,347)),"v-f15f9572":()=>t.e(21).then(t.bind(null,348)),"v-b94bd26c":()=>t.e(22).then(t.bind(null,349)),"v-325034ba":()=>t.e(23).then(t.bind(null,350)),"v-6d4f7ede":()=>t.e(24).then(t.bind(null,351)),"v-2d7b28d6":()=>t.e(25).then(t.bind(null,352)),"v-54833ab4":()=>t.e(26).then(t.bind(null,353)),"v-f4a93384":()=>t.e(27).then(t.bind(null,354)),"v-0ad9c9b7":()=>t.e(28).then(t.bind(null,355)),"v-9ede4212":()=>t.e(29).then(t.bind(null,356)),"v-2f68e86c":()=>t.e(30).then(t.bind(null,357)),"v-53f9261a":()=>t.e(31).then(t.bind(null,358)),"v-e957dff6":()=>t.e(32).then(t.bind(null,359)),"v-605baf28":()=>t.e(33).then(t.bind(null,360)),"v-da1159c4":()=>t.e(34).then(t.bind(null,361)),"v-93be6cd2":()=>t.e(35).then(t.bind(null,362)),"v-8d5a0674":()=>t.e(36).then(t.bind(null,363)),"v-217168dc":()=>t.e(37).then(t.bind(null,364)),"v-f8ffc25c":()=>t.e(38).then(t.bind(null,365)),"v-0a4c594d":()=>t.e(39).then(t.bind(null,366)),"v-00e633de":()=>t.e(40).then(t.bind(null,367)),"v-0f45791d":()=>t.e(41).then(t.bind(null,368)),"v-8d3daca2":()=>t.e(42).then(t.bind(null,369)),"v-1d080750":()=>t.e(43).then(t.bind(null,370)),"v-1fa6daf0":()=>t.e(44).then(t.bind(null,371)),"v-a55cb270":()=>t.e(45).then(t.bind(null,372)),"v-81b73566":()=>t.e(46).then(t.bind(null,373)),"v-17e022f6":()=>t.e(47).then(t.bind(null,374)),"v-180b4631":()=>t.e(48).then(t.bind(null,375)),"v-35ebce61":()=>t.e(49).then(t.bind(null,376)),"v-6bfff2f1":()=>t.e(50).then(t.bind(null,377)),"v-7ba47ebe":()=>t.e(51).then(t.bind(null,378)),"v-11840c14":()=>t.e(52).then(t.bind(null,379)),"v-25a11d4e":()=>t.e(53).then(t.bind(null,380)),"v-3c4081f6":()=>t.e(54).then(t.bind(null,381)),"v-47059fc8":()=>t.e(55).then(t.bind(null,382)),"v-21ecc4d2":()=>t.e(56).then(t.bind(null,383)),"v-20ab13d4":()=>t.e(57).then(t.bind(null,384)),"v-218f00a6":()=>t.e(58).then(t.bind(null,385)),"v-6ed28772":()=>t.e(59).then(t.bind(null,386)),"v-73f43abd":()=>t.e(60).then(t.bind(null,387)),"v-4f9430d9":()=>t.e(61).then(t.bind(null,388)),"v-7365a2db":()=>t.e(62).then(t.bind(null,389)),"v-1598588c":()=>t.e(63).then(t.bind(null,390)),"v-5133dd93":()=>t.e(64).then(t.bind(null,391)),"v-49e05f57":()=>t.e(65).then(t.bind(null,392)),"v-1c9efa1f":()=>t.e(66).then(t.bind(null,393)),"v-cf53aca6":()=>t.e(67).then(t.bind(null,394)),"v-75da521e":()=>t.e(68).then(t.bind(null,395)),"v-54191a9e":()=>t.e(69).then(t.bind(null,396)),"v-38c3379b":()=>t.e(70).then(t.bind(null,397)),"v-17aa954e":()=>t.e(71).then(t.bind(null,398)),"v-bbe4baae":()=>t.e(72).then(t.bind(null,399)),"v-7ae93e1c":()=>t.e(73).then(t.bind(null,400)),"v-3c0e1bb9":()=>t.e(74).then(t.bind(null,401)),"v-56e20f8a":()=>t.e(75).then(t.bind(null,402)),"v-b704fa22":()=>t.e(76).then(t.bind(null,403)),"v-e814cfd8":()=>t.e(77).then(t.bind(null,404)),"v-5b727396":()=>t.e(78).then(t.bind(null,405)),"v-72a0dc64":()=>t.e(79).then(t.bind(null,406)),"v-638b756f":()=>t.e(80).then(t.bind(null,407)),"v-15bb3d7d":()=>t.e(81).then(t.bind(null,408)),"v-046c9608":()=>t.e(82).then(t.bind(null,409)),"v-a3238f7a":()=>t.e(83).then(t.bind(null,410)),"v-889b9680":()=>t.e(84).then(t.bind(null,411)),"v-34f103b2":()=>t.e(85).then(t.bind(null,412)),"v-79d665d6":()=>t.e(86).then(t.bind(null,413)),"v-159cd9c6":()=>t.e(87).then(t.bind(null,414)),"v-9a7ceb4e":()=>t.e(88).then(t.bind(null,415)),"v-72ef87c1":()=>t.e(89).then(t.bind(null,416)),"v-f7e5f00a":()=>t.e(90).then(t.bind(null,417)),"v-3039e03b":()=>t.e(91).then(t.bind(null,418)),"v-fbb6475a":()=>t.e(92).then(t.bind(null,419)),"v-cdef8cd4":()=>t.e(93).then(t.bind(null,420)),"v-00f38f3a":()=>t.e(94).then(t.bind(null,421)),"v-218946b4":()=>t.e(95).then(t.bind(null,422)),"v-69c850bd":()=>t.e(96).then(t.bind(null,423)),"v-64669de5":()=>t.e(97).then(t.bind(null,424)),"v-1f7c083a":()=>t.e(98).then(t.bind(null,425)),"v-3c4a2030":()=>t.e(99).then(t.bind(null,426)),"v-aeaf62e4":()=>t.e(100).then(t.bind(null,427)),"v-5d535259":()=>t.e(101).then(t.bind(null,428)),"v-4786c633":()=>t.e(102).then(t.bind(null,429)),"v-1b073eaa":()=>t.e(103).then(t.bind(null,430)),"v-cb57926c":()=>t.e(104).then(t.bind(null,431)),"v-2bcd48ed":()=>t.e(105).then(t.bind(null,432)),"v-1109df90":()=>t.e(106).then(t.bind(null,433)),"v-61b66e0f":()=>t.e(107).then(t.bind(null,434)),"v-06664e26":()=>t.e(108).then(t.bind(null,435)),"v-b0913c7a":()=>t.e(109).then(t.bind(null,436)),"v-068d4a28":()=>t.e(110).then(t.bind(null,437)),"v-3d447ed6":()=>t.e(111).then(t.bind(null,438)),"v-7eaffbbc":()=>t.e(112).then(t.bind(null,439)),"v-a17ec6d2":()=>t.e(113).then(t.bind(null,440)),"v-18b54ca0":()=>t.e(114).then(t.bind(null,441)),"v-477a301f":()=>t.e(115).then(t.bind(null,442)),"v-0ddb40ea":()=>t.e(119).then(t.bind(null,443)),"v-2c7e0c4b":()=>t.e(120).then(t.bind(null,444)),"v-404f6236":()=>t.e(121).then(t.bind(null,445)),"v-04dccd77":()=>t.e(122).then(t.bind(null,446)),"v-5346a03e":()=>t.e(123).then(t.bind(null,447)),"v-d728c212":()=>t.e(124).then(t.bind(null,448)),"v-4a0528ed":()=>t.e(125).then(t.bind(null,449)),"v-de3dd5ac":()=>t.e(126).then(t.bind(null,450)),"v-37ddeda4":()=>t.e(127).then(t.bind(null,451)),"v-3ea3c6ca":()=>t.e(128).then(t.bind(null,452)),"v-6f1c1816":()=>t.e(129).then(t.bind(null,453)),"v-0544891e":()=>t.e(130).then(t.bind(null,454)),"v-dd5b10b0":()=>t.e(131).then(t.bind(null,455)),"v-e2fb1c2a":()=>t.e(132).then(t.bind(null,456)),"v-1fb6cd47":()=>t.e(133).then(t.bind(null,457)),"v-2124d7fc":()=>t.e(134).then(t.bind(null,458)),"v-6c380f3c":()=>t.e(135).then(t.bind(null,459)),"v-6b05a19d":()=>t.e(136).then(t.bind(null,460)),"v-5d0d0f9e":()=>t.e(137).then(t.bind(null,461)),"v-55f7df2a":()=>t.e(138).then(t.bind(null,462)),"v-70612210":()=>t.e(139).then(t.bind(null,463)),"v-38a4108f":()=>t.e(140).then(t.bind(null,464)),"v-6632c0ce":()=>t.e(141).then(t.bind(null,465)),"v-3a95fe52":()=>t.e(142).then(t.bind(null,466)),"v-9056ec2c":()=>t.e(143).then(t.bind(null,467)),"v-7eeb95da":()=>t.e(144).then(t.bind(null,468)),"v-7ea8e75a":()=>t.e(145).then(t.bind(null,469)),"v-2e0e850c":()=>t.e(146).then(t.bind(null,470)),"v-6adf3070":()=>t.e(147).then(t.bind(null,471)),"v-2a14cc38":()=>t.e(148).then(t.bind(null,472)),"v-61cc9f77":()=>t.e(149).then(t.bind(null,473)),"v-54199694":()=>t.e(150).then(t.bind(null,474)),"v-25a72634":()=>t.e(151).then(t.bind(null,475)),"v-38ae4266":()=>t.e(152).then(t.bind(null,476)),"v-1edd9c60":()=>t.e(153).then(t.bind(null,477)),"v-199b1610":()=>t.e(154).then(t.bind(null,478)),"v-45814dca":()=>t.e(155).then(t.bind(null,479)),"v-48886aed":()=>t.e(156).then(t.bind(null,480)),"v-dd580c7a":()=>t.e(157).then(t.bind(null,481)),"v-2788ef08":()=>t.e(158).then(t.bind(null,482)),"v-3b164efb":()=>t.e(159).then(t.bind(null,483)),"v-e24f836e":()=>t.e(160).then(t.bind(null,484)),"v-37cdc6f8":()=>t.e(161).then(t.bind(null,485)),"v-6397ae1b":()=>t.e(162).then(t.bind(null,486)),"v-52aba3b4":()=>t.e(163).then(t.bind(null,487)),"v-0018d08d":()=>t.e(164).then(t.bind(null,488)),"v-02c2afad":()=>t.e(166).then(t.bind(null,489)),"v-51972726":()=>t.e(165).then(t.bind(null,490)),"v-62e48c45":()=>t.e(167).then(t.bind(null,491)),"v-5e1b404a":()=>t.e(168).then(t.bind(null,492)),"v-d43ad834":()=>t.e(169).then(t.bind(null,493)),"v-01211f8e":()=>t.e(170).then(t.bind(null,494)),"v-b661f760":()=>t.e(171).then(t.bind(null,495)),"v-29a56b4e":()=>t.e(172).then(t.bind(null,496)),"v-db5d6e9c":()=>t.e(173).then(t.bind(null,497)),"v-3bc6e2d0":()=>t.e(174).then(t.bind(null,498)),"v-c76ded1a":()=>t.e(175).then(t.bind(null,499)),"v-c39498e0":()=>t.e(176).then(t.bind(null,500)),"v-86a00068":()=>t.e(177).then(t.bind(null,501)),"v-7f617a74":()=>t.e(178).then(t.bind(null,502)),"v-2fa92128":()=>t.e(179).then(t.bind(null,503)),"v-3f1b4b82":()=>t.e(180).then(t.bind(null,504)),"v-fa0dbca4":()=>t.e(181).then(t.bind(null,505)),"v-1b0cd9f8":()=>t.e(182).then(t.bind(null,506)),"v-6b40286e":()=>t.e(183).then(t.bind(null,507)),"v-23e575be":()=>t.e(184).then(t.bind(null,508)),"v-2203410d":()=>t.e(185).then(t.bind(null,509)),"v-67adcffe":()=>t.e(186).then(t.bind(null,510)),"v-b14ebb44":()=>t.e(187).then(t.bind(null,511)),"v-6e6d2c48":()=>t.e(188).then(t.bind(null,512)),"v-2d3903dd":()=>t.e(189).then(t.bind(null,513)),"v-864cbdf2":()=>t.e(190).then(t.bind(null,514)),"v-055ce36e":()=>t.e(191).then(t.bind(null,515)),"v-39c6fbcd":()=>t.e(192).then(t.bind(null,516)),"v-abf43b04":()=>t.e(193).then(t.bind(null,517)),"v-5c933400":()=>t.e(194).then(t.bind(null,518)),"v-31b70a5f":()=>t.e(195).then(t.bind(null,519)),"v-4ae463bf":()=>t.e(196).then(t.bind(null,520)),"v-7a5d5098":()=>t.e(197).then(t.bind(null,521)),"v-7062dffd":()=>t.e(198).then(t.bind(null,522)),"v-5e007e9e":()=>t.e(199).then(t.bind(null,523)),"v-766367b0":()=>t.e(200).then(t.bind(null,524)),"v-3ac3c5bf":()=>t.e(201).then(t.bind(null,525)),"v-6419c4d5":()=>t.e(202).then(t.bind(null,526)),"v-74022466":()=>t.e(203).then(t.bind(null,527)),"v-281e7683":()=>t.e(204).then(t.bind(null,528)),"v-04405839":()=>t.e(205).then(t.bind(null,529)),"v-49ca2b1c":()=>t.e(206).then(t.bind(null,530)),"v-3d73a434":()=>t.e(207).then(t.bind(null,531)),"v-5766fcc4":()=>t.e(208).then(t.bind(null,532)),"v-2c1431df":()=>t.e(209).then(t.bind(null,533)),"v-eace5c7c":()=>t.e(210).then(t.bind(null,534)),"v-77d9d1bd":()=>t.e(211).then(t.bind(null,535)),"v-7543bffe":()=>t.e(212).then(t.bind(null,536)),"v-61f87bf8":()=>t.e(213).then(t.bind(null,537)),"v-50a84ff8":()=>t.e(214).then(t.bind(null,538)),"v-7691670a":()=>t.e(215).then(t.bind(null,539)),"v-55238b17":()=>t.e(217).then(t.bind(null,540)),"v-715b54f6":()=>t.e(216).then(t.bind(null,541)),"v-8edc01ec":()=>t.e(218).then(t.bind(null,542)),"v-6eba0db4":()=>t.e(219).then(t.bind(null,543)),"v-ae62b842":()=>t.e(220).then(t.bind(null,544)),"v-b0357cfc":()=>t.e(221).then(t.bind(null,545)),"v-e6d11d7a":()=>t.e(222).then(t.bind(null,546)),"v-2ad7fa7c":()=>t.e(223).then(t.bind(null,547)),"v-9a8f5e4a":()=>t.e(224).then(t.bind(null,548)),"v-fc46af5c":()=>t.e(225).then(t.bind(null,549)),"v-695169c4":()=>t.e(226).then(t.bind(null,550)),"v-fe099c58":()=>t.e(227).then(t.bind(null,551)),"v-0f2f29d4":()=>t.e(228).then(t.bind(null,552)),"v-347e45ac":()=>t.e(229).then(t.bind(null,553)),"v-bdb3b278":()=>t.e(230).then(t.bind(null,554)),"v-573934c0":()=>t.e(231).then(t.bind(null,555)),"v-8333bcc2":()=>t.e(232).then(t.bind(null,556)),"v-7a4a3fcc":()=>t.e(233).then(t.bind(null,557)),"v-633b41b0":()=>t.e(234).then(t.bind(null,558)),"v-7006d63d":()=>t.e(235).then(t.bind(null,559)),"v-287ec08e":()=>t.e(236).then(t.bind(null,560)),"v-f4f24202":()=>t.e(237).then(t.bind(null,561)),"v-9a3b1246":()=>t.e(238).then(t.bind(null,562)),"v-5845d8e8":()=>t.e(239).then(t.bind(null,563)),"v-364bea08":()=>t.e(240).then(t.bind(null,564)),"v-513eccc6":()=>t.e(241).then(t.bind(null,565)),"v-39c91715":()=>t.e(242).then(t.bind(null,566)),"v-bbbaa4fa":()=>t.e(243).then(t.bind(null,567)),"v-20c0614d":()=>t.e(244).then(t.bind(null,568)),"v-eab0bdca":()=>t.e(245).then(t.bind(null,569)),"v-2b11bb3a":()=>t.e(247).then(t.bind(null,570)),"v-bc33ea14":()=>t.e(246).then(t.bind(null,571)),"v-0f1d08a6":()=>t.e(248).then(t.bind(null,572)),"v-5989d2b3":()=>t.e(249).then(t.bind(null,573)),"v-1c9f13f8":()=>t.e(116).then(t.bind(null,574)),"v-34a7b1f8":()=>t.e(250).then(t.bind(null,575)),"v-4177806d":()=>t.e(252).then(t.bind(null,576)),"v-97e09750":()=>t.e(251).then(t.bind(null,577)),"v-03423148":()=>t.e(253).then(t.bind(null,578)),"v-490137f5":()=>t.e(254).then(t.bind(null,579)),"v-6daed7c5":()=>t.e(255).then(t.bind(null,580)),"v-b19b5dd2":()=>t.e(256).then(t.bind(null,581)),"v-86b57bc6":()=>t.e(257).then(t.bind(null,582)),"v-726c37f8":()=>t.e(258).then(t.bind(null,583)),"v-3e1194da":()=>t.e(259).then(t.bind(null,584)),"v-3f1714d1":()=>t.e(260).then(t.bind(null,585)),"v-1456ec14":()=>t.e(261).then(t.bind(null,586)),"v-3b2f4a8c":()=>t.e(262).then(t.bind(null,587)),"v-0a68e3d0":()=>t.e(263).then(t.bind(null,588)),"v-1642c97c":()=>t.e(265).then(t.bind(null,589)),"v-4e381294":()=>t.e(264).then(t.bind(null,590)),"v-104c0473":()=>t.e(266).then(t.bind(null,591)),"v-a3c4af02":()=>t.e(267).then(t.bind(null,592)),"v-5459e177":()=>t.e(268).then(t.bind(null,593)),"v-52535292":()=>t.e(269).then(t.bind(null,594)),"v-52132daa":()=>t.e(270).then(t.bind(null,595)),"v-6830aa98":()=>t.e(271).then(t.bind(null,596)),"v-72503416":()=>t.e(272).then(t.bind(null,597)),"v-617dbfbc":()=>t.e(273).then(t.bind(null,598)),"v-7cea714c":()=>t.e(274).then(t.bind(null,599)),"v-a188cbf8":()=>t.e(275).then(t.bind(null,600)),"v-1786b60e":()=>t.e(276).then(t.bind(null,601)),"v-aca2ff6e":()=>t.e(277).then(t.bind(null,602)),"v-a163964a":()=>t.e(278).then(t.bind(null,603)),"v-f4c738d4":()=>t.e(279).then(t.bind(null,604)),"v-8402c606":()=>t.e(280).then(t.bind(null,605)),"v-4bb14ca2":()=>t.e(281).then(t.bind(null,606)),"v-22683f86":()=>t.e(282).then(t.bind(null,607)),"v-7a505fa0":()=>t.e(283).then(t.bind(null,608)),"v-0a5cdba6":()=>t.e(284).then(t.bind(null,609)),"v-1925ed26":()=>t.e(285).then(t.bind(null,610)),"v-0e4708a1":()=>t.e(286).then(t.bind(null,611)),"v-7653f6cc":()=>t.e(287).then(t.bind(null,612)),"v-374674c3":()=>t.e(288).then(t.bind(null,613)),"v-25268267":()=>t.e(289).then(t.bind(null,614)),"v-16be0b75":()=>t.e(290).then(t.bind(null,615)),"v-bcc2cd22":()=>t.e(291).then(t.bind(null,616)),"v-5519367f":()=>t.e(292).then(t.bind(null,617)),"v-f68eea1a":()=>t.e(293).then(t.bind(null,618)),"v-70d91d55":()=>t.e(294).then(t.bind(null,619)),"v-968013f4":()=>t.e(295).then(t.bind(null,620)),"v-ecf02760":()=>t.e(296).then(t.bind(null,621)),"v-2b4bdefd":()=>t.e(297).then(t.bind(null,622)),"v-c983e334":()=>t.e(298).then(t.bind(null,623)),"v-104bb908":()=>t.e(299).then(t.bind(null,624)),"v-49f8bbe0":()=>t.e(300).then(t.bind(null,625)),"v-788ad340":()=>t.e(301).then(t.bind(null,626)),"v-624330b0":()=>t.e(302).then(t.bind(null,627)),"v-3c9f3ea4":()=>t.e(303).then(t.bind(null,628)),"v-2be0cdda":()=>t.e(304).then(t.bind(null,629)),"v-2fa97bee":()=>t.e(305).then(t.bind(null,630)),"v-7f6fd396":()=>t.e(306).then(t.bind(null,631)),"v-2e449d2e":()=>t.e(307).then(t.bind(null,632)),"v-030ee6e9":()=>t.e(308).then(t.bind(null,633)),"v-da4b7ec6":()=>t.e(310).then(t.bind(null,634)),"v-28bacbcf":()=>t.e(309).then(t.bind(null,635)),"v-efc06c1e":()=>t.e(311).then(t.bind(null,636)),"v-acde98ae":()=>t.e(312).then(t.bind(null,637)),"v-088dc5dd":()=>t.e(313).then(t.bind(null,638)),"v-d6d9f736":()=>t.e(314).then(t.bind(null,639)),"v-4bef49e5":()=>t.e(315).then(t.bind(null,640)),"v-011f227e":()=>t.e(316).then(t.bind(null,641)),"v-a82b2222":()=>t.e(117).then(t.bind(null,642)),"v-49b2d391":()=>t.e(118).then(t.bind(null,643))};function Wo(n){const e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}const Ko=/-(\w)/g,Qo=Wo(n=>n.replace(Ko,(n,e)=>e?e.toUpperCase():"")),Go=/\B([A-Z])/g,Xo=Wo(n=>n.replace(Go,"-$1").toLowerCase()),Yo=Wo(n=>n.charAt(0).toUpperCase()+n.slice(1));function ns(n,e){if(!e)return;if(n(e))return n(e);return e.includes("-")?n(Yo(Qo(e))):n(Yo(e))||n(Xo(e))}const es=Object.assign({},Ho,$o),ts=n=>es[n],as=n=>$o[n],rs=n=>Ho[n],is=n=>Ht.component(n);function os(n){return ns(as,n)}function ss(n){return ns(rs,n)}function ls(n){return ns(ts,n)}function ds(n){return ns(is,n)}function cs(...n){return Promise.all(n.filter(n=>n).map(async n=>{if(!ds(n)&&ls(n)){const e=await ls(n)();Ht.component(n,e.default)}}))}function us(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var ps=t(92),ms=t.n(ps),hs=t(93),gs=t.n(hs),fs={created(){if(this.siteMeta=this.$site.headTags.filter(([n])=>"meta"===n).map(([n,e])=>e),this.$ssrContext){const e=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(n=e)?n.map(n=>{let e="<meta";return Object.keys(n).forEach(t=>{e+=` ${t}="${gs()(n[t])}"`}),e+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=vs(this.$canonicalUrl)}var n},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const n=this.getMergedMetaTags();this.currentMetaTags=ys(n,this.currentMetaTags)},getMergedMetaTags(){const n=this.$page.frontmatter.meta||[];return ms()([{name:"description",content:this.$description}],n,this.siteMeta,ks)},updateCanonicalLink(){bs(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",vs(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){ys(null,this.currentMetaTags),bs()}};function bs(){const n=document.querySelector("link[rel='canonical']");n&&n.remove()}function vs(n=""){return n?`<link href="${n}" rel="canonical" />`:""}function ys(n,e){if(e&&[...e].filter(n=>n.parentNode===document.head).forEach(n=>document.head.removeChild(n)),n)return n.map(n=>{const e=document.createElement("meta");return Object.keys(n).forEach(t=>{e.setAttribute(t,n[t])}),document.head.appendChild(e),e})}function ks(n){for(const e of["name","property","itemprop"])if(n.hasOwnProperty(e))return n[e]+e;return JSON.stringify(n)}var xs=t(50),ws={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(xs)()((function(){this.setActiveHash()}),300),setActiveHash(){const n=[].slice.call(document.querySelectorAll(".sidebar-link")),e=[].slice.call(document.querySelectorAll(".header-anchor")).filter(e=>n.some(n=>n.hash===e.hash)),t=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),a=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),r=window.innerHeight+t;for(let n=0;n<e.length;n++){const i=e[n],o=e[n+1],s=0===n&&0===t||t>=i.parentElement.offsetTop+10&&(!o||t<o.parentElement.offsetTop-10),l=decodeURIComponent(this.$route.hash);if(s&&l!==decodeURIComponent(i.hash)){const t=i;if(r===a)for(let t=n+1;t<e.length;t++)if(l===decodeURIComponent(e[t].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(t.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}},Cs=t(24),Es=t.n(Cs),Ls={mounted(){Es.a.configure({showSpinner:!1}),this.$router.beforeEach((n,e,t)=>{n.path===e.path||Ht.component(n.name)||Es.a.start(),t()}),this.$router.afterEach(()=>{Es.a.done(),this.isSidebarOpen=!1})}};t(238),t(239);class Ts{constructor(){this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}show({text:n="",duration:e=3e3}){let t=document.createElement("div");t.className="message move-in",t.innerHTML=`\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">${n}</div>\n    `,this.containerEl.appendChild(t),e>0&&setTimeout(()=>{this.close(t)},e)}close(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",()=>{n.remove()})}}var js={mounted(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy(){setTimeout(()=>{(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach(n=>{document.querySelectorAll(n).forEach(this.generateCopyButton)})},1e3)},generateCopyButton(n){if(n.classList.contains("codecopy-enabled"))return;const e=document.createElement("i");e.className="code-copy",e.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',e.title="Copy to clipboard",e.addEventListener("click",()=>{this.copyToClipboard(n.innerText)}),n.appendChild(e),n.classList.add("codecopy-enabled")},copyToClipboard(n){const e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);const t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy");(new Ts).show({text:"复制成功",duration:1e3}),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}};!function(n,e){void 0===e&&(e={});var t=e.insertAt;if(n&&"undefined"!=typeof document){var a=document.head||document.getElementsByTagName("head")[0],r=document.createElement("style");r.type="text/css","top"===t&&a.firstChild?a.insertBefore(r,a.firstChild):a.appendChild(r),r.styleSheet?r.styleSheet.cssText=n:r.appendChild(document.createTextNode(n))}}("@media (max-width: 1000px) {\n  .vuepress-plugin-demo-block__h_code {\n    display: none;\n  }\n  .vuepress-plugin-demo-block__app {\n    margin-left: auto !important;\n    margin-right: auto !important;\n  }\n}\n.vuepress-plugin-demo-block__wrapper {\n  margin-top: 10px;\n  border: 1px solid #ebebeb;\n  border-radius: 4px;\n  transition: all 0.2s;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display {\n  height: 400px;\n  display: flex;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__app {\n  width: 300px;\n  border: 1px solid #ebebeb;\n  box-shadow: 1px 1px 3px #ebebeb;\n  margin-right: 5px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code {\n  flex: 1;\n  overflow: auto;\n  height: 100%;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code > pre {\n  overflow: visible;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  max-height: 400px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper div {\n  box-sizing: border-box;\n}\n.vuepress-plugin-demo-block__wrapper:hover {\n  box-shadow: 0 0 11px rgba(33, 33, 33, 0.2);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code {\n  overflow: hidden;\n  height: 0;\n  padding: 0 !important;\n  background-color: #282c34;\n  border-radius: 0 !important;\n  transition: height 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code pre {\n  margin: 0 !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  padding: 20px;\n  border-bottom: 1px solid #ebebeb;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer {\n  position: relative;\n  text-align: center;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__codepen {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__expand::before {\n  border-top: none;\n  border-right: 6px solid transparent;\n  border-bottom: 6px solid #ccc;\n  border-left: 6px solid transparent;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__codepen,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand span,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand::before {\n  border-top-color: #3eaf7c !important;\n  border-bottom-color: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover svg {\n  fill: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand-text {\n  transition: all 0.5s;\n  opacity: 0;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:nth-last-child(2) {\n  right: 50px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:last-child {\n  right: 10px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button {\n  border-color: transparent;\n  background-color: transparent;\n  font-size: 14px;\n  color: #3eaf7c;\n  cursor: pointer;\n  outline: none;\n  margin: 0;\n  width: 46px;\n  position: relative;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::before {\n  content: attr(data-tip);\n  white-space: nowrap;\n  position: absolute;\n  top: -30px;\n  left: 50%;\n  color: #eee;\n  line-height: 1;\n  z-index: 1000;\n  border-radius: 4px;\n  padding: 6px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  background-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::after {\n  content: '' !important;\n  display: block;\n  position: absolute;\n  left: 50%;\n  top: -5px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  border: 5px solid transparent;\n  border-top-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button svg {\n  width: 34px;\n  height: 20px;\n  fill: #ccc;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__codepen {\n  position: absolute;\n  top: 10px;\n  transition: all 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand {\n  position: relative;\n  width: 100px;\n  height: 40px;\n  margin: 0;\n  color: #3eaf7c;\n  font-size: 14px;\n  background-color: transparent;\n  border-color: transparent;\n  outline: none;\n  transition: all 0.5s;\n  cursor: pointer;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand::before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-top: 6px solid #ccc;\n  border-right: 6px solid transparent;\n  border-left: 6px solid transparent;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n}\n");var Ss={jsLib:[],cssLib:[],jsfiddle:!0,codepen:!0,codepenLayout:"left",codepenJsProcessor:"babel",codepenEditors:"101",horizontal:!1,vue:"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js",react:"https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js",reactDOM:"https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"},As={},Ps=function(n){return'<div id="app">\n'.concat(n,"\n</div>")},_s=function(n){return window.$VUEPRESS_DEMO_BLOCK&&void 0!==window.$VUEPRESS_DEMO_BLOCK[n]?window.$VUEPRESS_DEMO_BLOCK[n]:Ss[n]},Bs=function n(e,t,a){var r=document.createElement(e);return t&&Object.keys(t).forEach((function(n){if(n.indexOf("data"))r[n]=t[n];else{var e=n.replace("data","");r.dataset[e]=t[n]}})),a&&a.forEach((function(e){var t=e.tag,a=e.attrs,i=e.children;r.appendChild(n(t,a,i))})),r},zs=function(n,e,t){var a,r=(a=n.querySelectorAll(".".concat(e)),Array.prototype.slice.call(a));return 1!==r.length||t?r:r[0]},Is=function(n,e){var t,a,r=n.match(/<style>([\s\S]+)<\/style>/),i=n.match(/<template>([\s\S]+)<\/template>/),o=n.match(/<script>([\s\S]+)<\/script>/),s={css:r&&r[1].replace(/^\n|\n$/g,""),html:i&&i[1].replace(/^\n|\n$/g,""),js:o&&o[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};s.htmlTpl=Ps(s.html),s.jsTpl=(t=s.js,a=t.replace(/export\s+default\s*?\{\n*/,"").replace(/\n*\}\s*$/,"").trim(),"new Vue({\n  el: '#app',\n  ".concat(a,"\n})")),s.script=function(n,e){var t=n.split(/export\s+default/),a="(function() {".concat(t[0]," ; return ").concat(t[1],"})()"),r=window.Babel?window.Babel.transform(a,{presets:["es2015"]}).code:a,i=[eval][0](r);return i.template=e,i}(s.js,s.html);var l=_s("vue");return s.jsLib.unshift(l),s},Os=function(n,e){var t,a=n.match(/<style>([\s\S]+)<\/style>/),r=n.match(/<html>([\s\S]+)<\/html>/),i=n.match(/<script>([\s\S]+)<\/script>/),o={css:a&&a[1].replace(/^\n|\n$/g,""),html:r&&r[1].replace(/^\n|\n$/g,""),js:i&&i[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};return o.htmlTpl=o.html,o.jsTpl=o.js,o.script=(t=o.js,window.Babel?window.Babel.transform(t,{presets:["es2015"]}).code:t),o},Ms=function(n){return n=n.replace("export default ","").replace(/App\.__style__(\s*)=(\s*)`([\s\S]*)?`/,""),n+='ReactDOM.render(React.createElement(App), document.getElementById("app"))'};function Js(){var n=zs(document,"vuepress-plugin-demo-block__wrapper",!0);n.length?n.forEach((function(n){if("true"!==n.dataset.created){n.style.display="block";var e=zs(n,"vuepress-plugin-demo-block__code"),t=zs(n,"vuepress-plugin-demo-block__display"),a=zs(n,"vuepress-plugin-demo-block__footer"),r=zs(t,"vuepress-plugin-demo-block__app"),i=decodeURIComponent(n.dataset.code),o=decodeURIComponent(n.dataset.config),s=decodeURIComponent(n.dataset.type);o=o?JSON.parse(o):{};var l=e.querySelector("div").clientHeight,d="react"===s?function(n,e){var t=(0,window.Babel.transform)(n,{presets:["es2015","react"]}).code,a="(function(exports){var module={};module.exports=exports;".concat(t,";return module.exports.__esModule?module.exports.default:module.exports;})({})"),r=new Function("return ".concat(a))(),i={js:r,css:r.__style__||"",jsLib:e.jsLib||[],cssLib:e.cssLib||[],jsTpl:Ms(n),htmlTpl:Ps("")},o=_s("react"),s=_s("reactDOM");return i.jsLib.unshift(o,s),i}(i,o):"vanilla"===s?Os(i,o):Is(i,o),c=Bs("button",{className:"".concat("vuepress-plugin-demo-block__expand")});if(a.appendChild(c),c.addEventListener("click",Ds.bind(null,c,l,e,a)),_s("jsfiddle")&&a.appendChild(function(n){var e=n.css,t=n.htmlTpl,a=n.jsTpl,r=n.jsLib,i=n.cssLib,o=r.concat(i).concat(_s("cssLib")).concat(_s("jsLib")).join(",");return Bs("form",{className:"vuepress-plugin-demo-block__jsfiddle",target:"_blank",action:"https://jsfiddle.net/api/post/library/pure/",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"css",value:e}},{tag:"input",attrs:{type:"hidden",name:"html",value:t}},{tag:"input",attrs:{type:"hidden",name:"js",value:a}},{tag:"input",attrs:{type:"hidden",name:"panel_js",value:3}},{tag:"input",attrs:{type:"hidden",name:"wrap",value:1}},{tag:"input",attrs:{type:"hidden",name:"resources",value:o}},{tag:"button",attrs:{type:"submit",className:"vuepress-plugin-demo-block__button",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088289967" class="icon" style="" viewBox="0 0 1170 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1952" xmlns:xlink="http://www.w3.org/1999/xlink" width="228.515625" height="200"><defs><style type="text/css"></style></defs><path d="M1028.571429 441.142857q63.428571 26.285714 102.571428 83.142857T1170.285714 650.857143q0 93.714286-67.428571 160.285714T940 877.714286q-2.285714 0-6.571429-0.285715t-6-0.285714H232q-97.142857-5.714286-164.571429-71.714286T0 645.142857q0-62.857143 31.428571-116t84-84q-6.857143-22.285714-6.857142-46.857143 0-65.714286 46.857142-112t113.714286-46.285714q54.285714 0 98.285714 33.142857 42.857143-88 127.142858-141.714286t186.571428-53.714285q94.857143 0 174.857143 46T982.571429 248.571429t46.571428 172q0 3.428571-0.285714 10.285714t-0.285714 10.285714zM267.428571 593.142857q0 69.714286 48 110.285714t118.857143 40.571429q78.285714 0 137.142857-56.571429-9.142857-11.428571-27.142857-32.285714T519.428571 626.285714q-38.285714 37.142857-82.285714 37.142857-31.428571 0-53.428571-19.142857T361.714286 594.285714q0-30.285714 22-49.714285t52.285714-19.428572q25.142857 0 48.285714 12t41.714286 31.428572 37.142857 42.857142 39.428572 46.857143 44 42.857143 55.428571 31.428572 69.428571 12q69.142857 0 116.857143-40.857143T936 594.857143q0-69.142857-48-109.714286t-118.285714-40.571428q-81.714286 0-137.714286 55.428571l53.142857 61.714286q37.714286-36.571429 81.142857-36.571429 29.714286 0 52.571429 18.857143t22.857143 48q0 32.571429-21.142857 52.285714t-53.714286 19.714286q-24.571429 0-47.142857-12t-41.142857-31.428571-37.428572-42.857143-39.714286-46.857143-44.285714-42.857143-55.142857-31.428571T434.285714 444.571429q-69.714286 0-118.285714 40.285714T267.428571 593.142857z" p-id="1953"></path></svg>',datatip:"JSFiddle"}}])}(d)),_s("codepen")&&a.appendChild(function(n){var e=n.css,t=n.htmlTpl,a=n.jsTpl,r=n.jsLib,i=n.cssLib,o=JSON.stringify({css:e,html:t,js:a,js_external:r.concat(_s("jsLib")).join(";"),css_external:i.concat(_s("cssLib")).join(";"),layout:_s("codepenLayout"),js_pre_processor:_s("codepenJsProcessor"),editors:_s("codepenEditors")});return Bs("form",{className:"vuepress-plugin-demo-block__codepen",target:"_blank",action:"https://codepen.io/pen/define",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"data",value:o}},{tag:"button",attrs:{type:"submit",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088271207" class="icon" style="" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1737" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M123.428571 668l344.571429 229.714286v-205.142857L277.142857 565.142857z m-35.428571-82.285714l110.285714-73.714286-110.285714-73.714286v147.428572z m468 312l344.571429-229.714286-153.714286-102.857143-190.857143 127.428572v205.142857z m-44-281.714286l155.428571-104-155.428571-104-155.428571 104zM277.142857 458.857143l190.857143-127.428572V126.285714L123.428571 356z m548.571429 53.142857l110.285714 73.714286V438.285714z m-78.857143-53.142857l153.714286-102.857143-344.571429-229.714286v205.142857z m277.142857-102.857143v312q0 23.428571-19.428571 36.571429l-468 312q-12 7.428571-24.571429 7.428571t-24.571429-7.428571L19.428571 704.571429q-19.428571-13.142857-19.428571-36.571429V356q0-23.428571 19.428571-36.571429L487.428571 7.428571q12-7.428571 24.571429-7.428571t24.571429 7.428571l468 312q19.428571 13.142857 19.428571 36.571429z" p-id="1738"></path></svg>',className:"vuepress-plugin-demo-block__button",datatip:"Codepen"}}])}(d)),void 0!==o.horizontal?o.horizontal:_s("horizontal")){n.classList.add("vuepress-plugin-demo-block__horizontal");var u=e.firstChild.cloneNode(!0);u.classList.add("vuepress-plugin-demo-block__h_code"),t.appendChild(u)}if(d.css&&function(n){if(!As[n]){var e=Bs("style",{innerHTML:n});document.body.appendChild(e),As[n]=!0}}(d.css),"react"===s)ReactDOM.render(React.createElement(d.js),r);else if("vue"===s){var p=(new(Vue.extend(d.script))).$mount();r.appendChild(p.$el)}else"vanilla"===s&&(r.innerHTML=d.html,new Function("return (function(){".concat(d.script,"})()"))());n.dataset.created="true"}})):setTimeout((function(n){Js()}),300)}function Ds(n,e,t,a){var r="1"!==n.dataset.isExpand;t.style.height=r?"".concat(e,"px"):0,r?a.classList.add("vuepress-plugin-demo-block__show-link"):a.classList.remove("vuepress-plugin-demo-block__show-link"),n.dataset.isExpand=r?"1":"0"}var Ns={mounted:function(){window.$VUEPRESS_DEMO_BLOCK={jsfiddle:!1,codepen:!0,horizontal:!1},Js()},updated:function(){Js()}},Fs="auto",Us="zoom-in",qs="zoom-out",Rs="grab",Vs="move";function Zs(n,e,t){var a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],r={passive:!1};a?n.addEventListener(e,t,r):n.removeEventListener(e,t,r)}function Hs(n,e){if(n){var t=new Image;t.onload=function(){e&&e(t)},t.src=n}}function $s(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function Ws(n,e,t){!function(n){var e=Ks,t=Qs;if(n.transition){var a=n.transition;delete n.transition,n[e]=a}if(n.transform){var r=n.transform;delete n.transform,n[t]=r}}(e);var a=n.style,r={};for(var i in e)t&&(r[i]=a[i]||""),a[i]=e[i];return r}var Ks="transition",Qs="transform",Gs="transform",Xs="transitionend";var Ys=function(){},nl={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:Ys,onClose:Ys,onGrab:Ys,onMove:Ys,onRelease:Ys,onBeforeOpen:Ys,onBeforeClose:Ys,onBeforeGrab:Ys,onBeforeRelease:Ys,onImageLoading:Ys,onImageLoaded:Ys},el={init:function(n){var e,t;e=this,t=n,Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(n){e[n]=e[n].bind(t)}))},click:function(n){if(n.preventDefault(),al(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,e=window.pageXOffset||n.scrollLeft,t=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:e,y:t});var a=this.lastScrollPosition.x-e,r=this.lastScrollPosition.y-t,i=this.options.scrollThreshold;(Math.abs(r)>=i||Math.abs(a)>=i)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if(tl(n)&&!al(n)){n.preventDefault();var e=n.clientX,t=n.clientY;this.pressTimer=setTimeout(function(){this.grab(e,t)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){tl(n)&&!al(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var e=n.touches[0],t=e.clientX,a=e.clientY;this.pressTimer=setTimeout(function(){this.grab(t,a)}.bind(this),200)},touchmove:function(n){if(!this.released){var e=n.touches[0],t=e.clientX,a=e.clientY;this.move(t,a)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function tl(n){return 0===n.button}function al(n){return n.metaKey||n.ctrlKey}var rl={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,Ws(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),Zs(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){Ws(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},il="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},ol=function(){function n(n,e){for(var t=0;t<e.length;t++){var a=e[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,a.key,a)}}return function(e,t,a){return t&&n(e.prototype,t),a&&n(e,a),e}}(),sl=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(n[a]=t[a])}return n},ll={init:function(n,e){this.el=n,this.instance=e,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=$s(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,e=n.zIndex,t=n.enableGrab,a=n.transitionDuration,r=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:e+1,cursor:t?Rs:qs,transition:Gs+"\n        "+a+"s\n        "+r,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=Ws(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,Ws(this.el,{transform:"none"})},grab:function(n,e,t){var a=dl(),r=a.x-n,i=a.y-e;Ws(this.el,{cursor:Vs,transform:"translate3d(\n        "+(this.translate.x+r)+"px, "+(this.translate.y+i)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},move:function(n,e,t){var a=dl(),r=a.x-n,i=a.y-e;Ws(this.el,{transition:Gs,transform:"translate3d(\n        "+(this.translate.x+r)+"px, "+(this.translate.y+i)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},restoreCloseStyle:function(){Ws(this.el,this.styleClose)},restoreOpenStyle:function(){Ws(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var e=this.el.cloneNode(!1);e.setAttribute("src",this.srcOriginal),e.style.position="fixed",e.style.visibility="hidden",n.appendChild(e),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(e)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=dl(),e=this.rect.left+this.rect.width/2,t=this.rect.top+this.rect.height/2;return{x:n.x-e,y:n.y-t}},calculateScale:function(){var n=this.el.dataset,e=n.zoomingHeight,t=n.zoomingWidth,a=this.instance.options,r=a.customSize,i=a.scaleBase;if(!r&&e&&t)return{x:t/this.rect.width,y:e/this.rect.height};if(r&&"object"===(void 0===r?"undefined":il(r)))return{x:r.width/this.rect.width,y:r.height/this.rect.height};var o=this.rect.width/2,s=this.rect.height/2,l=dl(),d={x:l.x-o,y:l.y-s},c=d.x/o,u=d.y/s,p=i+Math.min(c,u);if(r&&"string"==typeof r){var m=t||this.el.naturalWidth,h=e||this.el.naturalHeight,g=parseFloat(r)*m/(100*this.rect.width),f=parseFloat(r)*h/(100*this.rect.height);if(p>g||p>f)return{x:g,y:f}}return{x:p,y:p}}};function dl(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function cl(n,e,t){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(a){Zs(n,a,e[a],t)}))}var ul=function(){function n(e){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create(ll),this.overlay=Object.create(rl),this.handler=Object.create(el),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=sl({},nl,e),this.overlay.init(this),this.handler.init(this)}return ol(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var e=document.querySelectorAll(n),t=e.length;t--;)this.listen(e[t]);else"IMG"===n.tagName&&(n.style.cursor=Us,Zs(n,"click",this.handler.click),this.options.preloadImage&&Hs($s(n)));return this}},{key:"config",value:function(n){return n?(sl(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var a="string"==typeof n?document.querySelector(n):n;if("IMG"===a.tagName){if(this.options.onBeforeOpen(a),this.target.init(a,this),!this.options.preloadImage){var r=this.target.srcOriginal;null!=r&&(this.options.onImageLoading(a),Hs(r,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),Zs(document,"scroll",this.handler.scroll),Zs(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&Zs(window,"resize",this.handler.resizeWindow);var i=function n(){Zs(a,Xs,n,!1),e.lock=!1,e.target.upgradeSource(),e.options.enableGrab&&cl(document,e.handler,!0),t(a)};return Zs(a,Xs,i),this}}}},{key:"close",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeClose(t),this.lock=!0,this.body.style.cursor=Fs,this.overlay.fadeOut(),this.target.zoomOut(),Zs(document,"scroll",this.handler.scroll,!1),Zs(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&Zs(window,"resize",this.handler.resizeWindow,!1);var a=function a(){Zs(t,Xs,a,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&cl(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),e(t)};return Zs(t,Xs,a),this}}},{key:"grab",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var r=this.target.el;this.options.onBeforeGrab(r),this.released=!1,this.target.grab(n,e,t);var i=function n(){Zs(r,Xs,n,!1),a(r)};return Zs(r,Xs,i),this}}},{key:"move",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=Vs,this.target.move(n,e,t);var r=this.target.el,i=function n(){Zs(r,Xs,n,!1),a(r)};return Zs(r,Xs,i),this}}},{key:"release",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeRelease(t),this.lock=!0,this.body.style.cursor=Fs,this.target.restoreOpenStyle();var a=function a(){Zs(t,Xs,a,!1),n.lock=!1,n.released=!0,e(t)};return Zs(t,Xs,a),this}}}]),n}();const pl=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),ml=Number("500");class hl{constructor(){this.instance=new ul(pl)}update(n=".theme-vdoing-content img:not(.no-zoom)"){"undefined"!=typeof window&&this.instance.listen(n)}updateDelay(n=".theme-vdoing-content img:not(.no-zoom)",e=ml){setTimeout(()=>this.update(n),e)}}var gl=[fs,ws,Ls,js,Ns,{watch:{"$page.path"(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted(){this.$vuepress.zooming=new hl,this.$vuepress.zooming.updateDelay()}}],fl={name:"GlobalLayout",computed:{layout(){const n=this.getLayout();return us("layout",n),Ht.component(n)}},methods:{getLayout(){if(this.$page.path){const n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},bl=t(7),vl=Object(bl.a)(fl,(function(){return(0,this._self._c)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),n[e].push(...t);break;default:throw new Error("Unknown option name.")}}(vl,"mixins",gl);const yl=[{name:"v-177c102a",path:"/pages/7848bb/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-177c102a").then(t)}},{path:"/pages/7848bb/index.html",redirect:"/pages/7848bb/"},{path:"/00.导航/01.概览.html",redirect:"/pages/7848bb/"},{name:"v-2d7fd9fc",path:"/pages/ddcc22/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-2d7fd9fc").then(t)}},{path:"/pages/ddcc22/index.html",redirect:"/pages/ddcc22/"},{path:"/01.Java/01.Java/01.Java-基础/02.动态代理使用方法.html",redirect:"/pages/ddcc22/"},{name:"v-0c96d161",path:"/pages/225727/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-0c96d161").then(t)}},{path:"/pages/225727/index.html",redirect:"/pages/225727/"},{path:"/01.Java/01.Java/01.Java-基础/01.Java反射获取类对象的三种方式.html",redirect:"/pages/225727/"},{name:"v-6b386ebf",path:"/pages/9786e5/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-6b386ebf").then(t)}},{path:"/pages/9786e5/index.html",redirect:"/pages/9786e5/"},{path:"/01.Java/01.Java/02.Java-集合/01.ArrayList的扩容机制.html",redirect:"/pages/9786e5/"},{name:"v-2f72ba66",path:"/pages/487c60/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-2f72ba66").then(t)}},{path:"/pages/487c60/index.html",redirect:"/pages/487c60/"},{path:"/01.Java/01.Java/03.Java-多线程与并发/01.Java多线程实现的几种方式.html",redirect:"/pages/487c60/"},{name:"v-6950b4e9",path:"/pages/5047a0/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-6950b4e9").then(t)}},{path:"/pages/5047a0/index.html",redirect:"/pages/5047a0/"},{path:"/01.Java/01.Java/03.Java-多线程与并发/02.多线程打印数字-多种实现.html",redirect:"/pages/5047a0/"},{name:"v-3b417cdd",path:"/pages/bccbee/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-3b417cdd").then(t)}},{path:"/pages/bccbee/index.html",redirect:"/pages/bccbee/"},{path:"/01.Java/01.Java/03.Java-多线程与并发/03.CountDownLatch使用方法.html",redirect:"/pages/bccbee/"},{name:"v-3676674e",path:"/pages/3898a4/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-3676674e").then(t)}},{path:"/pages/3898a4/index.html",redirect:"/pages/3898a4/"},{path:"/01.Java/01.Java/03.Java-多线程与并发/04.CyclicBarrier使用方法.html",redirect:"/pages/3898a4/"},{name:"v-49bdbdb9",path:"/pages/8e40cc/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-49bdbdb9").then(t)}},{path:"/pages/8e40cc/index.html",redirect:"/pages/8e40cc/"},{path:"/01.Java/01.Java/03.Java-多线程与并发/05.Semaphore使用方法.html",redirect:"/pages/8e40cc/"},{name:"v-45d73e1d",path:"/pages/b1318d/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-45d73e1d").then(t)}},{path:"/pages/b1318d/index.html",redirect:"/pages/b1318d/"},{path:"/01.Java/01.Java/03.Java-多线程与并发/06.CompletableFuture常用用法及问题排查.html",redirect:"/pages/b1318d/"},{name:"v-8c545382",path:"/pages/0a146e/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-8c545382").then(t)}},{path:"/pages/0a146e/index.html",redirect:"/pages/0a146e/"},{path:"/01.Java/01.Java/04.Java-JVM/01.自定义类加载器.html",redirect:"/pages/0a146e/"},{name:"v-76f6c282",path:"/pages/ffed02/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-76f6c282").then(t)}},{path:"/pages/ffed02/index.html",redirect:"/pages/ffed02/"},{path:"/01.Java/01.Java/04.Java-JVM/02.JMH-基准测试框架.html",redirect:"/pages/ffed02/"},{name:"v-975bc690",path:"/pages/4aef64/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-975bc690").then(t)}},{path:"/pages/4aef64/index.html",redirect:"/pages/4aef64/"},{path:"/01.Java/01.Java/05.Java-IO/01.概览.html",redirect:"/pages/4aef64/"},{name:"v-074d5d6d",path:"/pages/0de67d/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-074d5d6d").then(t)}},{path:"/pages/0de67d/index.html",redirect:"/pages/0de67d/"},{path:"/02.Python/01.Python-基础/01.assert语句的运用.html",redirect:"/pages/0de67d/"},{name:"v-f15f9572",path:"/pages/50bf39/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-f15f9572").then(t)}},{path:"/pages/50bf39/index.html",redirect:"/pages/50bf39/"},{path:"/02.Python/01.Python-基础/02.list(列表)、tuple(元组)、dict(字典)的回顾.html",redirect:"/pages/50bf39/"},{name:"v-b94bd26c",path:"/pages/31bd37/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-b94bd26c").then(t)}},{path:"/pages/31bd37/index.html",redirect:"/pages/31bd37/"},{path:"/02.Python/01.Python-基础/03.Python中的Docstring.html",redirect:"/pages/31bd37/"},{name:"v-325034ba",path:"/pages/866a91/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-325034ba").then(t)}},{path:"/pages/866a91/index.html",redirect:"/pages/866a91/"},{path:"/02.Python/01.Python-基础/04.Python中的多态.html",redirect:"/pages/866a91/"},{name:"v-6d4f7ede",path:"/pages/c47343/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-6d4f7ede").then(t)}},{path:"/pages/c47343/index.html",redirect:"/pages/c47343/"},{path:"/02.Python/01.Python-基础/05.Python中的集合.html",redirect:"/pages/c47343/"},{name:"v-2d7b28d6",path:"/pages/c498f9/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-2d7b28d6").then(t)}},{path:"/pages/c498f9/index.html",redirect:"/pages/c498f9/"},{path:"/02.Python/01.Python-基础/06.Python中的列表.html",redirect:"/pages/c498f9/"},{name:"v-54833ab4",path:"/pages/0d6aa8/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-54833ab4").then(t)}},{path:"/pages/0d6aa8/index.html",redirect:"/pages/0d6aa8/"},{path:"/02.Python/01.Python-基础/07.Python中的序列以及切片的解释.html",redirect:"/pages/0d6aa8/"},{name:"v-f4a93384",path:"/pages/037f6f/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-f4a93384").then(t)}},{path:"/pages/037f6f/index.html",redirect:"/pages/037f6f/"},{path:"/02.Python/01.Python-基础/08.Python中的引用和切片.html",redirect:"/pages/037f6f/"},{name:"v-0ad9c9b7",path:"/pages/e8270d/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-0ad9c9b7").then(t)}},{path:"/pages/e8270d/index.html",redirect:"/pages/e8270d/"},{path:"/02.Python/01.Python-基础/09.Python中的元组.html",redirect:"/pages/e8270d/"},{name:"v-9ede4212",path:"/pages/bf2ef2/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-9ede4212").then(t)}},{path:"/pages/bf2ef2/index.html",redirect:"/pages/bf2ef2/"},{path:"/02.Python/01.Python-基础/10.Python中对列表和元组的切片操作.html",redirect:"/pages/bf2ef2/"},{name:"v-2f68e86c",path:"/pages/7c7c36/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-2f68e86c").then(t)}},{path:"/pages/7c7c36/index.html",redirect:"/pages/7c7c36/"},{path:"/02.Python/01.Python-基础/11.Python中完整for循环的实际运用.html",redirect:"/pages/7c7c36/"},{name:"v-53f9261a",path:"/pages/76ac47/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-53f9261a").then(t)}},{path:"/pages/76ac47/index.html",redirect:"/pages/76ac47/"},{path:"/02.Python/01.Python-基础/12.Python中字典(key-value).html",redirect:"/pages/76ac47/"},{name:"v-e957dff6",path:"/pages/5386bd/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-e957dff6").then(t)}},{path:"/pages/5386bd/index.html",redirect:"/pages/5386bd/"},{path:"/02.Python/01.Python-基础/13.Python中字符串的一些方法回顾(拆分与合并).html",redirect:"/pages/5386bd/"},{name:"v-605baf28",path:"/pages/c7192a/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-605baf28").then(t)}},{path:"/pages/c7192a/index.html",redirect:"/pages/c7192a/"},{path:"/02.Python/01.Python-基础/14.Python中字符串的一些方法回顾(切片回顾).html",redirect:"/pages/c7192a/"},{name:"v-da1159c4",path:"/pages/a7c3f3/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-da1159c4").then(t)}},{path:"/pages/a7c3f3/index.html",redirect:"/pages/a7c3f3/"},{path:"/02.Python/01.Python-基础/15.Python中字符串的一些方法回顾(文本对齐、去除空白).html",redirect:"/pages/a7c3f3/"},{name:"v-93be6cd2",path:"/pages/800d04/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-93be6cd2").then(t)}},{path:"/pages/800d04/index.html",redirect:"/pages/800d04/"},{path:"/02.Python/01.Python-基础/16.Python中字符串的一些方法回顾.html",redirect:"/pages/800d04/"},{name:"v-8d5a0674",path:"/pages/76881f/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-8d5a0674").then(t)}},{path:"/pages/76881f/index.html",redirect:"/pages/76881f/"},{path:"/02.Python/01.Python-基础/17.Python中字符串的一些基本操作.html",redirect:"/pages/76881f/"},{name:"v-217168dc",path:"/pages/e5cf66/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-217168dc").then(t)}},{path:"/pages/e5cf66/index.html",redirect:"/pages/e5cf66/"},{path:"/02.Python/01.Python-基础/18.多种方法快速交换两个变量的值.html",redirect:"/pages/e5cf66/"},{name:"v-f8ffc25c",path:"/pages/369a5f/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-f8ffc25c").then(t)}},{path:"/pages/369a5f/index.html",redirect:"/pages/369a5f/"},{path:"/02.Python/01.Python-基础/19.利用Python进行文件的自动备份.html",redirect:"/pages/369a5f/"},{name:"v-0a4c594d",path:"/pages/04f569/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-0a4c594d").then(t)}},{path:"/pages/04f569/index.html",redirect:"/pages/04f569/"},{path:"/02.Python/01.Python-基础/20.利用Python进行文件的自动备份(第二版).html",redirect:"/pages/04f569/"},{name:"v-00e633de",path:"/pages/a8d563/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-00e633de").then(t)}},{path:"/pages/a8d563/index.html",redirect:"/pages/a8d563/"},{path:"/02.Python/01.Python-基础/21.利用Python进行文件的自动备份(第三版和第四版).html",redirect:"/pages/a8d563/"},{name:"v-0f45791d",path:"/pages/f7e4b1/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-0f45791d").then(t)}},{path:"/pages/f7e4b1/index.html",redirect:"/pages/f7e4b1/"},{path:"/02.Python/01.Python-基础/22.列表推导.html",redirect:"/pages/f7e4b1/"},{name:"v-8d3daca2",path:"/pages/f954d1/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-8d3daca2").then(t)}},{path:"/pages/f954d1/index.html",redirect:"/pages/f954d1/"},{path:"/02.Python/01.Python-基础/23.在函数中接受元组与字典.html",redirect:"/pages/f954d1/"},{name:"v-1d080750",path:"/pages/962777/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-1d080750").then(t)}},{path:"/pages/962777/index.html",redirect:"/pages/962777/"},{path:"/02.Python/01.Python-基础/24.装饰器.html",redirect:"/pages/962777/"},{name:"v-1fa6daf0",path:"/pages/cd9b6e/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-1fa6daf0").then(t)}},{path:"/pages/cd9b6e/index.html",redirect:"/pages/cd9b6e/"},{path:"/02.Python/01.Python-基础/25.finally异常处理.html",redirect:"/pages/cd9b6e/"},{name:"v-a55cb270",path:"/pages/f09b25/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-a55cb270").then(t)}},{path:"/pages/f09b25/index.html",redirect:"/pages/f09b25/"},{path:"/02.Python/01.Python-基础/26.Python的main函数作用.html",redirect:"/pages/f09b25/"},{name:"v-81b73566",path:"/pages/ee2549/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-81b73566").then(t)}},{path:"/pages/ee2549/index.html",redirect:"/pages/ee2549/"},{path:"/02.Python/01.Python-基础/27.Python的pickle模块.html",redirect:"/pages/ee2549/"},{name:"v-17e022f6",path:"/pages/7cedd2/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-17e022f6").then(t)}},{path:"/pages/7cedd2/index.html",redirect:"/pages/7cedd2/"},{path:"/02.Python/01.Python-基础/28.Python对象的实例化.html",redirect:"/pages/7cedd2/"},{name:"v-180b4631",path:"/pages/adffdd/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-180b4631").then(t)}},{path:"/pages/adffdd/index.html",redirect:"/pages/adffdd/"},{path:"/02.Python/01.Python-基础/29.Python日志模块.html",redirect:"/pages/adffdd/"},{name:"v-35ebce61",path:"/pages/985752/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-35ebce61").then(t)}},{path:"/pages/985752/index.html",redirect:"/pages/985752/"},{path:"/02.Python/01.Python-基础/30.Python中的__new__方法的重写.html",redirect:"/pages/985752/"},{name:"v-6bfff2f1",path:"/pages/7235b8/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-6bfff2f1").then(t)}},{path:"/pages/7235b8/index.html",redirect:"/pages/7235b8/"},{path:"/02.Python/01.Python-基础/31.Python中的lambda函数.html",redirect:"/pages/7235b8/"},{name:"v-7ba47ebe",path:"/pages/57af9e/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-7ba47ebe").then(t)}},{path:"/pages/57af9e/index.html",redirect:"/pages/57af9e/"},{path:"/02.Python/01.Python-基础/32.Python中的静态方法、实例方法、类方法的区别.html",redirect:"/pages/57af9e/"},{name:"v-11840c14",path:"/pages/38b0ff/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-11840c14").then(t)}},{path:"/pages/38b0ff/index.html",redirect:"/pages/38b0ff/"},{path:"/02.Python/01.Python-基础/33.Python中的正则表达式.html",redirect:"/pages/38b0ff/"},{name:"v-25a11d4e",path:"/pages/ee44fe/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-25a11d4e").then(t)}},{path:"/pages/ee44fe/index.html",redirect:"/pages/ee44fe/"},{path:"/02.Python/01.Python-基础/34.Python中的正则表达式match和search.html",redirect:"/pages/ee44fe/"},{name:"v-3c4081f6",path:"/pages/d79b2c/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-3c4081f6").then(t)}},{path:"/pages/d79b2c/index.html",redirect:"/pages/d79b2c/"},{path:"/02.Python/01.Python-基础/35.Python中面向对象比较简单的内部函数.html",redirect:"/pages/d79b2c/"},{name:"v-47059fc8",path:"/pages/c20072/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-47059fc8").then(t)}},{path:"/pages/c20072/index.html",redirect:"/pages/c20072/"},{path:"/02.Python/01.Python-基础/36.with-open异常处理.html",redirect:"/pages/c20072/"},{name:"v-21ecc4d2",path:"/pages/ccdd54/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-21ecc4d2").then(t)}},{path:"/pages/ccdd54/index.html",redirect:"/pages/ccdd54/"},{path:"/02.Python/01.Python-基础/37.Python单例设计模式.html",redirect:"/pages/ccdd54/"},{name:"v-20ab13d4",path:"/pages/6a1778/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-20ab13d4").then(t)}},{path:"/pages/6a1778/index.html",redirect:"/pages/6a1778/"},{path:"/02.Python/01.Python-基础/38.继承的运用.html",redirect:"/pages/6a1778/"},{name:"v-218f00a6",path:"/pages/8d431d/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-218f00a6").then(t)}},{path:"/pages/8d431d/index.html",redirect:"/pages/8d431d/"},{path:"/02.Python/01.Python-基础/39.简单的异常处理.html",redirect:"/pages/8d431d/"},{name:"v-6ed28772",path:"/pages/43bfe3/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-6ed28772").then(t)}},{path:"/pages/43bfe3/index.html",redirect:"/pages/43bfe3/"},{path:"/02.Python/01.Python-基础/40.类变量与对象变量.html",redirect:"/pages/43bfe3/"},{name:"v-73f43abd",path:"/pages/0f3eea/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-73f43abd").then(t)}},{path:"/pages/0f3eea/index.html",redirect:"/pages/0f3eea/"},{path:"/02.Python/01.Python-基础/41.输入输出——简单的回文判断.html",redirect:"/pages/0f3eea/"},{name:"v-4f9430d9",path:"/pages/efd97d/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-4f9430d9").then(t)}},{path:"/pages/efd97d/index.html",redirect:"/pages/efd97d/"},{path:"/02.Python/01.Python-基础/42.输入输出——回文字串的判断（加强版）.html",redirect:"/pages/efd97d/"},{name:"v-7365a2db",path:"/pages/9d76ce/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-7365a2db").then(t)}},{path:"/pages/9d76ce/index.html",redirect:"/pages/9d76ce/"},{path:"/02.Python/01.Python-基础/43.文件操作.html",redirect:"/pages/9d76ce/"},{name:"v-1598588c",path:"/pages/74cf7d/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-1598588c").then(t)}},{path:"/pages/74cf7d/index.html",redirect:"/pages/74cf7d/"},{path:"/02.Python/01.Python-基础/44.用户自己引发的异常处理.html",redirect:"/pages/74cf7d/"},{name:"v-5133dd93",path:"/pages/e8935b/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-5133dd93").then(t)}},{path:"/pages/e8935b/index.html",redirect:"/pages/e8935b/"},{path:"/02.Python/01.Python-基础/45.正则表达式检索与替换.html",redirect:"/pages/e8935b/"},{name:"v-49e05f57",path:"/pages/270272/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-49e05f57").then(t)}},{path:"/pages/270272/index.html",redirect:"/pages/270272/"},{path:"/02.Python/01.Python-基础/46.正则表达式中的compile函数.html",redirect:"/pages/270272/"},{name:"v-1c9efa1f",path:"/pages/bff928/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-1c9efa1f").then(t)}},{path:"/pages/bff928/index.html",redirect:"/pages/bff928/"},{path:"/02.Python/01.Python-基础/47.正则表达式中的compile函数(二).html",redirect:"/pages/bff928/"},{name:"v-cf53aca6",path:"/pages/43f8b9/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-cf53aca6").then(t)}},{path:"/pages/43f8b9/index.html",redirect:"/pages/43f8b9/"},{path:"/02.Python/02.Python-机器学习/01.Numpy库的首次使用.html",redirect:"/pages/43f8b9/"},{name:"v-75da521e",path:"/pages/b2a5ff/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-75da521e").then(t)}},{path:"/pages/b2a5ff/index.html",redirect:"/pages/b2a5ff/"},{path:"/02.Python/02.Python-机器学习/02.kNN（k-近邻算法）.html",redirect:"/pages/b2a5ff/"},{name:"v-54191a9e",path:"/pages/6c1c7d/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-54191a9e").then(t)}},{path:"/pages/6c1c7d/index.html",redirect:"/pages/6c1c7d/"},{path:"/02.Python/02.Python-机器学习/03.kNN识别手写图像.html",redirect:"/pages/6c1c7d/"},{name:"v-38c3379b",path:"/pages/dbeb49/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-38c3379b").then(t)}},{path:"/pages/dbeb49/index.html",redirect:"/pages/dbeb49/"},{path:"/02.Python/02.Python-机器学习/04.LogisticRegression(逻辑回归).html",redirect:"/pages/dbeb49/"},{name:"v-17aa954e",path:"/pages/6ae370/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-17aa954e").then(t)}},{path:"/pages/6ae370/index.html",redirect:"/pages/6ae370/"},{path:"/02.Python/02.Python-机器学习/05.Ndarray对象.html",redirect:"/pages/6ae370/"},{name:"v-bbe4baae",path:"/pages/cdba0b/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-bbe4baae").then(t)}},{path:"/pages/cdba0b/index.html",redirect:"/pages/cdba0b/"},{path:"/02.Python/02.Python-机器学习/06.Numpy中的数组维度.html",redirect:"/pages/cdba0b/"},{name:"v-7ae93e1c",path:"/pages/92372b/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-7ae93e1c").then(t)}},{path:"/pages/92372b/index.html",redirect:"/pages/92372b/"},{path:"/02.Python/02.Python-机器学习/07.Numpy中花式索引和shape用法.html",redirect:"/pages/92372b/"},{name:"v-3c0e1bb9",path:"/pages/0779b1/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-3c0e1bb9").then(t)}},{path:"/pages/0779b1/index.html",redirect:"/pages/0779b1/"},{path:"/02.Python/02.Python-机器学习/08.turtle绘图库.html",redirect:"/pages/0779b1/"},{name:"v-56e20f8a",path:"/pages/6cd0c4/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-56e20f8a").then(t)}},{path:"/pages/6cd0c4/index.html",redirect:"/pages/6cd0c4/"},{path:"/02.Python/02.Python-机器学习/09.第一个使用Tensorflow的程序.html",redirect:"/pages/6cd0c4/"},{name:"v-b704fa22",path:"/pages/8b335a/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-b704fa22").then(t)}},{path:"/pages/8b335a/index.html",redirect:"/pages/8b335a/"},{path:"/02.Python/02.Python-机器学习/10.将下载下来的MNIST手写数字数据集转化成为图片.html",redirect:"/pages/8b335a/"},{name:"v-e814cfd8",path:"/pages/b8d563/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-e814cfd8").then(t)}},{path:"/pages/b8d563/index.html",redirect:"/pages/b8d563/"},{path:"/02.Python/02.Python-机器学习/11.Tensorflow交互式使用.html",redirect:"/pages/b8d563/"},{name:"v-5b727396",path:"/pages/a76d65/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-5b727396").then(t)}},{path:"/pages/a76d65/index.html",redirect:"/pages/a76d65/"},{path:"/02.Python/02.Python-机器学习/12.使用k-近邻算法改进约会网站的配对效果.html",redirect:"/pages/a76d65/"},{name:"v-72a0dc64",path:"/pages/f66019/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-72a0dc64").then(t)}},{path:"/pages/f66019/index.html",redirect:"/pages/f66019/"},{path:"/02.Python/02.Python-机器学习/13.Numpy数据类型和arange方法_astype方法的使用.html",redirect:"/pages/f66019/"},{name:"v-638b756f",path:"/pages/f9a151/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-638b756f").then(t)}},{path:"/pages/f9a151/index.html",redirect:"/pages/f9a151/"},{path:"/02.Python/02.Python-机器学习/14.一些TensorFlow的基本操作.html",redirect:"/pages/f9a151/"},{name:"v-15bb3d7d",path:"/pages/b53b0f/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-15bb3d7d").then(t)}},{path:"/pages/b53b0f/index.html",redirect:"/pages/b53b0f/"},{path:"/03.分布式与中间件/01.Kafka/01.概览.html",redirect:"/pages/b53b0f/"},{name:"v-046c9608",path:"/pages/847591/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-046c9608").then(t)}},{path:"/pages/847591/index.html",redirect:"/pages/847591/"},{path:"/03.分布式与中间件/02.Redis/01.Redis实现共享Session.html",redirect:"/pages/847591/"},{name:"v-a3238f7a",path:"/pages/b185b0/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-a3238f7a").then(t)}},{path:"/pages/b185b0/index.html",redirect:"/pages/b185b0/"},{path:"/03.分布式与中间件/02.Redis/02.自定义RedisTemplate.html",redirect:"/pages/b185b0/"},{name:"v-889b9680",path:"/pages/3aa0a8/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-889b9680").then(t)}},{path:"/pages/3aa0a8/index.html",redirect:"/pages/3aa0a8/"},{path:"/03.分布式与中间件/02.Redis/03.Redis哨兵.html",redirect:"/pages/3aa0a8/"},{name:"v-34f103b2",path:"/pages/2f1bf8/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-34f103b2").then(t)}},{path:"/pages/2f1bf8/index.html",redirect:"/pages/2f1bf8/"},{path:"/03.分布式与中间件/02.Redis/04.Redis持久化RDB.html",redirect:"/pages/2f1bf8/"},{name:"v-79d665d6",path:"/pages/c48db1/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-79d665d6").then(t)}},{path:"/pages/c48db1/index.html",redirect:"/pages/c48db1/"},{path:"/03.分布式与中间件/02.Redis/05.Redis持久化AOF.html",redirect:"/pages/c48db1/"},{name:"v-159cd9c6",path:"/pages/20361f/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-159cd9c6").then(t)}},{path:"/pages/20361f/index.html",redirect:"/pages/20361f/"},{path:"/03.分布式与中间件/02.Redis/06.Redis分片集群.html",redirect:"/pages/20361f/"},{name:"v-9a7ceb4e",path:"/pages/aaed8c/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-9a7ceb4e").then(t)}},{path:"/pages/aaed8c/index.html",redirect:"/pages/aaed8c/"},{path:"/03.分布式与中间件/03.分布式事务/01.事务的特性、CAP定理、BASE理论.html",redirect:"/pages/aaed8c/"},{name:"v-72ef87c1",path:"/pages/e8a7fb/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-72ef87c1").then(t)}},{path:"/pages/e8a7fb/index.html",redirect:"/pages/e8a7fb/"},{path:"/03.分布式与中间件/03.分布式事务/02.分布式事务XA、AT、TCC、SAGA.html",redirect:"/pages/e8a7fb/"},{name:"v-f7e5f00a",path:"/pages/81dbd1/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-f7e5f00a").then(t)}},{path:"/pages/81dbd1/index.html",redirect:"/pages/81dbd1/"},{path:"/03.分布式与中间件/03.分布式事务/03.分布式事务AT模式的脏写问题.html",redirect:"/pages/81dbd1/"},{name:"v-3039e03b",path:"/pages/f256e0/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-3039e03b").then(t)}},{path:"/pages/f256e0/index.html",redirect:"/pages/f256e0/"},{path:"/03.分布式与中间件/03.分布式事务/04.分布式事务TCC模式的空回滚和业务悬挂问题.html",redirect:"/pages/f256e0/"},{name:"v-fbb6475a",path:"/pages/0f7e8e/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-fbb6475a").then(t)}},{path:"/pages/0f7e8e/index.html",redirect:"/pages/0f7e8e/"},{path:"/04.数据库/01.MySQL/01.MySQL索引原理及应用场景.html",redirect:"/pages/0f7e8e/"},{name:"v-cdef8cd4",path:"/pages/6e0b99/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-cdef8cd4").then(t)}},{path:"/pages/6e0b99/index.html",redirect:"/pages/6e0b99/"},{path:"/05.框架/01.Spring/01.SpringIOC/01.概览.html",redirect:"/pages/6e0b99/"},{name:"v-00f38f3a",path:"/pages/a657d3/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-00f38f3a").then(t)}},{path:"/pages/a657d3/index.html",redirect:"/pages/a657d3/"},{path:"/05.框架/01.Spring/02.SpringAOP/01.利用AOP实现操作日志.html",redirect:"/pages/a657d3/"},{name:"v-218946b4",path:"/pages/83cdcf/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-218946b4").then(t)}},{path:"/pages/83cdcf/index.html",redirect:"/pages/83cdcf/"},{path:"/06.算法/01.剑指Offer/00.01背包问题详解.html",redirect:"/pages/83cdcf/"},{name:"v-69c850bd",path:"/pages/f411af/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-69c850bd").then(t)}},{path:"/pages/f411af/index.html",redirect:"/pages/f411af/"},{path:"/06.算法/01.剑指Offer/01.LeetCode-面试题17-打印从1到最大的n位数.html",redirect:"/pages/f411af/"},{name:"v-64669de5",path:"/pages/e68fc1/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-64669de5").then(t)}},{path:"/pages/e68fc1/index.html",redirect:"/pages/e68fc1/"},{path:"/06.算法/01.剑指Offer/02.LeetCode-面试题03-不修改数组找出重复的数字.html",redirect:"/pages/e68fc1/"},{name:"v-1f7c083a",path:"/pages/2f843e/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-1f7c083a").then(t)}},{path:"/pages/2f843e/index.html",redirect:"/pages/2f843e/"},{path:"/06.算法/01.剑指Offer/03.LeetCode-面试题03-数组中重复的数字.html",redirect:"/pages/2f843e/"},{name:"v-3c4a2030",path:"/pages/84f558/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-3c4a2030").then(t)}},{path:"/pages/84f558/index.html",redirect:"/pages/84f558/"},{path:"/06.算法/01.剑指Offer/04.LeetCode-面试题04-二维数组中的查找.html",redirect:"/pages/84f558/"},{name:"v-aeaf62e4",path:"/pages/b0f96d/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-aeaf62e4").then(t)}},{path:"/pages/b0f96d/index.html",redirect:"/pages/b0f96d/"},{path:"/06.算法/01.剑指Offer/05.LeetCode-面试题05-替换空格.html",redirect:"/pages/b0f96d/"},{name:"v-5d535259",path:"/pages/642877/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-5d535259").then(t)}},{path:"/pages/642877/index.html",redirect:"/pages/642877/"},{path:"/06.算法/01.剑指Offer/06.LeetCode-面试题06-从尾到头打印链表.html",redirect:"/pages/642877/"},{name:"v-4786c633",path:"/pages/e5bc1f/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-4786c633").then(t)}},{path:"/pages/e5bc1f/index.html",redirect:"/pages/e5bc1f/"},{path:"/06.算法/01.剑指Offer/07.LeetCode-面试题09-用两个栈实现队列.html",redirect:"/pages/e5bc1f/"},{name:"v-1b073eaa",path:"/pages/6a6f3c/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-1b073eaa").then(t)}},{path:"/pages/6a6f3c/index.html",redirect:"/pages/6a6f3c/"},{path:"/06.算法/01.剑指Offer/08.LeetCode-面试题10-1-斐波那契数列.html",redirect:"/pages/6a6f3c/"},{name:"v-cb57926c",path:"/pages/78c895/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-cb57926c").then(t)}},{path:"/pages/78c895/index.html",redirect:"/pages/78c895/"},{path:"/06.算法/01.剑指Offer/09.LeetCode-面试题10-2-青蛙跳台阶.html",redirect:"/pages/78c895/"},{name:"v-2bcd48ed",path:"/pages/ea52d6/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-2bcd48ed").then(t)}},{path:"/pages/ea52d6/index.html",redirect:"/pages/ea52d6/"},{path:"/06.算法/01.剑指Offer/10.LeetCode-面试题11-旋转数组的最小数字.html",redirect:"/pages/ea52d6/"},{name:"v-1109df90",path:"/pages/ab9430/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-1109df90").then(t)}},{path:"/pages/ab9430/index.html",redirect:"/pages/ab9430/"},{path:"/06.算法/01.剑指Offer/11.LeetCode-面试题13-机器人的运动范围.html",redirect:"/pages/ab9430/"},{name:"v-61b66e0f",path:"/pages/2d7b5b/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-61b66e0f").then(t)}},{path:"/pages/2d7b5b/index.html",redirect:"/pages/2d7b5b/"},{path:"/06.算法/01.剑指Offer/12.LeetCode-面试题14-1-剪绳子.html",redirect:"/pages/2d7b5b/"},{name:"v-06664e26",path:"/pages/7c3197/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-06664e26").then(t)}},{path:"/pages/7c3197/index.html",redirect:"/pages/7c3197/"},{path:"/06.算法/01.剑指Offer/13.LeetCode-面试题14-2-剪绳子(大数).html",redirect:"/pages/7c3197/"},{name:"v-b0913c7a",path:"/pages/5abb63/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-b0913c7a").then(t)}},{path:"/pages/5abb63/index.html",redirect:"/pages/5abb63/"},{path:"/06.算法/01.剑指Offer/14.LeetCode-面试题15-二进制中1的个数.html",redirect:"/pages/5abb63/"},{name:"v-068d4a28",path:"/pages/4e2fa9/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-068d4a28").then(t)}},{path:"/pages/4e2fa9/index.html",redirect:"/pages/4e2fa9/"},{path:"/06.算法/01.剑指Offer/15.LeetCode-面试题16-数值的整数次方.html",redirect:"/pages/4e2fa9/"},{name:"v-3d447ed6",path:"/pages/a7cb1c/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-3d447ed6").then(t)}},{path:"/pages/a7cb1c/index.html",redirect:"/pages/a7cb1c/"},{path:"/06.算法/01.剑指Offer/16.LeetCode-面试题18-删除链表的节点.html",redirect:"/pages/a7cb1c/"},{name:"v-7eaffbbc",path:"/pages/489cb9/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-7eaffbbc").then(t)}},{path:"/pages/489cb9/index.html",redirect:"/pages/489cb9/"},{path:"/06.算法/01.剑指Offer/17.LeetCode-面试题19-正则表达式匹配.html",redirect:"/pages/489cb9/"},{name:"v-a17ec6d2",path:"/pages/6845e4/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-a17ec6d2").then(t)}},{path:"/pages/6845e4/index.html",redirect:"/pages/6845e4/"},{path:"/06.算法/01.剑指Offer/18.LeetCode-面试题20-表示数值的字符串.html",redirect:"/pages/6845e4/"},{name:"v-18b54ca0",path:"/pages/d28ff3/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-18b54ca0").then(t)}},{path:"/pages/d28ff3/index.html",redirect:"/pages/d28ff3/"},{path:"/06.算法/01.剑指Offer/19.LeetCode-面试题21-调整数组顺序使奇数位于偶数前面.html",redirect:"/pages/d28ff3/"},{name:"v-477a301f",path:"/pages/663c3e/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-477a301f").then(t)}},{path:"/pages/663c3e/index.html",redirect:"/pages/663c3e/"},{path:"/06.算法/01.剑指Offer/20.LeetCode-面试题22-链表中倒数第k个节点.html",redirect:"/pages/663c3e/"},{name:"v-0ddb40ea",path:"/pages/107b94/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-0ddb40ea").then(t)}},{path:"/pages/107b94/index.html",redirect:"/pages/107b94/"},{path:"/06.算法/01.剑指Offer/24.LeetCode-面试题27-二叉树的镜像.html",redirect:"/pages/107b94/"},{name:"v-2c7e0c4b",path:"/pages/0b663a/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-2c7e0c4b").then(t)}},{path:"/pages/0b663a/index.html",redirect:"/pages/0b663a/"},{path:"/06.算法/01.剑指Offer/25.LeetCode-面试题29-顺时针打印矩阵.html",redirect:"/pages/0b663a/"},{name:"v-404f6236",path:"/pages/baac38/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-404f6236").then(t)}},{path:"/pages/baac38/index.html",redirect:"/pages/baac38/"},{path:"/06.算法/01.剑指Offer/26.LeetCode-面试题31-栈的压入弹出序列.html",redirect:"/pages/baac38/"},{name:"v-04dccd77",path:"/pages/f4c63f/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-04dccd77").then(t)}},{path:"/pages/f4c63f/index.html",redirect:"/pages/f4c63f/"},{path:"/06.算法/01.剑指Offer/27.LeetCode-面试题32-1-从上到下打印二叉树.html",redirect:"/pages/f4c63f/"},{name:"v-5346a03e",path:"/pages/7e90de/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-5346a03e").then(t)}},{path:"/pages/7e90de/index.html",redirect:"/pages/7e90de/"},{path:"/06.算法/01.剑指Offer/28.LeetCode-面试题32-2-从上到下打印二叉树 .html",redirect:"/pages/7e90de/"},{name:"v-d728c212",path:"/pages/a2ebc7/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-d728c212").then(t)}},{path:"/pages/a2ebc7/index.html",redirect:"/pages/a2ebc7/"},{path:"/06.算法/01.剑指Offer/29.LeetCode-面试题32-3-从上到下打印二叉树.html",redirect:"/pages/a2ebc7/"},{name:"v-4a0528ed",path:"/pages/9050fc/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-4a0528ed").then(t)}},{path:"/pages/9050fc/index.html",redirect:"/pages/9050fc/"},{path:"/06.算法/01.剑指Offer/30.LeetCode-面试题35-复杂链表的复制.html",redirect:"/pages/9050fc/"},{name:"v-de3dd5ac",path:"/pages/e44b62/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-de3dd5ac").then(t)}},{path:"/pages/e44b62/index.html",redirect:"/pages/e44b62/"},{path:"/06.算法/01.剑指Offer/31.LeetCode-面试题36-二叉搜索树与双向链表.html",redirect:"/pages/e44b62/"},{name:"v-37ddeda4",path:"/pages/1643b9/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-37ddeda4").then(t)}},{path:"/pages/1643b9/index.html",redirect:"/pages/1643b9/"},{path:"/06.算法/01.剑指Offer/32.LeetCode-面试题37-序列化二叉树.html",redirect:"/pages/1643b9/"},{name:"v-3ea3c6ca",path:"/pages/01dd29/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-3ea3c6ca").then(t)}},{path:"/pages/01dd29/index.html",redirect:"/pages/01dd29/"},{path:"/06.算法/01.剑指Offer/33.LeetCode-面试题38-字符串的排列.html",redirect:"/pages/01dd29/"},{name:"v-6f1c1816",path:"/pages/c61856/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-6f1c1816").then(t)}},{path:"/pages/c61856/index.html",redirect:"/pages/c61856/"},{path:"/06.算法/01.剑指Offer/34.LeetCode-面试题39-数组中出现次数超过一半的数字.html",redirect:"/pages/c61856/"},{name:"v-0544891e",path:"/pages/504abd/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-0544891e").then(t)}},{path:"/pages/504abd/index.html",redirect:"/pages/504abd/"},{path:"/06.算法/01.剑指Offer/35.LeetCode-面试题40-最小的k个数.html",redirect:"/pages/504abd/"},{name:"v-dd5b10b0",path:"/pages/888f97/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-dd5b10b0").then(t)}},{path:"/pages/888f97/index.html",redirect:"/pages/888f97/"},{path:"/06.算法/01.剑指Offer/36.LeetCode-面试题41-数据流中的中位数.html",redirect:"/pages/888f97/"},{name:"v-e2fb1c2a",path:"/pages/95eb09/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-e2fb1c2a").then(t)}},{path:"/pages/95eb09/index.html",redirect:"/pages/95eb09/"},{path:"/06.算法/01.剑指Offer/37.LeetCode-面试题42-连续子数组的最大和.html",redirect:"/pages/95eb09/"},{name:"v-1fb6cd47",path:"/pages/e9ceb8/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-1fb6cd47").then(t)}},{path:"/pages/e9ceb8/index.html",redirect:"/pages/e9ceb8/"},{path:"/06.算法/01.剑指Offer/38.LeetCode-面试题43-1到n整数中1出现的次数.html",redirect:"/pages/e9ceb8/"},{name:"v-2124d7fc",path:"/pages/11765a/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-2124d7fc").then(t)}},{path:"/pages/11765a/index.html",redirect:"/pages/11765a/"},{path:"/06.算法/01.剑指Offer/39.LeetCode-面试题44-数字序列中某一位的数字.html",redirect:"/pages/11765a/"},{name:"v-6c380f3c",path:"/pages/0856b2/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-6c380f3c").then(t)}},{path:"/pages/0856b2/index.html",redirect:"/pages/0856b2/"},{path:"/06.算法/01.剑指Offer/40.LeetCode-面试题45-把数组排成最小的数.html",redirect:"/pages/0856b2/"},{name:"v-6b05a19d",path:"/pages/85c8fd/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-6b05a19d").then(t)}},{path:"/pages/85c8fd/index.html",redirect:"/pages/85c8fd/"},{path:"/06.算法/01.剑指Offer/41.LeetCode-面试题47-礼物的最大价值.html",redirect:"/pages/85c8fd/"},{name:"v-5d0d0f9e",path:"/pages/7fd908/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-5d0d0f9e").then(t)}},{path:"/pages/7fd908/index.html",redirect:"/pages/7fd908/"},{path:"/06.算法/01.剑指Offer/42.LeetCode-面试题48-最长不含重复字符的子字符串.html",redirect:"/pages/7fd908/"},{name:"v-55f7df2a",path:"/pages/0b0978/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-55f7df2a").then(t)}},{path:"/pages/0b0978/index.html",redirect:"/pages/0b0978/"},{path:"/06.算法/01.剑指Offer/43.LeetCode-面试题49-丑数.html",redirect:"/pages/0b0978/"},{name:"v-70612210",path:"/pages/105b9d/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-70612210").then(t)}},{path:"/pages/105b9d/index.html",redirect:"/pages/105b9d/"},{path:"/06.算法/01.剑指Offer/44.LeetCode-面试题50-第一次只出现一次的字符.html",redirect:"/pages/105b9d/"},{name:"v-38a4108f",path:"/pages/3fafb8/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-38a4108f").then(t)}},{path:"/pages/3fafb8/index.html",redirect:"/pages/3fafb8/"},{path:"/06.算法/01.剑指Offer/45.LeetCode-面试题51-数组中的逆序对.html",redirect:"/pages/3fafb8/"},{name:"v-6632c0ce",path:"/pages/c7c072/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-6632c0ce").then(t)}},{path:"/pages/c7c072/index.html",redirect:"/pages/c7c072/"},{path:"/06.算法/01.剑指Offer/46.LeetCode-面试题53-1-在排序数组中查找数字I.html",redirect:"/pages/c7c072/"},{name:"v-3a95fe52",path:"/pages/fe51d2/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-3a95fe52").then(t)}},{path:"/pages/fe51d2/index.html",redirect:"/pages/fe51d2/"},{path:"/06.算法/01.剑指Offer/47.LeetCode-面试题33-二叉搜索树的后序遍历序列.html",redirect:"/pages/fe51d2/"},{name:"v-9056ec2c",path:"/pages/23d089/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-9056ec2c").then(t)}},{path:"/pages/23d089/index.html",redirect:"/pages/23d089/"},{path:"/06.算法/01.剑指Offer/48.LeetCode-面试题54-二叉搜索树的第k大节点.html",redirect:"/pages/23d089/"},{name:"v-7eeb95da",path:"/pages/485921/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-7eeb95da").then(t)}},{path:"/pages/485921/index.html",redirect:"/pages/485921/"},{path:"/06.算法/01.剑指Offer/49.LeetCode-面试题55-1-二叉树的深度.html",redirect:"/pages/485921/"},{name:"v-7ea8e75a",path:"/pages/254f95/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-7ea8e75a").then(t)}},{path:"/pages/254f95/index.html",redirect:"/pages/254f95/"},{path:"/06.算法/01.剑指Offer/50.LeetCode-面试题12-矩阵中的路径.html",redirect:"/pages/254f95/"},{name:"v-2e0e850c",path:"/pages/c9ae12/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-2e0e850c").then(t)}},{path:"/pages/c9ae12/index.html",redirect:"/pages/c9ae12/"},{path:"/06.算法/01.剑指Offer/51.LeetCode-面试题30-包含min函数的栈.html",redirect:"/pages/c9ae12/"},{name:"v-6adf3070",path:"/pages/e52256/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-6adf3070").then(t)}},{path:"/pages/e52256/index.html",redirect:"/pages/e52256/"},{path:"/06.算法/01.剑指Offer/52.LeetCode-面试题34-二叉树中和为某一值的路径.html",redirect:"/pages/e52256/"},{name:"v-2a14cc38",path:"/pages/73554a/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-2a14cc38").then(t)}},{path:"/pages/73554a/index.html",redirect:"/pages/73554a/"},{path:"/06.算法/01.剑指Offer/53.LeetCode-面试题46-把数字翻译成字符串.html",redirect:"/pages/73554a/"},{name:"v-61cc9f77",path:"/pages/8564b7/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-61cc9f77").then(t)}},{path:"/pages/8564b7/index.html",redirect:"/pages/8564b7/"},{path:"/06.算法/01.剑指Offer/54.LeetCode-面试题55-2-平衡二叉树.html",redirect:"/pages/8564b7/"},{name:"v-54199694",path:"/pages/0dd136/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-54199694").then(t)}},{path:"/pages/0dd136/index.html",redirect:"/pages/0dd136/"},{path:"/06.算法/01.剑指Offer/55.LeetCode-面试题56-1-数组中数字出现的次数1.html",redirect:"/pages/0dd136/"},{name:"v-25a72634",path:"/pages/322274/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-25a72634").then(t)}},{path:"/pages/322274/index.html",redirect:"/pages/322274/"},{path:"/06.算法/01.剑指Offer/56.LeetCode-面试题56-2-数组中数字出现的次数2.html",redirect:"/pages/322274/"},{name:"v-38ae4266",path:"/pages/64b7a6/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-38ae4266").then(t)}},{path:"/pages/64b7a6/index.html",redirect:"/pages/64b7a6/"},{path:"/06.算法/01.剑指Offer/57.LeetCode-面试题57-1-和为s的两个数字.html",redirect:"/pages/64b7a6/"},{name:"v-1edd9c60",path:"/pages/9fdad5/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-1edd9c60").then(t)}},{path:"/pages/9fdad5/index.html",redirect:"/pages/9fdad5/"},{path:"/06.算法/01.剑指Offer/58.LeetCode-面试题58-1-翻转单词顺序.html",redirect:"/pages/9fdad5/"},{name:"v-199b1610",path:"/pages/7c648d/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-199b1610").then(t)}},{path:"/pages/7c648d/index.html",redirect:"/pages/7c648d/"},{path:"/06.算法/01.剑指Offer/59.LeetCode-面试题58-2-左旋转字符串.html",redirect:"/pages/7c648d/"},{name:"v-45814dca",path:"/pages/0c523d/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-45814dca").then(t)}},{path:"/pages/0c523d/index.html",redirect:"/pages/0c523d/"},{path:"/06.算法/01.剑指Offer/60.LeetCode-面试题59-2-队列的最大值.html",redirect:"/pages/0c523d/"},{name:"v-48886aed",path:"/pages/517e93/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-48886aed").then(t)}},{path:"/pages/517e93/index.html",redirect:"/pages/517e93/"},{path:"/06.算法/01.剑指Offer/61.LeetCode-面试题60-n个骰子的点数 - 副本.html",redirect:"/pages/517e93/"},{name:"v-dd580c7a",path:"/pages/a7687d/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-dd580c7a").then(t)}},{path:"/pages/a7687d/index.html",redirect:"/pages/a7687d/"},{path:"/06.算法/01.剑指Offer/62.LeetCode-面试题61-扑克牌中的顺子.html",redirect:"/pages/a7687d/"},{name:"v-2788ef08",path:"/pages/9ca7ff/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-2788ef08").then(t)}},{path:"/pages/9ca7ff/index.html",redirect:"/pages/9ca7ff/"},{path:"/06.算法/01.剑指Offer/63.LeetCode-面试题62-圆圈中最后剩下的数字.html",redirect:"/pages/9ca7ff/"},{name:"v-3b164efb",path:"/pages/610009/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-3b164efb").then(t)}},{path:"/pages/610009/index.html",redirect:"/pages/610009/"},{path:"/06.算法/01.剑指Offer/64.LeetCode-面试题63-股票的最大利润.html",redirect:"/pages/610009/"},{name:"v-e24f836e",path:"/pages/4abc2f/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-e24f836e").then(t)}},{path:"/pages/4abc2f/index.html",redirect:"/pages/4abc2f/"},{path:"/06.算法/01.剑指Offer/65.LeetCode-面试题64-求1+2+到+n.html",redirect:"/pages/4abc2f/"},{name:"v-37cdc6f8",path:"/pages/808f6a/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-37cdc6f8").then(t)}},{path:"/pages/808f6a/index.html",redirect:"/pages/808f6a/"},{path:"/06.算法/01.剑指Offer/66.LeetCode-面试题65-不用加减乘除做加法.html",redirect:"/pages/808f6a/"},{name:"v-6397ae1b",path:"/pages/bcd8dc/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-6397ae1b").then(t)}},{path:"/pages/bcd8dc/index.html",redirect:"/pages/bcd8dc/"},{path:"/06.算法/01.剑指Offer/67.LeetCode-面试题66-构建乘积数组.html",redirect:"/pages/bcd8dc/"},{name:"v-52aba3b4",path:"/pages/bd49ec/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-52aba3b4").then(t)}},{path:"/pages/bd49ec/index.html",redirect:"/pages/bd49ec/"},{path:"/06.算法/01.剑指Offer/68.LeetCode-面试题67-把字符串转化成整数.html",redirect:"/pages/bd49ec/"},{name:"v-0018d08d",path:"/pages/2295ef/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-0018d08d").then(t)}},{path:"/pages/2295ef/index.html",redirect:"/pages/2295ef/"},{path:"/06.算法/01.剑指Offer/69.LeetCode-面试题68-1-二叉搜索树的最近公共祖先.html",redirect:"/pages/2295ef/"},{name:"v-02c2afad",path:"/pages/88652a/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-02c2afad").then(t)}},{path:"/pages/88652a/index.html",redirect:"/pages/88652a/"},{path:"/06.算法/01.剑指Offer/71.LeetCode-面试题07-重建二叉树.html",redirect:"/pages/88652a/"},{name:"v-51972726",path:"/pages/10adcf/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-51972726").then(t)}},{path:"/pages/10adcf/index.html",redirect:"/pages/10adcf/"},{path:"/06.算法/01.剑指Offer/70.LeetCode-面试题68-2-二叉搜索树的最近公共祖先.html",redirect:"/pages/10adcf/"},{name:"v-62e48c45",path:"/pages/a0e6b3/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-62e48c45").then(t)}},{path:"/pages/a0e6b3/index.html",redirect:"/pages/a0e6b3/"},{path:"/06.算法/01.剑指Offer/72.LeetCode-面试题52-两个链表的第一个公共节点.html",redirect:"/pages/a0e6b3/"},{name:"v-5e1b404a",path:"/pages/f558cf/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-5e1b404a").then(t)}},{path:"/pages/f558cf/index.html",redirect:"/pages/f558cf/"},{path:"/06.算法/01.剑指Offer/73.LeetCode-面试题53-2-0到n-1中缺失的数字.html",redirect:"/pages/f558cf/"},{name:"v-d43ad834",path:"/pages/a09b75/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-d43ad834").then(t)}},{path:"/pages/a09b75/index.html",redirect:"/pages/a09b75/"},{path:"/06.算法/01.剑指Offer/74.LeetCode-面试题57-2-和为s的连续正数序列.html",redirect:"/pages/a09b75/"},{name:"v-01211f8e",path:"/pages/e91bb1/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-01211f8e").then(t)}},{path:"/pages/e91bb1/index.html",redirect:"/pages/e91bb1/"},{path:"/06.算法/01.剑指Offer/75.LeetCode-面试题59-1-滑动窗口的最大值.html",redirect:"/pages/e91bb1/"},{name:"v-b661f760",path:"/pages/28dd80/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-b661f760").then(t)}},{path:"/pages/28dd80/index.html",redirect:"/pages/28dd80/"},{path:"/06.算法/01.剑指Offer/76.LeetCode-面试题28-对称的二叉树.html",redirect:"/pages/28dd80/"},{name:"v-29a56b4e",path:"/pages/b2b5b5/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-29a56b4e").then(t)}},{path:"/pages/b2b5b5/index.html",redirect:"/pages/b2b5b5/"},{path:"/06.算法/02.LeetCode/01.LeetCode-54-螺旋矩阵.html",redirect:"/pages/b2b5b5/"},{name:"v-db5d6e9c",path:"/pages/7d3b6e/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-db5d6e9c").then(t)}},{path:"/pages/7d3b6e/index.html",redirect:"/pages/7d3b6e/"},{path:"/06.算法/02.LeetCode/02.LeetCode-67-二进制求和.html",redirect:"/pages/7d3b6e/"},{name:"v-3bc6e2d0",path:"/pages/fb7a5f/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-3bc6e2d0").then(t)}},{path:"/pages/fb7a5f/index.html",redirect:"/pages/fb7a5f/"},{path:"/06.算法/02.LeetCode/03.LeetCode-83-删除排序链表中的重复元素.html",redirect:"/pages/fb7a5f/"},{name:"v-c76ded1a",path:"/pages/9c3f56/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-c76ded1a").then(t)}},{path:"/pages/9c3f56/index.html",redirect:"/pages/9c3f56/"},{path:"/06.算法/02.LeetCode/04.LeetCode-415-字符串相加.html",redirect:"/pages/9c3f56/"},{name:"v-c39498e0",path:"/pages/45d832/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-c39498e0").then(t)}},{path:"/pages/45d832/index.html",redirect:"/pages/45d832/"},{path:"/06.算法/02.LeetCode/05.LeetCode-498-对角线遍历.html",redirect:"/pages/45d832/"},{name:"v-86a00068",path:"/pages/f095b3/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-86a00068").then(t)}},{path:"/pages/f095b3/index.html",redirect:"/pages/f095b3/"},{path:"/06.算法/02.LeetCode/06.LeetCode-724-寻找数组的中心索引.html",redirect:"/pages/f095b3/"},{name:"v-7f617a74",path:"/pages/6ddb3f/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-7f617a74").then(t)}},{path:"/pages/6ddb3f/index.html",redirect:"/pages/6ddb3f/"},{path:"/06.算法/02.LeetCode/07.动态规划问题——最长上升子序列(LIS)(一).html",redirect:"/pages/6ddb3f/"},{name:"v-2fa92128",path:"/pages/1f5b98/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-2fa92128").then(t)}},{path:"/pages/1f5b98/index.html",redirect:"/pages/1f5b98/"},{path:"/06.算法/02.LeetCode/08.动态规划问题——最长上升子序列(LIS)(二).html",redirect:"/pages/1f5b98/"},{name:"v-3f1b4b82",path:"/pages/f98f70/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-3f1b4b82").then(t)}},{path:"/pages/f98f70/index.html",redirect:"/pages/f98f70/"},{path:"/06.算法/02.LeetCode/09.动态规划问题——最长上升子序列(LIS)(三).html",redirect:"/pages/f98f70/"},{name:"v-fa0dbca4",path:"/pages/b03f05/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-fa0dbca4").then(t)}},{path:"/pages/b03f05/index.html",redirect:"/pages/b03f05/"},{path:"/06.算法/02.LeetCode/10.LeetCode-144-二叉树的前序遍历.html",redirect:"/pages/b03f05/"},{name:"v-1b0cd9f8",path:"/pages/bac26b/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-1b0cd9f8").then(t)}},{path:"/pages/bac26b/index.html",redirect:"/pages/bac26b/"},{path:"/06.算法/02.LeetCode/100.最小字典序字符串.html",redirect:"/pages/bac26b/"},{name:"v-6b40286e",path:"/pages/005df6/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-6b40286e").then(t)}},{path:"/pages/005df6/index.html",redirect:"/pages/005df6/"},{path:"/06.算法/02.LeetCode/101.LeetCode-1-两数之和.html",redirect:"/pages/005df6/"},{name:"v-23e575be",path:"/pages/ce722a/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-23e575be").then(t)}},{path:"/pages/ce722a/index.html",redirect:"/pages/ce722a/"},{path:"/06.算法/02.LeetCode/102.LeetCode-16-最接近的三数之和.html",redirect:"/pages/ce722a/"},{name:"v-2203410d",path:"/pages/ebc391/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-2203410d").then(t)}},{path:"/pages/ebc391/index.html",redirect:"/pages/ebc391/"},{path:"/06.算法/02.LeetCode/103.LeetCode-679-24点游戏.html",redirect:"/pages/ebc391/"},{name:"v-67adcffe",path:"/pages/edad8f/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-67adcffe").then(t)}},{path:"/pages/edad8f/index.html",redirect:"/pages/edad8f/"},{path:"/06.算法/02.LeetCode/104.LeetCode-141-环形链表.html",redirect:"/pages/edad8f/"},{name:"v-b14ebb44",path:"/pages/2fc7af/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-b14ebb44").then(t)}},{path:"/pages/2fc7af/index.html",redirect:"/pages/2fc7af/"},{path:"/06.算法/02.LeetCode/105.LeetCode-155-最小栈.html",redirect:"/pages/2fc7af/"},{name:"v-6e6d2c48",path:"/pages/19f71b/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-6e6d2c48").then(t)}},{path:"/pages/19f71b/index.html",redirect:"/pages/19f71b/"},{path:"/06.算法/02.LeetCode/106.LeetCode-160-相交链表.html",redirect:"/pages/19f71b/"},{name:"v-2d3903dd",path:"/pages/6d1dda/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-2d3903dd").then(t)}},{path:"/pages/6d1dda/index.html",redirect:"/pages/6d1dda/"},{path:"/06.算法/02.LeetCode/107.判断一棵二叉树是否为二叉搜索树和完全二叉树.html",redirect:"/pages/6d1dda/"},{name:"v-864cbdf2",path:"/pages/657ad4/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-864cbdf2").then(t)}},{path:"/pages/657ad4/index.html",redirect:"/pages/657ad4/"},{path:"/06.算法/02.LeetCode/108.LeetCode-169-多数元素.html",redirect:"/pages/657ad4/"},{name:"v-055ce36e",path:"/pages/4923ab/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-055ce36e").then(t)}},{path:"/pages/4923ab/index.html",redirect:"/pages/4923ab/"},{path:"/06.算法/02.LeetCode/109.LeetCode-234-回文链表.html",redirect:"/pages/4923ab/"},{name:"v-39c6fbcd",path:"/pages/4517f3/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-39c6fbcd").then(t)}},{path:"/pages/4517f3/index.html",redirect:"/pages/4517f3/"},{path:"/06.算法/02.LeetCode/11.LeetCode-94-二叉树的中序遍历.html",redirect:"/pages/4517f3/"},{name:"v-abf43b04",path:"/pages/c56f5d/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-abf43b04").then(t)}},{path:"/pages/c56f5d/index.html",redirect:"/pages/c56f5d/"},{path:"/06.算法/02.LeetCode/110.LeetCode-238-除自身以外数组的乘积.html",redirect:"/pages/c56f5d/"},{name:"v-5c933400",path:"/pages/b249d6/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-5c933400").then(t)}},{path:"/pages/b249d6/index.html",redirect:"/pages/b249d6/"},{path:"/06.算法/02.LeetCode/111.LeetCode-283-移动零.html",redirect:"/pages/b249d6/"},{name:"v-31b70a5f",path:"/pages/4a24f6/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-31b70a5f").then(t)}},{path:"/pages/4a24f6/index.html",redirect:"/pages/4a24f6/"},{path:"/06.算法/02.LeetCode/112.LeetCode-338-比特位计数.html",redirect:"/pages/4a24f6/"},{name:"v-4ae463bf",path:"/pages/0b83ab/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-4ae463bf").then(t)}},{path:"/pages/0b83ab/index.html",redirect:"/pages/0b83ab/"},{path:"/06.算法/02.LeetCode/113.LeetCode-797-所有可能的路径.html",redirect:"/pages/0b83ab/"},{name:"v-7a5d5098",path:"/pages/bc617d/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-7a5d5098").then(t)}},{path:"/pages/bc617d/index.html",redirect:"/pages/bc617d/"},{path:"/06.算法/02.LeetCode/12.LeetCode-145-二叉树的后序遍历.html",redirect:"/pages/bc617d/"},{name:"v-7062dffd",path:"/pages/1ac9e8/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-7062dffd").then(t)}},{path:"/pages/1ac9e8/index.html",redirect:"/pages/1ac9e8/"},{path:"/06.算法/02.LeetCode/13.LeetCode-53-最大子序和.html",redirect:"/pages/1ac9e8/"},{name:"v-5e007e9e",path:"/pages/20a5df/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-5e007e9e").then(t)}},{path:"/pages/20a5df/index.html",redirect:"/pages/20a5df/"},{path:"/06.算法/02.LeetCode/14.LeetCode-392-判断子序列.html",redirect:"/pages/20a5df/"},{name:"v-766367b0",path:"/pages/d42c3d/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-766367b0").then(t)}},{path:"/pages/d42c3d/index.html",redirect:"/pages/d42c3d/"},{path:"/06.算法/02.LeetCode/15.LeetCode-303-区域和检索-数组不可变.html",redirect:"/pages/d42c3d/"},{name:"v-3ac3c5bf",path:"/pages/95fe08/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-3ac3c5bf").then(t)}},{path:"/pages/95fe08/index.html",redirect:"/pages/95fe08/"},{path:"/06.算法/02.LeetCode/16.LeetCode-2-两数相加.html",redirect:"/pages/95fe08/"},{name:"v-6419c4d5",path:"/pages/30e6dd/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-6419c4d5").then(t)}},{path:"/pages/30e6dd/index.html",redirect:"/pages/30e6dd/"},{path:"/06.算法/02.LeetCode/17.LeetCode-3-无重复字符的最长字串.html",redirect:"/pages/30e6dd/"},{name:"v-74022466",path:"/pages/e945ea/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-74022466").then(t)}},{path:"/pages/e945ea/index.html",redirect:"/pages/e945ea/"},{path:"/06.算法/02.LeetCode/18.LeetCode-4-寻找两个正序数组的中位数.html",redirect:"/pages/e945ea/"},{name:"v-281e7683",path:"/pages/c3c526/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-281e7683").then(t)}},{path:"/pages/c3c526/index.html",redirect:"/pages/c3c526/"},{path:"/06.算法/02.LeetCode/19.LeetCode-5-最长回文字串.html",redirect:"/pages/c3c526/"},{name:"v-04405839",path:"/pages/1104ba/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-04405839").then(t)}},{path:"/pages/1104ba/index.html",redirect:"/pages/1104ba/"},{path:"/06.算法/02.LeetCode/20.LeetCode-11-盛最多水的容器.html",redirect:"/pages/1104ba/"},{name:"v-49ca2b1c",path:"/pages/5a4da3/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-49ca2b1c").then(t)}},{path:"/pages/5a4da3/index.html",redirect:"/pages/5a4da3/"},{path:"/06.算法/02.LeetCode/21.LeetCode-15-三数之和.html",redirect:"/pages/5a4da3/"},{name:"v-3d73a434",path:"/pages/23ca91/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-3d73a434").then(t)}},{path:"/pages/23ca91/index.html",redirect:"/pages/23ca91/"},{path:"/06.算法/02.LeetCode/22.LeetCode-17-电话号码的字母组合.html",redirect:"/pages/23ca91/"},{name:"v-5766fcc4",path:"/pages/2b5a76/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-5766fcc4").then(t)}},{path:"/pages/2b5a76/index.html",redirect:"/pages/2b5a76/"},{path:"/06.算法/02.LeetCode/23.LeetCode-19-删除链表的倒数第N个节点.html",redirect:"/pages/2b5a76/"},{name:"v-2c1431df",path:"/pages/b7ac0a/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-2c1431df").then(t)}},{path:"/pages/b7ac0a/index.html",redirect:"/pages/b7ac0a/"},{path:"/06.算法/02.LeetCode/24.LeetCode-20-有效的括号.html",redirect:"/pages/b7ac0a/"},{name:"v-eace5c7c",path:"/pages/d0dd86/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-eace5c7c").then(t)}},{path:"/pages/d0dd86/index.html",redirect:"/pages/d0dd86/"},{path:"/06.算法/02.LeetCode/25.LeetCode-21-合并两个有序链表.html",redirect:"/pages/d0dd86/"},{name:"v-77d9d1bd",path:"/pages/a6eaf0/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-77d9d1bd").then(t)}},{path:"/pages/a6eaf0/index.html",redirect:"/pages/a6eaf0/"},{path:"/06.算法/02.LeetCode/26.LeetCode-22-括号生成.html",redirect:"/pages/a6eaf0/"},{name:"v-7543bffe",path:"/pages/e24301/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-7543bffe").then(t)}},{path:"/pages/e24301/index.html",redirect:"/pages/e24301/"},{path:"/06.算法/02.LeetCode/27.LeetCode-23-合并K个排序链表.html",redirect:"/pages/e24301/"},{name:"v-61f87bf8",path:"/pages/d9a097/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-61f87bf8").then(t)}},{path:"/pages/d9a097/index.html",redirect:"/pages/d9a097/"},{path:"/06.算法/02.LeetCode/28.LeetCode-31-下一个排列.html",redirect:"/pages/d9a097/"},{name:"v-50a84ff8",path:"/pages/bcf8b4/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-50a84ff8").then(t)}},{path:"/pages/bcf8b4/index.html",redirect:"/pages/bcf8b4/"},{path:"/06.算法/02.LeetCode/29.LeetCode-32-最长有效括号.html",redirect:"/pages/bcf8b4/"},{name:"v-7691670a",path:"/pages/1b9196/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-7691670a").then(t)}},{path:"/pages/1b9196/index.html",redirect:"/pages/1b9196/"},{path:"/06.算法/02.LeetCode/30.LeetCode-33-搜索旋转排序数组.html",redirect:"/pages/1b9196/"},{name:"v-55238b17",path:"/pages/731f67/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-55238b17").then(t)}},{path:"/pages/731f67/index.html",redirect:"/pages/731f67/"},{path:"/06.算法/02.LeetCode/32.LeetCode-39-组合总数.html",redirect:"/pages/731f67/"},{name:"v-715b54f6",path:"/pages/1f0b71/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-715b54f6").then(t)}},{path:"/pages/1f0b71/index.html",redirect:"/pages/1f0b71/"},{path:"/06.算法/02.LeetCode/31.LeetCode-34-在排序数组中查找元素的第一个和最后一个位置.html",redirect:"/pages/1f0b71/"},{name:"v-8edc01ec",path:"/pages/292c69/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-8edc01ec").then(t)}},{path:"/pages/292c69/index.html",redirect:"/pages/292c69/"},{path:"/06.算法/02.LeetCode/33.LeetCode-46-全排列.html",redirect:"/pages/292c69/"},{name:"v-6eba0db4",path:"/pages/ed20fe/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-6eba0db4").then(t)}},{path:"/pages/ed20fe/index.html",redirect:"/pages/ed20fe/"},{path:"/06.算法/02.LeetCode/34.LeetCode-47-全排列2.html",redirect:"/pages/ed20fe/"},{name:"v-ae62b842",path:"/pages/cd98da/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-ae62b842").then(t)}},{path:"/pages/cd98da/index.html",redirect:"/pages/cd98da/"},{path:"/06.算法/02.LeetCode/35.LeetCode-51-N皇后.html",redirect:"/pages/cd98da/"},{name:"v-b0357cfc",path:"/pages/010874/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-b0357cfc").then(t)}},{path:"/pages/010874/index.html",redirect:"/pages/010874/"},{path:"/06.算法/02.LeetCode/36.LeetCode-55-跳跃游戏.html",redirect:"/pages/010874/"},{name:"v-e6d11d7a",path:"/pages/232d3c/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-e6d11d7a").then(t)}},{path:"/pages/232d3c/index.html",redirect:"/pages/232d3c/"},{path:"/06.算法/02.LeetCode/37.LeetCode-56-合并区间.html",redirect:"/pages/232d3c/"},{name:"v-2ad7fa7c",path:"/pages/193e4b/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-2ad7fa7c").then(t)}},{path:"/pages/193e4b/index.html",redirect:"/pages/193e4b/"},{path:"/06.算法/02.LeetCode/38.LeetCode-62-不同路径.html",redirect:"/pages/193e4b/"},{name:"v-9a8f5e4a",path:"/pages/b04e8c/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-9a8f5e4a").then(t)}},{path:"/pages/b04e8c/index.html",redirect:"/pages/b04e8c/"},{path:"/06.算法/02.LeetCode/39.LeetCode-64-最小路径和.html",redirect:"/pages/b04e8c/"},{name:"v-fc46af5c",path:"/pages/b9a49e/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-fc46af5c").then(t)}},{path:"/pages/b9a49e/index.html",redirect:"/pages/b9a49e/"},{path:"/06.算法/02.LeetCode/40.LeetCode-70-爬楼梯.html",redirect:"/pages/b9a49e/"},{name:"v-695169c4",path:"/pages/dfda01/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-695169c4").then(t)}},{path:"/pages/dfda01/index.html",redirect:"/pages/dfda01/"},{path:"/06.算法/02.LeetCode/41.LeetCode-72-编辑距离.html",redirect:"/pages/dfda01/"},{name:"v-fe099c58",path:"/pages/a35d7b/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-fe099c58").then(t)}},{path:"/pages/a35d7b/index.html",redirect:"/pages/a35d7b/"},{path:"/06.算法/02.LeetCode/42.LeetCode-75-颜色分类.html",redirect:"/pages/a35d7b/"},{name:"v-0f2f29d4",path:"/pages/a90162/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-0f2f29d4").then(t)}},{path:"/pages/a90162/index.html",redirect:"/pages/a90162/"},{path:"/06.算法/02.LeetCode/43.LeetCode-76-最小覆盖字串.html",redirect:"/pages/a90162/"},{name:"v-347e45ac",path:"/pages/c30be8/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-347e45ac").then(t)}},{path:"/pages/c30be8/index.html",redirect:"/pages/c30be8/"},{path:"/06.算法/02.LeetCode/44.LeetCode-77-组合.html",redirect:"/pages/c30be8/"},{name:"v-bdb3b278",path:"/pages/60626a/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-bdb3b278").then(t)}},{path:"/pages/60626a/index.html",redirect:"/pages/60626a/"},{path:"/06.算法/02.LeetCode/45.LeetCode-78-子集.html",redirect:"/pages/60626a/"},{name:"v-573934c0",path:"/pages/16f784/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-573934c0").then(t)}},{path:"/pages/16f784/index.html",redirect:"/pages/16f784/"},{path:"/06.算法/02.LeetCode/46.LeetCode-84-柱状图中最大的矩形.html",redirect:"/pages/16f784/"},{name:"v-8333bcc2",path:"/pages/bcc13b/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-8333bcc2").then(t)}},{path:"/pages/bcc13b/index.html",redirect:"/pages/bcc13b/"},{path:"/06.算法/02.LeetCode/47.LeetCode-102-二叉树的层序遍历.html",redirect:"/pages/bcc13b/"},{name:"v-7a4a3fcc",path:"/pages/95771c/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-7a4a3fcc").then(t)}},{path:"/pages/95771c/index.html",redirect:"/pages/95771c/"},{path:"/06.算法/02.LeetCode/48.LeetCode-104-二叉树的最大深度.html",redirect:"/pages/95771c/"},{name:"v-633b41b0",path:"/pages/c5dd58/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-633b41b0").then(t)}},{path:"/pages/c5dd58/index.html",redirect:"/pages/c5dd58/"},{path:"/06.算法/02.LeetCode/49.LeetCode-105-从前序与中序遍历构造二叉树.html",redirect:"/pages/c5dd58/"},{name:"v-7006d63d",path:"/pages/4d6c7d/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-7006d63d").then(t)}},{path:"/pages/4d6c7d/index.html",redirect:"/pages/4d6c7d/"},{path:"/06.算法/02.LeetCode/50.LeetCode-107-二叉树的层次遍历2.html",redirect:"/pages/4d6c7d/"},{name:"v-287ec08e",path:"/pages/f626bf/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-287ec08e").then(t)}},{path:"/pages/f626bf/index.html",redirect:"/pages/f626bf/"},{path:"/06.算法/02.LeetCode/51.LeetCode-114-二叉树展开为链表.html",redirect:"/pages/f626bf/"},{name:"v-f4f24202",path:"/pages/6f907a/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-f4f24202").then(t)}},{path:"/pages/6f907a/index.html",redirect:"/pages/6f907a/"},{path:"/06.算法/02.LeetCode/52.LeetCode-121-买卖股票的最佳时机.html",redirect:"/pages/6f907a/"},{name:"v-9a3b1246",path:"/pages/1c92f0/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-9a3b1246").then(t)}},{path:"/pages/1c92f0/index.html",redirect:"/pages/1c92f0/"},{path:"/06.算法/02.LeetCode/53.LeetCode-128-最长连续序列.html",redirect:"/pages/1c92f0/"},{name:"v-5845d8e8",path:"/pages/7a9856/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-5845d8e8").then(t)}},{path:"/pages/7a9856/index.html",redirect:"/pages/7a9856/"},{path:"/06.算法/02.LeetCode/54.LeetCode-136-只出现一次的数字.html",redirect:"/pages/7a9856/"},{name:"v-364bea08",path:"/pages/21e57b/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-364bea08").then(t)}},{path:"/pages/21e57b/index.html",redirect:"/pages/21e57b/"},{path:"/06.算法/02.LeetCode/55.LeetCode-142-环形链表2.html",redirect:"/pages/21e57b/"},{name:"v-513eccc6",path:"/pages/825806/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-513eccc6").then(t)}},{path:"/pages/825806/index.html",redirect:"/pages/825806/"},{path:"/06.算法/02.LeetCode/56.LeetCode-143-重排链表.html",redirect:"/pages/825806/"},{name:"v-39c91715",path:"/pages/0d05d2/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-39c91715").then(t)}},{path:"/pages/0d05d2/index.html",redirect:"/pages/0d05d2/"},{path:"/06.算法/02.LeetCode/57.LeetCode-146-LRU缓存机制.html",redirect:"/pages/0d05d2/"},{name:"v-bbbaa4fa",path:"/pages/87a481/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-bbbaa4fa").then(t)}},{path:"/pages/87a481/index.html",redirect:"/pages/87a481/"},{path:"/06.算法/02.LeetCode/58.LeetCode-152-乘积最大子数组.html",redirect:"/pages/87a481/"},{name:"v-20c0614d",path:"/pages/bd9776/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-20c0614d").then(t)}},{path:"/pages/bd9776/index.html",redirect:"/pages/bd9776/"},{path:"/06.算法/02.LeetCode/59.LeetCode-198-打家劫舍.html",redirect:"/pages/bd9776/"},{name:"v-eab0bdca",path:"/pages/2aa937/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-eab0bdca").then(t)}},{path:"/pages/2aa937/index.html",redirect:"/pages/2aa937/"},{path:"/06.算法/02.LeetCode/60.LeetCode-199-二叉树的右视图.html",redirect:"/pages/2aa937/"},{name:"v-2b11bb3a",path:"/pages/44df2f/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-2b11bb3a").then(t)}},{path:"/pages/44df2f/index.html",redirect:"/pages/44df2f/"},{path:"/06.算法/02.LeetCode/62.LeetCode-207-课程表.html",redirect:"/pages/44df2f/"},{name:"v-bc33ea14",path:"/pages/7c576f/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-bc33ea14").then(t)}},{path:"/pages/7c576f/index.html",redirect:"/pages/7c576f/"},{path:"/06.算法/02.LeetCode/61.LeetCode-206-反转链表.html",redirect:"/pages/7c576f/"},{name:"v-0f1d08a6",path:"/pages/f586d8/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-0f1d08a6").then(t)}},{path:"/pages/f586d8/index.html",redirect:"/pages/f586d8/"},{path:"/06.算法/02.LeetCode/63.LeetCode-215-数组中的第K个最大元素.html",redirect:"/pages/f586d8/"},{name:"v-5989d2b3",path:"/pages/3b7ec6/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-5989d2b3").then(t)}},{path:"/pages/3b7ec6/index.html",redirect:"/pages/3b7ec6/"},{path:"/06.算法/02.LeetCode/64.LeetCode-221-最大正方形.html",redirect:"/pages/3b7ec6/"},{name:"v-1c9f13f8",path:"/pages/2dfb9f/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-1c9f13f8").then(t)}},{path:"/pages/2dfb9f/index.html",redirect:"/pages/2dfb9f/"},{path:"/06.算法/01.剑指Offer/21.LeetCode-面试题24-反转链表.html",redirect:"/pages/2dfb9f/"},{name:"v-34a7b1f8",path:"/pages/2bee97/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-34a7b1f8").then(t)}},{path:"/pages/2bee97/index.html",redirect:"/pages/2bee97/"},{path:"/06.算法/02.LeetCode/65.LeetCode-226-翻转二叉树.html",redirect:"/pages/2bee97/"},{name:"v-4177806d",path:"/pages/aa9694/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-4177806d").then(t)}},{path:"/pages/aa9694/index.html",redirect:"/pages/aa9694/"},{path:"/06.算法/02.LeetCode/67.LeetCode-279-完全平方数.html",redirect:"/pages/aa9694/"},{name:"v-97e09750",path:"/pages/ceb226/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-97e09750").then(t)}},{path:"/pages/ceb226/index.html",redirect:"/pages/ceb226/"},{path:"/06.算法/02.LeetCode/66.LeetCode-236-二叉树的最近公共祖先.html",redirect:"/pages/ceb226/"},{name:"v-03423148",path:"/pages/d6c0fb/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-03423148").then(t)}},{path:"/pages/d6c0fb/index.html",redirect:"/pages/d6c0fb/"},{path:"/06.算法/02.LeetCode/68.LeetCode-287-寻找重复数.html",redirect:"/pages/d6c0fb/"},{name:"v-490137f5",path:"/pages/444ab2/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-490137f5").then(t)}},{path:"/pages/444ab2/index.html",redirect:"/pages/444ab2/"},{path:"/06.算法/02.LeetCode/69.LeetCode-300-最长上升子序列.html",redirect:"/pages/444ab2/"},{name:"v-6daed7c5",path:"/pages/3b3388/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-6daed7c5").then(t)}},{path:"/pages/3b3388/index.html",redirect:"/pages/3b3388/"},{path:"/06.算法/02.LeetCode/70.LeetCode-309-最佳买卖股票时机含冷冻期.html",redirect:"/pages/3b3388/"},{name:"v-b19b5dd2",path:"/pages/9868ec/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-b19b5dd2").then(t)}},{path:"/pages/9868ec/index.html",redirect:"/pages/9868ec/"},{path:"/06.算法/02.LeetCode/71.LeetCode-322-零钱兑换.html",redirect:"/pages/9868ec/"},{name:"v-86b57bc6",path:"/pages/74a1b6/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-86b57bc6").then(t)}},{path:"/pages/74a1b6/index.html",redirect:"/pages/74a1b6/"},{path:"/06.算法/02.LeetCode/72.LeetCode-328-奇偶链表.html",redirect:"/pages/74a1b6/"},{name:"v-726c37f8",path:"/pages/5abc8f/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-726c37f8").then(t)}},{path:"/pages/5abc8f/index.html",redirect:"/pages/5abc8f/"},{path:"/06.算法/02.LeetCode/73.LeetCode-347-前K个高频元素.html",redirect:"/pages/5abc8f/"},{name:"v-3e1194da",path:"/pages/0af455/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-3e1194da").then(t)}},{path:"/pages/0af455/index.html",redirect:"/pages/0af455/"},{path:"/06.算法/02.LeetCode/74.LeetCode-394-字符串解码.html",redirect:"/pages/0af455/"},{name:"v-3f1714d1",path:"/pages/8d243f/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-3f1714d1").then(t)}},{path:"/pages/8d243f/index.html",redirect:"/pages/8d243f/"},{path:"/06.算法/02.LeetCode/75.LeetCode-406-根据身高重建队列.html",redirect:"/pages/8d243f/"},{name:"v-1456ec14",path:"/pages/cd66f6/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-1456ec14").then(t)}},{path:"/pages/cd66f6/index.html",redirect:"/pages/cd66f6/"},{path:"/06.算法/02.LeetCode/76.LeetCode-413-等差数列划分.html",redirect:"/pages/cd66f6/"},{name:"v-3b2f4a8c",path:"/pages/87a353/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-3b2f4a8c").then(t)}},{path:"/pages/87a353/index.html",redirect:"/pages/87a353/"},{path:"/06.算法/02.LeetCode/77.LeetCode-416-分割等和子集.html",redirect:"/pages/87a353/"},{name:"v-0a68e3d0",path:"/pages/e8a730/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-0a68e3d0").then(t)}},{path:"/pages/e8a730/index.html",redirect:"/pages/e8a730/"},{path:"/06.算法/02.LeetCode/78.LeetCode-438-找到字符串中所有字母异位词.html",redirect:"/pages/e8a730/"},{name:"v-1642c97c",path:"/pages/ad566a/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-1642c97c").then(t)}},{path:"/pages/ad566a/index.html",redirect:"/pages/ad566a/"},{path:"/06.算法/02.LeetCode/80.LeetCode-461-汉明距离.html",redirect:"/pages/ad566a/"},{name:"v-4e381294",path:"/pages/d2f3f5/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-4e381294").then(t)}},{path:"/pages/d2f3f5/index.html",redirect:"/pages/d2f3f5/"},{path:"/06.算法/02.LeetCode/79.LeetCode-448-找到所有数组中消失的数字.html",redirect:"/pages/d2f3f5/"},{name:"v-104c0473",path:"/pages/ed7689/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-104c0473").then(t)}},{path:"/pages/ed7689/index.html",redirect:"/pages/ed7689/"},{path:"/06.算法/02.LeetCode/81.LeetCode-494-目标和.html",redirect:"/pages/ed7689/"},{name:"v-a3c4af02",path:"/pages/9d7aee/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-a3c4af02").then(t)}},{path:"/pages/9d7aee/index.html",redirect:"/pages/9d7aee/"},{path:"/06.算法/02.LeetCode/82.LeetCode-538-把二叉搜索树转换为累加树.html",redirect:"/pages/9d7aee/"},{name:"v-5459e177",path:"/pages/a78f8c/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-5459e177").then(t)}},{path:"/pages/a78f8c/index.html",redirect:"/pages/a78f8c/"},{path:"/06.算法/02.LeetCode/83.LeetCode-543-二叉树的直径.html",redirect:"/pages/a78f8c/"},{name:"v-52535292",path:"/pages/c7dca6/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-52535292").then(t)}},{path:"/pages/c7dca6/index.html",redirect:"/pages/c7dca6/"},{path:"/06.算法/02.LeetCode/84.LeetCode-560-和为K的子数组.html",redirect:"/pages/c7dca6/"},{name:"v-52132daa",path:"/pages/5997b7/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-52132daa").then(t)}},{path:"/pages/5997b7/index.html",redirect:"/pages/5997b7/"},{path:"/06.算法/02.LeetCode/85.LeetCode-567-字符串的排列.html",redirect:"/pages/5997b7/"},{name:"v-6830aa98",path:"/pages/9686ce/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-6830aa98").then(t)}},{path:"/pages/9686ce/index.html",redirect:"/pages/9686ce/"},{path:"/06.算法/02.LeetCode/86.LeetCode-581-最短无序连续子数组.html",redirect:"/pages/9686ce/"},{name:"v-72503416",path:"/pages/f24660/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-72503416").then(t)}},{path:"/pages/f24660/index.html",redirect:"/pages/f24660/"},{path:"/06.算法/02.LeetCode/87.LeetCode-617-合并二叉树.html",redirect:"/pages/f24660/"},{name:"v-617dbfbc",path:"/pages/326143/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-617dbfbc").then(t)}},{path:"/pages/326143/index.html",redirect:"/pages/326143/"},{path:"/06.算法/02.LeetCode/88.LeetCode-704-二分查找.html",redirect:"/pages/326143/"},{name:"v-7cea714c",path:"/pages/d7d595/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-7cea714c").then(t)}},{path:"/pages/d7d595/index.html",redirect:"/pages/d7d595/"},{path:"/06.算法/02.LeetCode/89.LeetCode-739-每日温度.html",redirect:"/pages/d7d595/"},{name:"v-a188cbf8",path:"/pages/0343b2/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-a188cbf8").then(t)}},{path:"/pages/0343b2/index.html",redirect:"/pages/0343b2/"},{path:"/06.算法/02.LeetCode/90.LeetCode-747-至少是其他数字两倍的最大数.html",redirect:"/pages/0343b2/"},{name:"v-1786b60e",path:"/pages/a29fa8/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-1786b60e").then(t)}},{path:"/pages/a29fa8/index.html",redirect:"/pages/a29fa8/"},{path:"/06.算法/02.LeetCode/91.LeetCode-890-查找和替换模式.html",redirect:"/pages/a29fa8/"},{name:"v-aca2ff6e",path:"/pages/77c839/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-aca2ff6e").then(t)}},{path:"/pages/77c839/index.html",redirect:"/pages/77c839/"},{path:"/06.算法/02.LeetCode/92.LeetCode-1143-最长公共子序列.html",redirect:"/pages/77c839/"},{name:"v-a163964a",path:"/pages/961a11/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-a163964a").then(t)}},{path:"/pages/961a11/index.html",redirect:"/pages/961a11/"},{path:"/06.算法/02.LeetCode/93.LeetCode-1247-交换字符使得字符串相同.html",redirect:"/pages/961a11/"},{name:"v-f4c738d4",path:"/pages/053bcf/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-f4c738d4").then(t)}},{path:"/pages/053bcf/index.html",redirect:"/pages/053bcf/"},{path:"/06.算法/02.LeetCode/94.LeetCode-1367-二叉树中的列表.html",redirect:"/pages/053bcf/"},{name:"v-8402c606",path:"/pages/a64c8b/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-8402c606").then(t)}},{path:"/pages/a64c8b/index.html",redirect:"/pages/a64c8b/"},{path:"/06.算法/02.LeetCode/95.LeetCode-字符串排序.html",redirect:"/pages/a64c8b/"},{name:"v-4bb14ca2",path:"/pages/7899ff/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-4bb14ca2").then(t)}},{path:"/pages/7899ff/index.html",redirect:"/pages/7899ff/"},{path:"/06.算法/02.LeetCode/96.LeetCode-面试题02-02-返回倒数第k个节点.html",redirect:"/pages/7899ff/"},{name:"v-22683f86",path:"/pages/0c5197/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-22683f86").then(t)}},{path:"/pages/0c5197/index.html",redirect:"/pages/0c5197/"},{path:"/06.算法/02.LeetCode/97.LeetCode-面试题17-16-按摩师.html",redirect:"/pages/0c5197/"},{name:"v-7a505fa0",path:"/pages/5969d4/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-7a505fa0").then(t)}},{path:"/pages/5969d4/index.html",redirect:"/pages/5969d4/"},{path:"/06.算法/02.LeetCode/98.获取满足指数的最长字符串.html",redirect:"/pages/5969d4/"},{name:"v-0a5cdba6",path:"/pages/13f871/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-0a5cdba6").then(t)}},{path:"/pages/13f871/index.html",redirect:"/pages/13f871/"},{path:"/06.算法/02.LeetCode/99.数组的最多素数个数.html",redirect:"/pages/13f871/"},{name:"v-1925ed26",path:"/pages/8d006a/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-1925ed26").then(t)}},{path:"/pages/8d006a/index.html",redirect:"/pages/8d006a/"},{path:"/06.算法/03.排序算法/00.常见排序算法总结.html",redirect:"/pages/8d006a/"},{name:"v-0e4708a1",path:"/pages/3fd3f6/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-0e4708a1").then(t)}},{path:"/pages/3fd3f6/index.html",redirect:"/pages/3fd3f6/"},{path:"/06.算法/03.排序算法/01.冒泡排序.html",redirect:"/pages/3fd3f6/"},{name:"v-7653f6cc",path:"/pages/5ee1b6/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-7653f6cc").then(t)}},{path:"/pages/5ee1b6/index.html",redirect:"/pages/5ee1b6/"},{path:"/06.算法/03.排序算法/02.基数排序.html",redirect:"/pages/5ee1b6/"},{name:"v-374674c3",path:"/pages/c0468a/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-374674c3").then(t)}},{path:"/pages/c0468a/index.html",redirect:"/pages/c0468a/"},{path:"/06.算法/03.排序算法/03.堆排序.html",redirect:"/pages/c0468a/"},{name:"v-25268267",path:"/pages/05578a/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-25268267").then(t)}},{path:"/pages/05578a/index.html",redirect:"/pages/05578a/"},{path:"/06.算法/03.排序算法/04.希尔排序.html",redirect:"/pages/05578a/"},{name:"v-16be0b75",path:"/pages/246724/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-16be0b75").then(t)}},{path:"/pages/246724/index.html",redirect:"/pages/246724/"},{path:"/06.算法/03.排序算法/05.归并排序.html",redirect:"/pages/246724/"},{name:"v-bcc2cd22",path:"/pages/c1fce8/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-bcc2cd22").then(t)}},{path:"/pages/c1fce8/index.html",redirect:"/pages/c1fce8/"},{path:"/06.算法/03.排序算法/06.快速排序.html",redirect:"/pages/c1fce8/"},{name:"v-5519367f",path:"/pages/db04fa/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-5519367f").then(t)}},{path:"/pages/db04fa/index.html",redirect:"/pages/db04fa/"},{path:"/06.算法/03.排序算法/07.插入排序.html",redirect:"/pages/db04fa/"},{name:"v-f68eea1a",path:"/pages/7a5e99/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-f68eea1a").then(t)}},{path:"/pages/7a5e99/index.html",redirect:"/pages/7a5e99/"},{path:"/06.算法/03.排序算法/08.桶排序.html",redirect:"/pages/7a5e99/"},{name:"v-70d91d55",path:"/pages/ee0279/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-70d91d55").then(t)}},{path:"/pages/ee0279/index.html",redirect:"/pages/ee0279/"},{path:"/06.算法/03.排序算法/09.选择排序.html",redirect:"/pages/ee0279/"},{name:"v-968013f4",path:"/pages/f6b758/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-968013f4").then(t)}},{path:"/pages/f6b758/index.html",redirect:"/pages/f6b758/"},{path:"/07.实践/01.hexo/01.将hexo自定义域名升级https.html",redirect:"/pages/f6b758/"},{name:"v-ecf02760",path:"/pages/a07112/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-ecf02760").then(t)}},{path:"/pages/a07112/index.html",redirect:"/pages/a07112/"},{path:"/07.实践/01.hexo/02.hexo到Typecho的迁移日志.html",redirect:"/pages/a07112/"},{name:"v-2b4bdefd",path:"/pages/2c256c/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-2b4bdefd").then(t)}},{path:"/pages/2c256c/index.html",redirect:"/pages/2c256c/"},{path:"/07.实践/02.思考与方案/01.海量数据TopK问题.html",redirect:"/pages/2c256c/"},{name:"v-c983e334",path:"/pages/45617b/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-c983e334").then(t)}},{path:"/pages/45617b/index.html",redirect:"/pages/45617b/"},{path:"/07.实践/02.思考与方案/02.关于DO,VO,DTO,QueryParam的思考.html",redirect:"/pages/45617b/"},{name:"v-104bb908",path:"/pages/3572ad/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-104bb908").then(t)}},{path:"/pages/3572ad/index.html",redirect:"/pages/3572ad/"},{path:"/07.实践/02.思考与方案/03.异步消息通知.html",redirect:"/pages/3572ad/"},{name:"v-49f8bbe0",path:"/pages/2efaaf/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-49f8bbe0").then(t)}},{path:"/pages/2efaaf/index.html",redirect:"/pages/2efaaf/"},{path:"/07.实践/02.思考与方案/04.二叉搜索树及AVL树详解.html",redirect:"/pages/2efaaf/"},{name:"v-788ad340",path:"/pages/3147fe/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-788ad340").then(t)}},{path:"/pages/3147fe/index.html",redirect:"/pages/3147fe/"},{path:"/08.开源项目/01.Rpamis/01.Utils/01.无惧性能烦恼-12款Bean拷贝工具压测大比拼.html",redirect:"/pages/3147fe/"},{name:"v-624330b0",path:"/pages/cedee6/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-624330b0").then(t)}},{path:"/pages/cedee6/index.html",redirect:"/pages/cedee6/"},{path:"/08.开源项目/01.Rpamis/01.Utils/02.Bean工具类-RpasBeanUtils.html",redirect:"/pages/cedee6/"},{name:"v-3c9f3ea4",path:"/pages/b127c7/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-3c9f3ea4").then(t)}},{path:"/pages/b127c7/index.html",redirect:"/pages/b127c7/"},{path:"/08.开源项目/01.Rpamis/02.Exception/01.MethodHandle结合LambdaMetafactory-使用方法及性能测试.html",redirect:"/pages/b127c7/"},{name:"v-2be0cdda",path:"/pages/1c47ed/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-2be0cdda").then(t)}},{path:"/pages/1c47ed/index.html",redirect:"/pages/1c47ed/"},{path:"/08.开源项目/01.Rpamis/02.Exception/02.优雅的参数校验与全局异常.html",redirect:"/pages/1c47ed/"},{name:"v-2fa97bee",path:"/pages/4c5812/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-2fa97bee").then(t)}},{path:"/pages/4c5812/index.html",redirect:"/pages/4c5812/"},{path:"/08.开源项目/01.Rpamis/02.Exception/03.异常工具类-ExceptionFactory.html",redirect:"/pages/4c5812/"},{name:"v-7f6fd396",path:"/pages/cb1099/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-7f6fd396").then(t)}},{path:"/pages/cb1099/index.html",redirect:"/pages/cb1099/"},{path:"/08.开源项目/01.Rpamis/02.Exception/04.异常工具类-Assert.html",redirect:"/pages/cb1099/"},{name:"v-2e449d2e",path:"/pages/2c6c1b/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-2e449d2e").then(t)}},{path:"/pages/2c6c1b/index.html",redirect:"/pages/2c6c1b/"},{path:"/09.索引/01.开源项目/01.概览.html",redirect:"/pages/2c6c1b/"},{name:"v-030ee6e9",path:"/about/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-030ee6e9").then(t)}},{path:"/about/index.html",redirect:"/about/"},{path:"/10.关于/01.关于.html",redirect:"/about/"},{name:"v-da4b7ec6",path:"/pages/ad6515/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-da4b7ec6").then(t)}},{path:"/pages/ad6515/index.html",redirect:"/pages/ad6515/"},{path:"/11.目录/02.Python/01.Python基础.html",redirect:"/pages/ad6515/"},{name:"v-28bacbcf",path:"/pages/059f1f/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-28bacbcf").then(t)}},{path:"/pages/059f1f/index.html",redirect:"/pages/059f1f/"},{path:"/11.目录/01.Java/01.Java.html",redirect:"/pages/059f1f/"},{name:"v-efc06c1e",path:"/pages/82c271/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-efc06c1e").then(t)}},{path:"/pages/82c271/index.html",redirect:"/pages/82c271/"},{path:"/11.目录/02.Python/02.Python机器学习.html",redirect:"/pages/82c271/"},{name:"v-acde98ae",path:"/pages/f91e0d/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-acde98ae").then(t)}},{path:"/pages/f91e0d/index.html",redirect:"/pages/f91e0d/"},{path:"/11.目录/06.算法/01.剑指Offer.html",redirect:"/pages/f91e0d/"},{name:"v-088dc5dd",path:"/pages/b59559/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-088dc5dd").then(t)}},{path:"/pages/b59559/index.html",redirect:"/pages/b59559/"},{path:"/11.目录/06.算法/02.LeetCode.html",redirect:"/pages/b59559/"},{name:"v-d6d9f736",path:"/archives/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-d6d9f736").then(t)}},{path:"/archives/index.html",redirect:"/archives/"},{path:"/@pages/archivesPage.html",redirect:"/archives/"},{name:"v-4bef49e5",path:"/tags/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-4bef49e5").then(t)}},{path:"/tags/index.html",redirect:"/tags/"},{path:"/@pages/tagsPage.html",redirect:"/tags/"},{name:"v-011f227e",path:"/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-011f227e").then(t)}},{path:"/index.html",redirect:"/"},{name:"v-a82b2222",path:"/pages/7b5838/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-a82b2222").then(t)}},{path:"/pages/7b5838/index.html",redirect:"/pages/7b5838/"},{path:"/06.算法/01.剑指Offer/22.LeetCode-面试题25-合并两个排序的链表.html",redirect:"/pages/7b5838/"},{name:"v-49b2d391",path:"/pages/022144/",component:vl,beforeEnter:(n,e,t)=>{cs("Layout","v-49b2d391").then(t)}},{path:"/pages/022144/index.html",redirect:"/pages/022144/"},{path:"/06.算法/01.剑指Offer/23.LeetCode-面试题26-树的子结构.html",redirect:"/pages/022144/"},{path:"*",component:vl}],kl={title:"benym的知识笔记",description:"benym的知识管理&博客",base:"/",headTags:[["link",{rel:"icon",href:"/img/favicon-two.ico"}],["meta",{name:"keywords",content:"Java,benym,blog,knowledge"}],["meta",{name:"theme-color",content:"#ff954b"}],["link",{rel:"stylesheet",href:"https://at.alicdn.com/t/font_3077305_pt8umhrn4k9.css"}],["meta",{name:"referrer",content:"no-referrer-when-downgrade"}]],pages:[{title:"概览",frontmatter:{title:"概览",article:!1,tags:[null],date:"2022-04-17T18:56:31.000Z",permalink:"/pages/7848bb/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/00.%E5%AF%BC%E8%88%AA/01.%E6%A6%82%E8%A7%88.html",relativePath:"00.导航/01.概览.md",key:"v-177c102a",path:"/pages/7848bb/",headersStr:null,content:"提示\n\n正在路上...",normalizedContent:"提示\n\n正在路上...",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"动态代理",frontmatter:{title:"动态代理",date:"2021-10-19T14:46:15.000Z",description:"总结",categories:["Java"],tags:["动态代理","Java"],keywords:"Java,动态代理,JDK,Cglib",permalink:"/pages/ddcc22/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/01.Java/01.Java/01.Java-%E5%9F%BA%E7%A1%80/02.%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.html",relativePath:"01.Java/01.Java/01.Java-基础/02.动态代理使用方法.md",key:"v-2d7fd9fc",path:"/pages/ddcc22/",headers:[{level:2,title:"动态代理使用方法",slug:"动态代理使用方法",normalizedTitle:"动态代理使用方法",charIndex:2},{level:3,title:"代理模式",slug:"代理模式",normalizedTitle:"代理模式",charIndex:34},{level:3,title:"1.静态代理",slug:"_1-静态代理",normalizedTitle:"1.静态代理",charIndex:364},{level:4,title:"场景",slug:"场景",normalizedTitle:"场景",charIndex:374},{level:4,title:"实现方法",slug:"实现方法",normalizedTitle:"实现方法",charIndex:20},{level:4,title:"测试效果",slug:"测试效果",normalizedTitle:"测试效果",charIndex:1728},{level:4,title:"静态代理缺陷",slug:"静态代理缺陷",normalizedTitle:"静态代理缺陷",charIndex:2111},{level:4,title:"解决方法",slug:"解决方法",normalizedTitle:"解决方法",charIndex:2171},{level:3,title:"2.动态代理-JDK",slug:"_2-动态代理-jdk",normalizedTitle:"2.动态代理-jdk",charIndex:2539},{level:4,title:"动态代理步骤",slug:"动态代理步骤",normalizedTitle:"动态代理步骤",charIndex:2553},{level:4,title:"第一种方法",slug:"第一种方法",normalizedTitle:"第一种方法",charIndex:3851},{level:4,title:"第二种方法",slug:"第二种方法",normalizedTitle:"第二种方法",charIndex:4919},{level:3,title:"3.动态代理-Cglib",slug:"_3-动态代理-cglib",normalizedTitle:"3.动态代理-cglib",charIndex:6023},{level:4,title:"Cglib代理步骤",slug:"cglib代理步骤",normalizedTitle:"cglib代理步骤",charIndex:6140},{level:4,title:"测试效果",slug:"测试效果-2",normalizedTitle:"测试效果",charIndex:1728},{level:5,title:"非final方法",slug:"非final方法",normalizedTitle:"非final方法",charIndex:9020},{level:5,title:"final方法",slug:"final方法",normalizedTitle:"final方法",charIndex:6820},{level:4,title:"为什么需要无参构造函数",slug:"为什么需要无参构造函数",normalizedTitle:"为什么需要无参构造函数",charIndex:9187},{level:5,title:"测试结果",slug:"测试结果",normalizedTitle:"测试结果",charIndex:9460},{level:4,title:"如何支持有参构造函数创建对象",slug:"如何支持有参构造函数创建对象",normalizedTitle:"如何支持有参构造函数创建对象",charIndex:10477},{level:5,title:"测试结果",slug:"测试结果-2",normalizedTitle:"测试结果",charIndex:9460},{level:3,title:"4.总结",slug:"_4-总结",normalizedTitle:"4.总结",charIndex:13255},{level:2,title:"参考资料：",slug:"参考资料",normalizedTitle:"参考资料：",charIndex:13547}],headersStr:"动态代理使用方法 代理模式 1.静态代理 场景 实现方法 测试效果 静态代理缺陷 解决方法 2.动态代理-JDK 动态代理步骤 第一种方法 第二种方法 3.动态代理-Cglib Cglib代理步骤 测试效果 非final方法 final方法 为什么需要无参构造函数 测试结果 如何支持有参构造函数创建对象 测试结果 4.总结 参考资料：",content:'# 动态代理使用方法\n\nJava动态代理实现方法概述与实验\n\n\n# 代理模式\n\n代理模式是指：为其他对象提供一种代理以控制对某个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，此时可以引入代理对象作为该情况下客户端和目标对象之间的中介。\n\n作用：通过代理对象访问目标对象，可以在不修改目标对象的前提下，提供额外的功能操作，扩展目标对象的功能\n\n在Spring生态中，AOP正是用到了代理模式，作为切面去增强业务方法。\n\n代理目前可以分为静态代理和动态代理2类，而动态代理则分为JDK代理和Cglib代理。\n\n * 静态代理：编译时实现，编译完成后的代理类是一个实际的class文件\n * 动态代理：在运行时动态生成，编译完成后没有实际的class文件，而是在运行时动态生成类字节码，并加载到JVM中\n\n\n# 1.静态代理\n\n# 场景\n\n假设现在我们需要创建一个用户，在创建用户的前后需要记录相关日志，但用户的创建逻辑在其他系统，我们无法直接访问代码修改业务逻辑，此时我们就需要一个代理对象在创建用户业务的前后做日志增强操作，达到扩展的目的。\n\n# 实现方法\n\n * 创建一个User接口定义createUser方法\n * 创建一个实现了User接口的RealUser实体类，作为代理对象\n * 创建一个StaticProxyHandler代理类，同样也实现User接口，并在代理类中持有代理对象的引用，在后续通过代理方法调用此引用对象的方法，以达到代理的目的\n\npublic interface User {\n  \n    String createUser(String userName, String passWord);\n}\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\npublic class RealUser implements User {\n\n    @Override\n    public String createUser(String userName, String passWord) {\n        System.out.println("用户名：" + userName + "，密码：" + passWord);\n        return userName + ":" + passWord;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\npublic class StaticProxyHandler implements User {\n\n    private RealUser realUser;\n\n    public StaticProxyHandler(RealUser realUser) {\n        this.realUser = realUser;\n    }\n\n    @Override\n    public String createUser(String userName, String passWord) {\n        // 调用目标方法前的处理\n        System.out.println("开始创建用户了...");\n        // 调用目标对象的方法\n        String user = realUser.createUser(userName, passWord);\n        // 调用目标方法后的处理\n        System.out.println("用户创建完了...");\n        return user;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n其中的User类定义了代理类和代理对象之间的共用接口，而RealUser作为代理对象实现了真正执行的业务逻辑(在这里为创建用户)，StaticProxyHandler代理RealUser在创建用户逻辑前后做方法增强\n\n# 测试效果\n\npublic class Main {\n\n    public static void main(String[] args) {\n        // 新建目标对象\n        RealUser target = new RealUser();\n        // 创建代理对象，并使用接口对其引用\n        User user = new StaticProxyHandler(target);\n        // 调用接口方法\n        user.createUser("张三", "123");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n开始创建用户了...\n用户名：张三，密码：123\n用户创建完了...\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n# 静态代理缺陷\n\n对于每个目标类都需要编写对应的代理类，如果需要代理的目标很多，那么就会写大量的代理代码，过程繁琐\n\n# 解决方法\n\n仔细思考一下上述过程，代理类中我们会创建代理对象的引用，且需要去实现和他相同的接口，我们想要减少代理类的最直接的方法是通过不断的在类中增加代理对象，实现代理方法，但是这样的代码是不具备通用性的，当遇到了需要代理的目标就需要不断的实现和引用。\n\n * 能不能动态的创建代理类，减少代理类的书写呢？\n   * Answer: 动态代理类\n\n在JDK中Proxy.getProxyClass可以获得动态代理类\n\n * 能不能使这个代理类无需显示定义代理对象的引用，还能知道这个代理对象的方法，做到通用性呢？\n   * Answer: 动态代理对象\n\n可以想到的是利用反射机制，动态的去生成代理的Class对象，Class对象中包含了构造器、方法、字段等，能拿到Class对象我们就能够进行对象实例化，创建一个动态的实例了\n\n\n# 2.动态代理-JDK\n\n# 动态代理步骤\n\n 1. 实现InvocationHandler接口自定义自己的InvocationHandler\n 2. 通过Proxy.getProxyClass获得动态代理类\n 3. 通过反射机制获取代理类的构造方法，方法签名为getConstructor(InvocationHandler.class)\n 4. 通过构造函数获取代理对象，并将自定义的InvocationHandler实例对象作为参数传入\n 5. 通过代理对象调用目标方法\n\n还是以上文的对象为例\n\npublic interface User {\n  \n    String createUser(String userName, String passWord);\n}\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\npublic class RealUser implements User {\n\n    @Override\n    public String createUser(String userName, String passWord) {\n        System.out.println("用户名：" + userName + "，密码：" + passWord);\n        return userName + ":" + passWord;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\n\npublic class DynamicProxyHandler implements InvocationHandler {\n\n    // 目标方法\n    private Object target;\n\n    public DynamicProxyHandler(Object target) {\n        this.target = target;\n    }\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        System.out.println("开始创建用户了...");\n        // 调用目标对象的方法\n        Object result = method.invoke(target, args);\n        System.out.println("用户创建完了...");\n        return result;\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n# 第一种方法\n\n严格按照上述2-5步骤实现动态代理\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Proxy;\n\npublic class ProxyTest {\n\n    public static void main(String[] args) throws Exception {\n        // 生成$Proxy0的class文件\n        System.getProperties().put("sun.misc.ProxyGenerator.saveGeneratedFiles", "true");\n        // 获取动态代理对象\n        Class<?> proxyClass = Proxy.getProxyClass(\n                        RealUser.class.getClassLoader(), // 代理对象类加载器\n                        RealUser.class.getInterfaces()); // 代理对象和目标对象实现相同的接口\n        // 获取代理类的构造函数，并传入InvocationHandler.class\n        Constructor<?> constructor = proxyClass.getConstructor(InvocationHandler.class);\n        // 通过构造函数来创建动态代理对象，将自定义的InvocationHandler实例传入\n        User user = (User) constructor\n                .newInstance(new DynamicProxyHandler(new RealUser()));\n        // 通过代理对象调用目标方法\n        user.createUser("张三", "123456");\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n# 第二种方法\n\n上述2-5步骤可以简化为Proxy类提供的方法\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Proxy;\n\npublic class ProxyTest {\n\n    public static void main(String[] args) throws Exception {\n        /**\n         * 第二种方法，使用Proxy类已封装好的方法\n         */\n        User user2 = (User) Proxy.newProxyInstance(\n                        RealUser.class.getClassLoader(),\n                        RealUser.class.getInterfaces(),\n                        new DynamicProxyHandler(new RealUser())); // 创建一个与代理对象关联的InvocationHandler\n        user2.createUser("李四", "45678");\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nProxy.newProxyInstance()方法接受三个参数：\n\n * ClassLoader loader: 指定当前目标对象使用的类加载器,获取加载器的方法是固定的\n * Class<?>[] interfaces: 指定目标对象实现的接口的类型,使用泛型方式确认类型\n * InvocationHandler: 指定动态处理器，执行目标对象的方法时,会触发事件处理器的方法\n\nJDK代理和静态代理的不同之处：\n\n * 静态代理需要编码创建代理类\n * JDK代理时，代理类不再需要直接实现代理对象的接口，而是采用了动态代理的方式在运行时进行代理类的创建。其核心在于实现了InvocationHandler，通过invoke来调用代理对象的方法\n\n值得注意的是，JDK代理和静态代理都要求代理对象(本文中的RealUser)去实现接口，局限性很强，如果代理对象没有实现接口应该怎么去做呢？\n\n\n# 3.动态代理-Cglib\n\nCglib包底层采用了字节码处理框架ASM，通过字节码技术为一个类创建子类，并在子类中拦截所有父类方法的调用，由于Cglib在生成的代理类中会去继承代理对象，所以其不能对final修饰的类进行代理。\n\n# Cglib代理步骤\n\n 1. 实现一个MethodInterceptor，与JDK动态代理InvocationHandler接口类型，invoke变为了intercept\n 2. 通过Cglib的Enhancer类实现动态代理获取代理对象\n\n为了和JDK代理区分开，这里我们构造一个没有实现接口的方法\n\npublic class CglibUser {\n\n    private String name;\n\n    public CglibUser() {\n        System.out.println("无参构造函数创建代理对象");\n    }\n\n    public CglibUser(String name) {\n        System.out.println("有参构造函数创建代理对象" + name);\n    }\n\n    public String createUser(String userName, String passWord) {\n        System.out.println("用户名：" + userName + "，密码：" + passWord);\n        return userName + ":" + passWord;\n    }\n\n    /**\n     * 该方法不能被子类覆盖，Cglib无法代理final修饰的方法，而是直接调用\n     */\n    public final void finalTest() {\n        System.out.println("final方法不能被代理");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n实现MethodInterceptor接口，在接口内实现方法增强\n\nimport java.lang.reflect.Method;\nimport net.sf.cglib.proxy.MethodInterceptor;\nimport net.sf.cglib.proxy.MethodProxy;\n\npublic class CglibProxyInterceptor implements MethodInterceptor {\n\n    /**\n     * @param o cglib生成的代理对象\n     * @param method 被代理对象方法\n     * @param objects 方法入参\n     * @param methodProxy 代理方法\n     */\n    @Override\n    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy)\n            throws Throwable {\n        System.out.println("开始创建用户了...");\n        // 调用目标对象的方法\n        // 1. 这里不能使用methodProxy.invoke()，会栈溢出，此时等于循环调用methodProxy自身\n        // 2. 使用method.invoke()的时候不能使用参数中的o作为执行对象，否则也会发生\n        // 类似的栈溢出错误，必须自行另外创建一个新的对象\n        Object result = methodProxy.invokeSuper(o, objects);\n        System.out.println("用户创建完了...");\n        return result;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n> 在自定义Interceptor中，采用methodProxy.invoke()方法会发生栈溢出，而采用methodProxy.invokeSuper才能得到正确的结果。出现这种问题的原因可见这篇博文https://juejin.cn/post/6844904054833807374\n\n在测试类中使用Enhancer对象实现动态代理\n\nimport net.sf.cglib.core.DebuggingClassWriter;\nimport net.sf.cglib.proxy.Enhancer;\n\npublic class CglibMain {\n\n    public static void main(String[] args) {\n        // 代理类class文件存入本地磁盘方便我们反编译查看源码\n        System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, "/Users/ben");\n        // 创建增强器\n        Enhancer enhancer = new Enhancer();\n        // 设置enhancer对象需要代理的类，等价于JDK中newProxyInstance的第二个参数\n        enhancer.setSuperclass(CglibUser.class);\n        // 设置enhancer的回调对象，等价于JDK中newProxyInstance的第三个参数\n        enhancer.setCallback(new CglibProxyInterceptor());\n        // 创建代理对象\n        CglibUser proxy = (CglibUser) enhancer.create();\n        // 通过代理对象调用目标方法\n        proxy.createUser("王五","123");\n        // 测试final方法\n        proxy.finalTest();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n# 测试效果\n\n# 非final方法\n\n前后可以增强，可以发现，在创建代理对象时，Cglib将调用代理对象的无参构造函数\n\n无参构造函数创建代理对象\n开始创建用户了...\n用户名：王五，密码：123\n用户创建完了...\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n# final方法\n\n直接调用不能做增强\n\nfinal方法不能被代理\n\n\n1\n\n1\n\n\n# 为什么需要无参构造函数\n\nCglib需要代理对象实现无参构造函数，否则会出现错误\n\npublic class CglibUser {\n\n    private String name;\n\n    // 仅有参构造函数\n    public CglibUser(String name) {\n        System.out.println("有参构造函数创建代理对象" + name);\n    }\n\n    /**省略**/\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# 测试结果\n\nException in thread "main" java.lang.IllegalArgumentException: Superclass has no null constructors but no arguments were given\n\tat net.sf.cglib.proxy.Enhancer.emitConstructors(Enhancer.java:931)\n\tat net.sf.cglib.proxy.Enhancer.generateClass(Enhancer.java:631)\n\tat net.sf.cglib.core.DefaultGeneratorStrategy.generate(DefaultGeneratorStrategy.java:25)\n\t....省略\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\nenhancer.create()\n\n出现这种问题的原因可以通过enhancer.create()源码了解到，create默认argumentTypes为null，如果需要无参创建代理对象自然需要代理对象具有无参构造方法\n\n    /**\n     * Generate a new class if necessary and uses the specified\n     * callbacks (if any) to create a new object instance.\n     * Uses the no-arg constructor of the superclass.\n     * @return a new instance\n     */\n    public Object create() {\n        // 用于判断是否需要创建对象，false表示需要创建对象\n        classOnly = false;\n        // 因为使用的是无参构造，所以该属性为null\n        argumentTypes = null;\n        // 创建动态代理class的方法\n        return createHelper();\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# 如何支持有参构造函数创建对象\n\n很多时候代理的对象内部持有有参的构造函数，纯无参的代理方式显然不满足这样的场景，在Cglib中create具有重载方法来支持这种代理场景\n\n    /**\n     * Generate a new class if necessary and uses the specified\n     * callbacks (if any) to create a new object instance.\n     * Uses the constructor of the superclass matching the <code>argumentTypes</code>\n     * parameter, with the given arguments.\n     * @param argumentTypes constructor signature\n     * @param arguments compatible wrapped arguments to pass to constructor\n     * @return a new instance\n     */\n\n    // 接收两个参数\n    // 1. 参数类型数组\n    // 2. 具体的参数数组\n    public Object create(Class[] argumentTypes, Object[] arguments) {\n        classOnly = false;\n        if (argumentTypes == null || arguments == null || argumentTypes.length != arguments.length) {\n            throw new IllegalArgumentException("Arguments must be non-null and of equal length");\n        }\n        this.argumentTypes = argumentTypes;\n        this.arguments = arguments;\n        return createHelper();\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n接着上面的例子，此时我们需要一个代理类从一个有参构造函数生成，稍微改造一下代理对象\n\npublic class CglibUser {\n\n    private String name;\n\n    private Integer passWord;\n\n    public CglibUser() {\n        System.out.println("无参构造函数创建代理对象");\n    }\n\n    public CglibUser(String name,Integer passWord) {\n        this.name = name;\n        this.passWord = passWord;\n        System.out.println("有参构造函数创建代理对象" + name);\n    }\n\n    public String createUser() {\n        System.out.println("用户名：" + this.name + "，密码：" + this.passWord);\n        return this.name + ":" + this.passWord;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n此时构造函数内有两个参数，对应的测试类需要重载create方法，第一个参数是CglibUser构造函数的参数列表的Class数组，第二个参数是对应的值\n\nimport net.sf.cglib.core.DebuggingClassWriter;\nimport net.sf.cglib.proxy.Enhancer;\n\npublic class CglibMain {\n\n    public static void main(String[] args) {\n        // 代理类class文件存入本地磁盘方便我们反编译查看源码\n        System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, "/Users/ben");\n        // 通过CGLIB动态代理获取代理对象的过程\n        Enhancer enhancer = new Enhancer();\n        // 设置enhancer对象的父类\n        enhancer.setSuperclass(CglibUser.class);\n        // 设置enhancer的回调对象\n        enhancer.setCallback(new CglibProxyInterceptor());\n        // 创建代理对象，重载create方法填写\n        CglibUser proxy = (CglibUser) enhancer\n                .create(new Class[]{String.class, Integer.class}, new Object[]{"李四", 12345});\n        // 通过代理对象调用目标方法\n        proxy.createUser();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n# 测试结果\n\n有参构造函数创建代理对象李四\n开始创建用户了...\n用户名：李四，密码：12345\n用户创建完了...\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n\n# 4.总结\n\n 1. Cglib动态代理基于继承，可以不需要代理没有实现接口的类，也可以代理实现了接口的类，但Cglib无法对final方法进行代理，核心方法MethodInterceptor\n\n 2. JDK代理只能基于接口，代理类必须是一个实现了某个接口的类，核心方法InvocationHandler\n\n 3. Spring中JDK代理和Cglib代理同时存在\n    \n    * 当Bean实现接口时，Spring就会用JDK的动态代理。\n    \n    * 当Bean没有实现接口时，Spring使用CGlib实现。\n    \n    * 可以强制使用CGlib\n\n\n# 参考资料：\n\n>  1. https://www.zhihu.com/question/20794107\n>  2. https://qiankunli.github.io/2020/04/09/java_dynamic_proxy.html\n>  3. https://www.cnblogs.com/gonjan-blog/p/6685611.html\n>  4. https://developer.aliyun.com/article/71337\n>  5. https://mp.weixin.qq.com/s/dBoihzxGiDpOP8ObSHrE_w\n>  6. https://www.cnblogs.com/daniels/p/8242592.html\n>  7. https://baike.baidu.com/item/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/8374046?fr=aladdin\n>  8. https://stackoverflow.com/questions/15223297/superclass-has-no-null-constructors-but-no-arguments-were-given\n>  9. https://juejin.cn/post/6844904054833807374',normalizedContent:'# 动态代理使用方法\n\njava动态代理实现方法概述与实验\n\n\n# 代理模式\n\n代理模式是指：为其他对象提供一种代理以控制对某个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，此时可以引入代理对象作为该情况下客户端和目标对象之间的中介。\n\n作用：通过代理对象访问目标对象，可以在不修改目标对象的前提下，提供额外的功能操作，扩展目标对象的功能\n\n在spring生态中，aop正是用到了代理模式，作为切面去增强业务方法。\n\n代理目前可以分为静态代理和动态代理2类，而动态代理则分为jdk代理和cglib代理。\n\n * 静态代理：编译时实现，编译完成后的代理类是一个实际的class文件\n * 动态代理：在运行时动态生成，编译完成后没有实际的class文件，而是在运行时动态生成类字节码，并加载到jvm中\n\n\n# 1.静态代理\n\n# 场景\n\n假设现在我们需要创建一个用户，在创建用户的前后需要记录相关日志，但用户的创建逻辑在其他系统，我们无法直接访问代码修改业务逻辑，此时我们就需要一个代理对象在创建用户业务的前后做日志增强操作，达到扩展的目的。\n\n# 实现方法\n\n * 创建一个user接口定义createuser方法\n * 创建一个实现了user接口的realuser实体类，作为代理对象\n * 创建一个staticproxyhandler代理类，同样也实现user接口，并在代理类中持有代理对象的引用，在后续通过代理方法调用此引用对象的方法，以达到代理的目的\n\npublic interface user {\n  \n    string createuser(string username, string password);\n}\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\npublic class realuser implements user {\n\n    @override\n    public string createuser(string username, string password) {\n        system.out.println("用户名：" + username + "，密码：" + password);\n        return username + ":" + password;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\npublic class staticproxyhandler implements user {\n\n    private realuser realuser;\n\n    public staticproxyhandler(realuser realuser) {\n        this.realuser = realuser;\n    }\n\n    @override\n    public string createuser(string username, string password) {\n        // 调用目标方法前的处理\n        system.out.println("开始创建用户了...");\n        // 调用目标对象的方法\n        string user = realuser.createuser(username, password);\n        // 调用目标方法后的处理\n        system.out.println("用户创建完了...");\n        return user;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n其中的user类定义了代理类和代理对象之间的共用接口，而realuser作为代理对象实现了真正执行的业务逻辑(在这里为创建用户)，staticproxyhandler代理realuser在创建用户逻辑前后做方法增强\n\n# 测试效果\n\npublic class main {\n\n    public static void main(string[] args) {\n        // 新建目标对象\n        realuser target = new realuser();\n        // 创建代理对象，并使用接口对其引用\n        user user = new staticproxyhandler(target);\n        // 调用接口方法\n        user.createuser("张三", "123");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n开始创建用户了...\n用户名：张三，密码：123\n用户创建完了...\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n# 静态代理缺陷\n\n对于每个目标类都需要编写对应的代理类，如果需要代理的目标很多，那么就会写大量的代理代码，过程繁琐\n\n# 解决方法\n\n仔细思考一下上述过程，代理类中我们会创建代理对象的引用，且需要去实现和他相同的接口，我们想要减少代理类的最直接的方法是通过不断的在类中增加代理对象，实现代理方法，但是这样的代码是不具备通用性的，当遇到了需要代理的目标就需要不断的实现和引用。\n\n * 能不能动态的创建代理类，减少代理类的书写呢？\n   * answer: 动态代理类\n\n在jdk中proxy.getproxyclass可以获得动态代理类\n\n * 能不能使这个代理类无需显示定义代理对象的引用，还能知道这个代理对象的方法，做到通用性呢？\n   * answer: 动态代理对象\n\n可以想到的是利用反射机制，动态的去生成代理的class对象，class对象中包含了构造器、方法、字段等，能拿到class对象我们就能够进行对象实例化，创建一个动态的实例了\n\n\n# 2.动态代理-jdk\n\n# 动态代理步骤\n\n 1. 实现invocationhandler接口自定义自己的invocationhandler\n 2. 通过proxy.getproxyclass获得动态代理类\n 3. 通过反射机制获取代理类的构造方法，方法签名为getconstructor(invocationhandler.class)\n 4. 通过构造函数获取代理对象，并将自定义的invocationhandler实例对象作为参数传入\n 5. 通过代理对象调用目标方法\n\n还是以上文的对象为例\n\npublic interface user {\n  \n    string createuser(string username, string password);\n}\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\npublic class realuser implements user {\n\n    @override\n    public string createuser(string username, string password) {\n        system.out.println("用户名：" + username + "，密码：" + password);\n        return username + ":" + password;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nimport java.lang.reflect.invocationhandler;\nimport java.lang.reflect.method;\n\npublic class dynamicproxyhandler implements invocationhandler {\n\n    // 目标方法\n    private object target;\n\n    public dynamicproxyhandler(object target) {\n        this.target = target;\n    }\n\n    @override\n    public object invoke(object proxy, method method, object[] args) throws throwable {\n        system.out.println("开始创建用户了...");\n        // 调用目标对象的方法\n        object result = method.invoke(target, args);\n        system.out.println("用户创建完了...");\n        return result;\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n# 第一种方法\n\n严格按照上述2-5步骤实现动态代理\n\nimport java.lang.reflect.constructor;\nimport java.lang.reflect.invocationhandler;\nimport java.lang.reflect.proxy;\n\npublic class proxytest {\n\n    public static void main(string[] args) throws exception {\n        // 生成$proxy0的class文件\n        system.getproperties().put("sun.misc.proxygenerator.savegeneratedfiles", "true");\n        // 获取动态代理对象\n        class<?> proxyclass = proxy.getproxyclass(\n                        realuser.class.getclassloader(), // 代理对象类加载器\n                        realuser.class.getinterfaces()); // 代理对象和目标对象实现相同的接口\n        // 获取代理类的构造函数，并传入invocationhandler.class\n        constructor<?> constructor = proxyclass.getconstructor(invocationhandler.class);\n        // 通过构造函数来创建动态代理对象，将自定义的invocationhandler实例传入\n        user user = (user) constructor\n                .newinstance(new dynamicproxyhandler(new realuser()));\n        // 通过代理对象调用目标方法\n        user.createuser("张三", "123456");\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n# 第二种方法\n\n上述2-5步骤可以简化为proxy类提供的方法\n\nimport java.lang.reflect.constructor;\nimport java.lang.reflect.invocationhandler;\nimport java.lang.reflect.proxy;\n\npublic class proxytest {\n\n    public static void main(string[] args) throws exception {\n        /**\n         * 第二种方法，使用proxy类已封装好的方法\n         */\n        user user2 = (user) proxy.newproxyinstance(\n                        realuser.class.getclassloader(),\n                        realuser.class.getinterfaces(),\n                        new dynamicproxyhandler(new realuser())); // 创建一个与代理对象关联的invocationhandler\n        user2.createuser("李四", "45678");\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nproxy.newproxyinstance()方法接受三个参数：\n\n * classloader loader: 指定当前目标对象使用的类加载器,获取加载器的方法是固定的\n * class<?>[] interfaces: 指定目标对象实现的接口的类型,使用泛型方式确认类型\n * invocationhandler: 指定动态处理器，执行目标对象的方法时,会触发事件处理器的方法\n\njdk代理和静态代理的不同之处：\n\n * 静态代理需要编码创建代理类\n * jdk代理时，代理类不再需要直接实现代理对象的接口，而是采用了动态代理的方式在运行时进行代理类的创建。其核心在于实现了invocationhandler，通过invoke来调用代理对象的方法\n\n值得注意的是，jdk代理和静态代理都要求代理对象(本文中的realuser)去实现接口，局限性很强，如果代理对象没有实现接口应该怎么去做呢？\n\n\n# 3.动态代理-cglib\n\ncglib包底层采用了字节码处理框架asm，通过字节码技术为一个类创建子类，并在子类中拦截所有父类方法的调用，由于cglib在生成的代理类中会去继承代理对象，所以其不能对final修饰的类进行代理。\n\n# cglib代理步骤\n\n 1. 实现一个methodinterceptor，与jdk动态代理invocationhandler接口类型，invoke变为了intercept\n 2. 通过cglib的enhancer类实现动态代理获取代理对象\n\n为了和jdk代理区分开，这里我们构造一个没有实现接口的方法\n\npublic class cglibuser {\n\n    private string name;\n\n    public cglibuser() {\n        system.out.println("无参构造函数创建代理对象");\n    }\n\n    public cglibuser(string name) {\n        system.out.println("有参构造函数创建代理对象" + name);\n    }\n\n    public string createuser(string username, string password) {\n        system.out.println("用户名：" + username + "，密码：" + password);\n        return username + ":" + password;\n    }\n\n    /**\n     * 该方法不能被子类覆盖，cglib无法代理final修饰的方法，而是直接调用\n     */\n    public final void finaltest() {\n        system.out.println("final方法不能被代理");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n实现methodinterceptor接口，在接口内实现方法增强\n\nimport java.lang.reflect.method;\nimport net.sf.cglib.proxy.methodinterceptor;\nimport net.sf.cglib.proxy.methodproxy;\n\npublic class cglibproxyinterceptor implements methodinterceptor {\n\n    /**\n     * @param o cglib生成的代理对象\n     * @param method 被代理对象方法\n     * @param objects 方法入参\n     * @param methodproxy 代理方法\n     */\n    @override\n    public object intercept(object o, method method, object[] objects, methodproxy methodproxy)\n            throws throwable {\n        system.out.println("开始创建用户了...");\n        // 调用目标对象的方法\n        // 1. 这里不能使用methodproxy.invoke()，会栈溢出，此时等于循环调用methodproxy自身\n        // 2. 使用method.invoke()的时候不能使用参数中的o作为执行对象，否则也会发生\n        // 类似的栈溢出错误，必须自行另外创建一个新的对象\n        object result = methodproxy.invokesuper(o, objects);\n        system.out.println("用户创建完了...");\n        return result;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n> 在自定义interceptor中，采用methodproxy.invoke()方法会发生栈溢出，而采用methodproxy.invokesuper才能得到正确的结果。出现这种问题的原因可见这篇博文https://juejin.cn/post/6844904054833807374\n\n在测试类中使用enhancer对象实现动态代理\n\nimport net.sf.cglib.core.debuggingclasswriter;\nimport net.sf.cglib.proxy.enhancer;\n\npublic class cglibmain {\n\n    public static void main(string[] args) {\n        // 代理类class文件存入本地磁盘方便我们反编译查看源码\n        system.setproperty(debuggingclasswriter.debug_location_property, "/users/ben");\n        // 创建增强器\n        enhancer enhancer = new enhancer();\n        // 设置enhancer对象需要代理的类，等价于jdk中newproxyinstance的第二个参数\n        enhancer.setsuperclass(cglibuser.class);\n        // 设置enhancer的回调对象，等价于jdk中newproxyinstance的第三个参数\n        enhancer.setcallback(new cglibproxyinterceptor());\n        // 创建代理对象\n        cglibuser proxy = (cglibuser) enhancer.create();\n        // 通过代理对象调用目标方法\n        proxy.createuser("王五","123");\n        // 测试final方法\n        proxy.finaltest();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n# 测试效果\n\n# 非final方法\n\n前后可以增强，可以发现，在创建代理对象时，cglib将调用代理对象的无参构造函数\n\n无参构造函数创建代理对象\n开始创建用户了...\n用户名：王五，密码：123\n用户创建完了...\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n# final方法\n\n直接调用不能做增强\n\nfinal方法不能被代理\n\n\n1\n\n1\n\n\n# 为什么需要无参构造函数\n\ncglib需要代理对象实现无参构造函数，否则会出现错误\n\npublic class cglibuser {\n\n    private string name;\n\n    // 仅有参构造函数\n    public cglibuser(string name) {\n        system.out.println("有参构造函数创建代理对象" + name);\n    }\n\n    /**省略**/\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# 测试结果\n\nexception in thread "main" java.lang.illegalargumentexception: superclass has no null constructors but no arguments were given\n\tat net.sf.cglib.proxy.enhancer.emitconstructors(enhancer.java:931)\n\tat net.sf.cglib.proxy.enhancer.generateclass(enhancer.java:631)\n\tat net.sf.cglib.core.defaultgeneratorstrategy.generate(defaultgeneratorstrategy.java:25)\n\t....省略\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\nenhancer.create()\n\n出现这种问题的原因可以通过enhancer.create()源码了解到，create默认argumenttypes为null，如果需要无参创建代理对象自然需要代理对象具有无参构造方法\n\n    /**\n     * generate a new class if necessary and uses the specified\n     * callbacks (if any) to create a new object instance.\n     * uses the no-arg constructor of the superclass.\n     * @return a new instance\n     */\n    public object create() {\n        // 用于判断是否需要创建对象，false表示需要创建对象\n        classonly = false;\n        // 因为使用的是无参构造，所以该属性为null\n        argumenttypes = null;\n        // 创建动态代理class的方法\n        return createhelper();\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# 如何支持有参构造函数创建对象\n\n很多时候代理的对象内部持有有参的构造函数，纯无参的代理方式显然不满足这样的场景，在cglib中create具有重载方法来支持这种代理场景\n\n    /**\n     * generate a new class if necessary and uses the specified\n     * callbacks (if any) to create a new object instance.\n     * uses the constructor of the superclass matching the <code>argumenttypes</code>\n     * parameter, with the given arguments.\n     * @param argumenttypes constructor signature\n     * @param arguments compatible wrapped arguments to pass to constructor\n     * @return a new instance\n     */\n\n    // 接收两个参数\n    // 1. 参数类型数组\n    // 2. 具体的参数数组\n    public object create(class[] argumenttypes, object[] arguments) {\n        classonly = false;\n        if (argumenttypes == null || arguments == null || argumenttypes.length != arguments.length) {\n            throw new illegalargumentexception("arguments must be non-null and of equal length");\n        }\n        this.argumenttypes = argumenttypes;\n        this.arguments = arguments;\n        return createhelper();\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n接着上面的例子，此时我们需要一个代理类从一个有参构造函数生成，稍微改造一下代理对象\n\npublic class cglibuser {\n\n    private string name;\n\n    private integer password;\n\n    public cglibuser() {\n        system.out.println("无参构造函数创建代理对象");\n    }\n\n    public cglibuser(string name,integer password) {\n        this.name = name;\n        this.password = password;\n        system.out.println("有参构造函数创建代理对象" + name);\n    }\n\n    public string createuser() {\n        system.out.println("用户名：" + this.name + "，密码：" + this.password);\n        return this.name + ":" + this.password;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n此时构造函数内有两个参数，对应的测试类需要重载create方法，第一个参数是cglibuser构造函数的参数列表的class数组，第二个参数是对应的值\n\nimport net.sf.cglib.core.debuggingclasswriter;\nimport net.sf.cglib.proxy.enhancer;\n\npublic class cglibmain {\n\n    public static void main(string[] args) {\n        // 代理类class文件存入本地磁盘方便我们反编译查看源码\n        system.setproperty(debuggingclasswriter.debug_location_property, "/users/ben");\n        // 通过cglib动态代理获取代理对象的过程\n        enhancer enhancer = new enhancer();\n        // 设置enhancer对象的父类\n        enhancer.setsuperclass(cglibuser.class);\n        // 设置enhancer的回调对象\n        enhancer.setcallback(new cglibproxyinterceptor());\n        // 创建代理对象，重载create方法填写\n        cglibuser proxy = (cglibuser) enhancer\n                .create(new class[]{string.class, integer.class}, new object[]{"李四", 12345});\n        // 通过代理对象调用目标方法\n        proxy.createuser();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n# 测试结果\n\n有参构造函数创建代理对象李四\n开始创建用户了...\n用户名：李四，密码：12345\n用户创建完了...\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n\n# 4.总结\n\n 1. cglib动态代理基于继承，可以不需要代理没有实现接口的类，也可以代理实现了接口的类，但cglib无法对final方法进行代理，核心方法methodinterceptor\n\n 2. jdk代理只能基于接口，代理类必须是一个实现了某个接口的类，核心方法invocationhandler\n\n 3. spring中jdk代理和cglib代理同时存在\n    \n    * 当bean实现接口时，spring就会用jdk的动态代理。\n    \n    * 当bean没有实现接口时，spring使用cglib实现。\n    \n    * 可以强制使用cglib\n\n\n# 参考资料：\n\n>  1. https://www.zhihu.com/question/20794107\n>  2. https://qiankunli.github.io/2020/04/09/java_dynamic_proxy.html\n>  3. https://www.cnblogs.com/gonjan-blog/p/6685611.html\n>  4. https://developer.aliyun.com/article/71337\n>  5. https://mp.weixin.qq.com/s/dboihzxgidpop8obshre_w\n>  6. https://www.cnblogs.com/daniels/p/8242592.html\n>  7. https://baike.baidu.com/item/%e4%bb%a3%e7%90%86%e6%a8%a1%e5%bc%8f/8374046?fr=aladdin\n>  8. https://stackoverflow.com/questions/15223297/superclass-has-no-null-constructors-but-no-arguments-were-given\n>  9. https://juejin.cn/post/6844904054833807374',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"Java反射获取类对象的三种方式",frontmatter:{title:"Java反射获取类对象的三种方式",date:"2020-06-29T19:36:09.000Z",description:"总结",categories:["Java"],tags:["反射","Java"],keywords:"反射,Java",permalink:"/pages/225727/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/01.Java/01.Java/01.Java-%E5%9F%BA%E7%A1%80/01.Java%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F.html",relativePath:"01.Java/01.Java/01.Java-基础/01.Java反射获取类对象的三种方式.md",key:"v-0c96d161",path:"/pages/225727/",headers:[{level:2,title:"Java反射获取类对象的三种方式",slug:"java反射获取类对象的三种方式",normalizedTitle:"java反射获取类对象的三种方式",charIndex:2}],headersStr:"Java反射获取类对象的三种方式",content:'# Java反射获取类对象的三种方式\n\n简单了解Java获取类的3种方式\n\n1、Class.forName("全类名")\n\n将字节吗文件加载进内存，返回Class对象，多用于配指文件，将类名定义在配置文件中，便于利用java的反射机制生成类对象，加载类。\n\n//加载一个用户实体类UserBean\nClass c1 = Class.forName(``"com.test.UserBean"``)；\n\n\n1\n2\n\n1\n2\n\n\n2、类名.class\n\n通过类名的属性class获取，多用于传递参数。\n\nClass c2 = UserBean.class;\n\n\n1\n\n1\n\n\n3、对象.getClass()\n\n多用于对象获取字节码的方式。\n\nUserBean user = new UserBean();\nClass c3 = user.getClass();\n\n\n1\n2\n\n1\n2\n\n\n对于三种方式获取到的类对象都指向堆内存中同一个地址，所以三种方式获取的类对象都是同一个，根据实际应用环境选择使用。',normalizedContent:'# java反射获取类对象的三种方式\n\n简单了解java获取类的3种方式\n\n1、class.forname("全类名")\n\n将字节吗文件加载进内存，返回class对象，多用于配指文件，将类名定义在配置文件中，便于利用java的反射机制生成类对象，加载类。\n\n//加载一个用户实体类userbean\nclass c1 = class.forname(``"com.test.userbean"``)；\n\n\n1\n2\n\n1\n2\n\n\n2、类名.class\n\n通过类名的属性class获取，多用于传递参数。\n\nclass c2 = userbean.class;\n\n\n1\n\n1\n\n\n3、对象.getclass()\n\n多用于对象获取字节码的方式。\n\nuserbean user = new userbean();\nclass c3 = user.getclass();\n\n\n1\n2\n\n1\n2\n\n\n对于三种方式获取到的类对象都指向堆内存中同一个地址，所以三种方式获取的类对象都是同一个，根据实际应用环境选择使用。',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"ArrayList的扩容机制",frontmatter:{title:"ArrayList的扩容机制",date:"2020-07-07T10:20:55.000Z",description:"总结",categories:["Java"],tags:["Java"],keywords:"Java",permalink:"/pages/9786e5/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/01.Java/01.Java/02.Java-%E9%9B%86%E5%90%88/01.ArrayList%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6.html",relativePath:"01.Java/01.Java/02.Java-集合/01.ArrayList的扩容机制.md",key:"v-6b386ebf",path:"/pages/9786e5/",headers:[{level:2,title:"ArrayList的扩容机制",slug:"arraylist的扩容机制",normalizedTitle:"arraylist的扩容机制",charIndex:2},{level:3,title:"ArrayList构造函数",slug:"arraylist构造函数",normalizedTitle:"arraylist构造函数",charIndex:82},{level:3,title:"1.Add方法",slug:"_1-add方法",normalizedTitle:"1.add方法",charIndex:3496},{level:3,title:"2.ensureCapacityInternal()方法",slug:"_2-ensurecapacityinternal-方法",normalizedTitle:"2.ensurecapacityinternal()方法",charIndex:4034},{level:3,title:"3.calculateCapacity()方法",slug:"_3-calculatecapacity-方法",normalizedTitle:"3.calculatecapacity()方法",charIndex:4351},{level:3,title:"4.ensureExplicitCapacity()方法",slug:"_4-ensureexplicitcapacity-方法",normalizedTitle:"4.ensureexplicitcapacity()方法",charIndex:4862},{level:3,title:"5.grow()方法",slug:"_5-grow-方法",normalizedTitle:"5.grow()方法",charIndex:5409},{level:3,title:"6.hugeCapacity()方法",slug:"_6-hugecapacity-方法",normalizedTitle:"6.hugecapacity()方法",charIndex:7365},{level:3,title:"其他方法(ensureCapacity方法)",slug:"其他方法-ensurecapacity方法",normalizedTitle:"其他方法(ensurecapacity方法)",charIndex:7898}],headersStr:"ArrayList的扩容机制 ArrayList构造函数 1.Add方法 2.ensureCapacityInternal()方法 3.calculateCapacity()方法 4.ensureExplicitCapacity()方法 5.grow()方法 6.hugeCapacity()方法 其他方法(ensureCapacity方法)",content:'# ArrayList的扩容机制\n\nArrayList是List接口的实现类，能够根据需要动态增长数组，本文通过分析源码，总结ArrayList的扩容机制\n\n\n# ArrayList构造函数\n\n在ArrayList中有3种方法进行初始化，构造方法源码如下\n\n    /**\n     * Default initial capacity. 默认初始容量大小\n     */\n    private static final int DEFAULT_CAPACITY = 10;\n\n    /**\n     * Shared empty array instance used for empty instances.\n     */\n    private static final Object[] EMPTY_ELEMENTDATA = {};\n\n    /**\n     * Shared empty array instance used for default sized empty instances. We\n     * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when\n     * first element is added.\n     */\n    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n\n    /**\n     * The array buffer into which the elements of the ArrayList are stored.\n     * The capacity of the ArrayList is the length of this array buffer. Any\n     * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA\n     * will be expanded to DEFAULT_CAPACITY when the first element is added.\n     */\n    transient Object[] elementData; // non-private to simplify nested class access\n\n    /**\n     * The size of the ArrayList (the number of elements it contains).\n     *\n     * @serial\n     */\n    private int size;\n\n\t/**\n\t * 带初始容量参数的构造方法，容量由用户指定\n\t */\n    public ArrayList(int initialCapacity) {\n        if (initialCapacity > 0) { // 初始容量大于0\n            // 创建initialCapacity大小的数组\n            this.elementData = new Object[initialCapacity];\n        } else if (initialCapacity == 0) { // 初始容量等于0\n            // 创建空数组\n            this.elementData = EMPTY_ELEMENTDATA;\n        } else { // 初始容量小于0，抛出异常\n            throw new IllegalArgumentException("Illegal Capacity: "+\n                                               initialCapacity);\n        }\n    }\n\n    /**\n     * Constructs an empty list with an initial capacity of ten.\n     * 默认构造函数，使用初始容量10构造一个空列表(无参数构造)\n     */\n    public ArrayList() {\n        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n    }\n\n    /**\n     * Constructs a list containing the elements of the specified\n     * collection, in the order they are returned by the collection\'s\n     * iterator.\n     * 构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回\n     * 如果指定的集合为null，抛出空指针异常\n     * @param c the collection whose elements are to be placed into this list\n     * @throws NullPointerException if the specified collection is null\n     */\n    public ArrayList(Collection<? extends E> c) {\n        elementData = c.toArray();\n        if ((size = elementData.length) != 0) {\n            // c.toArray might (incorrectly) not return Object[] (see 6260652)\n            if (elementData.getClass() != Object[].class)\n                elementData = Arrays.copyOf(elementData, size, Object[].class);\n        } else {\n            // replace with empty array.\n            this.elementData = EMPTY_ELEMENTDATA;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n\n\n在无参构造方法中，创建ArrayList实际上是初始化一个空数组。\n\nEMPTY_ELEMENTDATA常量数组为空实例共享一个空数组\n\nDEFAULTCAPACITY_EMPTY_ELEMENTDATA常量数组，与EMPTY_ELEMENTDATA不同，用于默认大小的空实例的共享空数组实例。将其与EMPTY_ELEMENTDATA区分开来，以便知道添加第一个元素时需要扩容多少。当真正对数组进行添加元素操作的时候，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为10\n\n\n# 1.Add方法\n\n    /**\n     * Appends the specified element to the end of this list.\n     * 将指定的元素追加到此列表的末尾\n     * @param e element to be appended to this list\n     * @return <tt>true</tt> (as specified by {@link Collection#add})\n     */\n    public boolean add(E e) {\n    // 添加元素之前，先调用ensureCapacityInternal方法\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        // 在ArrayList添加元素的实质，相当于为数组赋值\n        elementData[size++] = e;\n        return true;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 2.ensureCapacityInternal()方法\n\n在add方法中，调用了ensureCapacityInternal(size + 1)，ensureCapacityInternal源码如下\n\n    private void ensureCapacityInternal(int minCapacity) {\n        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\n    }\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n在源码中，又调用了calculateCapacity和ensureExplicitCapacity方法\n\n\n# 3.calculateCapacity()方法\n\ncalculateCapacity传入一个数组和最小扩容量，计算扩容量的值\n\n    private static int calculateCapacity(Object[] elementData, int minCapacity) {\n        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n            // 获取默认的容量和传入参数的较大值\n            return Math.max(DEFAULT_CAPACITY, minCapacity);\n        }\n        return minCapacity;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n当要add第一个元素时，数组的size为0，传入的参数为size+1，所以minCapacity为1，在Math.max方法比较后，minCapacity变为10，之后将minCapacity返回，执行ensureExplicitCapacity()方法\n\n\n# 4.ensureExplicitCapacity()方法\n\n当第1次add的时候，从上一个返回接回10，作为minCapacity的初始值，由于minCapacity-elementData.length > 0所以会进入到grow(minCapacity)方法\n\n此后，当添加2，3，......，10个元素时，由于数组容量足够大，都不会进行grow方法扩容\n\n而当添加第11个元素时，minCapacity - elementData.length > 0成立，再次进行扩容\n\n    //  判断是否需要扩容\n    private void ensureExplicitCapacity(int minCapacity) {\n        modCount++;\n\n        // overflow-conscious code\n        if (minCapacity - elementData.length > 0)\n            // 调用grow方法进行扩容，调用此方法代表已经开始扩容了\n            grow(minCapacity);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 5.grow()方法\n\n    // 要分配的最大数组大小\n    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n    \n    /**\n     * Increases the capacity to ensure that it can hold at least the\n     * number of elements specified by the minimum capacity argument.\n     * 增加容量，以确保它至少可以容纳最小容量参数指定的元素数量。\n     * ArrayList扩容的核心方法\n     * @param minCapacity the desired minimum capacity\n     */\n    private void grow(int minCapacity) {\n        // overflow-conscious code\n        // oldCapacity为旧容量，newCapacity为新容量\n        int oldCapacity = elementData.length;\n        // 将oldCapacity右移一位，其效果相当于oldCapacity/2\n        // 位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍\n        int newCapacity = oldCapacity + (oldCapacity >> 1);\n        // 然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量\n        if (newCapacity - minCapacity < 0)\n            newCapacity = minCapacity;\n        // 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE\n        // 如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`\n        if (newCapacity - MAX_ARRAY_SIZE > 0)\n            newCapacity = hugeCapacity(minCapacity);\n        // minCapacity is usually close to size, so this is a win:\n        elementData = Arrays.copyOf(elementData, newCapacity);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\nint newCapacity = oldCapacity + (oldCapacity >> 1)，所以ArrayList每次扩容之后容量都会变为原来的1.5倍左右(oldCapacity为偶数就是1.5倍，否则是1.5倍左右)，奇偶不同，比如：10+10/2 = 15，33+33/2 = 49。如果是奇数的话会丢掉小数。\n\n我们再来通过例子探究一下grow() 方法 ：\n\n * 当add第1个元素时，oldCapacity 为0，经比较后第一个if判断成立，newCapacity = minCapacity(为10)。但是第二个if判断不会成立，即newCapacity 不比 MAX_ARRAY_SIZE大，则不会进入 hugeCapacity 方法。数组容量为10，add方法中 return true,size增为1。\n * 当add第11个元素进入grow方法时，newCapacity为15，比minCapacity（为11）大，第一个if判断不成立。新容量没有大于数组最大size，不会进入hugeCapacity方法。数组容量扩为15，add方法中return true,size增为11。\n * 以此类推······\n\n\n# 6.hugeCapacity()方法\n\n从上面grow()方法源码中能够知道，如果新容量大于最大容量MAX_ARRAY_SIZE，进入(执行)hugeCapacity()方法来比较minCapacity和MAX_ARRAY_SIZE，如果minCapacity大于最大容量，则新容量则为Integer.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 Integer.MAX_VALUE - 8。\n\n    private static int hugeCapacity(int minCapacity) {\n        if (minCapacity < 0) // overflow\n            throw new OutOfMemoryError();\n        return (minCapacity > MAX_ARRAY_SIZE) ?\n            Integer.MAX_VALUE :\n            MAX_ARRAY_SIZE;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n通过以上6个方法，即可实现ArrayList的完整扩容流程\n\n\n# 其他方法(ensureCapacity方法)\n\nArrayList源码中，还有一个ensureCapacity方法，这个方法在ArrayList内部没有被调用过，所以显然是提供给用户调用的，那么这个方法有什么作用呢？\n\n    /**\n     * Increases the capacity of this <tt>ArrayList</tt> instance, if\n     * necessary, to ensure that it can hold at least the number of elements\n     * specified by the minimum capacity argument.\n     * 如有必要，增加此ArrayList实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数\n     * @param   minCapacity   the desired minimum capacity 所需的最小容量\n     */\n    public void ensureCapacity(int minCapacity) {\n        int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)\n            // any size if not default element table\n            ? 0\n            // larger than default for default empty table. It\'s already\n            // supposed to be at default size.\n            : DEFAULT_CAPACITY;\n\n        if (minCapacity > minExpand) {\n            ensureExplicitCapacity(minCapacity);\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n最好在add大量元素之前用ensureCapacity方法，以减少增量重新分配的次数\n\n代码示例\n\npublic class EnsureCapacityTest {\n\tpublic static void main(String[] args) {\n\t\tArrayList<Object> list = new ArrayList<Object>();\n\t\tfinal int N = 10000000;\n\t\tlong startTime = System.currentTimeMillis();\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tlist.add(i);\n\t\t}\n\t\tlong endTime = System.currentTimeMillis();\n\t\tSystem.out.println("使用ensureCapacity方法前："+(endTime - startTime));\n\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n运行结果：\n\n使用ensureCapacity方法前：2158\n\n\n1\n\n1\n\n\n使用ensureCapacity后\n\npublic class EnsureCapacityTest {\n    public static void main(String[] args) {\n        ArrayList<Object> list = new ArrayList<Object>();\n        final int N = 10000000;\n        list = new ArrayList<Object>();\n        long startTime1 = System.currentTimeMillis();\n        list.ensureCapacity(N);\n        for (int i = 0; i < N; i++) {\n            list.add(i);\n        }\n        long endTime1 = System.currentTimeMillis();\n        System.out.println("使用ensureCapacity方法后："+(endTime1 - startTime1));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n运行结果：\n\n使用ensureCapacity方法后：1773\n\n\n1\n\n1\n\n\n通过运行结果，我们可以看出向 ArrayList 添加大量元素之前最好先使用ensureCapacity 方法，以减少增量重新分配的次数。\n\n参考资料：\n\n> JavaGuide：https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/ArrayList-Grow.md',normalizedContent:'# arraylist的扩容机制\n\narraylist是list接口的实现类，能够根据需要动态增长数组，本文通过分析源码，总结arraylist的扩容机制\n\n\n# arraylist构造函数\n\n在arraylist中有3种方法进行初始化，构造方法源码如下\n\n    /**\n     * default initial capacity. 默认初始容量大小\n     */\n    private static final int default_capacity = 10;\n\n    /**\n     * shared empty array instance used for empty instances.\n     */\n    private static final object[] empty_elementdata = {};\n\n    /**\n     * shared empty array instance used for default sized empty instances. we\n     * distinguish this from empty_elementdata to know how much to inflate when\n     * first element is added.\n     */\n    private static final object[] defaultcapacity_empty_elementdata = {};\n\n    /**\n     * the array buffer into which the elements of the arraylist are stored.\n     * the capacity of the arraylist is the length of this array buffer. any\n     * empty arraylist with elementdata == defaultcapacity_empty_elementdata\n     * will be expanded to default_capacity when the first element is added.\n     */\n    transient object[] elementdata; // non-private to simplify nested class access\n\n    /**\n     * the size of the arraylist (the number of elements it contains).\n     *\n     * @serial\n     */\n    private int size;\n\n\t/**\n\t * 带初始容量参数的构造方法，容量由用户指定\n\t */\n    public arraylist(int initialcapacity) {\n        if (initialcapacity > 0) { // 初始容量大于0\n            // 创建initialcapacity大小的数组\n            this.elementdata = new object[initialcapacity];\n        } else if (initialcapacity == 0) { // 初始容量等于0\n            // 创建空数组\n            this.elementdata = empty_elementdata;\n        } else { // 初始容量小于0，抛出异常\n            throw new illegalargumentexception("illegal capacity: "+\n                                               initialcapacity);\n        }\n    }\n\n    /**\n     * constructs an empty list with an initial capacity of ten.\n     * 默认构造函数，使用初始容量10构造一个空列表(无参数构造)\n     */\n    public arraylist() {\n        this.elementdata = defaultcapacity_empty_elementdata;\n    }\n\n    /**\n     * constructs a list containing the elements of the specified\n     * collection, in the order they are returned by the collection\'s\n     * iterator.\n     * 构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回\n     * 如果指定的集合为null，抛出空指针异常\n     * @param c the collection whose elements are to be placed into this list\n     * @throws nullpointerexception if the specified collection is null\n     */\n    public arraylist(collection<? extends e> c) {\n        elementdata = c.toarray();\n        if ((size = elementdata.length) != 0) {\n            // c.toarray might (incorrectly) not return object[] (see 6260652)\n            if (elementdata.getclass() != object[].class)\n                elementdata = arrays.copyof(elementdata, size, object[].class);\n        } else {\n            // replace with empty array.\n            this.elementdata = empty_elementdata;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n\n\n在无参构造方法中，创建arraylist实际上是初始化一个空数组。\n\nempty_elementdata常量数组为空实例共享一个空数组\n\ndefaultcapacity_empty_elementdata常量数组，与empty_elementdata不同，用于默认大小的空实例的共享空数组实例。将其与empty_elementdata区分开来，以便知道添加第一个元素时需要扩容多少。当真正对数组进行添加元素操作的时候，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为10\n\n\n# 1.add方法\n\n    /**\n     * appends the specified element to the end of this list.\n     * 将指定的元素追加到此列表的末尾\n     * @param e element to be appended to this list\n     * @return <tt>true</tt> (as specified by {@link collection#add})\n     */\n    public boolean add(e e) {\n    // 添加元素之前，先调用ensurecapacityinternal方法\n        ensurecapacityinternal(size + 1);  // increments modcount!!\n        // 在arraylist添加元素的实质，相当于为数组赋值\n        elementdata[size++] = e;\n        return true;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 2.ensurecapacityinternal()方法\n\n在add方法中，调用了ensurecapacityinternal(size + 1)，ensurecapacityinternal源码如下\n\n    private void ensurecapacityinternal(int mincapacity) {\n        ensureexplicitcapacity(calculatecapacity(elementdata, mincapacity));\n    }\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n在源码中，又调用了calculatecapacity和ensureexplicitcapacity方法\n\n\n# 3.calculatecapacity()方法\n\ncalculatecapacity传入一个数组和最小扩容量，计算扩容量的值\n\n    private static int calculatecapacity(object[] elementdata, int mincapacity) {\n        if (elementdata == defaultcapacity_empty_elementdata) {\n            // 获取默认的容量和传入参数的较大值\n            return math.max(default_capacity, mincapacity);\n        }\n        return mincapacity;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n当要add第一个元素时，数组的size为0，传入的参数为size+1，所以mincapacity为1，在math.max方法比较后，mincapacity变为10，之后将mincapacity返回，执行ensureexplicitcapacity()方法\n\n\n# 4.ensureexplicitcapacity()方法\n\n当第1次add的时候，从上一个返回接回10，作为mincapacity的初始值，由于mincapacity-elementdata.length > 0所以会进入到grow(mincapacity)方法\n\n此后，当添加2，3，......，10个元素时，由于数组容量足够大，都不会进行grow方法扩容\n\n而当添加第11个元素时，mincapacity - elementdata.length > 0成立，再次进行扩容\n\n    //  判断是否需要扩容\n    private void ensureexplicitcapacity(int mincapacity) {\n        modcount++;\n\n        // overflow-conscious code\n        if (mincapacity - elementdata.length > 0)\n            // 调用grow方法进行扩容，调用此方法代表已经开始扩容了\n            grow(mincapacity);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 5.grow()方法\n\n    // 要分配的最大数组大小\n    private static final int max_array_size = integer.max_value - 8;\n    \n    /**\n     * increases the capacity to ensure that it can hold at least the\n     * number of elements specified by the minimum capacity argument.\n     * 增加容量，以确保它至少可以容纳最小容量参数指定的元素数量。\n     * arraylist扩容的核心方法\n     * @param mincapacity the desired minimum capacity\n     */\n    private void grow(int mincapacity) {\n        // overflow-conscious code\n        // oldcapacity为旧容量，newcapacity为新容量\n        int oldcapacity = elementdata.length;\n        // 将oldcapacity右移一位，其效果相当于oldcapacity/2\n        // 位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍\n        int newcapacity = oldcapacity + (oldcapacity >> 1);\n        // 然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量\n        if (newcapacity - mincapacity < 0)\n            newcapacity = mincapacity;\n        // 如果新容量大于 max_array_size,进入(执行) `hugecapacity()` 方法来比较 mincapacity 和 max_array_size\n        // 如果mincapacity大于最大容量，则新容量则为`integer.max_value`，否则，新容量大小则为 max_array_size 即为 `integer.max_value - 8`\n        if (newcapacity - max_array_size > 0)\n            newcapacity = hugecapacity(mincapacity);\n        // mincapacity is usually close to size, so this is a win:\n        elementdata = arrays.copyof(elementdata, newcapacity);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\nint newcapacity = oldcapacity + (oldcapacity >> 1)，所以arraylist每次扩容之后容量都会变为原来的1.5倍左右(oldcapacity为偶数就是1.5倍，否则是1.5倍左右)，奇偶不同，比如：10+10/2 = 15，33+33/2 = 49。如果是奇数的话会丢掉小数。\n\n我们再来通过例子探究一下grow() 方法 ：\n\n * 当add第1个元素时，oldcapacity 为0，经比较后第一个if判断成立，newcapacity = mincapacity(为10)。但是第二个if判断不会成立，即newcapacity 不比 max_array_size大，则不会进入 hugecapacity 方法。数组容量为10，add方法中 return true,size增为1。\n * 当add第11个元素进入grow方法时，newcapacity为15，比mincapacity（为11）大，第一个if判断不成立。新容量没有大于数组最大size，不会进入hugecapacity方法。数组容量扩为15，add方法中return true,size增为11。\n * 以此类推······\n\n\n# 6.hugecapacity()方法\n\n从上面grow()方法源码中能够知道，如果新容量大于最大容量max_array_size，进入(执行)hugecapacity()方法来比较mincapacity和max_array_size，如果mincapacity大于最大容量，则新容量则为integer.max_value，否则，新容量大小则为 max_array_size 即为 integer.max_value - 8。\n\n    private static int hugecapacity(int mincapacity) {\n        if (mincapacity < 0) // overflow\n            throw new outofmemoryerror();\n        return (mincapacity > max_array_size) ?\n            integer.max_value :\n            max_array_size;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n通过以上6个方法，即可实现arraylist的完整扩容流程\n\n\n# 其他方法(ensurecapacity方法)\n\narraylist源码中，还有一个ensurecapacity方法，这个方法在arraylist内部没有被调用过，所以显然是提供给用户调用的，那么这个方法有什么作用呢？\n\n    /**\n     * increases the capacity of this <tt>arraylist</tt> instance, if\n     * necessary, to ensure that it can hold at least the number of elements\n     * specified by the minimum capacity argument.\n     * 如有必要，增加此arraylist实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数\n     * @param   mincapacity   the desired minimum capacity 所需的最小容量\n     */\n    public void ensurecapacity(int mincapacity) {\n        int minexpand = (elementdata != defaultcapacity_empty_elementdata)\n            // any size if not default element table\n            ? 0\n            // larger than default for default empty table. it\'s already\n            // supposed to be at default size.\n            : default_capacity;\n\n        if (mincapacity > minexpand) {\n            ensureexplicitcapacity(mincapacity);\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n最好在add大量元素之前用ensurecapacity方法，以减少增量重新分配的次数\n\n代码示例\n\npublic class ensurecapacitytest {\n\tpublic static void main(string[] args) {\n\t\tarraylist<object> list = new arraylist<object>();\n\t\tfinal int n = 10000000;\n\t\tlong starttime = system.currenttimemillis();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tlist.add(i);\n\t\t}\n\t\tlong endtime = system.currenttimemillis();\n\t\tsystem.out.println("使用ensurecapacity方法前："+(endtime - starttime));\n\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n运行结果：\n\n使用ensurecapacity方法前：2158\n\n\n1\n\n1\n\n\n使用ensurecapacity后\n\npublic class ensurecapacitytest {\n    public static void main(string[] args) {\n        arraylist<object> list = new arraylist<object>();\n        final int n = 10000000;\n        list = new arraylist<object>();\n        long starttime1 = system.currenttimemillis();\n        list.ensurecapacity(n);\n        for (int i = 0; i < n; i++) {\n            list.add(i);\n        }\n        long endtime1 = system.currenttimemillis();\n        system.out.println("使用ensurecapacity方法后："+(endtime1 - starttime1));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n运行结果：\n\n使用ensurecapacity方法后：1773\n\n\n1\n\n1\n\n\n通过运行结果，我们可以看出向 arraylist 添加大量元素之前最好先使用ensurecapacity 方法，以减少增量重新分配的次数。\n\n参考资料：\n\n> javaguide：https://github.com/snailclimb/javaguide/blob/master/docs/java/collection/arraylist-grow.md',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"Java多线程实现的几种方式",frontmatter:{title:"Java多线程实现的几种方式",date:"2020-06-28T10:25:41.000Z",description:"总结",categories:["Java"],tags:["多线程","Java"],keywords:"多线程,Java",permalink:"/pages/487c60/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/01.Java/01.Java/03.Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/01.Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F.html",relativePath:"01.Java/01.Java/03.Java-多线程与并发/01.Java多线程实现的几种方式.md",key:"v-2f72ba66",path:"/pages/487c60/",headers:[{level:2,title:"Java多线程实现的几种方式",slug:"java多线程实现的几种方式",normalizedTitle:"java多线程实现的几种方式",charIndex:2},{level:4,title:"通过Runnable接口实现多线程",slug:"通过runnable接口实现多线程",normalizedTitle:"通过runnable接口实现多线程",charIndex:345},{level:4,title:"通过继承Thread类实现",slug:"通过继承thread类实现",normalizedTitle:"通过继承thread类实现",charIndex:785},{level:4,title:"通过继承Callable接口实现",slug:"通过继承callable接口实现",normalizedTitle:"通过继承callable接口实现",charIndex:1248}],headersStr:"Java多线程实现的几种方式 通过Runnable接口实现多线程 通过继承Thread类实现 通过继承Callable接口实现",content:'# Java多线程实现的几种方式\n\n多进程是计算机中的一个重要概念，通常一个任务称为一个进程，比如浏览网页、播放音乐都是一个进程。\n\n在进程内部可能还需要执行多个子任务，比如在使用word文档打字的时候，不仅要进行字符打印，同时还要进行字符统计、拼接检查等任务。\n\n进程和线程的关系是：一个进程可以包含一个或者多个线程，但至少会包含一个线程。\n\n在Java中，多线程的学习是非常重要的，本文主要概括Java多线程实现的几种方式。\n\nJava中实现多进程的方式大概有3种：\n\n 1. 实现Runnable接口，重写run方法\n 2. 继承Thread类，重写run方法(Thread类本身也实现了Runnable接口)\n 3. 实现Callable接口，重写call方法(带有返回值)\n\n# 通过Runnable接口实现多线程\n\npublic class Main {\n    public static void main(String[] args) {\n        Thread t = new Thread(new MyRunnable());\n        t.start(); // 启动新线程\n    }\n}\n\nclass MyRunnable implements Runnable {\n    @Override\n    public void run() {\n        System.out.println("start new thread!");\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n实现Runnable接口的类，只定义了任务，自身不具有线程能力。需要通过Thread类的构造器来将任务驱动在一个线程中。\n\n# 通过继承Thread类实现\n\nThread类中已经实现了Runnable接口，所以可以直接继承Thread类，覆写run方法实现多线程\n\npublic class MyThread extends Thread{\n    public void run(){\n        System.out.println("New Thread : "+Thread.currentThread().getName());\n    }\n    public static void main (String []args){\n        MyThread thread = new MyThread();\n        thread.start();\n        System.out.println("Main Thread : " + Thread.currentThread().getName());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 通过继承Callable接口实现\n\n相较于实现Runnable接口，Callable方法可以有返回值，并且可以抛出异常\n\n执行Callable方法，需要FutureTask实现类的支持，用于接受运算的结果，FutureTask是Future接口的实现\n\n需要覆写call方法，运行Callable任务可以拿到一个Future对象，Future表示异步计算的结果\n\n通过Future对象可了解任务执行情况，可取消任务的执行，还可以获取任务执行的结果\n\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.FutureTask;\n\npublic class TestCallable {\n\n    public static void main(String[] args) {\n        ThreadDemo td = new ThreadDemo();\n\n        FutureTask<Integer> result = new FutureTask<>(td);\n\n        new Thread(result).start();\n\n        try {\n            Integer sum = result.get();\n            System.out.println(sum);\n        } catch (InterruptedException | ExecutionException e) {\n            e.printStackTrace();\n        }\n    }\n\n}\n\nclass ThreadDemo implements Callable<Integer> {\n\n    @Override\n    public Integer call() throws Exception {\n        int sum = 0;\n\n        for (int i = 0; i <= 100; i++) {\n            sum += i;\n        }\n\n        return sum;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n',normalizedContent:'# java多线程实现的几种方式\n\n多进程是计算机中的一个重要概念，通常一个任务称为一个进程，比如浏览网页、播放音乐都是一个进程。\n\n在进程内部可能还需要执行多个子任务，比如在使用word文档打字的时候，不仅要进行字符打印，同时还要进行字符统计、拼接检查等任务。\n\n进程和线程的关系是：一个进程可以包含一个或者多个线程，但至少会包含一个线程。\n\n在java中，多线程的学习是非常重要的，本文主要概括java多线程实现的几种方式。\n\njava中实现多进程的方式大概有3种：\n\n 1. 实现runnable接口，重写run方法\n 2. 继承thread类，重写run方法(thread类本身也实现了runnable接口)\n 3. 实现callable接口，重写call方法(带有返回值)\n\n# 通过runnable接口实现多线程\n\npublic class main {\n    public static void main(string[] args) {\n        thread t = new thread(new myrunnable());\n        t.start(); // 启动新线程\n    }\n}\n\nclass myrunnable implements runnable {\n    @override\n    public void run() {\n        system.out.println("start new thread!");\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n实现runnable接口的类，只定义了任务，自身不具有线程能力。需要通过thread类的构造器来将任务驱动在一个线程中。\n\n# 通过继承thread类实现\n\nthread类中已经实现了runnable接口，所以可以直接继承thread类，覆写run方法实现多线程\n\npublic class mythread extends thread{\n    public void run(){\n        system.out.println("new thread : "+thread.currentthread().getname());\n    }\n    public static void main (string []args){\n        mythread thread = new mythread();\n        thread.start();\n        system.out.println("main thread : " + thread.currentthread().getname());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 通过继承callable接口实现\n\n相较于实现runnable接口，callable方法可以有返回值，并且可以抛出异常\n\n执行callable方法，需要futuretask实现类的支持，用于接受运算的结果，futuretask是future接口的实现\n\n需要覆写call方法，运行callable任务可以拿到一个future对象，future表示异步计算的结果\n\n通过future对象可了解任务执行情况，可取消任务的执行，还可以获取任务执行的结果\n\nimport java.util.concurrent.callable;\nimport java.util.concurrent.executionexception;\nimport java.util.concurrent.futuretask;\n\npublic class testcallable {\n\n    public static void main(string[] args) {\n        threaddemo td = new threaddemo();\n\n        futuretask<integer> result = new futuretask<>(td);\n\n        new thread(result).start();\n\n        try {\n            integer sum = result.get();\n            system.out.println(sum);\n        } catch (interruptedexception | executionexception e) {\n            e.printstacktrace();\n        }\n    }\n\n}\n\nclass threaddemo implements callable<integer> {\n\n    @override\n    public integer call() throws exception {\n        int sum = 0;\n\n        for (int i = 0; i <= 100; i++) {\n            sum += i;\n        }\n\n        return sum;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"多线程交替打印数字—多种实现",frontmatter:{title:"多线程交替打印数字—多种实现",date:"2022-01-14T21:18:48.000Z",categories:["Java"],tags:["Java","多线程"],permalink:"/pages/5047a0/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/01.Java/01.Java/03.Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/02.%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%89%93%E5%8D%B0%E6%95%B0%E5%AD%97-%E5%A4%9A%E7%A7%8D%E5%AE%9E%E7%8E%B0.html",relativePath:"01.Java/01.Java/03.Java-多线程与并发/02.多线程打印数字-多种实现.md",key:"v-6950b4e9",path:"/pages/5047a0/",headers:[{level:3,title:"多线程交替打印数字—多种实现",slug:"多线程交替打印数字-多种实现",normalizedTitle:"多线程交替打印数字—多种实现",charIndex:2},{level:4,title:"使用synchronized锁实现",slug:"使用synchronized锁实现",normalizedTitle:"使用synchronized锁实现",charIndex:20},{level:5,title:"打印结果",slug:"打印结果",normalizedTitle:"打印结果",charIndex:1270},{level:4,title:"使用valatile标志位实现",slug:"使用valatile标志位实现",normalizedTitle:"使用valatile标志位实现",charIndex:1413},{level:4,title:"使用AtomicInteger+LockSupport实现",slug:"使用atomicinteger-locksupport实现",normalizedTitle:"使用atomicinteger+locksupport实现",charIndex:3015},{level:4,title:"踩坑日志",slug:"踩坑日志",normalizedTitle:"踩坑日志",charIndex:5135}],headersStr:"多线程交替打印数字—多种实现 使用synchronized锁实现 打印结果 使用valatile标志位实现 使用AtomicInteger+LockSupport实现 踩坑日志",content:'# 多线程交替打印数字—多种实现\n\n# 使用synchronized锁实现\n\npublic class Test {\n\n    public static void main(String[] args) {\n        mutilThreadPrintNum m1 = new mutilThreadPrintNum();\n        Thread thread1 = new Thread(m1);\n        Thread thread2 = new Thread(m1);\n        thread1.setName("奇数");\n        thread2.setName("偶数");\n        thread1.start();\n        thread2.start();\n    }\n}\n\nclass mutilThreadPrintNum implements Runnable {\n\n    int num = 1;\n\n    @Override\n    public void run() {\n        synchronized (this) {\n            while (true) {\n                // 唤醒wait()的一个或所有线程\n                notify();\n                if (num <= 100) {\n                    System.out.println(Thread.currentThread().getName() + ":" + num);\n                    num++;\n                } else {\n                    break;\n                }\n                try {\n                    // wait会释放当前的锁，让另一个线程可以进入\n                    wait();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n# 打印结果\n\n奇数:1\n偶数:2\n奇数:3\n偶数:4\n......\n奇数:99\n偶数:100\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n通过加锁和notify()、wait()机制可以有效的实现两个线程分别打印奇数和偶数，但互斥锁始终会影响性能，效率不高。\n\n# 使用valatile标志位实现\n\npublic class Test {\n\n    static volatile boolean flag = true;\n    static volatile int num = 1;\n\n    public static void main(String[] args) {\n        mutilThreadPrintNumOdd m1 = new mutilThreadPrintNumOdd();\n        mutilThreadPrintNumEven m2 = new mutilThreadPrintNumEven();\n        Thread thread1 = new Thread(m1);\n        Thread thread2 = new Thread(m2);\n        thread1.setName("奇数");\n        thread2.setName("偶数");\n        thread1.start();\n        thread2.start();\n    }\n\n    public static class mutilThreadPrintNumOdd implements Runnable {\n\n        @Override\n        public void run() {\n            while (num <= 100) {\n                if (flag) {\n                    System.out.println(Thread.currentThread().getName() + ":" + num);\n                    num++;\n                    flag = false;\n                }\n            }\n        }\n    }\n\n    public static class mutilThreadPrintNumEven implements Runnable {\n\n        @Override\n        public void run() {\n            while (num <= 100) {\n                if (!flag) {\n                    System.out.println(Thread.currentThread().getName() + ":" + num);\n                    num++;\n                    flag = true;\n                }\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n打印结果和上文相同，使用volatile关键字可以保证变量的可见性，但并不能保证num的原子性，即多个线程操作num时，他是非线程安全的，此处能够正确打印的原因是因为flag标志位的判断。相对于加锁来说，效率更高\n\n# 使用AtomicInteger+LockSupport实现\n\npublic class Test {\n\n    public static AtomicInteger num = new AtomicInteger(1);\n\n    public static Thread thread1 = null, thread2 = null;\n\n    public static void main(String[] args) {\n        mutilThreadPrintNumOdd m1 = new mutilThreadPrintNumOdd();\n        mutilThreadPrintNumEven m2 = new mutilThreadPrintNumEven();\n        thread1 = new Thread(m1);\n        thread2 = new Thread(m2);\n        thread1.setName("奇数");\n        thread2.setName("偶数");\n        thread1.start();\n        thread2.start();\n\n    }\n\n    public static class mutilThreadPrintNumOdd implements Runnable {\n\n        @Override\n        public void run() {\n            while (true) {\n                if (num.get() % 2 != 0 && num.get() <= 100) {\n                    System.out.println(Thread.currentThread().getName() + ":" + num);\n                    // 原子递增\n                    num.incrementAndGet();\n                    // 获取许可，阻塞其他线程\n                    LockSupport.park();\n                } else {\n                    // 释放许可，并将许可传递到偶数线程\n                    LockSupport.unpark(thread2);\n                }\n            }\n        }\n    }\n\n    public static class mutilThreadPrintNumEven implements Runnable {\n\n        @Override\n        public void run() {\n            while (true) {\n                if (num.get() % 2 == 0 && num.get() <= 100) {\n                    System.out.println(Thread.currentThread().getName() + ":" + num);\n                    // 原子递增\n                    num.incrementAndGet();\n                    // 获取许可，阻塞其他线程\n                    LockSupport.park();\n                } else {\n                    // 释放许可，并将许可传递到奇数线程\n                    LockSupport.unpark(thread1);\n                }\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n使用JUC包内的AtomicInteger保持多线程并发安全，同时采用LockSupport唤醒或阻塞线程\n\n# 踩坑日志\n\n第三种实现方法一开始并不是正确的，如果LockSupport.park()方法放在如下位置\n\n@Override\npublic void run() {\n    while (true) {\n        // 获取许可，阻塞其他线程\n        LockSupport.park();\n        if (num.get() % 2 != 0 && num.get() <= 100) {\n            System.out.println(Thread.currentThread().getName() + ":" + num);\n            // 原子递增\n            num.incrementAndGet();\n        } else {\n            // 释放许可，并将许可传递到偶数线程\n            LockSupport.unpark(thread2);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n那么程序将会发生死锁，因为两个线程都持有当前线程的许可，并没有等待到释放许可的执行，当我们把断点放在奇数和偶数获取许可的代码段上时，会发现奇数线程先获取了许可，还没来得及执行if判断，偶数线程也获得了许可，此时程序没有任何打印。 奇数线程：\n\n\n\n偶数线程：\n\n\n\n此时我们采用jps命令找到当前线程的pid\n\n\n\n之后采用jstack pid命令分析当前线程的堆栈信息，可以发现奇数线程和偶数线程都处于WAITING状态，他们都在等待对方释放锁或传递许可。所以正确的写法应该在if判断内，当打印之后便会阻塞当前线程，由于数字已经打印，再次循环时便会进入到else的判断逻辑，即当前线程发现不是属于自己该打印的数字就会尝试唤醒另一个线程。\n\n',normalizedContent:'# 多线程交替打印数字—多种实现\n\n# 使用synchronized锁实现\n\npublic class test {\n\n    public static void main(string[] args) {\n        mutilthreadprintnum m1 = new mutilthreadprintnum();\n        thread thread1 = new thread(m1);\n        thread thread2 = new thread(m1);\n        thread1.setname("奇数");\n        thread2.setname("偶数");\n        thread1.start();\n        thread2.start();\n    }\n}\n\nclass mutilthreadprintnum implements runnable {\n\n    int num = 1;\n\n    @override\n    public void run() {\n        synchronized (this) {\n            while (true) {\n                // 唤醒wait()的一个或所有线程\n                notify();\n                if (num <= 100) {\n                    system.out.println(thread.currentthread().getname() + ":" + num);\n                    num++;\n                } else {\n                    break;\n                }\n                try {\n                    // wait会释放当前的锁，让另一个线程可以进入\n                    wait();\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n# 打印结果\n\n奇数:1\n偶数:2\n奇数:3\n偶数:4\n......\n奇数:99\n偶数:100\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n通过加锁和notify()、wait()机制可以有效的实现两个线程分别打印奇数和偶数，但互斥锁始终会影响性能，效率不高。\n\n# 使用valatile标志位实现\n\npublic class test {\n\n    static volatile boolean flag = true;\n    static volatile int num = 1;\n\n    public static void main(string[] args) {\n        mutilthreadprintnumodd m1 = new mutilthreadprintnumodd();\n        mutilthreadprintnumeven m2 = new mutilthreadprintnumeven();\n        thread thread1 = new thread(m1);\n        thread thread2 = new thread(m2);\n        thread1.setname("奇数");\n        thread2.setname("偶数");\n        thread1.start();\n        thread2.start();\n    }\n\n    public static class mutilthreadprintnumodd implements runnable {\n\n        @override\n        public void run() {\n            while (num <= 100) {\n                if (flag) {\n                    system.out.println(thread.currentthread().getname() + ":" + num);\n                    num++;\n                    flag = false;\n                }\n            }\n        }\n    }\n\n    public static class mutilthreadprintnumeven implements runnable {\n\n        @override\n        public void run() {\n            while (num <= 100) {\n                if (!flag) {\n                    system.out.println(thread.currentthread().getname() + ":" + num);\n                    num++;\n                    flag = true;\n                }\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n打印结果和上文相同，使用volatile关键字可以保证变量的可见性，但并不能保证num的原子性，即多个线程操作num时，他是非线程安全的，此处能够正确打印的原因是因为flag标志位的判断。相对于加锁来说，效率更高\n\n# 使用atomicinteger+locksupport实现\n\npublic class test {\n\n    public static atomicinteger num = new atomicinteger(1);\n\n    public static thread thread1 = null, thread2 = null;\n\n    public static void main(string[] args) {\n        mutilthreadprintnumodd m1 = new mutilthreadprintnumodd();\n        mutilthreadprintnumeven m2 = new mutilthreadprintnumeven();\n        thread1 = new thread(m1);\n        thread2 = new thread(m2);\n        thread1.setname("奇数");\n        thread2.setname("偶数");\n        thread1.start();\n        thread2.start();\n\n    }\n\n    public static class mutilthreadprintnumodd implements runnable {\n\n        @override\n        public void run() {\n            while (true) {\n                if (num.get() % 2 != 0 && num.get() <= 100) {\n                    system.out.println(thread.currentthread().getname() + ":" + num);\n                    // 原子递增\n                    num.incrementandget();\n                    // 获取许可，阻塞其他线程\n                    locksupport.park();\n                } else {\n                    // 释放许可，并将许可传递到偶数线程\n                    locksupport.unpark(thread2);\n                }\n            }\n        }\n    }\n\n    public static class mutilthreadprintnumeven implements runnable {\n\n        @override\n        public void run() {\n            while (true) {\n                if (num.get() % 2 == 0 && num.get() <= 100) {\n                    system.out.println(thread.currentthread().getname() + ":" + num);\n                    // 原子递增\n                    num.incrementandget();\n                    // 获取许可，阻塞其他线程\n                    locksupport.park();\n                } else {\n                    // 释放许可，并将许可传递到奇数线程\n                    locksupport.unpark(thread1);\n                }\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n使用juc包内的atomicinteger保持多线程并发安全，同时采用locksupport唤醒或阻塞线程\n\n# 踩坑日志\n\n第三种实现方法一开始并不是正确的，如果locksupport.park()方法放在如下位置\n\n@override\npublic void run() {\n    while (true) {\n        // 获取许可，阻塞其他线程\n        locksupport.park();\n        if (num.get() % 2 != 0 && num.get() <= 100) {\n            system.out.println(thread.currentthread().getname() + ":" + num);\n            // 原子递增\n            num.incrementandget();\n        } else {\n            // 释放许可，并将许可传递到偶数线程\n            locksupport.unpark(thread2);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n那么程序将会发生死锁，因为两个线程都持有当前线程的许可，并没有等待到释放许可的执行，当我们把断点放在奇数和偶数获取许可的代码段上时，会发现奇数线程先获取了许可，还没来得及执行if判断，偶数线程也获得了许可，此时程序没有任何打印。 奇数线程：\n\n\n\n偶数线程：\n\n\n\n此时我们采用jps命令找到当前线程的pid\n\n\n\n之后采用jstack pid命令分析当前线程的堆栈信息，可以发现奇数线程和偶数线程都处于waiting状态，他们都在等待对方释放锁或传递许可。所以正确的写法应该在if判断内，当打印之后便会阻塞当前线程，由于数字已经打印，再次循环时便会进入到else的判断逻辑，即当前线程发现不是属于自己该打印的数字就会尝试唤醒另一个线程。\n\n',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"CountDownLatch使用方法",frontmatter:{title:"CountDownLatch使用方法",date:"2022-01-18T16:18:48.000Z",categories:["Java"],tags:["Java","JUC"],permalink:"/pages/bccbee/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/01.Java/01.Java/03.Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/03.CountDownLatch%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.html",relativePath:"01.Java/01.Java/03.Java-多线程与并发/03.CountDownLatch使用方法.md",key:"v-3b417cdd",path:"/pages/bccbee/",headers:[{level:3,title:"CountDownLatch使用方法",slug:"countdownlatch使用方法",normalizedTitle:"countdownlatch使用方法",charIndex:2},{level:4,title:"应用场景",slug:"应用场景",normalizedTitle:"应用场景",charIndex:83},{level:4,title:"基本原理",slug:"基本原理",normalizedTitle:"基本原理",charIndex:250},{level:4,title:"使用方法",slug:"使用方法",normalizedTitle:"使用方法",charIndex:16},{level:5,title:"场景1：最大并行性，多个线程就绪同时执行",slug:"场景1-最大并行性-多个线程就绪同时执行",normalizedTitle:"场景1：最大并行性，多个线程就绪同时执行",charIndex:420},{level:5,title:"场景2：让单个线程等待其他多个线程执行完毕后，再执行",slug:"场景2-让单个线程等待其他多个线程执行完毕后-再执行",normalizedTitle:"场景2：让单个线程等待其他多个线程执行完毕后，再执行",charIndex:1490},{level:4,title:"CountDownLatch与CyclicBarrier的区别",slug:"countdownlatch与cyclicbarrier的区别",normalizedTitle:"countdownlatch与cyclicbarrier的区别",charIndex:2210}],headersStr:"CountDownLatch使用方法 应用场景 基本原理 使用方法 场景1：最大并行性，多个线程就绪同时执行 场景2：让单个线程等待其他多个线程执行完毕后，再执行 CountDownLatch与CyclicBarrier的区别",content:'# CountDownLatch使用方法\n\nCountDownLatch是JUC包中的一个同步工具类，允许一个或多个线程等待，直到其他线程执行完毕之后再执行。\n\n# 应用场景\n\nCountDownLatch通常有两种使用场景：\n\n * 场景1. 让多个线程等待——强调多个线程的最大并行性，即多个线程在同一时刻开始执行，类似赛跑场景，多个线程都在起点，等待发令后同时开跑，只需初始化1个计数器\n * 场景2. 让一个线程等待——主线程等待其他n个线程执行完毕之后进行执行，需要初始化n个计数器\n\n# 基本原理\n\n * 创建 CountDownLatch 并设置计数器值。\n * 启动多线程并且调用 CountDownLatch 实例的 countDown() 方法。\n * 主线程调用 await()方法，主线程的操作就会在这个方法上阻塞，直到其他线程完成各自的任务，count 值为 0，停止阻塞，主线程继续执行。\n\n# 使用方法\n\n# 场景1：最大并行性，多个线程就绪同时执行\n\n在这个场景中，CountDownLatch可类似于发令者的角色\n\npublic class Test {\n\n    public static void main(String[] args) throws InterruptedException{\n        \n        CountDownLatch count = new CountDownLatch(1);\n        for (int i = 0; i < 8; i++) {\n            new Thread(() -> {\n                try {\n                    // 线程阻塞，等待所有线程就绪\n                    count.await();\n                    System.out.println(Thread.currentThread().getName());\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }).start();\n        }\n        count.countDown(); // 计数器减1，多个线程开始同时执行\n        System.out.println("主线程打印");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n运行结果\n\n主线程打印\nThread-3\nThread-6\nThread-4\nThread-5\nThread-1\nThread-0\nThread-7\nThread-2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n通过count.await()使当前线程等待，直到计数器为0，或者线程被中断。由于count.countDown()在循环外部，每个线程启动的时候都会将自己阻塞，但此时的阻塞并没有阻塞主线程，所以主线程打印先一步执行，在循环内8个线程就绪之后，通过计数器减1，让他们同步执行打印，达到并行执行的目的。\n\n# 场景2：让单个线程等待其他多个线程执行完毕后，再执行\n\npublic class Test {\n\n    public static void main(String[] args) throws InterruptedException {\n        CountDownLatch count = new CountDownLatch(8);\n        for (int i = 0; i < 8; i++) {\n            new Thread(() -> {\n                System.out.println(Thread.currentThread().getName());\n                count.countDown();\n            }).start();\n        }\n        count.await();\n        System.out.println("主线程打印");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n运行结果\n\nThread-0\nThread-2\nThread-1\nThread-3\nThread-4\nThread-5\nThread-6\nThread-7\n主线程打印\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\ncount.await()在循环外部，阻塞主线程等待其他8个线程执行count.countDown()，当计数器为0时，才执行主线程打印\n\n# CountDownLatch与CyclicBarrier的区别\n\nCountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同：\n\n * CountDownLatch一般用于一个或多个线程，等待其他线程执行完任务后，再才执行\n * CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行 另外，CountDownLatch是减计数，计数减为0后不能重用；而CyclicBarrier是加计数，可置0后复用。',normalizedContent:'# countdownlatch使用方法\n\ncountdownlatch是juc包中的一个同步工具类，允许一个或多个线程等待，直到其他线程执行完毕之后再执行。\n\n# 应用场景\n\ncountdownlatch通常有两种使用场景：\n\n * 场景1. 让多个线程等待——强调多个线程的最大并行性，即多个线程在同一时刻开始执行，类似赛跑场景，多个线程都在起点，等待发令后同时开跑，只需初始化1个计数器\n * 场景2. 让一个线程等待——主线程等待其他n个线程执行完毕之后进行执行，需要初始化n个计数器\n\n# 基本原理\n\n * 创建 countdownlatch 并设置计数器值。\n * 启动多线程并且调用 countdownlatch 实例的 countdown() 方法。\n * 主线程调用 await()方法，主线程的操作就会在这个方法上阻塞，直到其他线程完成各自的任务，count 值为 0，停止阻塞，主线程继续执行。\n\n# 使用方法\n\n# 场景1：最大并行性，多个线程就绪同时执行\n\n在这个场景中，countdownlatch可类似于发令者的角色\n\npublic class test {\n\n    public static void main(string[] args) throws interruptedexception{\n        \n        countdownlatch count = new countdownlatch(1);\n        for (int i = 0; i < 8; i++) {\n            new thread(() -> {\n                try {\n                    // 线程阻塞，等待所有线程就绪\n                    count.await();\n                    system.out.println(thread.currentthread().getname());\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n            }).start();\n        }\n        count.countdown(); // 计数器减1，多个线程开始同时执行\n        system.out.println("主线程打印");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n运行结果\n\n主线程打印\nthread-3\nthread-6\nthread-4\nthread-5\nthread-1\nthread-0\nthread-7\nthread-2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n通过count.await()使当前线程等待，直到计数器为0，或者线程被中断。由于count.countdown()在循环外部，每个线程启动的时候都会将自己阻塞，但此时的阻塞并没有阻塞主线程，所以主线程打印先一步执行，在循环内8个线程就绪之后，通过计数器减1，让他们同步执行打印，达到并行执行的目的。\n\n# 场景2：让单个线程等待其他多个线程执行完毕后，再执行\n\npublic class test {\n\n    public static void main(string[] args) throws interruptedexception {\n        countdownlatch count = new countdownlatch(8);\n        for (int i = 0; i < 8; i++) {\n            new thread(() -> {\n                system.out.println(thread.currentthread().getname());\n                count.countdown();\n            }).start();\n        }\n        count.await();\n        system.out.println("主线程打印");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n运行结果\n\nthread-0\nthread-2\nthread-1\nthread-3\nthread-4\nthread-5\nthread-6\nthread-7\n主线程打印\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\ncount.await()在循环外部，阻塞主线程等待其他8个线程执行count.countdown()，当计数器为0时，才执行主线程打印\n\n# countdownlatch与cyclicbarrier的区别\n\ncountdownlatch和cyclicbarrier都能够实现线程之间的等待，只不过它们侧重点不同：\n\n * countdownlatch一般用于一个或多个线程，等待其他线程执行完任务后，再才执行\n * cyclicbarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行 另外，countdownlatch是减计数，计数减为0后不能重用；而cyclicbarrier是加计数，可置0后复用。',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"CyclicBarrier使用方法",frontmatter:{title:"CyclicBarrier使用方法",date:"2022-01-18T17:28:48.000Z",categories:["Java"],tags:["Java","JUC"],permalink:"/pages/3898a4/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/01.Java/01.Java/03.Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/04.CyclicBarrier%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.html",relativePath:"01.Java/01.Java/03.Java-多线程与并发/04.CyclicBarrier使用方法.md",key:"v-3676674e",path:"/pages/3898a4/",headers:[{level:3,title:"CyclicBarrier使用方法",slug:"cyclicbarrier使用方法",normalizedTitle:"cyclicbarrier使用方法",charIndex:2},{level:4,title:"应用场景",slug:"应用场景",normalizedTitle:"应用场景",charIndex:1783},{level:5,title:"场景一：多个线程执行读数据操作，读取完毕之后执行后续任务",slug:"场景一-多个线程执行读数据操作-读取完毕之后执行后续任务",normalizedTitle:"场景一：多个线程执行读数据操作，读取完毕之后执行后续任务",charIndex:1791},{level:5,title:"场景二：所有线程读取完毕之后，进行额外操作",slug:"场景二-所有线程读取完毕之后-进行额外操作",normalizedTitle:"场景二：所有线程读取完毕之后，进行额外操作",charIndex:2790},{level:5,title:"特性：指定await时间",slug:"特性-指定await时间",normalizedTitle:"特性：指定await时间",charIndex:4031},{level:5,title:"特性：可复用",slug:"特性-可复用",normalizedTitle:"特性：可复用",charIndex:8495}],headersStr:"CyclicBarrier使用方法 应用场景 场景一：多个线程执行读数据操作，读取完毕之后执行后续任务 场景二：所有线程读取完毕之后，进行额外操作 特性：指定await时间 特性：可复用",content:'# CyclicBarrier使用方法\n\nCyclicBarrier字面意思就是回环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier可以被重用。我们暂且把这个状态就叫做barrier，当调用await()方法之后，线程就处于barrier了。\n\n构造方法\n\n * parties指让多少个线程或者任务等待至barrier状态\n * barrierAction为当这些线程都达到barrier状态时会执行的内容\n\n    /**\n     * Creates a new {@code CyclicBarrier} that will trip when the\n     * given number of parties (threads) are waiting upon it, and which\n     * will execute the given barrier action when the barrier is tripped,\n     * performed by the last thread entering the barrier.\n     *\n     * @param parties the number of threads that must invoke {@link #await}\n     *        before the barrier is tripped\n     * @param barrierAction the command to execute when the barrier is\n     *        tripped, or {@code null} if there is no action\n     * @throws IllegalArgumentException if {@code parties} is less than 1\n     */\n    public CyclicBarrier(int parties, Runnable barrierAction) {\n        if (parties <= 0) throw new IllegalArgumentException();\n        this.parties = parties;\n        this.count = parties;\n        this.barrierCommand = barrierAction;\n    }\n\n    /**\n     * Creates a new {@code CyclicBarrier} that will trip when the\n     * given number of parties (threads) are waiting upon it, and\n     * does not perform a predefined action when the barrier is tripped.\n     *\n     * @param parties the number of threads that must invoke {@link #await}\n     *        before the barrier is tripped\n     * @throws IllegalArgumentException if {@code parties} is less than 1\n     */\n    public CyclicBarrier(int parties) {\n        this(parties, null);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n# 应用场景\n\n# 场景一：多个线程执行读数据操作，读取完毕之后执行后续任务\n\npublic class Test {\n\n    public static void main(String[] args) {\n        CyclicBarrier cyclicBarrier = new CyclicBarrier(8);\n        for (int i = 0; i < 8; i++) {\n            new Thread(() -> {\n                try {\n                    System.out.println("读取" + Thread.currentThread().getName());\n                    cyclicBarrier.await();\n                } catch (InterruptedException | BrokenBarrierException e) {\n                    e.printStackTrace();\n                }\n                System.out.println("后续操作" + Thread.currentThread().getName());\n            }).start();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n运行结果\n\n读取Thread-0\n读取Thread-2\n读取Thread-1\n读取Thread-4\n读取Thread-3\n读取Thread-5\n读取Thread-6\n读取Thread-7\n后续操作Thread-7\n后续操作Thread-0\n后续操作Thread-1\n后续操作Thread-5\n后续操作Thread-2\n后续操作Thread-6\n后续操作Thread-3\n后续操作Thread-4\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 场景二：所有线程读取完毕之后，进行额外操作\n\n在这时候初始化CyclicBarrier时可以开启一个额外的Runnable线程执行其他任务\n\npublic class Test {\n\n    public static void main(String[] args) {\n        CyclicBarrier cyclicBarrier = new CyclicBarrier(8,\n                () -> System.out.println(Thread.currentThread().getName() + "额外任务执行"));\n        for (int i = 0; i < 8; i++) {\n            new Thread(() -> {\n                try {\n                    System.out.println("读取" + Thread.currentThread().getName());\n                    cyclicBarrier.await();\n                } catch (InterruptedException | BrokenBarrierException e) {\n                    e.printStackTrace();\n                }\n                System.out.println("后续操作" + Thread.currentThread().getName());\n            }).start();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n运行结果\n\n读取Thread-0\n读取Thread-3\n读取Thread-2\n读取Thread-1\n读取Thread-5\n读取Thread-4\n读取Thread-6\n读取Thread-7\nThread-1额外任务执行\n后续操作Thread-1\n后续操作Thread-0\n后续操作Thread-5\n后续操作Thread-7\n后续操作Thread-3\n后续操作Thread-2\n后续操作Thread-6\n后续操作Thread-4\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n可以看出，当读取操作完成之后，这8个线程都到达了barrier状态，此时会随机其中的一个线程去执行额外的任务，这个执行额外任务的线程执行完毕之后，就会接着执行后续的任务。\n\n# 特性：指定await时间\n\npublic class Test {\n\n    public static void main(String[] args) {\n        CyclicBarrier cyclicBarrier = new CyclicBarrier(8);\n        for (int i = 0; i < 8; i++) {\n            if (i < 7) {\n                new Thread(() -> {\n                    try {\n                        System.out.println("读取" + Thread.currentThread().getName());\n                        cyclicBarrier.await(100, TimeUnit.MILLISECONDS);\n                    } catch (InterruptedException | BrokenBarrierException | TimeoutException e) {\n                        e.printStackTrace();\n                    }\n                    System.out.println("后续操作" + Thread.currentThread().getName());\n                }).start();\n            } else {\n                new Thread(() -> {\n                    try {\n                        Thread.sleep(5000);\n                        System.out.println("读取" + Thread.currentThread().getName());\n                        cyclicBarrier.await(100, TimeUnit.MILLISECONDS);\n                    } catch (InterruptedException | BrokenBarrierException | TimeoutException e) {\n                        e.printStackTrace();\n                    }\n                    System.out.println("后续操作" + Thread.currentThread().getName());\n                }).start();\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n运行结果\n\n读取Thread-0\n读取Thread-2\n读取Thread-1\n读取Thread-3\n读取Thread-4\n读取Thread-5\n读取Thread-6\njava.util.concurrent.BrokenBarrierException\n\tat java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:250)\n\tat java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:435)\n\tat com.tencent.ioc.duty.event.service.impl.Test.lambda$main$0(Test.java:21)\n\tat java.lang.Thread.run(Thread.java:748)\njava.util.concurrent.TimeoutException\n\tat java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:257)\n\tat java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:435)\n\tat com.tencent.ioc.duty.event.service.impl.Test.lambda$main$0(Test.java:21)\n\tat java.lang.Thread.run(Thread.java:748)\njava.util.concurrent.BrokenBarrierException\n\tat java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:250)\n\tat java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:435)\n\tat com.tencent.ioc.duty.event.service.impl.Test.lambda$main$0(Test.java:21)\n\tat java.lang.Thread.run(Thread.java:748)\njava.util.concurrent.BrokenBarrierException\n\tat java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:250)\n\tat java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:435)\n\tat com.tencent.ioc.duty.event.service.impl.Test.lambda$main$0(Test.java:21)\n\tat java.lang.Thread.run(Thread.java:748)\njava.util.concurrent.BrokenBarrierException\n\tat java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:250)\n\tat java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:435)\n\tat com.tencent.ioc.duty.event.service.impl.Test.lambda$main$0(Test.java:21)\n\tat java.lang.Thread.run(Thread.java:748)\njava.util.concurrent.BrokenBarrierException\n\tat java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:250)\n\tat java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:435)\n\tat com.tencent.ioc.duty.event.service.impl.Test.lambda$main$0(Test.java:21)\n\tat java.lang.Thread.run(Thread.java:748)\njava.util.concurrent.BrokenBarrierException\n\tat java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:250)\n\tat java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:435)\n\tat com.tencent.ioc.duty.event.service.impl.Test.lambda$main$0(Test.java:21)\n\tat java.lang.Thread.run(Thread.java:748)\n后续操作Thread-3\n后续操作Thread-4\n后续操作Thread-6\n后续操作Thread-5\n后续操作Thread-2\n后续操作Thread-1\n后续操作Thread-0\n读取Thread-7\n后续操作Thread-7\njava.util.concurrent.BrokenBarrierException\n\tat java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:207)\n\tat java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:435)\n\tat com.tencent.ioc.duty.event.service.impl.Test.lambda$main$1(Test.java:32)\n\tat java.lang.Thread.run(Thread.java:748)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n这个场景模拟其中一个线程延迟执行，await等待时间内，检测到最后一个线程还没有到达栅栏，就会直接抛出异常让到达栅栏的线程继续执行后面的任务\n\n# 特性：可复用\n\npublic class Test {\n\n    public static void main(String[] args) throws InterruptedException {\n        CyclicBarrier cyclicBarrier = new CyclicBarrier(5);\n        for (int i = 0; i < 5; i++) {\n            new Thread(() -> {\n                try {\n                    System.out.println("读取" + Thread.currentThread().getName());\n                    cyclicBarrier.await();\n                } catch (InterruptedException | BrokenBarrierException e) {\n                    e.printStackTrace();\n                }\n                System.out.println("后续操作" + Thread.currentThread().getName());\n            }).start();\n        }\n        Thread.sleep(5000);\n        System.out.println("CyclicBarrier复用");\n        for (int i = 0; i < 5; i++) {\n            new Thread(() -> {\n                try {\n                    System.out.println("读取" + Thread.currentThread().getName());\n                    cyclicBarrier.await();\n                } catch (InterruptedException | BrokenBarrierException e) {\n                    e.printStackTrace();\n                }\n                System.out.println("后续操作" + Thread.currentThread().getName());\n            }).start();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n运行结果\n\n读取Thread-0\n读取Thread-1\n读取Thread-2\n读取Thread-3\n读取Thread-4\n后续操作Thread-4\n后续操作Thread-0\n后续操作Thread-2\n后续操作Thread-3\n后续操作Thread-1\nCyclicBarrier复用\n读取Thread-5\n读取Thread-6\n读取Thread-7\n读取Thread-8\n读取Thread-9\n后续操作Thread-9\n后续操作Thread-5\n后续操作Thread-8\n后续操作Thread-7\n后续操作Thread-6\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n这里的可复用不是代表的线程复用，而是指的当之前的所有线程都达到栅栏之后，初始化的栅栏仍然能够在下一次线程操作复用，而不像CountDownLatch一样减为0之后就无法再使用了。',normalizedContent:'# cyclicbarrier使用方法\n\ncyclicbarrier字面意思就是回环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，cyclicbarrier可以被重用。我们暂且把这个状态就叫做barrier，当调用await()方法之后，线程就处于barrier了。\n\n构造方法\n\n * parties指让多少个线程或者任务等待至barrier状态\n * barrieraction为当这些线程都达到barrier状态时会执行的内容\n\n    /**\n     * creates a new {@code cyclicbarrier} that will trip when the\n     * given number of parties (threads) are waiting upon it, and which\n     * will execute the given barrier action when the barrier is tripped,\n     * performed by the last thread entering the barrier.\n     *\n     * @param parties the number of threads that must invoke {@link #await}\n     *        before the barrier is tripped\n     * @param barrieraction the command to execute when the barrier is\n     *        tripped, or {@code null} if there is no action\n     * @throws illegalargumentexception if {@code parties} is less than 1\n     */\n    public cyclicbarrier(int parties, runnable barrieraction) {\n        if (parties <= 0) throw new illegalargumentexception();\n        this.parties = parties;\n        this.count = parties;\n        this.barriercommand = barrieraction;\n    }\n\n    /**\n     * creates a new {@code cyclicbarrier} that will trip when the\n     * given number of parties (threads) are waiting upon it, and\n     * does not perform a predefined action when the barrier is tripped.\n     *\n     * @param parties the number of threads that must invoke {@link #await}\n     *        before the barrier is tripped\n     * @throws illegalargumentexception if {@code parties} is less than 1\n     */\n    public cyclicbarrier(int parties) {\n        this(parties, null);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n# 应用场景\n\n# 场景一：多个线程执行读数据操作，读取完毕之后执行后续任务\n\npublic class test {\n\n    public static void main(string[] args) {\n        cyclicbarrier cyclicbarrier = new cyclicbarrier(8);\n        for (int i = 0; i < 8; i++) {\n            new thread(() -> {\n                try {\n                    system.out.println("读取" + thread.currentthread().getname());\n                    cyclicbarrier.await();\n                } catch (interruptedexception | brokenbarrierexception e) {\n                    e.printstacktrace();\n                }\n                system.out.println("后续操作" + thread.currentthread().getname());\n            }).start();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n运行结果\n\n读取thread-0\n读取thread-2\n读取thread-1\n读取thread-4\n读取thread-3\n读取thread-5\n读取thread-6\n读取thread-7\n后续操作thread-7\n后续操作thread-0\n后续操作thread-1\n后续操作thread-5\n后续操作thread-2\n后续操作thread-6\n后续操作thread-3\n后续操作thread-4\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 场景二：所有线程读取完毕之后，进行额外操作\n\n在这时候初始化cyclicbarrier时可以开启一个额外的runnable线程执行其他任务\n\npublic class test {\n\n    public static void main(string[] args) {\n        cyclicbarrier cyclicbarrier = new cyclicbarrier(8,\n                () -> system.out.println(thread.currentthread().getname() + "额外任务执行"));\n        for (int i = 0; i < 8; i++) {\n            new thread(() -> {\n                try {\n                    system.out.println("读取" + thread.currentthread().getname());\n                    cyclicbarrier.await();\n                } catch (interruptedexception | brokenbarrierexception e) {\n                    e.printstacktrace();\n                }\n                system.out.println("后续操作" + thread.currentthread().getname());\n            }).start();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n运行结果\n\n读取thread-0\n读取thread-3\n读取thread-2\n读取thread-1\n读取thread-5\n读取thread-4\n读取thread-6\n读取thread-7\nthread-1额外任务执行\n后续操作thread-1\n后续操作thread-0\n后续操作thread-5\n后续操作thread-7\n后续操作thread-3\n后续操作thread-2\n后续操作thread-6\n后续操作thread-4\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n可以看出，当读取操作完成之后，这8个线程都到达了barrier状态，此时会随机其中的一个线程去执行额外的任务，这个执行额外任务的线程执行完毕之后，就会接着执行后续的任务。\n\n# 特性：指定await时间\n\npublic class test {\n\n    public static void main(string[] args) {\n        cyclicbarrier cyclicbarrier = new cyclicbarrier(8);\n        for (int i = 0; i < 8; i++) {\n            if (i < 7) {\n                new thread(() -> {\n                    try {\n                        system.out.println("读取" + thread.currentthread().getname());\n                        cyclicbarrier.await(100, timeunit.milliseconds);\n                    } catch (interruptedexception | brokenbarrierexception | timeoutexception e) {\n                        e.printstacktrace();\n                    }\n                    system.out.println("后续操作" + thread.currentthread().getname());\n                }).start();\n            } else {\n                new thread(() -> {\n                    try {\n                        thread.sleep(5000);\n                        system.out.println("读取" + thread.currentthread().getname());\n                        cyclicbarrier.await(100, timeunit.milliseconds);\n                    } catch (interruptedexception | brokenbarrierexception | timeoutexception e) {\n                        e.printstacktrace();\n                    }\n                    system.out.println("后续操作" + thread.currentthread().getname());\n                }).start();\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n运行结果\n\n读取thread-0\n读取thread-2\n读取thread-1\n读取thread-3\n读取thread-4\n读取thread-5\n读取thread-6\njava.util.concurrent.brokenbarrierexception\n\tat java.util.concurrent.cyclicbarrier.dowait(cyclicbarrier.java:250)\n\tat java.util.concurrent.cyclicbarrier.await(cyclicbarrier.java:435)\n\tat com.tencent.ioc.duty.event.service.impl.test.lambda$main$0(test.java:21)\n\tat java.lang.thread.run(thread.java:748)\njava.util.concurrent.timeoutexception\n\tat java.util.concurrent.cyclicbarrier.dowait(cyclicbarrier.java:257)\n\tat java.util.concurrent.cyclicbarrier.await(cyclicbarrier.java:435)\n\tat com.tencent.ioc.duty.event.service.impl.test.lambda$main$0(test.java:21)\n\tat java.lang.thread.run(thread.java:748)\njava.util.concurrent.brokenbarrierexception\n\tat java.util.concurrent.cyclicbarrier.dowait(cyclicbarrier.java:250)\n\tat java.util.concurrent.cyclicbarrier.await(cyclicbarrier.java:435)\n\tat com.tencent.ioc.duty.event.service.impl.test.lambda$main$0(test.java:21)\n\tat java.lang.thread.run(thread.java:748)\njava.util.concurrent.brokenbarrierexception\n\tat java.util.concurrent.cyclicbarrier.dowait(cyclicbarrier.java:250)\n\tat java.util.concurrent.cyclicbarrier.await(cyclicbarrier.java:435)\n\tat com.tencent.ioc.duty.event.service.impl.test.lambda$main$0(test.java:21)\n\tat java.lang.thread.run(thread.java:748)\njava.util.concurrent.brokenbarrierexception\n\tat java.util.concurrent.cyclicbarrier.dowait(cyclicbarrier.java:250)\n\tat java.util.concurrent.cyclicbarrier.await(cyclicbarrier.java:435)\n\tat com.tencent.ioc.duty.event.service.impl.test.lambda$main$0(test.java:21)\n\tat java.lang.thread.run(thread.java:748)\njava.util.concurrent.brokenbarrierexception\n\tat java.util.concurrent.cyclicbarrier.dowait(cyclicbarrier.java:250)\n\tat java.util.concurrent.cyclicbarrier.await(cyclicbarrier.java:435)\n\tat com.tencent.ioc.duty.event.service.impl.test.lambda$main$0(test.java:21)\n\tat java.lang.thread.run(thread.java:748)\njava.util.concurrent.brokenbarrierexception\n\tat java.util.concurrent.cyclicbarrier.dowait(cyclicbarrier.java:250)\n\tat java.util.concurrent.cyclicbarrier.await(cyclicbarrier.java:435)\n\tat com.tencent.ioc.duty.event.service.impl.test.lambda$main$0(test.java:21)\n\tat java.lang.thread.run(thread.java:748)\n后续操作thread-3\n后续操作thread-4\n后续操作thread-6\n后续操作thread-5\n后续操作thread-2\n后续操作thread-1\n后续操作thread-0\n读取thread-7\n后续操作thread-7\njava.util.concurrent.brokenbarrierexception\n\tat java.util.concurrent.cyclicbarrier.dowait(cyclicbarrier.java:207)\n\tat java.util.concurrent.cyclicbarrier.await(cyclicbarrier.java:435)\n\tat com.tencent.ioc.duty.event.service.impl.test.lambda$main$1(test.java:32)\n\tat java.lang.thread.run(thread.java:748)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n这个场景模拟其中一个线程延迟执行，await等待时间内，检测到最后一个线程还没有到达栅栏，就会直接抛出异常让到达栅栏的线程继续执行后面的任务\n\n# 特性：可复用\n\npublic class test {\n\n    public static void main(string[] args) throws interruptedexception {\n        cyclicbarrier cyclicbarrier = new cyclicbarrier(5);\n        for (int i = 0; i < 5; i++) {\n            new thread(() -> {\n                try {\n                    system.out.println("读取" + thread.currentthread().getname());\n                    cyclicbarrier.await();\n                } catch (interruptedexception | brokenbarrierexception e) {\n                    e.printstacktrace();\n                }\n                system.out.println("后续操作" + thread.currentthread().getname());\n            }).start();\n        }\n        thread.sleep(5000);\n        system.out.println("cyclicbarrier复用");\n        for (int i = 0; i < 5; i++) {\n            new thread(() -> {\n                try {\n                    system.out.println("读取" + thread.currentthread().getname());\n                    cyclicbarrier.await();\n                } catch (interruptedexception | brokenbarrierexception e) {\n                    e.printstacktrace();\n                }\n                system.out.println("后续操作" + thread.currentthread().getname());\n            }).start();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n运行结果\n\n读取thread-0\n读取thread-1\n读取thread-2\n读取thread-3\n读取thread-4\n后续操作thread-4\n后续操作thread-0\n后续操作thread-2\n后续操作thread-3\n后续操作thread-1\ncyclicbarrier复用\n读取thread-5\n读取thread-6\n读取thread-7\n读取thread-8\n读取thread-9\n后续操作thread-9\n后续操作thread-5\n后续操作thread-8\n后续操作thread-7\n后续操作thread-6\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n这里的可复用不是代表的线程复用，而是指的当之前的所有线程都达到栅栏之后，初始化的栅栏仍然能够在下一次线程操作复用，而不像countdownlatch一样减为0之后就无法再使用了。',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"Semaphore使用方法",frontmatter:{title:"Semaphore使用方法",date:"2022-01-18T22:35:48.000Z",categories:["Java"],tags:["Java","JUC"],permalink:"/pages/8e40cc/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/01.Java/01.Java/03.Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/05.Semaphore%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.html",relativePath:"01.Java/01.Java/03.Java-多线程与并发/05.Semaphore使用方法.md",key:"v-49bdbdb9",path:"/pages/8e40cc/",headers:[{level:3,title:"Semaphore使用方法",slug:"semaphore使用方法",normalizedTitle:"semaphore使用方法",charIndex:2},{level:4,title:"构造方法",slug:"构造方法",normalizedTitle:"构造方法",charIndex:110},{level:4,title:"常用方法",slug:"常用方法",normalizedTitle:"常用方法",charIndex:1329},{level:4,title:"使用案例",slug:"使用案例",normalizedTitle:"使用案例",charIndex:2265},{level:4,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:9359}],headersStr:"Semaphore使用方法 构造方法 常用方法 使用案例 参考文章",content:'# Semaphore使用方法\n\nSemaphore可以翻译为信号量，Semaphore可以控制同时访问的线程个数，通过acquire()获取一个许可，如果没有许可就等待，release()方法则可以释放一个许可\n\n# 构造方法\n\n    /**\n     * Creates a {@code Semaphore} with the given number of\n     * permits and nonfair fairness setting.\n     *\n     * @param permits the initial number of permits available.\n     *        This value may be negative, in which case releases\n     *        must occur before any acquires will be granted.\n     */\n    public Semaphore(int permits) {\n        sync = new NonfairSync(permits);\n    }\n\n    /**\n     * Creates a {@code Semaphore} with the given number of\n     * permits and the given fairness setting.\n     *\n     * @param permits the initial number of permits available.\n     *        This value may be negative, in which case releases\n     *        must occur before any acquires will be granted.\n     * @param fair {@code true} if this semaphore will guarantee\n     *        first-in first-out granting of permits under contention,\n     *        else {@code false}\n     */\n    public Semaphore(int permits, boolean fair) {\n        sync = fair ? new FairSync(permits) : new NonfairSync(permits);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n * permits表示许可线程的数量\n * fair表示公平性，如果为true则线程为先进先出\n\n# 常用方法\n\npublic void acquire() throws InterruptedException {  }     //获取一个许可\npublic void acquire(int permits) throws InterruptedException { }    //获取permits个许可\npublic void release() { }          //释放一个许可\npublic void release(int permits) { }    //释放permits个许可\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\nacquire()用来获取一个许可，若无许可能够获得，则会一直等待，直到获得许可\n\nrelease()用来释放许可。注意，在释放许可之前，必须先获获得许可\n\n这4个方法都会被阻塞，如果想立即执行得到结果，可以使用以下方法：\n\n//尝试获取一个许可，若获取成功，则立即返回true，若获取失败，则立即返回false\npublic boolean tryAcquire() { };    \n//尝试获取一个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false\npublic boolean tryAcquire(long timeout, TimeUnit unit) throws InterruptedException { };  \n//尝试获取permits个许可，若获取成功，则立即返回true，若获取失败，则立即返回false\npublic boolean tryAcquire(int permits) { }; \n//尝试获取permits个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false\npublic boolean tryAcquire(int permits, long timeout, TimeUnit unit) throws InterruptedException { }; \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n另外还可以通过availablePermits()方法得到可用的许可数目。\n\n# 使用案例\n\n**案例一：**假若一个工厂有5台机器，但是有8个工人，一台机器同时只能被一个工人使用，只有使用完了，其他工人才能继续使用。那么我们就可以通过Semaphore来实现\n\npublic class Test {\n\n    public static void main(String[] args) {\n        // 工人数目\n        int n = 8;\n        // 机器数目\n        Semaphore semaphore = new Semaphore(5);\n        for (int i = 0; i < n; i++) {\n            int finalI = i;\n            new Thread(() -> {\n                try {\n                    semaphore.acquire();\n                    System.out.println("工人" + finalI + "占用一个机器在生产");\n                    Thread.sleep(2000);\n                    System.out.println("工人" + finalI + "释放出机器");\n                    semaphore.release();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }).start();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n在获取许可之后，我们sleep一下当前线程，让他不要那么快进行释放，观察运行的结果\n\n运行结果\n\n工人0占用一个机器在生产\n工人3占用一个机器在生产\n工人2占用一个机器在生产\n工人1占用一个机器在生产\n工人4占用一个机器在生产\n工人3释放出机器\n工人4释放出机器\n工人0释放出机器\n工人1释放出机器\n工人2释放出机器\n工人6占用一个机器在生产\n工人5占用一个机器在生产\n工人7占用一个机器在生产\n工人6释放出机器\n工人7释放出机器\n工人5释放出机器\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n可以发现，当规定Semaphore的permits为5时，最多有5个线程获取许可，剩余的线程必须等待许可释放之后才能获取许可\n\n**案例二：**流量控制\n\nSemaphore可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。假如有一个需求， 要读取几万个文件的数据，因为都是 IO 密集型任务，我们可以启动几十个线程并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有 10 个，这时我们必须控制只有 10 个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这个时候，就可以使用 Semaphore 来做流量控制。\n\npublic class ConnectionSemaphore {\n\n    private final static int CONNECTION_SIZE = 10;\n    // 两个信号量，分别表示可用连接和已用连接\n    private final Semaphore userFulLink, useLessLink;\n    // 存放数据库链接的容器，这里用Integer代替\n    private static final LinkedList<Integer> connectionPool = new LinkedList<>();\n\n    static {\n        for (int i = 0; i < CONNECTION_SIZE; i++) {\n            connectionPool.addLast(i);\n        }\n    }\n\n    public ConnectionSemaphore(Semaphore userFulLink, Semaphore useLessLink) {\n        this.userFulLink = userFulLink;\n        this.useLessLink = useLessLink;\n    }\n\n    /*归还连接*/\n    public void returnConnect(Integer connection) throws InterruptedException {\n        if (connection != null) {\n            System.out.println(\n                    "当前有" + userFulLink.getQueueLength() + "个线程等待数据库连接，" + "可用连接数:" + userFulLink\n                            .availablePermits());\n            useLessLink.acquire();\n            synchronized (connectionPool) {\n                connectionPool.addLast(connection);\n            }\n            userFulLink.release();\n        }\n    }\n\n    /*从池子拿连接*/\n    public Integer takeConnect() throws InterruptedException {\n        userFulLink.acquire();\n        Integer connection;\n        synchronized (connectionPool) {\n            connection = connectionPool.removeFirst();\n        }\n        useLessLink.release();\n        return connection;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n/**\n * 测试类\n */\npublic class Test {\n\n    private static ConnectionSemaphore connectionSemaphore = new ConnectionSemaphore();\n\n    private static class testThread implements Runnable {\n\n        @Override\n        public void run() {\n            // 模拟每个线程的不同持有时间\n            Random randomTime = new Random();\n            long start = System.currentTimeMillis();\n            try {\n                Integer connect = connectionSemaphore.takeConnect();\n                System.out.println(Thread.currentThread().getName()\n                        + "_获取数据库连接共耗时【" + (System.currentTimeMillis() - start) + "】ms.");\n                // 模拟业务，线程持有连接查询数据\n                Thread.sleep(100 + randomTime.nextInt(100));\n                System.out.println(Thread.currentThread().getName()+"_查询数据完成，释放连接");\n                connectionSemaphore.returnConnect(connect);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n        }\n    }\n\n    public static void main(String[] args) {\n        for (int i = 0; i < 15; i++) {\n            Thread thread = new Thread(new testThread());\n            thread.start();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n运行结果\n\nThread-14_获取数据库连接共耗时【0】ms.\nThread-13_获取数据库连接共耗时【0】ms.\nThread-8_获取数据库连接共耗时【0】ms.\nThread-0_获取数据库连接共耗时【1】ms.\nThread-10_获取数据库连接共耗时【0】ms.\nThread-11_获取数据库连接共耗时【0】ms.\nThread-6_获取数据库连接共耗时【0】ms.\nThread-12_获取数据库连接共耗时【0】ms.\nThread-1_获取数据库连接共耗时【2】ms.\nThread-9_获取数据库连接共耗时【0】ms.\nThread-0_查询数据完成，释放连接\nThread-14_查询数据完成，释放连接\n当前有5个线程等待数据库连接，可用连接数:0\n当前有5个线程等待数据库连接，可用连接数:0\nThread-7_获取数据库连接共耗时【180】ms.\nThread-9_查询数据完成，释放连接\n当前有3个线程等待数据库连接，可用连接数:0\nThread-4_获取数据库连接共耗时【179】ms.\nThread-5_获取数据库连接共耗时【181】ms.\nThread-8_查询数据完成，释放连接\n当前有2个线程等待数据库连接，可用连接数:0\nThread-3_获取数据库连接共耗时【185】ms.\nThread-10_查询数据完成，释放连接\n当前有1个线程等待数据库连接，可用连接数:0\nThread-2_获取数据库连接共耗时【190】ms.\nThread-12_查询数据完成，释放连接\nThread-1_查询数据完成，释放连接\n当前有0个线程等待数据库连接，可用连接数:0\n当前有0个线程等待数据库连接，可用连接数:0\nThread-13_查询数据完成，释放连接\n当前有0个线程等待数据库连接，可用连接数:2\nThread-6_查询数据完成，释放连接\n当前有0个线程等待数据库连接，可用连接数:3\nThread-11_查询数据完成，释放连接\n当前有0个线程等待数据库连接，可用连接数:4\nThread-3_查询数据完成，释放连接\n当前有0个线程等待数据库连接，可用连接数:5\nThread-2_查询数据完成，释放连接\n当前有0个线程等待数据库连接，可用连接数:6\nThread-5_查询数据完成，释放连接\n当前有0个线程等待数据库连接，可用连接数:7\nThread-7_查询数据完成，释放连接\n当前有0个线程等待数据库连接，可用连接数:8\nThread-4_查询数据完成，释放连接\n当前有0个线程等待数据库连接，可用连接数:9\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n从打印结果可以看出，一次只有 10 个线程执行acquire()，只有线程进行release()方法后才会有别的线程执行acquire()。看到这里或许会疑惑在takeConnect中获取许可的是可用连接userFulLink，而释放许可的是useLessLink，在Semaphore中的release方法原本的注释如下\n\n    /**\n     * Releases a permit, returning it to the semaphore.\n     *\n     * <p>Releases a permit, increasing the number of available permits by\n     * one.  If any threads are trying to acquire a permit, then one is\n     * selected and given the permit that was just released.  That thread\n     * is (re)enabled for thread scheduling purposes.\n     *\n     * <p>There is no requirement that a thread that releases a permit must\n     * have acquired that permit by calling {@link #acquire}.\n     * Correct usage of a semaphore is established by programming convention\n     * in the application.\n     */\n    public void release() {\n        sync.releaseShared(1);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n> 释放许可证，将其返回给信号量。释放许可证，将可用许可证的数量增加一。如果任何线程试图获得许可，则选择一个线程并给予刚刚释放的许可。该线程（重新）启用用于线程调度目的。不要求释放许可的线程必须通过调用{@link acquire} 获得该许可。信号量的正确使用是通过应用程序中的编程约定建立的。\n\n这句话的意思就是说，release方法仅仅只是把许可证数量加一，在release之前不需要对应的信号量去执行acquire，那么这段代码的含义就可以理解为减少可用连接的数量，增加已用连接的数量，因为当一个线程持有连接之后可用连接应该-1，而已用的连接数应该+1，当一个线程执行完毕业务之后应该将已用连接-1，可用连接+1。\n\n需要注意的是：Semaphore只是对资源并发访问的线程数进行监控，并不会保证线程安全。\n\n# 参考文章\n\n> https://www.cnblogs.com/dolphin0520/p/3920397.html https://www.jianshu.com/p/0d53a643a60c',normalizedContent:'# semaphore使用方法\n\nsemaphore可以翻译为信号量，semaphore可以控制同时访问的线程个数，通过acquire()获取一个许可，如果没有许可就等待，release()方法则可以释放一个许可\n\n# 构造方法\n\n    /**\n     * creates a {@code semaphore} with the given number of\n     * permits and nonfair fairness setting.\n     *\n     * @param permits the initial number of permits available.\n     *        this value may be negative, in which case releases\n     *        must occur before any acquires will be granted.\n     */\n    public semaphore(int permits) {\n        sync = new nonfairsync(permits);\n    }\n\n    /**\n     * creates a {@code semaphore} with the given number of\n     * permits and the given fairness setting.\n     *\n     * @param permits the initial number of permits available.\n     *        this value may be negative, in which case releases\n     *        must occur before any acquires will be granted.\n     * @param fair {@code true} if this semaphore will guarantee\n     *        first-in first-out granting of permits under contention,\n     *        else {@code false}\n     */\n    public semaphore(int permits, boolean fair) {\n        sync = fair ? new fairsync(permits) : new nonfairsync(permits);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n * permits表示许可线程的数量\n * fair表示公平性，如果为true则线程为先进先出\n\n# 常用方法\n\npublic void acquire() throws interruptedexception {  }     //获取一个许可\npublic void acquire(int permits) throws interruptedexception { }    //获取permits个许可\npublic void release() { }          //释放一个许可\npublic void release(int permits) { }    //释放permits个许可\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\nacquire()用来获取一个许可，若无许可能够获得，则会一直等待，直到获得许可\n\nrelease()用来释放许可。注意，在释放许可之前，必须先获获得许可\n\n这4个方法都会被阻塞，如果想立即执行得到结果，可以使用以下方法：\n\n//尝试获取一个许可，若获取成功，则立即返回true，若获取失败，则立即返回false\npublic boolean tryacquire() { };    \n//尝试获取一个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false\npublic boolean tryacquire(long timeout, timeunit unit) throws interruptedexception { };  \n//尝试获取permits个许可，若获取成功，则立即返回true，若获取失败，则立即返回false\npublic boolean tryacquire(int permits) { }; \n//尝试获取permits个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false\npublic boolean tryacquire(int permits, long timeout, timeunit unit) throws interruptedexception { }; \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n另外还可以通过availablepermits()方法得到可用的许可数目。\n\n# 使用案例\n\n**案例一：**假若一个工厂有5台机器，但是有8个工人，一台机器同时只能被一个工人使用，只有使用完了，其他工人才能继续使用。那么我们就可以通过semaphore来实现\n\npublic class test {\n\n    public static void main(string[] args) {\n        // 工人数目\n        int n = 8;\n        // 机器数目\n        semaphore semaphore = new semaphore(5);\n        for (int i = 0; i < n; i++) {\n            int finali = i;\n            new thread(() -> {\n                try {\n                    semaphore.acquire();\n                    system.out.println("工人" + finali + "占用一个机器在生产");\n                    thread.sleep(2000);\n                    system.out.println("工人" + finali + "释放出机器");\n                    semaphore.release();\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n            }).start();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n在获取许可之后，我们sleep一下当前线程，让他不要那么快进行释放，观察运行的结果\n\n运行结果\n\n工人0占用一个机器在生产\n工人3占用一个机器在生产\n工人2占用一个机器在生产\n工人1占用一个机器在生产\n工人4占用一个机器在生产\n工人3释放出机器\n工人4释放出机器\n工人0释放出机器\n工人1释放出机器\n工人2释放出机器\n工人6占用一个机器在生产\n工人5占用一个机器在生产\n工人7占用一个机器在生产\n工人6释放出机器\n工人7释放出机器\n工人5释放出机器\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n可以发现，当规定semaphore的permits为5时，最多有5个线程获取许可，剩余的线程必须等待许可释放之后才能获取许可\n\n**案例二：**流量控制\n\nsemaphore可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。假如有一个需求， 要读取几万个文件的数据，因为都是 io 密集型任务，我们可以启动几十个线程并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有 10 个，这时我们必须控制只有 10 个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这个时候，就可以使用 semaphore 来做流量控制。\n\npublic class connectionsemaphore {\n\n    private final static int connection_size = 10;\n    // 两个信号量，分别表示可用连接和已用连接\n    private final semaphore userfullink, uselesslink;\n    // 存放数据库链接的容器，这里用integer代替\n    private static final linkedlist<integer> connectionpool = new linkedlist<>();\n\n    static {\n        for (int i = 0; i < connection_size; i++) {\n            connectionpool.addlast(i);\n        }\n    }\n\n    public connectionsemaphore(semaphore userfullink, semaphore uselesslink) {\n        this.userfullink = userfullink;\n        this.uselesslink = uselesslink;\n    }\n\n    /*归还连接*/\n    public void returnconnect(integer connection) throws interruptedexception {\n        if (connection != null) {\n            system.out.println(\n                    "当前有" + userfullink.getqueuelength() + "个线程等待数据库连接，" + "可用连接数:" + userfullink\n                            .availablepermits());\n            uselesslink.acquire();\n            synchronized (connectionpool) {\n                connectionpool.addlast(connection);\n            }\n            userfullink.release();\n        }\n    }\n\n    /*从池子拿连接*/\n    public integer takeconnect() throws interruptedexception {\n        userfullink.acquire();\n        integer connection;\n        synchronized (connectionpool) {\n            connection = connectionpool.removefirst();\n        }\n        uselesslink.release();\n        return connection;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n/**\n * 测试类\n */\npublic class test {\n\n    private static connectionsemaphore connectionsemaphore = new connectionsemaphore();\n\n    private static class testthread implements runnable {\n\n        @override\n        public void run() {\n            // 模拟每个线程的不同持有时间\n            random randomtime = new random();\n            long start = system.currenttimemillis();\n            try {\n                integer connect = connectionsemaphore.takeconnect();\n                system.out.println(thread.currentthread().getname()\n                        + "_获取数据库连接共耗时【" + (system.currenttimemillis() - start) + "】ms.");\n                // 模拟业务，线程持有连接查询数据\n                thread.sleep(100 + randomtime.nextint(100));\n                system.out.println(thread.currentthread().getname()+"_查询数据完成，释放连接");\n                connectionsemaphore.returnconnect(connect);\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n\n        }\n    }\n\n    public static void main(string[] args) {\n        for (int i = 0; i < 15; i++) {\n            thread thread = new thread(new testthread());\n            thread.start();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n运行结果\n\nthread-14_获取数据库连接共耗时【0】ms.\nthread-13_获取数据库连接共耗时【0】ms.\nthread-8_获取数据库连接共耗时【0】ms.\nthread-0_获取数据库连接共耗时【1】ms.\nthread-10_获取数据库连接共耗时【0】ms.\nthread-11_获取数据库连接共耗时【0】ms.\nthread-6_获取数据库连接共耗时【0】ms.\nthread-12_获取数据库连接共耗时【0】ms.\nthread-1_获取数据库连接共耗时【2】ms.\nthread-9_获取数据库连接共耗时【0】ms.\nthread-0_查询数据完成，释放连接\nthread-14_查询数据完成，释放连接\n当前有5个线程等待数据库连接，可用连接数:0\n当前有5个线程等待数据库连接，可用连接数:0\nthread-7_获取数据库连接共耗时【180】ms.\nthread-9_查询数据完成，释放连接\n当前有3个线程等待数据库连接，可用连接数:0\nthread-4_获取数据库连接共耗时【179】ms.\nthread-5_获取数据库连接共耗时【181】ms.\nthread-8_查询数据完成，释放连接\n当前有2个线程等待数据库连接，可用连接数:0\nthread-3_获取数据库连接共耗时【185】ms.\nthread-10_查询数据完成，释放连接\n当前有1个线程等待数据库连接，可用连接数:0\nthread-2_获取数据库连接共耗时【190】ms.\nthread-12_查询数据完成，释放连接\nthread-1_查询数据完成，释放连接\n当前有0个线程等待数据库连接，可用连接数:0\n当前有0个线程等待数据库连接，可用连接数:0\nthread-13_查询数据完成，释放连接\n当前有0个线程等待数据库连接，可用连接数:2\nthread-6_查询数据完成，释放连接\n当前有0个线程等待数据库连接，可用连接数:3\nthread-11_查询数据完成，释放连接\n当前有0个线程等待数据库连接，可用连接数:4\nthread-3_查询数据完成，释放连接\n当前有0个线程等待数据库连接，可用连接数:5\nthread-2_查询数据完成，释放连接\n当前有0个线程等待数据库连接，可用连接数:6\nthread-5_查询数据完成，释放连接\n当前有0个线程等待数据库连接，可用连接数:7\nthread-7_查询数据完成，释放连接\n当前有0个线程等待数据库连接，可用连接数:8\nthread-4_查询数据完成，释放连接\n当前有0个线程等待数据库连接，可用连接数:9\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n从打印结果可以看出，一次只有 10 个线程执行acquire()，只有线程进行release()方法后才会有别的线程执行acquire()。看到这里或许会疑惑在takeconnect中获取许可的是可用连接userfullink，而释放许可的是uselesslink，在semaphore中的release方法原本的注释如下\n\n    /**\n     * releases a permit, returning it to the semaphore.\n     *\n     * <p>releases a permit, increasing the number of available permits by\n     * one.  if any threads are trying to acquire a permit, then one is\n     * selected and given the permit that was just released.  that thread\n     * is (re)enabled for thread scheduling purposes.\n     *\n     * <p>there is no requirement that a thread that releases a permit must\n     * have acquired that permit by calling {@link #acquire}.\n     * correct usage of a semaphore is established by programming convention\n     * in the application.\n     */\n    public void release() {\n        sync.releaseshared(1);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n> 释放许可证，将其返回给信号量。释放许可证，将可用许可证的数量增加一。如果任何线程试图获得许可，则选择一个线程并给予刚刚释放的许可。该线程（重新）启用用于线程调度目的。不要求释放许可的线程必须通过调用{@link acquire} 获得该许可。信号量的正确使用是通过应用程序中的编程约定建立的。\n\n这句话的意思就是说，release方法仅仅只是把许可证数量加一，在release之前不需要对应的信号量去执行acquire，那么这段代码的含义就可以理解为减少可用连接的数量，增加已用连接的数量，因为当一个线程持有连接之后可用连接应该-1，而已用的连接数应该+1，当一个线程执行完毕业务之后应该将已用连接-1，可用连接+1。\n\n需要注意的是：semaphore只是对资源并发访问的线程数进行监控，并不会保证线程安全。\n\n# 参考文章\n\n> https://www.cnblogs.com/dolphin0520/p/3920397.html https://www.jianshu.com/p/0d53a643a60c',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"CompletableFuture常用用法及踩坑",frontmatter:{title:"CompletableFuture常用用法及踩坑",categories:["Java"],tags:["Java","JUC","CompletableFuture"],date:"2022-06-06T21:05:25.000Z",permalink:"/pages/b1318d/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/01.Java/01.Java/03.Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/06.CompletableFuture%E5%B8%B8%E7%94%A8%E7%94%A8%E6%B3%95%E5%8F%8A%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5.html",relativePath:"01.Java/01.Java/03.Java-多线程与并发/06.CompletableFuture常用用法及问题排查.md",key:"v-45d73e1d",path:"/pages/b1318d/",headers:[{level:3,title:"CompletableFuture常用用法及踩坑",slug:"completablefuture常用用法及踩坑",normalizedTitle:"completablefuture常用用法及踩坑",charIndex:2},{level:4,title:"适用场景",slug:"适用场景",normalizedTitle:"适用场景",charIndex:158},{level:4,title:"场景一",slug:"场景一",normalizedTitle:"场景一",charIndex:239},{level:5,title:"如果不join会发生什么？",slug:"如果不join会发生什么",normalizedTitle:"如果不join会发生什么？",charIndex:1449},{level:4,title:"场景二",slug:"场景二",normalizedTitle:"场景二",charIndex:1514},{level:5,title:"踩坑场景",slug:"踩坑场景",normalizedTitle:"踩坑场景",charIndex:3820},{level:4,title:"场景三",slug:"场景三",normalizedTitle:"场景三",charIndex:4439},{level:5,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:6551}],headersStr:"CompletableFuture常用用法及踩坑 适用场景 场景一 如果不join会发生什么？ 场景二 踩坑场景 场景三 运行结果",content:'# CompletableFuture常用用法及踩坑\n\n作为常用的并发类，CompletableFuture在项目中会经常使用，其作用与Google的ListenableFuture类似；\n\n总结来说CompletableFuture比Future多出了流式计算，返回值，异步回调，多Future组合的功能。\n\n# 适用场景\n\n * 某个接口不好修改，又没有提供批量的方法时\n * 需要异步调用接口时\n * CPU密集型任务，计算场景多，或多个不关联的接口需要同时调用时\n\n# 场景一\n\n问题：系统中存量老接口，逻辑复杂，改造成本大。\n\n解决方案：利用CompletableFuture提交多个任务分别执行逻辑，join等待所有任务执行完毕\n\n// 模拟功能：根据某个id列表，查询得到与id相关的数据，其中查询得到与id相关数据的过程非常复杂且耗时\n// executor为全局线程池\n\nList<MockDTO> results = Collections.synchronizedList(new ArrayList<>());\n\nList<String> mockIds = new ArrayList<>();\nList<CompletableFuture<Void>> futures = new ArrayList<>();\nmockIds.forEach(mockId -> {\n    CompletableFuture<Void> res = CompletableFuture.supplyAsync(() -> {\n        // 根据mockId组装查询实体\n      \tMockDTO mockdto = new MockDTO();\n        mockdto.setId(mockId);\n        \n        // 调用存量老接口\n        List<MockDTO> result = mockService\n                .getDataByMockIds(mockdto);\n        return result;\n    },executor).thenAccept(results::addAll).exceptionally(ex -> {\n        throw new RuntimeException(ex.getMessage() + "异步数据获取执行异常");\n    });\n    futures.add(res);\n});\nfutures.forEach(CompletableFuture::join);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n * 这一场景描述一个典型的问题，当存量接口不好更改，查询速度很慢时，我们可以通过简单的CompletableFuture任务来并行执行。\n * 由于返回值是List的原因，需要注意并发add问题，可采用一个synchronizedList来解决。\n * 对于每一个任务返回之后执行thenAccept将返回数据加入到results中。\n * 同时，主线程需要等待异步线程全部执行完毕才返回结果，即join操作。\n\n# 如果不join会发生什么？\n\n主线程会很快就执行完毕，异步线程还没有执行完，主线程就返回了结果，这个结果必然不是我们预期的\n\n# 场景二\n\n问题：异步调用接口，比如消息发送接口，不能够阻塞主流程，但又需要获取返回值/知道本次调用是否成功\n\n解决方案：CompletableFuture异步调用+handle同时处理结果和异常\n\nhandle与whenComplete均可\n\n以一个更容易踩坑的异步调用第三方接口为例\n\nlog.info("url={}, messageDTO={}", serverUrl, messageDTO);\nString jsonParams = JacksonUtils.toJson(messageDTO);\nHttpHeaders headers = new HttpHeaders();\nheaders.set("Content-Type", "application/json");\nHttpEntity<String> entity = new HttpEntity<>(jsonParams, headers);\nAtomicReference<JSONObject> responseJsonObject = new AtomicReference<>();\nlog.info("==============Entity=========={}",entity);\ntry {\n    CompletableFuture future = CompletableFuture.supplyAsync(() -> {\n        // 一定要设置超时时间\n        ResponseEntity<JSONObject> exchange = restTemplate.exchange(serverUrl, HttpMethod.POST, entity,\n                JSONObject.class);\n        return exchange;\n    },asyncTaskExecutor)\n            .handle((exchange, ex) -> {\n                if (ex == null) {\n                    if (exchange.hasBody()) {\n                        responseJsonObject.set(exchange.getBody());\n                        log.info("=========Message body========={}", responseJsonObject);\n                        //当返回对象为空或者不为规定的code时，接口失败\n                        if (responseJsonObject.get() == null || !responseJsonObject.get().getString("code").equals("200")) {\n                            String errCode = responseJsonObject.get().getString("code");\n                            String errMsg = responseJsonObject.get().getString("message");\n                            log.warn("消息接口应答码不成功，错误代码:{}，返回消息{}",errCode,errMsg);\n                        } else {\n                            log.info("消息接口返回成功，返回消息{}",exchange.getBody());\n                        }\n                    } else {\n                        log.warn("消息接口返回body不存在");\n                    }\n                } else {\n                    log.warn("=========消息发送失败,第三方提供接口异常========={}",ex.getMessage());\n                }\n                return null;\n            });\n} catch (Exception e) {\n    log.warn("异步线程内部异常",e);\n}\nlog.info("发送消息主线程执行完毕");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n以上代码逻辑很简单，处理原则就是有异常处理异常，没有异常就正常解析返回值。同时打印足量的日志方便排查。\n\n# 踩坑场景\n\n对于调用非主流程接口，如发送消息等，其调用原则不应该阻塞主流程，同时出现错误可不用抛出异常，以免发生主流程正常执行，但发送消息失败，消息模块抛出异常造成主流程回滚。本文不讨论消息如何可靠，只考虑作为生产者，在不引入中间件的情况下，如何简单快速的对接第三方消息接口。\n\n处理原则：\n\n 1. 对于一般的RPC，如Fegin、Dubbo等。或者外部提供的接口/或需要走RestTemplate的接口。\n    \n    设置RPC或者全局RestTemplate的超时时间\n    \n    如果不设置超时时间，运行上述代码时会发现，明明主线程执行完毕，异步线程没有直接报错，但异步线程的结果迟迟没有返回(假设调用的接口网络不通，且没有回TCP包，没有快速失败)，也没有打印日志。以RestTemplate为例，其默认的超时时间为30s，也就是说其实不是不会打印日志，只是30秒之后才觉得调用的接口网络不通。很久才打印日志，会让我们排查问题时变得疑惑\n\n 2. 对于直接调用的Service服务：即时返回结果，可不做超时设置\n\n提示\n\n注意点： CompletableFuture在本地测试的时候会发现，主线程执行完毕了，异步线程一直没有返回，这是因为如果使用java的主线程方法测试，那么运行结束后，程序就退出了，异步线程自然也就没有了。对于Web项目，调用该方法时，只是主线程结束，但程序没有退出，异步线程依旧可以运行\n\n# 场景三\n\n问题：多个不相关的任务，并行计算\n\n解决方案：多个CompletableFuture异步计算，使用allOf+join\n\nList<CompletableFuture> futures = new ArrayList<>(3);\nList<Double> result = new ArrayList<>();\n// 创建异步执行任务:\nCompletableFuture<List<Double>> cf = CompletableFuture.supplyAsync(() -> {\n    System.out.println(\n            Thread.currentThread() + " start job1,time->" + System.currentTimeMillis());\n    // 执行业务逻辑\n    result.add(1.2);\n    System.out.println(\n            Thread.currentThread() + " exit job1,time->" + System.currentTimeMillis());\n    return result;\n});\nCompletableFuture<List<Double>> cf2 = CompletableFuture.supplyAsync(() -> {\n    System.out.println(\n            Thread.currentThread() + " start job2,time->" + System.currentTimeMillis());\n    // 执行业务逻辑\n    result.add(3.2);\n    System.out.println(\n            Thread.currentThread() + " exit job2,time->" + System.currentTimeMillis());\n    return result;\n});\nCompletableFuture<List<Double>> cf3 = CompletableFuture.supplyAsync(() -> {\n    System.out.println(\n            Thread.currentThread() + " start job3,time->" + System.currentTimeMillis());\n    // 执行业务逻辑\n    result.add(2.2);\n    System.out.println(\n            Thread.currentThread() + " exit job3,time->" + System.currentTimeMillis());\n    return result;\n});\nfutures.add(cf);\nfutures.add(cf2);\nfutures.add(cf3);\n//allof等待所有任务执行完成才执行cf4，如果有一个任务异常终止，则cf4.get时会抛出异常，都是正常执行，cf4.get返回null\n//anyOf是只有一个任务执行完成，无论是正常执行或者执行异常，都会执行cf4，cf4.get的结果就是已执行完成的任务的执行结果\nCompletableFuture<Void> cf4 = CompletableFuture\n        .allOf(futures.toArray(new CompletableFuture[0]));\n\nSystem.out.println("main thread start cf4.get(),time->" + System.currentTimeMillis());\n//等待子任务执行完成\ncf4.join();\nSystem.out.println("子任务状态" + cf.isDone() + " " + cf2.isDone() + " " + cf3.isDone());\nSystem.out.println("计算结果" + result);\nSystem.out.println("main thread exit,time->" + System.currentTimeMillis());\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n# 运行结果\n\nThread[ForkJoinPool.commonPool-worker-9,5,main] start job1,time->1654514454630\nThread[ForkJoinPool.commonPool-worker-9,5,main] exit job1,time->1654514454630\nThread[ForkJoinPool.commonPool-worker-9,5,main] start job2,time->1654514454631\nThread[ForkJoinPool.commonPool-worker-9,5,main] exit job2,time->1654514454631\nThread[ForkJoinPool.commonPool-worker-9,5,main] start job3,time->1654514454631\nThread[ForkJoinPool.commonPool-worker-9,5,main] exit job3,time->1654514454631\nmain thread start cf4.get(),time->1654514454631\n子任务状态true true true\n计算结果[1.2, 3.2, 2.2]\nmain thread exit,time->1654514454633\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n异步线程依次执行，同时主线程等待所有子任务执行完毕，等到子任务执行完之后汇总结果，最后主线程退出。',normalizedContent:'# completablefuture常用用法及踩坑\n\n作为常用的并发类，completablefuture在项目中会经常使用，其作用与google的listenablefuture类似；\n\n总结来说completablefuture比future多出了流式计算，返回值，异步回调，多future组合的功能。\n\n# 适用场景\n\n * 某个接口不好修改，又没有提供批量的方法时\n * 需要异步调用接口时\n * cpu密集型任务，计算场景多，或多个不关联的接口需要同时调用时\n\n# 场景一\n\n问题：系统中存量老接口，逻辑复杂，改造成本大。\n\n解决方案：利用completablefuture提交多个任务分别执行逻辑，join等待所有任务执行完毕\n\n// 模拟功能：根据某个id列表，查询得到与id相关的数据，其中查询得到与id相关数据的过程非常复杂且耗时\n// executor为全局线程池\n\nlist<mockdto> results = collections.synchronizedlist(new arraylist<>());\n\nlist<string> mockids = new arraylist<>();\nlist<completablefuture<void>> futures = new arraylist<>();\nmockids.foreach(mockid -> {\n    completablefuture<void> res = completablefuture.supplyasync(() -> {\n        // 根据mockid组装查询实体\n      \tmockdto mockdto = new mockdto();\n        mockdto.setid(mockid);\n        \n        // 调用存量老接口\n        list<mockdto> result = mockservice\n                .getdatabymockids(mockdto);\n        return result;\n    },executor).thenaccept(results::addall).exceptionally(ex -> {\n        throw new runtimeexception(ex.getmessage() + "异步数据获取执行异常");\n    });\n    futures.add(res);\n});\nfutures.foreach(completablefuture::join);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n * 这一场景描述一个典型的问题，当存量接口不好更改，查询速度很慢时，我们可以通过简单的completablefuture任务来并行执行。\n * 由于返回值是list的原因，需要注意并发add问题，可采用一个synchronizedlist来解决。\n * 对于每一个任务返回之后执行thenaccept将返回数据加入到results中。\n * 同时，主线程需要等待异步线程全部执行完毕才返回结果，即join操作。\n\n# 如果不join会发生什么？\n\n主线程会很快就执行完毕，异步线程还没有执行完，主线程就返回了结果，这个结果必然不是我们预期的\n\n# 场景二\n\n问题：异步调用接口，比如消息发送接口，不能够阻塞主流程，但又需要获取返回值/知道本次调用是否成功\n\n解决方案：completablefuture异步调用+handle同时处理结果和异常\n\nhandle与whencomplete均可\n\n以一个更容易踩坑的异步调用第三方接口为例\n\nlog.info("url={}, messagedto={}", serverurl, messagedto);\nstring jsonparams = jacksonutils.tojson(messagedto);\nhttpheaders headers = new httpheaders();\nheaders.set("content-type", "application/json");\nhttpentity<string> entity = new httpentity<>(jsonparams, headers);\natomicreference<jsonobject> responsejsonobject = new atomicreference<>();\nlog.info("==============entity=========={}",entity);\ntry {\n    completablefuture future = completablefuture.supplyasync(() -> {\n        // 一定要设置超时时间\n        responseentity<jsonobject> exchange = resttemplate.exchange(serverurl, httpmethod.post, entity,\n                jsonobject.class);\n        return exchange;\n    },asynctaskexecutor)\n            .handle((exchange, ex) -> {\n                if (ex == null) {\n                    if (exchange.hasbody()) {\n                        responsejsonobject.set(exchange.getbody());\n                        log.info("=========message body========={}", responsejsonobject);\n                        //当返回对象为空或者不为规定的code时，接口失败\n                        if (responsejsonobject.get() == null || !responsejsonobject.get().getstring("code").equals("200")) {\n                            string errcode = responsejsonobject.get().getstring("code");\n                            string errmsg = responsejsonobject.get().getstring("message");\n                            log.warn("消息接口应答码不成功，错误代码:{}，返回消息{}",errcode,errmsg);\n                        } else {\n                            log.info("消息接口返回成功，返回消息{}",exchange.getbody());\n                        }\n                    } else {\n                        log.warn("消息接口返回body不存在");\n                    }\n                } else {\n                    log.warn("=========消息发送失败,第三方提供接口异常========={}",ex.getmessage());\n                }\n                return null;\n            });\n} catch (exception e) {\n    log.warn("异步线程内部异常",e);\n}\nlog.info("发送消息主线程执行完毕");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n以上代码逻辑很简单，处理原则就是有异常处理异常，没有异常就正常解析返回值。同时打印足量的日志方便排查。\n\n# 踩坑场景\n\n对于调用非主流程接口，如发送消息等，其调用原则不应该阻塞主流程，同时出现错误可不用抛出异常，以免发生主流程正常执行，但发送消息失败，消息模块抛出异常造成主流程回滚。本文不讨论消息如何可靠，只考虑作为生产者，在不引入中间件的情况下，如何简单快速的对接第三方消息接口。\n\n处理原则：\n\n 1. 对于一般的rpc，如fegin、dubbo等。或者外部提供的接口/或需要走resttemplate的接口。\n    \n    设置rpc或者全局resttemplate的超时时间\n    \n    如果不设置超时时间，运行上述代码时会发现，明明主线程执行完毕，异步线程没有直接报错，但异步线程的结果迟迟没有返回(假设调用的接口网络不通，且没有回tcp包，没有快速失败)，也没有打印日志。以resttemplate为例，其默认的超时时间为30s，也就是说其实不是不会打印日志，只是30秒之后才觉得调用的接口网络不通。很久才打印日志，会让我们排查问题时变得疑惑\n\n 2. 对于直接调用的service服务：即时返回结果，可不做超时设置\n\n提示\n\n注意点： completablefuture在本地测试的时候会发现，主线程执行完毕了，异步线程一直没有返回，这是因为如果使用java的主线程方法测试，那么运行结束后，程序就退出了，异步线程自然也就没有了。对于web项目，调用该方法时，只是主线程结束，但程序没有退出，异步线程依旧可以运行\n\n# 场景三\n\n问题：多个不相关的任务，并行计算\n\n解决方案：多个completablefuture异步计算，使用allof+join\n\nlist<completablefuture> futures = new arraylist<>(3);\nlist<double> result = new arraylist<>();\n// 创建异步执行任务:\ncompletablefuture<list<double>> cf = completablefuture.supplyasync(() -> {\n    system.out.println(\n            thread.currentthread() + " start job1,time->" + system.currenttimemillis());\n    // 执行业务逻辑\n    result.add(1.2);\n    system.out.println(\n            thread.currentthread() + " exit job1,time->" + system.currenttimemillis());\n    return result;\n});\ncompletablefuture<list<double>> cf2 = completablefuture.supplyasync(() -> {\n    system.out.println(\n            thread.currentthread() + " start job2,time->" + system.currenttimemillis());\n    // 执行业务逻辑\n    result.add(3.2);\n    system.out.println(\n            thread.currentthread() + " exit job2,time->" + system.currenttimemillis());\n    return result;\n});\ncompletablefuture<list<double>> cf3 = completablefuture.supplyasync(() -> {\n    system.out.println(\n            thread.currentthread() + " start job3,time->" + system.currenttimemillis());\n    // 执行业务逻辑\n    result.add(2.2);\n    system.out.println(\n            thread.currentthread() + " exit job3,time->" + system.currenttimemillis());\n    return result;\n});\nfutures.add(cf);\nfutures.add(cf2);\nfutures.add(cf3);\n//allof等待所有任务执行完成才执行cf4，如果有一个任务异常终止，则cf4.get时会抛出异常，都是正常执行，cf4.get返回null\n//anyof是只有一个任务执行完成，无论是正常执行或者执行异常，都会执行cf4，cf4.get的结果就是已执行完成的任务的执行结果\ncompletablefuture<void> cf4 = completablefuture\n        .allof(futures.toarray(new completablefuture[0]));\n\nsystem.out.println("main thread start cf4.get(),time->" + system.currenttimemillis());\n//等待子任务执行完成\ncf4.join();\nsystem.out.println("子任务状态" + cf.isdone() + " " + cf2.isdone() + " " + cf3.isdone());\nsystem.out.println("计算结果" + result);\nsystem.out.println("main thread exit,time->" + system.currenttimemillis());\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n# 运行结果\n\nthread[forkjoinpool.commonpool-worker-9,5,main] start job1,time->1654514454630\nthread[forkjoinpool.commonpool-worker-9,5,main] exit job1,time->1654514454630\nthread[forkjoinpool.commonpool-worker-9,5,main] start job2,time->1654514454631\nthread[forkjoinpool.commonpool-worker-9,5,main] exit job2,time->1654514454631\nthread[forkjoinpool.commonpool-worker-9,5,main] start job3,time->1654514454631\nthread[forkjoinpool.commonpool-worker-9,5,main] exit job3,time->1654514454631\nmain thread start cf4.get(),time->1654514454631\n子任务状态true true true\n计算结果[1.2, 3.2, 2.2]\nmain thread exit,time->1654514454633\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n异步线程依次执行，同时主线程等待所有子任务执行完毕，等到子任务执行完之后汇总结果，最后主线程退出。',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"自定义类加载器",frontmatter:{title:"自定义类加载器",date:"2021-11-18T19:48:15.000Z",description:"总结",categories:["Java"],tags:["类加载器","ClassLoader","双亲委派模型","Java"],keywords:"Java,类加载器,ClassLoader,双亲委派模型",permalink:"/pages/0a146e/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/01.Java/01.Java/04.Java-JVM/01.%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.html",relativePath:"01.Java/01.Java/04.Java-JVM/01.自定义类加载器.md",key:"v-8c545382",path:"/pages/0a146e/",headers:[{level:2,title:"自定义类加载器",slug:"自定义类加载器",normalizedTitle:"自定义类加载器",charIndex:2},{level:3,title:"为什么需要自定义类加载器",slug:"为什么需要自定义类加载器",normalizedTitle:"为什么需要自定义类加载器",charIndex:29},{level:3,title:"双亲委派模型",slug:"双亲委派模型",normalizedTitle:"双亲委派模型",charIndex:416},{level:3,title:"双亲委派的好处",slug:"双亲委派的好处",normalizedTitle:"双亲委派的好处",charIndex:2686},{level:3,title:"自定义步骤",slug:"自定义步骤",normalizedTitle:"自定义步骤",charIndex:2915},{level:4,title:"POJO测试类LoadCustomPojoTest",slug:"pojo测试类loadcustompojotest",normalizedTitle:"pojo测试类loadcustompojotest",charIndex:5474},{level:4,title:"测试POJO结果",slug:"测试pojo结果",normalizedTitle:"测试pojo结果",charIndex:7354},{level:4,title:"Service测试类LoadCustomMethodTest",slug:"service测试类loadcustommethodtest",normalizedTitle:"service测试类loadcustommethodtest",charIndex:7583},{level:4,title:"测试Service结果",slug:"测试service结果",normalizedTitle:"测试service结果",charIndex:8454},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:8535}],headersStr:"自定义类加载器 为什么需要自定义类加载器 双亲委派模型 双亲委派的好处 自定义步骤 POJO测试类LoadCustomPojoTest 测试POJO结果 Service测试类LoadCustomMethodTest 测试Service结果 参考资料",content:'# 自定义类加载器\n\n自定义类加载器的实现与作用\n\n\n# 为什么需要自定义类加载器\n\n自定义类加载器是从实际场景出发，解决一些应用上的问题，比如：\n\n 1. 热部署、插件化类：常用的比如SpringBoot-devtools和Arthas等工具，其实现原理就用到了类加载机制\n 2. 加密：有些核心代码不想公开，但又必须使用，可以通过加密类字节码的方式将编译后的加密代码交给类加载器加载，再采用某种解密算法将真正的类载入JVM，保证核心代码不被反编译泄漏\n 3. 类隔离：在项目中可能不同的微服务用的某个类的版本不一样，某些应用依赖于特定版本的SDK功能，自定义类加载器可以解决某个同名的Class想要加载不同的版本的场景，实现同名Class多版本共存，相互隔离从而达到解决版本冲突的目的。如Java模块化规范 OSGi、蚂蚁金服的类隔离框架SOFAArk\n 4. 非标准化来源加载代码：编译后的字节码在数据库、云端等情况\n\n\n# 双亲委派模型\n\n想要自定义类加载器，一定需要了解双亲委派模型\n\n双亲委派模型加载class的步骤可为如下几步：\n\n 1. 根据全限定类名(name)判断类是否加载，如果已经加载则直接返回已加载类。\n 2. 如果没有加载，尝试委托父类加载器加载此类。同时，父类加载器也会采用相同的策略，查看是否自己已经加载该类，如果有就返回，没有就继续委托给父类进行加载，直到BootStrapClassLoader。如果父类加载器为null则代表使用BootStrapClassLoader进行加载。\n 3. 父类无法加载，交给子类进行加载。按照从BootStrapClassLoader->ExtClassLoader->AppClassLoader->自定义类加载器的顺序依次尝试加载。\n\n其加载class的核心方法loadClass源码如下：\n\n    protected Class<?> loadClass(String name, boolean resolve)\n        throws ClassNotFoundException\n    {\n        synchronized (getClassLoadingLock(name)) {\n            // First, check if the class has already been loaded\n            // 第一步，检查需要加载的这个类是否已经被加载过\n            Class<?> c = findLoadedClass(name);\n            if (c == null) {\n                long t0 = System.nanoTime();\n                try {\n                    // 调用父类加载器尝试加载\n                    if (parent != null) {\n                        c = parent.loadClass(name, false);\n                    } else {\n                        c = findBootstrapClassOrNull(name);\n                    }\n                } catch (ClassNotFoundException e) {\n                    // ClassNotFoundException thrown if class not found\n                    // from the non-null parent class loader\n                    // 捕获父类加载器无法加载的请求\n                }\n\n                if (c == null) {\n                    // If still not found, then invoke findClass in order\n                    // to find the class.\n                    long t1 = System.nanoTime();\n                    // 如果父类加载器不能加载，就尝试采用子类加载器加载\n                    c = findClass(name);\n\n                    // this is the defining class loader; record the stats\n                    PerfCounter.getParentDelegationTime().addTime(t1 - t0);\n                    PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);\n                    PerfCounter.getFindClasses().increment();\n                }\n            }\n            if (resolve) {\n                // 链接指定类\n                resolveClass(c);\n            }\n            return c;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n下图更好的展示了双亲委派的过程：\n\n\n\n\n# 双亲委派的好处\n\n 1. 安全性。避免了用户自己编写的类与Java的核心类冲突，如自定义了java.lang.String.class类不会被系统加载，因为顶层启动类加载器会先于自定义加载器加载该类，防止核心API被修改\n 2. 避免类的重复加载。如果父类已经加载过该类，则直接返回，在JVM中区分不同的类，不仅需要根据全限定名，且需要判断是否是同一个ClassLoader。相同的class文件被不同的ClassLoader加载就是不同的两个类。\n\n\n# 自定义步骤\n\n自定义类加载器只需要继承ClassLoader，同时覆盖findClass方法(而不是loadClass方法)即可\n\n提示\n\nSubclasses of ClassLoader are encouraged to override findClass(String), rather than this method. Unless overridden, this method synchronizes on the result of getClassLoadingLock method during the entire class loading process. 官方推荐\n\n准备两个类，一个类作为实体，一个类作为Service\n\nTestUser.java\n\npublic class TestUser {\n\n    private String name;\n\n    public TestUser() {\n    }\n\n    public TestUser(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public String toString() {\n        return "========这是User测试文件1号========";\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\nTestService.java\n\npublic class TestService {\n\n    public String testPrint(String name) {\n        String result = name + "调用当前方法";\n        System.out.println(name + "调用当前方法");\n        return result;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n自定义类加载器CustomClassLoader.java\n\npackage com.test.custom;\n\nimport java.io.FileInputStream;\n\n\npublic class CustomClassLoader extends ClassLoader {\n\n    private String classPath;\n\n    public CustomClassLoader() {\n    }\n\n    public CustomClassLoader(String classPath) {\n        this.classPath = classPath;\n    }\n\n    private byte[] loadByte(String name) throws Exception {\n        name = name.replaceAll("\\\\.", "/");\n        String a = classPath + "/" + name + ".class";\n        FileInputStream fileInputStream = new FileInputStream(classPath + "/" + name + ".class");\n        int len = fileInputStream.available();\n        byte[] data = new byte[len];\n        fileInputStream.read(data);\n        fileInputStream.close();\n        return data;\n    }\n\n    @Override\n    protected Class<?> findClass(String name) throws ClassNotFoundException {\n        try {\n            byte[] data = loadByte(name);\n            //defineClass将一个字节数组转为Class对象，这个字节数组是class文件读取后最终的字节数组。\n            return defineClass(name, data, 0, data.length);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return super.findClass(name);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n自定义的函数很简单，将全限定名的class文件加载为字节码数组，然后传入defineClass方法进行加载，defineClass的作用是将一个字节数组转化为Class对象\n\n# POJO测试类LoadCustomPojoTest\n\n需要注意的是要加载的Class必须在全限定名一样的目录下进行javac编译，以为package必须一致，比如com.test.custom.pojo.TestUser，TestUser必须在com.test.custom.pojo目录下编译生成字节码\n\npackage com.test.custom;\n\n\npublic class LoadCustomPoJoTest {\n\n    public static void main(String[] args) throws Exception {\n        // 初始化自定义类加载器，会先初始化父类ClassLoader，其中会把自定义类加载器的父类加载器设置为应用程序类加载器AppClassLoader\n        CustomClassLoader classLoader = new CustomClassLoader(\n                "E:/ideaProject/custom-classloader/src");\n        // 从磁盘中创建一个目录，将要加载的类的class放入目录\n        // Class.forName效果和classLoader.loadClass一致\n        Class<?> clazz = Class.forName("com.test.custom.pojo.TestUser", true, classLoader);\n        Object obj = clazz.newInstance();\n        System.out.println(obj.toString());\n        System.out.println(clazz.getClassLoader());\n\n        System.out.println();\n        CustomClassLoader classLoader2 = new CustomClassLoader(\n                "E:/ideaProject/custom-classloader/src");\n        Class clazz1 = Class.forName("com.test.custom.pojo.repeat.TestUser", true, classLoader2);\n        Object obj1 = clazz1.newInstance();\n        System.out.println(obj1.toString());\n        System.out.println(clazz1.getClassLoader());\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n我们测试两个同名的Class对象共存的情况，两个TestUser只在toString方法打印的数据和包名不一样\n\n必须采用不同的类加载器加载同名对象，否则同一个类加载器会以第一次加载的对象为准\n\ncom.test.custom.pojo.TestUser\n\npackage com.test.custom.pojo;\n\npublic class TestUser {\n    // ......\n    public String toString() {\n        return "========这是User测试文件1号========";\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\npackage com.test.custom.pojo.repeat;\n\npublic class TestUser {\n    // ......\n    public String toString() {\n        return "========这是User测试文件2号========";\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 测试POJO结果\n\n========这是User测试文件1号========\ncom.test.custom.CustomClassLoader@2133c8f8\n\n========这是User测试文件2号========\ncom.test.custom.CustomClassLoader@30c7da1e\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n可以看到，两个类加载器是不一样的，且两个类的方法都已经打印了，说明此时同名类不同版本共存。\n\n# Service测试类LoadCustomMethodTest\n\n构建一个带参数的Service方法，加载到方法之后，利用反射进行调用\n\npackage com.test.custom;\n\nimport java.lang.reflect.Method;\n\n\npublic class LoadCustomMethodTest {\n\n    public static void main(String[] args) throws Exception {\n        // 初始化自定义类加载器，会先初始化父类ClassLoader，其中会把自定义类加载器的父类加载器设置为应用程序类加载器AppClassLoader\n        CustomClassLoader classLoader = new CustomClassLoader(\n                "E:/ideaProject/custom-classloader/src");\n        // 从磁盘中创建一个目录，将要加载的类的class放入目录\n        Class clazz = classLoader.loadClass("com.test.custom.service.TestService");\n        Object obj = clazz.newInstance();\n        Method method = clazz.getDeclaredMethod("testPrint", String.class);\n        method.invoke(obj, "李四");\n        System.out.println(clazz.getClassLoader());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n# 测试Service结果\n\n李四调用当前方法\ncom.test.custom.CustomClassLoader@49e4cb85\n\n\n1\n2\n\n1\n2\n\n\n\n# 参考资料\n\n>  1. https://www.cnblogs.com/twoheads/p/10143038.html\n>  2. https://blog.csdn.net/liubenlong007/article/details/103593443\n>  3. https://www.cnblogs.com/lichmama/p/12858517.html\n>  4. https://www.cnblogs.com/huangjianping/p/14968403.html',normalizedContent:'# 自定义类加载器\n\n自定义类加载器的实现与作用\n\n\n# 为什么需要自定义类加载器\n\n自定义类加载器是从实际场景出发，解决一些应用上的问题，比如：\n\n 1. 热部署、插件化类：常用的比如springboot-devtools和arthas等工具，其实现原理就用到了类加载机制\n 2. 加密：有些核心代码不想公开，但又必须使用，可以通过加密类字节码的方式将编译后的加密代码交给类加载器加载，再采用某种解密算法将真正的类载入jvm，保证核心代码不被反编译泄漏\n 3. 类隔离：在项目中可能不同的微服务用的某个类的版本不一样，某些应用依赖于特定版本的sdk功能，自定义类加载器可以解决某个同名的class想要加载不同的版本的场景，实现同名class多版本共存，相互隔离从而达到解决版本冲突的目的。如java模块化规范 osgi、蚂蚁金服的类隔离框架sofaark\n 4. 非标准化来源加载代码：编译后的字节码在数据库、云端等情况\n\n\n# 双亲委派模型\n\n想要自定义类加载器，一定需要了解双亲委派模型\n\n双亲委派模型加载class的步骤可为如下几步：\n\n 1. 根据全限定类名(name)判断类是否加载，如果已经加载则直接返回已加载类。\n 2. 如果没有加载，尝试委托父类加载器加载此类。同时，父类加载器也会采用相同的策略，查看是否自己已经加载该类，如果有就返回，没有就继续委托给父类进行加载，直到bootstrapclassloader。如果父类加载器为null则代表使用bootstrapclassloader进行加载。\n 3. 父类无法加载，交给子类进行加载。按照从bootstrapclassloader->extclassloader->appclassloader->自定义类加载器的顺序依次尝试加载。\n\n其加载class的核心方法loadclass源码如下：\n\n    protected class<?> loadclass(string name, boolean resolve)\n        throws classnotfoundexception\n    {\n        synchronized (getclassloadinglock(name)) {\n            // first, check if the class has already been loaded\n            // 第一步，检查需要加载的这个类是否已经被加载过\n            class<?> c = findloadedclass(name);\n            if (c == null) {\n                long t0 = system.nanotime();\n                try {\n                    // 调用父类加载器尝试加载\n                    if (parent != null) {\n                        c = parent.loadclass(name, false);\n                    } else {\n                        c = findbootstrapclassornull(name);\n                    }\n                } catch (classnotfoundexception e) {\n                    // classnotfoundexception thrown if class not found\n                    // from the non-null parent class loader\n                    // 捕获父类加载器无法加载的请求\n                }\n\n                if (c == null) {\n                    // if still not found, then invoke findclass in order\n                    // to find the class.\n                    long t1 = system.nanotime();\n                    // 如果父类加载器不能加载，就尝试采用子类加载器加载\n                    c = findclass(name);\n\n                    // this is the defining class loader; record the stats\n                    perfcounter.getparentdelegationtime().addtime(t1 - t0);\n                    perfcounter.getfindclasstime().addelapsedtimefrom(t1);\n                    perfcounter.getfindclasses().increment();\n                }\n            }\n            if (resolve) {\n                // 链接指定类\n                resolveclass(c);\n            }\n            return c;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n下图更好的展示了双亲委派的过程：\n\n\n\n\n# 双亲委派的好处\n\n 1. 安全性。避免了用户自己编写的类与java的核心类冲突，如自定义了java.lang.string.class类不会被系统加载，因为顶层启动类加载器会先于自定义加载器加载该类，防止核心api被修改\n 2. 避免类的重复加载。如果父类已经加载过该类，则直接返回，在jvm中区分不同的类，不仅需要根据全限定名，且需要判断是否是同一个classloader。相同的class文件被不同的classloader加载就是不同的两个类。\n\n\n# 自定义步骤\n\n自定义类加载器只需要继承classloader，同时覆盖findclass方法(而不是loadclass方法)即可\n\n提示\n\nsubclasses of classloader are encouraged to override findclass(string), rather than this method. unless overridden, this method synchronizes on the result of getclassloadinglock method during the entire class loading process. 官方推荐\n\n准备两个类，一个类作为实体，一个类作为service\n\ntestuser.java\n\npublic class testuser {\n\n    private string name;\n\n    public testuser() {\n    }\n\n    public testuser(string name) {\n        this.name = name;\n    }\n\n    public string getname() {\n        return name;\n    }\n\n    public void setname(string name) {\n        this.name = name;\n    }\n\n    @override\n    public string tostring() {\n        return "========这是user测试文件1号========";\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\ntestservice.java\n\npublic class testservice {\n\n    public string testprint(string name) {\n        string result = name + "调用当前方法";\n        system.out.println(name + "调用当前方法");\n        return result;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n自定义类加载器customclassloader.java\n\npackage com.test.custom;\n\nimport java.io.fileinputstream;\n\n\npublic class customclassloader extends classloader {\n\n    private string classpath;\n\n    public customclassloader() {\n    }\n\n    public customclassloader(string classpath) {\n        this.classpath = classpath;\n    }\n\n    private byte[] loadbyte(string name) throws exception {\n        name = name.replaceall("\\\\.", "/");\n        string a = classpath + "/" + name + ".class";\n        fileinputstream fileinputstream = new fileinputstream(classpath + "/" + name + ".class");\n        int len = fileinputstream.available();\n        byte[] data = new byte[len];\n        fileinputstream.read(data);\n        fileinputstream.close();\n        return data;\n    }\n\n    @override\n    protected class<?> findclass(string name) throws classnotfoundexception {\n        try {\n            byte[] data = loadbyte(name);\n            //defineclass将一个字节数组转为class对象，这个字节数组是class文件读取后最终的字节数组。\n            return defineclass(name, data, 0, data.length);\n        } catch (exception e) {\n            e.printstacktrace();\n        }\n        return super.findclass(name);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n自定义的函数很简单，将全限定名的class文件加载为字节码数组，然后传入defineclass方法进行加载，defineclass的作用是将一个字节数组转化为class对象\n\n# pojo测试类loadcustompojotest\n\n需要注意的是要加载的class必须在全限定名一样的目录下进行javac编译，以为package必须一致，比如com.test.custom.pojo.testuser，testuser必须在com.test.custom.pojo目录下编译生成字节码\n\npackage com.test.custom;\n\n\npublic class loadcustompojotest {\n\n    public static void main(string[] args) throws exception {\n        // 初始化自定义类加载器，会先初始化父类classloader，其中会把自定义类加载器的父类加载器设置为应用程序类加载器appclassloader\n        customclassloader classloader = new customclassloader(\n                "e:/ideaproject/custom-classloader/src");\n        // 从磁盘中创建一个目录，将要加载的类的class放入目录\n        // class.forname效果和classloader.loadclass一致\n        class<?> clazz = class.forname("com.test.custom.pojo.testuser", true, classloader);\n        object obj = clazz.newinstance();\n        system.out.println(obj.tostring());\n        system.out.println(clazz.getclassloader());\n\n        system.out.println();\n        customclassloader classloader2 = new customclassloader(\n                "e:/ideaproject/custom-classloader/src");\n        class clazz1 = class.forname("com.test.custom.pojo.repeat.testuser", true, classloader2);\n        object obj1 = clazz1.newinstance();\n        system.out.println(obj1.tostring());\n        system.out.println(clazz1.getclassloader());\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n我们测试两个同名的class对象共存的情况，两个testuser只在tostring方法打印的数据和包名不一样\n\n必须采用不同的类加载器加载同名对象，否则同一个类加载器会以第一次加载的对象为准\n\ncom.test.custom.pojo.testuser\n\npackage com.test.custom.pojo;\n\npublic class testuser {\n    // ......\n    public string tostring() {\n        return "========这是user测试文件1号========";\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\npackage com.test.custom.pojo.repeat;\n\npublic class testuser {\n    // ......\n    public string tostring() {\n        return "========这是user测试文件2号========";\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 测试pojo结果\n\n========这是user测试文件1号========\ncom.test.custom.customclassloader@2133c8f8\n\n========这是user测试文件2号========\ncom.test.custom.customclassloader@30c7da1e\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n可以看到，两个类加载器是不一样的，且两个类的方法都已经打印了，说明此时同名类不同版本共存。\n\n# service测试类loadcustommethodtest\n\n构建一个带参数的service方法，加载到方法之后，利用反射进行调用\n\npackage com.test.custom;\n\nimport java.lang.reflect.method;\n\n\npublic class loadcustommethodtest {\n\n    public static void main(string[] args) throws exception {\n        // 初始化自定义类加载器，会先初始化父类classloader，其中会把自定义类加载器的父类加载器设置为应用程序类加载器appclassloader\n        customclassloader classloader = new customclassloader(\n                "e:/ideaproject/custom-classloader/src");\n        // 从磁盘中创建一个目录，将要加载的类的class放入目录\n        class clazz = classloader.loadclass("com.test.custom.service.testservice");\n        object obj = clazz.newinstance();\n        method method = clazz.getdeclaredmethod("testprint", string.class);\n        method.invoke(obj, "李四");\n        system.out.println(clazz.getclassloader());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n# 测试service结果\n\n李四调用当前方法\ncom.test.custom.customclassloader@49e4cb85\n\n\n1\n2\n\n1\n2\n\n\n\n# 参考资料\n\n>  1. https://www.cnblogs.com/twoheads/p/10143038.html\n>  2. https://blog.csdn.net/liubenlong007/article/details/103593443\n>  3. https://www.cnblogs.com/lichmama/p/12858517.html\n>  4. https://www.cnblogs.com/huangjianping/p/14968403.html',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"JMH-基准测试框架",frontmatter:{title:"JMH-基准测试框架",date:"2022-12-29T14:16:15.000Z",description:"总结",categories:["Java","JVM"],tags:["Java","JVM","JMH","BenchMark"],permalink:"/pages/ffed02/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/01.Java/01.Java/04.Java-JVM/02.JMH-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6.html",relativePath:"01.Java/01.Java/04.Java-JVM/02.JMH-基准测试框架.md",key:"v-76f6c282",path:"/pages/ffed02/",headers:[{level:2,title:"什么是JMH",slug:"什么是jmh",normalizedTitle:"什么是jmh",charIndex:2},{level:2,title:"同类工具",slug:"同类工具",normalizedTitle:"同类工具",charIndex:270},{level:2,title:"JMH使用",slug:"jmh使用",normalizedTitle:"jmh使用",charIndex:888},{level:2,title:"常用注解解析",slug:"常用注解解析",normalizedTitle:"常用注解解析",charIndex:3678},{level:3,title:"@BenchmarkMode",slug:"benchmarkmode",normalizedTitle:"@benchmarkmode",charIndex:3732},{level:3,title:"@State",slug:"state",normalizedTitle:"@state",charIndex:4408},{level:3,title:"@Setup及@TearDown",slug:"setup及-teardown",normalizedTitle:"@setup及@teardown",charIndex:5010},{level:3,title:"@Warmup",slug:"warmup",normalizedTitle:"@warmup",charIndex:6453},{level:3,title:"@Measurement",slug:"measurement",normalizedTitle:"@measurement",charIndex:6798},{level:3,title:"@Param",slug:"param",normalizedTitle:"@param",charIndex:6941},{level:3,title:"@Threads",slug:"threads",normalizedTitle:"@threads",charIndex:7742},{level:3,title:"@Fork",slug:"fork",normalizedTitle:"@fork",charIndex:7778},{level:3,title:"@OutputTimeUnit",slug:"outputtimeunit",normalizedTitle:"@outputtimeunit",charIndex:7866},{level:2,title:"快速上手",slug:"快速上手",normalizedTitle:"快速上手",charIndex:7930},{level:2,title:"JMH-避免死代码消除陷阱",slug:"jmh-避免死代码消除陷阱",normalizedTitle:"jmh-避免死代码消除陷阱",charIndex:10495},{level:2,title:"JMH可视化",slug:"jmh可视化",normalizedTitle:"jmh可视化",charIndex:11898},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:12034}],headersStr:"什么是JMH 同类工具 JMH使用 常用注解解析 @BenchmarkMode @State @Setup及@TearDown @Warmup @Measurement @Param @Threads @Fork @OutputTimeUnit 快速上手 JMH-避免死代码消除陷阱 JMH可视化 参考文章",content:'# 什么是JMH\n\nJMH(Java Microbenchmark Harness)由OpenJDK团队开发，是一款基准测试工具。作为JDK官方的基准测试工具，在JDK9开始已内嵌。通常用于代码的性能调优，JMH开发者同样为JIT的开发者，得益于专业的JVM优化分析，JMH具有高精度的特点，适用于Java及基于JVM的语言。通常JMH能够统计程序的OPS(Opeartion Per Second，每秒操作量)、及TP99、平均差等，JMH测试的对象可以是方法级的，粒度更小、不限于REST API。\n\n官方JMH代码示例在这里\n\n\n# 同类工具\n\n与之类似的工具还有Apache JMeter、Wrk等\n\n * Apache JMeter：提供GUI创建压力测试、调试，可在GUI执行压测(官方不推荐、误差大)，优选在GUI配置后在命令行压测\n * Wrk: 热门开源压测工具、C语言编写、支持脚本进行压测，请求高度可定制\n\n差异：\n\n * Apache JMeter: 具有简单易懂的GUI，配置友好。支持吞吐量(Throughput、TPS)、TP90、TP95、TP99等多种指标，结果自带Web报告和文件报告，支持分布式压测。\n * Wrk: 支持多种脚本工具，对网络的设置更多，能够更好的模拟出用户请求，发压效率高，支持TP50、TP75、TP90、TP99、每秒请求数(Requests Per Second、QPS)等指标，支持通过脚本自定义指标比例、TCP长/短连接设置，wrk没有GUI，但学习成本不高，结果通常为输出形式，仅支持单机压测。\n\n定位：JMH更多的是代码级、方法级的压测，能够反映出某一方法的瓶颈，对网络包的定制不关心。而Apache JMeter和Wrk能做的很多、对于处理网络中的请求，对REST接口更具准确性。\n\n更多关于Apache JMeter和Wrk的使用可阅读这篇文章如何利用Wrk与JMeter做性能压测\n\n提示\n\n通常来说准确的请求压测，发压机应和服务不在同一机器，毕竟一个请求到来时，网络情况也是观测的重要部分\n\n\n# JMH使用\n\n在JDK8中使用JMH需要先引入\n\n<dependency>\n    <groupId>org.openjdk.jmh</groupId>\n    <artifactId>jmh-core</artifactId>\n    <version>1.29</version>\n</dependency>\n\n<dependency>\n    <groupId>org.openjdk.jmh</groupId>\n    <artifactId>jmh-generator-annprocess</artifactId>\n    <version>1.29</version>\n    <scope>provided</scope>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nJMH实现了JSR269规范，即注解处理器，能在编译Java源码的时候识别到需要处理的注解\n\n在pom文件中引入对应需要的插件\n\n<plugin>\n    <groupId>org.apache.maven.plugins</groupId>\n    <artifactId>maven-shade-plugin</artifactId>\n    <version>2.4.1</version>\n    <executions>\n        <execution>\n            <phase>package</phase>\n            <goals>\n                <goal>shade</goal>\n            </goals>\n            <configuration>\n                <finalName>jmh-demo</finalName>\n                <transformers>\n                    <transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer">\n                        <mainClass>org.openjdk.jmh.Main</mainClass>\n                    </transformer>\n                </transformers>\n            </configuration>\n        </execution>\n    </executions>\n</plugin>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n一个简单的基准测试代码，只需要加入@Benchmark\n\npublic class MHBenchmark {\n\n    @Benchmark\n    public void test() {\n        int i = 1;\n        i+=1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上述代码意思是采用默认参数，测试i+1的性能\n\n当然这样的类还不能够跑起来，JMH提供了2种方式运行代码\n\n> ====================== HOW TO RUN THIS TEST: ============================\n> \n> You can run this test:\n> \n> a) Via the command line:\n> \n> $ mvn clean install\n> \n> $ java -jar target/benchmarks.jar JMHSample_09 -f 1\n> \n> (we requested single fork; there are also other options, see -h)\n> \n> b) Via the Java API:\n> \n> (see the JMH homepage for possible caveats when running from IDE: http://openjdk.java.net/projects/code-tools/jmh/)\n\n 1. 命令行\n\nmvn clean install\njava -jar xxx.jar\n\n\n1\n2\n\n1\n2\n\n 2. 通过Java API，在IDE运行\n\npublic static void main(String[] args) throws RunnerException {\n    Options options = new OptionsBuilder()\n            .include(MHBenchmark.class.getSimpleName())\n            .result("./result-mh.json")\n            .resultFormat(ResultFormatType.JSON)\n            .build();\n    new Runner(options).run();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n如果觉得每次运行都需要手动输入命令行的方法1繁琐，可以使用IDE运行的方法2，如果方法2的main函数不好记忆，这时候可以使用JMH插件JMH Java Microbenchmark Harness，其作者为Aleksey Shipilev，受雇于Red Hat，是OpenJDK子项目、JMH的开发者。\n\n在Idea的Plugins搜索JMH、安装即可\n\n插件可以让我们能够以JUnit相同的方式使用JMH，主要功能如下：\n\n * 自动生成带有@Benchmark的方法\n * 运行单独的Benchmark方法\n * 运行类中所有的Benchmark方法\n\n和生成构造方法的Idea目录相同，插件支持通过右键点击Generate，选择操作 Generate JMH benchmark 就可以生成一个带有 @Benchmark 的方法。\n\n\n\n此时不需要手动打包，也不需要编写main方法，直接点击左侧运行即可\n\n\n# 常用注解解析\n\nJMH提供的注解相当多，这里仅列出较为常用的注解，更多注解运用可查看JMH官方用例\n\n\n# @BenchmarkMode\n\n可用于类或方法上，配置Benchmark的模式，总共支持如下5种：\n\n 1. Throughput: 吞吐量，每秒执行了多少次调用\n 2. AverageTime: 平均时间，每次操作的平均时间\n 3. SampleTime: 对每次操作随机取样，最后输出取样结果的分布\n 4. SingleShotTime: 单词操作时间，可衡量冷启动时的性能\n 5. All: 所有模式都执行一次\n\n同时支持分组操作\n\n作用类上\n\n@BenchmarkMode(Mode.Throughput)\npublic class JMHSample {\n    \n    @Benchmark\n    public void measureShared(BenchmarkState state) {\n        TimeUnit.MILLISECONDS.sleep(100);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n作用方法上\n\npublic class JMHSample {\n    \n    @BenchmarkMode(Mode.Throughput)\n    @Benchmark\n    public void measureShared(BenchmarkState state) {\n        TimeUnit.MILLISECONDS.sleep(100);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# @State\n\n可用于类和方法上、通过@State进行标记指定对象的作用范围，JMH根据@State的Scope参数来进行实例化和共享操作。根据作用范围的不同分为如下3类：\n\n 1. Scope.Benchmark: 基准状态范围。同一类型的所有实例将在所有工作线程之间共享。\n 2. Scope.Group: 组状态范围。同一类型的所有实例将在同一组内的所有线程之间共享。\n 3. Scope.Thread: 线程状态范围。使用线程作用域，同一类型的所有实例都是不同的，即在同一个基准测试中注入了多个实例。\n\n如@State作用于类内部的class上，通常用与@Setup结合\n\n当使用@State标记内部类后，在使用时应包含该入参\n\npublic class JMHSample {\n    @State(Scope.Benchmark)\n    public static class BenchmarkState {\n        volatile double x = Math.PI;\n    }\n    @Benchmark\n    public void measureShared(BenchmarkState state) {\n        state.x++;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# @Setup及@TearDown\n\n@Setup: 用于基准测试方法之前调用，通常用于资源的初始化\n\n@TearDown: 用于基准测试方法之后调用，通常用于资源的回收清理工作\n\n两者都可以使用Level控制\n\nLevel: 使用@Setup和@TearDown时，在默认情况下，@Setup和@TearDown会在一个基准方法的所有批次执行前后分别执行，如果需要在每一个批次或者每一次基准方法调用执行的前后执行对应的套件方法，则可通过Level控制\n\n * Trial: 试验级别。Setup和TearDown默认的配置，在每次基准测试运行之前/之后执行\n * Iteration: 迭代级别。在基准测试的每次迭代之前/之后执行\n * Invocation: 调用级别。为每个基准测试方法执行\n\n单独使用\n\npublic class JMHSample {\n    \n    private List<Integer> list = null;\n    \n    @Setup\n    public void setup(){\n        this.list = new ArrayList<>();\n    }\n    \n    @TearDown\n    public void tearDown() {\n        assert this.list.size() > 0 : "The Size  Of List Must Lager Than Zero";\n    }\n    \n    @Benchmark\n    public void testRight() {\n        this.list.add("Test");\n    }\n\n    @Benchmark\n    public void testWrong() {\n        \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n针对testRight和testWrong进行测试，testRight能够正确通过，因为list内部有值，后置的TearDown不会被断言拦截。testWrong会被断言拦截，导致Benchmark终止。\n\n和@State混合使用，组合方式不限于以下一种\n\npublic class JMHSample {\n    \n    @State(Scope.Benchmark)\n    public static class BenchmarkState {\n        double x;\n        @Setup\n        public void setup(){\n            x = Math.PI;\n        }\n    }\n    \n    @Benchmark\n    public void measureShared(BenchmarkState state) {\n        state.x++;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# @Warmup\n\n预热所需要配置的一些基本测试参数，可用于类或者方法上。放在Benchmark方法上，只对该方法起作用，也可以放在外围类实例上，对该类中的所有Benchmark方法起作用。一般前几次进行程序测试的时候会遇到冷启动问题，导致程序很慢，使用@Warmup，可以将JIT进行提前预热解决冷启动问题，因为 JVM 的 JIT 机制的存在，如果某个函数被调用多次之后，JVM 会尝试将其编译为机器码，从而提高执行速度，所以为了让 Benchmark 的结果更加接近真实情况就需要进行预热。\n\n 1. iterations：预热的次数\n 2. time：每次预热的时间\n 3. timeUnit：时间的单位，默认秒\n 4. batchSize：批处理大小，每次操作调用几次方法\n\n\n# @Measurement\n\n实际调用方法所需要配置的一些基本测试参数，可用于类或者方法上，参数和 @Warmup相同。\n\n比如\n\n@Measurement(iterations = 10, time = 5)\n\n\n1\n\n1\n\n\n表示为迭代10次，每次5s。可用于控制压测时间。\n\n\n# @Param\n\n指定某项参数的多种情况，适合用来测试一个函数在不同的参数输入的情况下的性能，只能作用在字段上，使用该注解必须定义@State注解。\n\npublic class JMHSample {\n    \n    @Param({"1", "31", "65", "101", "103"})\n    public int arg;\n\n    @Param({"0", "1", "2", "4", "8", "16", "32"})\n    public int certainty;\n    \n    @Benchmark\n    public boolean bench() {\n        return BigInteger.valueOf(arg).isProbablePrime(certainty);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上述代码的含义为对于arg数组中的每个数，测试是否是certainty数组内以下的素数，压测计算时间，总计执行次数为arg的数组长度xcertainty的数组长度=35次\n\n再看一个例子\n\npublic class JMHSample {\n    \n    @Param({"1", "31", "65", "101", "103"})\n    public int arg;\n    \n    @Benchmark\n    public boolean bench() {\n        return String.valueOf(arg);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上述代码为依次执行arg数组中数据，转换到String类型的耗时\n\n\n# @Threads\n\n每个进程中的测试线程，可用于类或者方法上。\n\n\n# @Fork\n\n进行Fork的次数，可用于类或者方法上。如果Fork数是2的话，则JMH会Fork出两个进程来进行测试。模拟多进程环境，完全隔离多个进程，不会相互影响。\n\n\n# @OutputTimeUnit\n\n为统计结果的时间单位，可用于类或者方法注解，单位为TimeUnit类，支持到纳秒级。\n\n\n# 快速上手\n\n以一个全面的例子来进行解释\n\n@Fork(1) // Fork 1个进程进行测试\n@BenchmarkMode(Mode.Throughput) // 吞吐量\n@Warmup(iterations = 3) // JIT预热\n@Measurement(iterations = 10, time = 5) // 迭代10次,每次5s\n@OutputTimeUnit(TimeUnit.MILLISECONDS) // 结果所使用的时间单位\n@Threads(10) // 线程10个\npublic class BenchmarkTestSimple {\n\n    /**\n     * 作用域为本次JMH测试，线程共享\n     * <p>\n     * 初始化source数据集\n     */\n    @State(Scope.Benchmark)\n    public static class GenerateModel {\n        DataBaseDO dataBaseModel;\n\n        // 初始化\n        @Setup(Level.Trial)\n        public void prepare() {\n            dataBaseModel = new ModelService().get();\n        }\n    }\n\n    /**\n     * 初始化MapStruct\n     */\n    @State(Scope.Benchmark)\n    public static class MapStructInit {\n        MapStructMapper mapStructMapper;\n\n        @Setup(Level.Trial)\n        public void prepare() {\n            mapStructMapper = Mappers.getMapper(MapStructMapper.class);\n        }\n    }\n\n    /**\n     * get/set 基准测试\n     *\n     * @param generateModel source\n     * @return target       DataBaseVO\n     * @throws Exception    Exception\n     */\n    @Benchmark\n    public DataBaseVO testGetSet(GenerateModel generateModel) throws Exception {\n        DataBaseVO dataBaseVO = new DataBaseVO();\n        DataBaseDO dataBaseModel = generateModel.dataBaseModel;\n        dataBaseVO.setAge(dataBaseModel.getAge());\n        dataBaseVO.setName(dataBaseModel.getName());\n        dataBaseVO.setTime(dataBaseModel.getTime());\n        dataBaseVO.setYear(dataBaseModel.getYear());\n        dataBaseVO.setOtherTime(dataBaseModel.getOtherTime());\n        return dataBaseVO;\n    }\n\n    /**\n     * MapStruct基准测试\n     *\n     * @param generateModel source\n     * @param init          初始化的mapper\n     * @return target       DataBaseVO\n     * @throws Exception    Exception\n     */\n    @Benchmark\n    public DataBaseVO testMapStruct(GenerateModel generateModel, MapStructInit init) throws Exception {\n        DataBaseVO dataBaseVO = init.mapStructMapper.copy(generateModel.dataBaseModel);\n        return dataBaseVO;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\n上述代码的含义为：\n\nFork一个进程进行测试，利用吞吐量作为衡量指标，预热3轮再进行测试，对每个测试方法迭代10次、每次5秒，结果采用微秒作为单位，并采用10个线程进行发压。同时对MapStruct和源数据进行初始化，消除初始化开销，评估MapStruct和原生get/set的性能差异。\n\n\n# JMH-避免死代码消除陷阱\n\n> The downfall of many benchmarks is Dead-Code Elimination (DCE): compilers\n> \n> are smart enough to deduce some computations are redundant and eliminate\n> \n> them completely. If the eliminated part was our benchmarked code, we are\n> \n> in trouble.\n> \n> Fortunately, JMH provides the essential infrastructure to fight this\n> \n> where appropriate: returning the result of the computation will ask JMH\n> \n> to deal with the result to limit dead-code elimination (returned results\n> \n> are implicitly consumed by Blackholes, see JMHSample_09_Blackholes).\n\n引用官方的解释: 许多基准测试的失败是因为死代码消除(DCE)，因为编译器足够聪明，可以推断出一些计算是冗余的并完全消除掉他们，如果被淘汰的部分是基准测试的代码，那将引起基准测试的失败(不准确)\n\n死代码陷阱的一个典型场景如下\n\npublic class JMHSample {\n    \n    private double x = Math.PI;\n    \n    @Benchmark\n    public void measureWrong() {\n        // This is wrong: result is not used and the entire computation is optimized away.\n        Math.log(x);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上述代码采用void进行返回，使得变量x的结果并没有被用到，JVM优化时会将整个方法的内部代码移除。\n\nJMH提供了2种方式避免该问题:\n\n 1. 将变量作为方法的返回值，即此时方法返回double，return Math.log(x)\n 2. 通过JMH的Blackhole consume避免JIT优化消除\n\n通过JMH插件创建的Benchmark自带该入参\n\n@Benchmark\npublic void measureName(Blackhole bh) {\n    bh.consume(xxxxx)\n}\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\nJMH的其他死代码陷阱还有常量折叠、常量传播、永远不要在测试中写循环、使用 Fork 隔离多个测试方法、方法内联、伪共享与缓存行、分支预测、多线程测试等，可参考JMH专家Aleksey Shipilev的JMH公开课Benchmarking ("The Lesser of Two Evils" Story)\n\n\n# JMH可视化\n\nJMH打印的结果为文字型，运行时可以指定保存为文件，为了更直观的观察结果，可以尝试使用JMH可视化网站\n\n 1. http://deepoove.com/jmh-visual-chart/\n 2. https://jmh.morethan.io/\n\n\n# 参考文章\n\n[1]. https://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples/\n\n[2]. https://jmeter.apache.org/\n\n[3]. https://github.com/wg/wrk\n\n[4]. https://cloud.tencent.com/developer/article/1896652\n\n[5]. http://shipilev.net/\n\n[6]. https://www.youtube.com/watch?v=VaWgOCDBxYw',normalizedContent:'# 什么是jmh\n\njmh(java microbenchmark harness)由openjdk团队开发，是一款基准测试工具。作为jdk官方的基准测试工具，在jdk9开始已内嵌。通常用于代码的性能调优，jmh开发者同样为jit的开发者，得益于专业的jvm优化分析，jmh具有高精度的特点，适用于java及基于jvm的语言。通常jmh能够统计程序的ops(opeartion per second，每秒操作量)、及tp99、平均差等，jmh测试的对象可以是方法级的，粒度更小、不限于rest api。\n\n官方jmh代码示例在这里\n\n\n# 同类工具\n\n与之类似的工具还有apache jmeter、wrk等\n\n * apache jmeter：提供gui创建压力测试、调试，可在gui执行压测(官方不推荐、误差大)，优选在gui配置后在命令行压测\n * wrk: 热门开源压测工具、c语言编写、支持脚本进行压测，请求高度可定制\n\n差异：\n\n * apache jmeter: 具有简单易懂的gui，配置友好。支持吞吐量(throughput、tps)、tp90、tp95、tp99等多种指标，结果自带web报告和文件报告，支持分布式压测。\n * wrk: 支持多种脚本工具，对网络的设置更多，能够更好的模拟出用户请求，发压效率高，支持tp50、tp75、tp90、tp99、每秒请求数(requests per second、qps)等指标，支持通过脚本自定义指标比例、tcp长/短连接设置，wrk没有gui，但学习成本不高，结果通常为输出形式，仅支持单机压测。\n\n定位：jmh更多的是代码级、方法级的压测，能够反映出某一方法的瓶颈，对网络包的定制不关心。而apache jmeter和wrk能做的很多、对于处理网络中的请求，对rest接口更具准确性。\n\n更多关于apache jmeter和wrk的使用可阅读这篇文章如何利用wrk与jmeter做性能压测\n\n提示\n\n通常来说准确的请求压测，发压机应和服务不在同一机器，毕竟一个请求到来时，网络情况也是观测的重要部分\n\n\n# jmh使用\n\n在jdk8中使用jmh需要先引入\n\n<dependency>\n    <groupid>org.openjdk.jmh</groupid>\n    <artifactid>jmh-core</artifactid>\n    <version>1.29</version>\n</dependency>\n\n<dependency>\n    <groupid>org.openjdk.jmh</groupid>\n    <artifactid>jmh-generator-annprocess</artifactid>\n    <version>1.29</version>\n    <scope>provided</scope>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\njmh实现了jsr269规范，即注解处理器，能在编译java源码的时候识别到需要处理的注解\n\n在pom文件中引入对应需要的插件\n\n<plugin>\n    <groupid>org.apache.maven.plugins</groupid>\n    <artifactid>maven-shade-plugin</artifactid>\n    <version>2.4.1</version>\n    <executions>\n        <execution>\n            <phase>package</phase>\n            <goals>\n                <goal>shade</goal>\n            </goals>\n            <configuration>\n                <finalname>jmh-demo</finalname>\n                <transformers>\n                    <transformer implementation="org.apache.maven.plugins.shade.resource.manifestresourcetransformer">\n                        <mainclass>org.openjdk.jmh.main</mainclass>\n                    </transformer>\n                </transformers>\n            </configuration>\n        </execution>\n    </executions>\n</plugin>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n一个简单的基准测试代码，只需要加入@benchmark\n\npublic class mhbenchmark {\n\n    @benchmark\n    public void test() {\n        int i = 1;\n        i+=1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上述代码意思是采用默认参数，测试i+1的性能\n\n当然这样的类还不能够跑起来，jmh提供了2种方式运行代码\n\n> ====================== how to run this test: ============================\n> \n> you can run this test:\n> \n> a) via the command line:\n> \n> $ mvn clean install\n> \n> $ java -jar target/benchmarks.jar jmhsample_09 -f 1\n> \n> (we requested single fork; there are also other options, see -h)\n> \n> b) via the java api:\n> \n> (see the jmh homepage for possible caveats when running from ide: http://openjdk.java.net/projects/code-tools/jmh/)\n\n 1. 命令行\n\nmvn clean install\njava -jar xxx.jar\n\n\n1\n2\n\n1\n2\n\n 2. 通过java api，在ide运行\n\npublic static void main(string[] args) throws runnerexception {\n    options options = new optionsbuilder()\n            .include(mhbenchmark.class.getsimplename())\n            .result("./result-mh.json")\n            .resultformat(resultformattype.json)\n            .build();\n    new runner(options).run();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n如果觉得每次运行都需要手动输入命令行的方法1繁琐，可以使用ide运行的方法2，如果方法2的main函数不好记忆，这时候可以使用jmh插件jmh java microbenchmark harness，其作者为aleksey shipilev，受雇于red hat，是openjdk子项目、jmh的开发者。\n\n在idea的plugins搜索jmh、安装即可\n\n插件可以让我们能够以junit相同的方式使用jmh，主要功能如下：\n\n * 自动生成带有@benchmark的方法\n * 运行单独的benchmark方法\n * 运行类中所有的benchmark方法\n\n和生成构造方法的idea目录相同，插件支持通过右键点击generate，选择操作 generate jmh benchmark 就可以生成一个带有 @benchmark 的方法。\n\n\n\n此时不需要手动打包，也不需要编写main方法，直接点击左侧运行即可\n\n\n# 常用注解解析\n\njmh提供的注解相当多，这里仅列出较为常用的注解，更多注解运用可查看jmh官方用例\n\n\n# @benchmarkmode\n\n可用于类或方法上，配置benchmark的模式，总共支持如下5种：\n\n 1. throughput: 吞吐量，每秒执行了多少次调用\n 2. averagetime: 平均时间，每次操作的平均时间\n 3. sampletime: 对每次操作随机取样，最后输出取样结果的分布\n 4. singleshottime: 单词操作时间，可衡量冷启动时的性能\n 5. all: 所有模式都执行一次\n\n同时支持分组操作\n\n作用类上\n\n@benchmarkmode(mode.throughput)\npublic class jmhsample {\n    \n    @benchmark\n    public void measureshared(benchmarkstate state) {\n        timeunit.milliseconds.sleep(100);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n作用方法上\n\npublic class jmhsample {\n    \n    @benchmarkmode(mode.throughput)\n    @benchmark\n    public void measureshared(benchmarkstate state) {\n        timeunit.milliseconds.sleep(100);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# @state\n\n可用于类和方法上、通过@state进行标记指定对象的作用范围，jmh根据@state的scope参数来进行实例化和共享操作。根据作用范围的不同分为如下3类：\n\n 1. scope.benchmark: 基准状态范围。同一类型的所有实例将在所有工作线程之间共享。\n 2. scope.group: 组状态范围。同一类型的所有实例将在同一组内的所有线程之间共享。\n 3. scope.thread: 线程状态范围。使用线程作用域，同一类型的所有实例都是不同的，即在同一个基准测试中注入了多个实例。\n\n如@state作用于类内部的class上，通常用与@setup结合\n\n当使用@state标记内部类后，在使用时应包含该入参\n\npublic class jmhsample {\n    @state(scope.benchmark)\n    public static class benchmarkstate {\n        volatile double x = math.pi;\n    }\n    @benchmark\n    public void measureshared(benchmarkstate state) {\n        state.x++;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# @setup及@teardown\n\n@setup: 用于基准测试方法之前调用，通常用于资源的初始化\n\n@teardown: 用于基准测试方法之后调用，通常用于资源的回收清理工作\n\n两者都可以使用level控制\n\nlevel: 使用@setup和@teardown时，在默认情况下，@setup和@teardown会在一个基准方法的所有批次执行前后分别执行，如果需要在每一个批次或者每一次基准方法调用执行的前后执行对应的套件方法，则可通过level控制\n\n * trial: 试验级别。setup和teardown默认的配置，在每次基准测试运行之前/之后执行\n * iteration: 迭代级别。在基准测试的每次迭代之前/之后执行\n * invocation: 调用级别。为每个基准测试方法执行\n\n单独使用\n\npublic class jmhsample {\n    \n    private list<integer> list = null;\n    \n    @setup\n    public void setup(){\n        this.list = new arraylist<>();\n    }\n    \n    @teardown\n    public void teardown() {\n        assert this.list.size() > 0 : "the size  of list must lager than zero";\n    }\n    \n    @benchmark\n    public void testright() {\n        this.list.add("test");\n    }\n\n    @benchmark\n    public void testwrong() {\n        \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n针对testright和testwrong进行测试，testright能够正确通过，因为list内部有值，后置的teardown不会被断言拦截。testwrong会被断言拦截，导致benchmark终止。\n\n和@state混合使用，组合方式不限于以下一种\n\npublic class jmhsample {\n    \n    @state(scope.benchmark)\n    public static class benchmarkstate {\n        double x;\n        @setup\n        public void setup(){\n            x = math.pi;\n        }\n    }\n    \n    @benchmark\n    public void measureshared(benchmarkstate state) {\n        state.x++;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# @warmup\n\n预热所需要配置的一些基本测试参数，可用于类或者方法上。放在benchmark方法上，只对该方法起作用，也可以放在外围类实例上，对该类中的所有benchmark方法起作用。一般前几次进行程序测试的时候会遇到冷启动问题，导致程序很慢，使用@warmup，可以将jit进行提前预热解决冷启动问题，因为 jvm 的 jit 机制的存在，如果某个函数被调用多次之后，jvm 会尝试将其编译为机器码，从而提高执行速度，所以为了让 benchmark 的结果更加接近真实情况就需要进行预热。\n\n 1. iterations：预热的次数\n 2. time：每次预热的时间\n 3. timeunit：时间的单位，默认秒\n 4. batchsize：批处理大小，每次操作调用几次方法\n\n\n# @measurement\n\n实际调用方法所需要配置的一些基本测试参数，可用于类或者方法上，参数和 @warmup相同。\n\n比如\n\n@measurement(iterations = 10, time = 5)\n\n\n1\n\n1\n\n\n表示为迭代10次，每次5s。可用于控制压测时间。\n\n\n# @param\n\n指定某项参数的多种情况，适合用来测试一个函数在不同的参数输入的情况下的性能，只能作用在字段上，使用该注解必须定义@state注解。\n\npublic class jmhsample {\n    \n    @param({"1", "31", "65", "101", "103"})\n    public int arg;\n\n    @param({"0", "1", "2", "4", "8", "16", "32"})\n    public int certainty;\n    \n    @benchmark\n    public boolean bench() {\n        return biginteger.valueof(arg).isprobableprime(certainty);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上述代码的含义为对于arg数组中的每个数，测试是否是certainty数组内以下的素数，压测计算时间，总计执行次数为arg的数组长度xcertainty的数组长度=35次\n\n再看一个例子\n\npublic class jmhsample {\n    \n    @param({"1", "31", "65", "101", "103"})\n    public int arg;\n    \n    @benchmark\n    public boolean bench() {\n        return string.valueof(arg);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上述代码为依次执行arg数组中数据，转换到string类型的耗时\n\n\n# @threads\n\n每个进程中的测试线程，可用于类或者方法上。\n\n\n# @fork\n\n进行fork的次数，可用于类或者方法上。如果fork数是2的话，则jmh会fork出两个进程来进行测试。模拟多进程环境，完全隔离多个进程，不会相互影响。\n\n\n# @outputtimeunit\n\n为统计结果的时间单位，可用于类或者方法注解，单位为timeunit类，支持到纳秒级。\n\n\n# 快速上手\n\n以一个全面的例子来进行解释\n\n@fork(1) // fork 1个进程进行测试\n@benchmarkmode(mode.throughput) // 吞吐量\n@warmup(iterations = 3) // jit预热\n@measurement(iterations = 10, time = 5) // 迭代10次,每次5s\n@outputtimeunit(timeunit.milliseconds) // 结果所使用的时间单位\n@threads(10) // 线程10个\npublic class benchmarktestsimple {\n\n    /**\n     * 作用域为本次jmh测试，线程共享\n     * <p>\n     * 初始化source数据集\n     */\n    @state(scope.benchmark)\n    public static class generatemodel {\n        databasedo databasemodel;\n\n        // 初始化\n        @setup(level.trial)\n        public void prepare() {\n            databasemodel = new modelservice().get();\n        }\n    }\n\n    /**\n     * 初始化mapstruct\n     */\n    @state(scope.benchmark)\n    public static class mapstructinit {\n        mapstructmapper mapstructmapper;\n\n        @setup(level.trial)\n        public void prepare() {\n            mapstructmapper = mappers.getmapper(mapstructmapper.class);\n        }\n    }\n\n    /**\n     * get/set 基准测试\n     *\n     * @param generatemodel source\n     * @return target       databasevo\n     * @throws exception    exception\n     */\n    @benchmark\n    public databasevo testgetset(generatemodel generatemodel) throws exception {\n        databasevo databasevo = new databasevo();\n        databasedo databasemodel = generatemodel.databasemodel;\n        databasevo.setage(databasemodel.getage());\n        databasevo.setname(databasemodel.getname());\n        databasevo.settime(databasemodel.gettime());\n        databasevo.setyear(databasemodel.getyear());\n        databasevo.setothertime(databasemodel.getothertime());\n        return databasevo;\n    }\n\n    /**\n     * mapstruct基准测试\n     *\n     * @param generatemodel source\n     * @param init          初始化的mapper\n     * @return target       databasevo\n     * @throws exception    exception\n     */\n    @benchmark\n    public databasevo testmapstruct(generatemodel generatemodel, mapstructinit init) throws exception {\n        databasevo databasevo = init.mapstructmapper.copy(generatemodel.databasemodel);\n        return databasevo;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\n上述代码的含义为：\n\nfork一个进程进行测试，利用吞吐量作为衡量指标，预热3轮再进行测试，对每个测试方法迭代10次、每次5秒，结果采用微秒作为单位，并采用10个线程进行发压。同时对mapstruct和源数据进行初始化，消除初始化开销，评估mapstruct和原生get/set的性能差异。\n\n\n# jmh-避免死代码消除陷阱\n\n> the downfall of many benchmarks is dead-code elimination (dce): compilers\n> \n> are smart enough to deduce some computations are redundant and eliminate\n> \n> them completely. if the eliminated part was our benchmarked code, we are\n> \n> in trouble.\n> \n> fortunately, jmh provides the essential infrastructure to fight this\n> \n> where appropriate: returning the result of the computation will ask jmh\n> \n> to deal with the result to limit dead-code elimination (returned results\n> \n> are implicitly consumed by blackholes, see jmhsample_09_blackholes).\n\n引用官方的解释: 许多基准测试的失败是因为死代码消除(dce)，因为编译器足够聪明，可以推断出一些计算是冗余的并完全消除掉他们，如果被淘汰的部分是基准测试的代码，那将引起基准测试的失败(不准确)\n\n死代码陷阱的一个典型场景如下\n\npublic class jmhsample {\n    \n    private double x = math.pi;\n    \n    @benchmark\n    public void measurewrong() {\n        // this is wrong: result is not used and the entire computation is optimized away.\n        math.log(x);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上述代码采用void进行返回，使得变量x的结果并没有被用到，jvm优化时会将整个方法的内部代码移除。\n\njmh提供了2种方式避免该问题:\n\n 1. 将变量作为方法的返回值，即此时方法返回double，return math.log(x)\n 2. 通过jmh的blackhole consume避免jit优化消除\n\n通过jmh插件创建的benchmark自带该入参\n\n@benchmark\npublic void measurename(blackhole bh) {\n    bh.consume(xxxxx)\n}\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\njmh的其他死代码陷阱还有常量折叠、常量传播、永远不要在测试中写循环、使用 fork 隔离多个测试方法、方法内联、伪共享与缓存行、分支预测、多线程测试等，可参考jmh专家aleksey shipilev的jmh公开课benchmarking ("the lesser of two evils" story)\n\n\n# jmh可视化\n\njmh打印的结果为文字型，运行时可以指定保存为文件，为了更直观的观察结果，可以尝试使用jmh可视化网站\n\n 1. http://deepoove.com/jmh-visual-chart/\n 2. https://jmh.morethan.io/\n\n\n# 参考文章\n\n[1]. https://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples/\n\n[2]. https://jmeter.apache.org/\n\n[3]. https://github.com/wg/wrk\n\n[4]. https://cloud.tencent.com/developer/article/1896652\n\n[5]. http://shipilev.net/\n\n[6]. https://www.youtube.com/watch?v=vawgocdbxyw',charsets:{cjk:!0},lastUpdated:"2022/12/30, 20:16:31",lastUpdatedTimestamp:1672402591e3},{title:"概览",frontmatter:{title:"概览",article:!1,tags:[null],date:"2022-04-17T18:55:36.000Z",permalink:"/pages/4aef64/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/01.Java/01.Java/05.Java-IO/01.%E6%A6%82%E8%A7%88.html",relativePath:"01.Java/01.Java/05.Java-IO/01.概览.md",key:"v-975bc690",path:"/pages/4aef64/",headersStr:null,content:"提示\n\n正在路上...",normalizedContent:"提示\n\n正在路上...",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"assert语句的运用",frontmatter:{title:"assert语句的运用",date:"2018-07-24T18:41:28.000Z",categories:["Python-基础"],tags:["Python基础","assert"],permalink:"/pages/0de67d/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/01.Python-%E5%9F%BA%E7%A1%80/01.assert%E8%AF%AD%E5%8F%A5%E7%9A%84%E8%BF%90%E7%94%A8.html",relativePath:"02.Python/01.Python-基础/01.assert语句的运用.md",key:"v-074d5d6d",path:"/pages/0de67d/",headers:[{level:3,title:"assert语句的运用",slug:"assert语句的运用",normalizedTitle:"assert语句的运用",charIndex:2},{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:18},{level:2,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:195}],headersStr:"assert语句的运用 代码 运行结果",content:"# assert语句的运用\n\n\n# 代码\n\n# assert语句\n# pop() 函数用于移除列表中的一个元素（默认最后一个元素），并且返回该元素的值。\nmylist = ['item']\nassert len(mylist) >= 1\nprint(mylist.pop())\nassert len(mylist) >= 1\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 运行结果\n\nitem\nTraceback (most recent call last):\n  File \"E:/PythonProject/more/more_assert.py\", line 6, in <module>\n    assert len(mylist) >= 1\nAssertionError\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n",normalizedContent:"# assert语句的运用\n\n\n# 代码\n\n# assert语句\n# pop() 函数用于移除列表中的一个元素（默认最后一个元素），并且返回该元素的值。\nmylist = ['item']\nassert len(mylist) >= 1\nprint(mylist.pop())\nassert len(mylist) >= 1\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 运行结果\n\nitem\ntraceback (most recent call last):\n  file \"e:/pythonproject/more/more_assert.py\", line 6, in <module>\n    assert len(mylist) >= 1\nassertionerror\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n",charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"list(列表)、tuple（元组）、dict（字典）的回顾",frontmatter:{title:"list(列表)、tuple（元组）、dict（字典）的回顾",date:"2018-07-25T20:57:55.000Z",categories:["Python-基础"],tags:["Python基础","Python集合"],permalink:"/pages/50bf39/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/01.Python-%E5%9F%BA%E7%A1%80/02.list(%E5%88%97%E8%A1%A8)%E3%80%81tuple(%E5%85%83%E7%BB%84)%E3%80%81dict(%E5%AD%97%E5%85%B8)%E7%9A%84%E5%9B%9E%E9%A1%BE.html",relativePath:"02.Python/01.Python-基础/02.list(列表)、tuple(元组)、dict(字典)的回顾.md",key:"v-f15f9572",path:"/pages/50bf39/",headers:[{level:3,title:"list(列表)、tuple（元组）、dict（字典）的回顾",slug:"list-列表-、tuple-元组-、dict-字典-的回顾",normalizedTitle:"list(列表)、tuple（元组）、dict（字典）的回顾",charIndex:2},{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:37},{level:2,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:1479},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:1898}],headersStr:"list(列表)、tuple（元组）、dict（字典）的回顾 代码 运行结果 总结",content:'# list(列表)、tuple（元组）、dict（字典）的回顾\n\n\n# 代码\n\nlist1 = [5, 6, 87, 671, 3, 54, 67, 0, 1, -6, -7]\n\n# 升序排序\n\nlist1.sort()\nprint(list1)\n\n# 降序排序\nlist1.sort(reverse=True)\nprint(list1)\n\n# 列表和元组之间相互转换\nprint(type(list1))\n\n# 1、列表转换成元组\nnum_tuple = tuple(list1)\nprint(type(num_tuple))\n\n# 2 、元组转换成列表\nnum2_list = list(num_tuple)\nprint(type(num2_list))\n\n# 字典的使用\n# 1、取值\ndict_test = {"name": "xxx"}\nprint(dict_test["name"])\n\n# 2、增加/修改\ndict_test["age"] = 18  # 增加\ndict_test["name"] = "yyy"  # 修改\nprint(dict_test)\n# 3、删除\ndict_test.pop("name")\nprint(dict_test)\n# 4、统计键值对的数量\nprint(len(dict_test))\n# 5、合并字典\n# 如果被合并的字典中包含已经存在的键值对，会覆盖原有的键值对\ntemp_dict = {"height": 123,\n             "age": 20}\ndict_test.update(temp_dict)\nprint(dict_test)\n# 6、清空字典\ndict_test.clear()\nprint(dict_test)\n# 7、迭代遍历字典\n# 变量k是每次循环中，获取到的键值对的值\nnew_dict = {"name": "xxx",\n            "age": 20,\n            "height": 200}\nfor k in new_dict:\n    print("{} - {}".format(k, new_dict[k]))\n# 8、列表中保存多个字典,并用for循环迭代输出\nlist2 = [\n    {"name": "qqq",\n     "email": "163",\n     "phone": 119},\n    {"name": "sss",\n     "email": "cc",\n     "phone": 110}\n]\nfor i in list2:\n    print(i)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n\n\n\n# 运行结果\n\n[-7, -6, 0, 1, 3, 5, 6, 54, 67, 87, 671]\n[671, 87, 67, 54, 6, 5, 3, 1, 0, -6, -7]\n<class \'list\'>\n<class \'tuple\'>\n<class \'list\'>\nxxx\n{\'age\': 18, \'name\': \'yyy\'}\n{\'age\': 18}\n1\n{\'age\': 20, \'height\': 123}\n{}\nage - 20\nname - xxx\nheight - 200\n{\'phone\': 119, \'name\': \'qqq\', \'email\': \'163\'}\n{\'phone\': 110, \'name\': \'sss\', \'email\': \'cc\'}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 总结\n\n总结：\n\nlist使用的是方括号，类似与数组结构， tuple元组使用的是圆括号，跟list类似但是数据不能进行修改， 所以应用的场景基本上用在需要数据存储，或者是需要保证数据安全无法修改的情况， 字典用的是大括号，是key-value结构的, 操作数据的时候，是操作key，而不是索引。',normalizedContent:'# list(列表)、tuple（元组）、dict（字典）的回顾\n\n\n# 代码\n\nlist1 = [5, 6, 87, 671, 3, 54, 67, 0, 1, -6, -7]\n\n# 升序排序\n\nlist1.sort()\nprint(list1)\n\n# 降序排序\nlist1.sort(reverse=true)\nprint(list1)\n\n# 列表和元组之间相互转换\nprint(type(list1))\n\n# 1、列表转换成元组\nnum_tuple = tuple(list1)\nprint(type(num_tuple))\n\n# 2 、元组转换成列表\nnum2_list = list(num_tuple)\nprint(type(num2_list))\n\n# 字典的使用\n# 1、取值\ndict_test = {"name": "xxx"}\nprint(dict_test["name"])\n\n# 2、增加/修改\ndict_test["age"] = 18  # 增加\ndict_test["name"] = "yyy"  # 修改\nprint(dict_test)\n# 3、删除\ndict_test.pop("name")\nprint(dict_test)\n# 4、统计键值对的数量\nprint(len(dict_test))\n# 5、合并字典\n# 如果被合并的字典中包含已经存在的键值对，会覆盖原有的键值对\ntemp_dict = {"height": 123,\n             "age": 20}\ndict_test.update(temp_dict)\nprint(dict_test)\n# 6、清空字典\ndict_test.clear()\nprint(dict_test)\n# 7、迭代遍历字典\n# 变量k是每次循环中，获取到的键值对的值\nnew_dict = {"name": "xxx",\n            "age": 20,\n            "height": 200}\nfor k in new_dict:\n    print("{} - {}".format(k, new_dict[k]))\n# 8、列表中保存多个字典,并用for循环迭代输出\nlist2 = [\n    {"name": "qqq",\n     "email": "163",\n     "phone": 119},\n    {"name": "sss",\n     "email": "cc",\n     "phone": 110}\n]\nfor i in list2:\n    print(i)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n\n\n\n# 运行结果\n\n[-7, -6, 0, 1, 3, 5, 6, 54, 67, 87, 671]\n[671, 87, 67, 54, 6, 5, 3, 1, 0, -6, -7]\n<class \'list\'>\n<class \'tuple\'>\n<class \'list\'>\nxxx\n{\'age\': 18, \'name\': \'yyy\'}\n{\'age\': 18}\n1\n{\'age\': 20, \'height\': 123}\n{}\nage - 20\nname - xxx\nheight - 200\n{\'phone\': 119, \'name\': \'qqq\', \'email\': \'163\'}\n{\'phone\': 110, \'name\': \'sss\', \'email\': \'cc\'}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 总结\n\n总结：\n\nlist使用的是方括号，类似与数组结构， tuple元组使用的是圆括号，跟list类似但是数据不能进行修改， 所以应用的场景基本上用在需要数据存储，或者是需要保证数据安全无法修改的情况， 字典用的是大括号，是key-value结构的, 操作数据的时候，是操作key，而不是索引。',charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"Python中的Docstring",frontmatter:{title:"Python中的Docstring",date:"2018-06-27T17:14:51.000Z",categories:["Python-基础"],tags:["Python基础"],permalink:"/pages/31bd37/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/01.Python-%E5%9F%BA%E7%A1%80/03.Python%E4%B8%AD%E7%9A%84Docstring.html",relativePath:"02.Python/01.Python-基础/03.Python中的Docstring.md",key:"v-b94bd26c",path:"/pages/31bd37/",headers:[{level:3,title:"基本教程",slug:"基本教程",normalizedTitle:"基本教程",charIndex:2}],headersStr:"基本教程",content:"# 基本教程\n\n'''\n文档字符串的应用\n\n该文档字符串所约定的是一串多行字符串，其中第一行以某一大写字母开始，以句号结束。\n第二行为空行，后跟的第三行开始是任何详细的解释说明。 在此强烈建议你在有关你所有非\n凡功能的文档字符串中都遵循这一约定。\n'''\n\n\ndef print_max(x, y):\n    '''Prints the maximum of two numbers.打印两个数值中的最大数。\n\n    The two values must be integers.这两个数都应该是整数\n    '''\n    # 如果可能，将其转换至整数类型\n    x = int(x)\n    y = int(y)\n\n    if x > y:\n        print(x, 'is maximum')\n    else:\n        print(y, 'is maximum')\n\n\nprint_max(3, 5)\nprint(print_max.__doc__)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n",normalizedContent:"# 基本教程\n\n'''\n文档字符串的应用\n\n该文档字符串所约定的是一串多行字符串，其中第一行以某一大写字母开始，以句号结束。\n第二行为空行，后跟的第三行开始是任何详细的解释说明。 在此强烈建议你在有关你所有非\n凡功能的文档字符串中都遵循这一约定。\n'''\n\n\ndef print_max(x, y):\n    '''prints the maximum of two numbers.打印两个数值中的最大数。\n\n    the two values must be integers.这两个数都应该是整数\n    '''\n    # 如果可能，将其转换至整数类型\n    x = int(x)\n    y = int(y)\n\n    if x > y:\n        print(x, 'is maximum')\n    else:\n        print(y, 'is maximum')\n\n\nprint_max(3, 5)\nprint(print_max.__doc__)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n",charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"Python中的多态",frontmatter:{title:"Python中的多态",date:"2018-08-08T19:41:53.000Z",categories:["Python-基础"],tags:["Python多态","Python基础"],permalink:"/pages/866a91/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/01.Python-%E5%9F%BA%E7%A1%80/04.Python%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%80%81.html",relativePath:"02.Python/01.Python-基础/04.Python中的多态.md",key:"v-325034ba",path:"/pages/866a91/",headers:[{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:49},{level:2,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:1167}],headersStr:"代码 运行结果",content:'当子类和父类都存在相同的 game()方法时，子类的 game() 覆盖了父类的 game()，在代码运行时，会调用子类的 game()。\n\n这样，我们就获得了继承的另一个好处：多态。\n\n多态的好处就是，当我们需要传入更多的子类，例如新增 XX Dog、YY Dog 等时，我们只需要继承 Dog 类型就可以了，而game()方法既可以直不重写（即使用Dog的），也可以重写一个特有的。这就是多态的意思。调用方只管调用，不管细节，而当我们新增一种Dog的子类时，只要确保新方法编写正确，而不用管原来的代码。这就是著名的“开闭”原则：\n\n * 对扩展开放（Open for extension）：允许子类重写方法函数\n * 对修改封闭（Closed for modification）：不重写，直接继承父类方法函数\n\n\n# 代码\n\nclass Dog(object):\n\n    def __init__(self, name):\n        self.name = name\n\n    def game(self):\n        print("{}跳".format(self.name))\n\n\nclass XiaoTianDog(Dog):\n\n    # 方法重写\n    def game(self):\n        print("{}飞".format(self.name))\n\n\nclass Person(object):\n\n    def __init__(self, name):\n        self.name = name\n\n    def game_with_dog(self, dog):\n        print("{}和{}玩耍".format(self.name, dog.name))\n\n\n# 创建Dog对象\nPeter = Dog("皮特")\n# 创建XiaoTianDog对象\nwangcai = XiaoTianDog("旺财")\n# 调用Dog里面的game方法\nPeter.game()\n# 调用XiaoTianDog里面的game方法\nwangcai.game()\nxiaoming = Person("小明")\nxiaoming.game_with_dog(wangcai)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 运行结果\n\n皮特跳\n旺财飞\n小明和旺财玩耍\n\n\n1\n2\n3\n\n1\n2\n3\n',normalizedContent:'当子类和父类都存在相同的 game()方法时，子类的 game() 覆盖了父类的 game()，在代码运行时，会调用子类的 game()。\n\n这样，我们就获得了继承的另一个好处：多态。\n\n多态的好处就是，当我们需要传入更多的子类，例如新增 xx dog、yy dog 等时，我们只需要继承 dog 类型就可以了，而game()方法既可以直不重写（即使用dog的），也可以重写一个特有的。这就是多态的意思。调用方只管调用，不管细节，而当我们新增一种dog的子类时，只要确保新方法编写正确，而不用管原来的代码。这就是著名的“开闭”原则：\n\n * 对扩展开放（open for extension）：允许子类重写方法函数\n * 对修改封闭（closed for modification）：不重写，直接继承父类方法函数\n\n\n# 代码\n\nclass dog(object):\n\n    def __init__(self, name):\n        self.name = name\n\n    def game(self):\n        print("{}跳".format(self.name))\n\n\nclass xiaotiandog(dog):\n\n    # 方法重写\n    def game(self):\n        print("{}飞".format(self.name))\n\n\nclass person(object):\n\n    def __init__(self, name):\n        self.name = name\n\n    def game_with_dog(self, dog):\n        print("{}和{}玩耍".format(self.name, dog.name))\n\n\n# 创建dog对象\npeter = dog("皮特")\n# 创建xiaotiandog对象\nwangcai = xiaotiandog("旺财")\n# 调用dog里面的game方法\npeter.game()\n# 调用xiaotiandog里面的game方法\nwangcai.game()\nxiaoming = person("小明")\nxiaoming.game_with_dog(wangcai)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 运行结果\n\n皮特跳\n旺财飞\n小明和旺财玩耍\n\n\n1\n2\n3\n\n1\n2\n3\n',charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"Python中的集合",frontmatter:{title:"Python中的集合",date:"2018-07-07T17:34:06.000Z",categories:["Python-基础"],tags:["Python基础","Python集合"],permalink:"/pages/c47343/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/01.Python-%E5%9F%BA%E7%A1%80/05.Python%E4%B8%AD%E7%9A%84%E9%9B%86%E5%90%88.html",relativePath:"02.Python/01.Python-基础/05.Python中的集合.md",key:"v-6d4f7ede",path:"/pages/c47343/",headers:[{level:3,title:"集合",slug:"集合",normalizedTitle:"集合",charIndex:2},{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:131},{level:2,title:"输出结果",slug:"输出结果",normalizedTitle:"输出结果",charIndex:435}],headersStr:"集合 代码 输出结果",content:"# 集合\n\n集合（Set）是简单对象的无序集合（Collection）。当集合中的项目存在与否比起次序或其出 现次数更加重要时，我们就会使用集合。 通过使用集合，你可以测试某些对象的资格或情况，检查它们是否是其它集合的子集，找到 两个集合的交集，等等。\n\n\n# 代码\n\n# 集合    判断子集\n\nbri = set(['brazil', 'russia', 'india'])\n\nif 'india' in bri:\n    print('True')\nif 'usa' in bri:\n    print('False')\nbric = bri.copy()\nbric.add('china')\nprint(bric.issuperset(bri))\nbri.remove('russia')\nprint(bri & bric)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 输出结果\n\nTrue True {'india', 'brazil'}",normalizedContent:"# 集合\n\n集合（set）是简单对象的无序集合（collection）。当集合中的项目存在与否比起次序或其出 现次数更加重要时，我们就会使用集合。 通过使用集合，你可以测试某些对象的资格或情况，检查它们是否是其它集合的子集，找到 两个集合的交集，等等。\n\n\n# 代码\n\n# 集合    判断子集\n\nbri = set(['brazil', 'russia', 'india'])\n\nif 'india' in bri:\n    print('true')\nif 'usa' in bri:\n    print('false')\nbric = bri.copy()\nbric.add('china')\nprint(bric.issuperset(bri))\nbri.remove('russia')\nprint(bri & bric)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 输出结果\n\ntrue true {'india', 'brazil'}",charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"Python中的列表",frontmatter:{title:"Python中的列表",date:"2018-07-07T17:19:37.000Z",categories:["Python-基础"],tags:["Python基础"],permalink:"/pages/c498f9/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/01.Python-%E5%9F%BA%E7%A1%80/06.Python%E4%B8%AD%E7%9A%84%E5%88%97%E8%A1%A8.html",relativePath:"02.Python/01.Python-基础/06.Python中的列表.md",key:"v-2d7b28d6",path:"/pages/c498f9/",headers:[{level:3,title:"列表",slug:"列表",normalizedTitle:"列表",charIndex:2},{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:141}],headersStr:"列表 代码",content:"# 列表\n\n列表 是一种用于保存一系列有序项目的集合，也就是说，你可以利用列表保存一串项目的序 列。想象起来也不难，你可以想象你有一张购物清单，上面列出了需要购买的商品，除开在 购物清单上你可能为每件物品都单独列一行，在 Python 中你需要在它们之间多加上一个逗 号。\n\n\n# 代码\n\n# 列表\n# This is my shopping list\n'''\n在这里要注意在调用  print  函数时我们使用  end  参数，这样就能通过一个空格来结束输出\n工作，而不是通常的换行。\n'''\nshoplist = ['apple', 'mango', 'carrot', 'banana']\n\nprint('I have', len(shoplist), 'items to purchase')\n\nprint('These item are:', end=' ')\nfor item in shoplist:\n    print(item, end=' ')\n\nprint('\\nI also have to buy rice.')\nshoplist.append('rice')\nprint('My shopping list is now', shoplist)\n\nprint('I will sort my list now')\nshoplist.sort()\nprint('Sorted shopping list is', shoplist)\n\nprint('The first item I will buy is', shoplist[0])\nolditem = shoplist[0]\ndel shoplist[0]\nprint('I bought the', olditem)\nprint('My shopping list is now', shoplist)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n",normalizedContent:"# 列表\n\n列表 是一种用于保存一系列有序项目的集合，也就是说，你可以利用列表保存一串项目的序 列。想象起来也不难，你可以想象你有一张购物清单，上面列出了需要购买的商品，除开在 购物清单上你可能为每件物品都单独列一行，在 python 中你需要在它们之间多加上一个逗 号。\n\n\n# 代码\n\n# 列表\n# this is my shopping list\n'''\n在这里要注意在调用  print  函数时我们使用  end  参数，这样就能通过一个空格来结束输出\n工作，而不是通常的换行。\n'''\nshoplist = ['apple', 'mango', 'carrot', 'banana']\n\nprint('i have', len(shoplist), 'items to purchase')\n\nprint('these item are:', end=' ')\nfor item in shoplist:\n    print(item, end=' ')\n\nprint('\\ni also have to buy rice.')\nshoplist.append('rice')\nprint('my shopping list is now', shoplist)\n\nprint('i will sort my list now')\nshoplist.sort()\nprint('sorted shopping list is', shoplist)\n\nprint('the first item i will buy is', shoplist[0])\nolditem = shoplist[0]\ndel shoplist[0]\nprint('i bought the', olditem)\nprint('my shopping list is now', shoplist)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n",charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"Python中的序列以及切片的解释",frontmatter:{title:"Python中的序列以及切片的解释",date:"2018-07-07T17:07:39.000Z",categories:["Python-基础"],tags:["Python基础","Python切片"],permalink:"/pages/0d6aa8/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/01.Python-%E5%9F%BA%E7%A1%80/07.Python%E4%B8%AD%E7%9A%84%E5%BA%8F%E5%88%97%E4%BB%A5%E5%8F%8A%E5%88%87%E7%89%87%E7%9A%84%E8%A7%A3%E9%87%8A.html",relativePath:"02.Python/01.Python-基础/07.Python中的序列以及切片的解释.md",key:"v-54833ab4",path:"/pages/0d6aa8/",headers:[{level:3,title:"python中的序列以及切片的解释",slug:"python中的序列以及切片的解释",normalizedTitle:"python中的序列以及切片的解释",charIndex:2},{level:2,title:"切片：",slug:"切片",normalizedTitle:"切片：",charIndex:24},{level:2,title:"序列",slug:"序列",normalizedTitle:"序列",charIndex:10}],headersStr:"python中的序列以及切片的解释 切片： 序列",content:"# python中的序列以及切片的解释\n\n\n# 切片：\n\n有一种切片（Slicing）运算 符，它能够允许我们序列中的某段切片——也就是序列之中的一部分。\n\n\n# 序列\n\n# 序列  跑一下看看\n\nshoplist = ['apple', 'mango', 'carrot', 'banana']\nname = 'swaroop'\n\n# Indexing or 'Subscription' operation #\n# 索引或“下标（Subcription）”操作符 #\nprint('Item 0 is', shoplist[0])\nprint('Item 1 is', shoplist[1])\nprint('Item 2 is', shoplist[2])\nprint('Item 3 is', shoplist[3])\nprint('Item -1 is', shoplist[-1])\nprint('Item -2 is', shoplist[-2])\nprint('Character 0 is', name[0])\n\n# Slicing on a list #\nprint('Item 1 to 3 is', shoplist[1:3])\nprint('Item 2 to end is', shoplist[2:])\nprint('Item 1 to -1 is', shoplist[1:-1])\nprint('Item start to end is', shoplist[:])\n\n# 从某一字符串中切片 #\nprint('characters 1 to 3 is', name[1:3])\nprint('characters 2 to end is', name[2:])\nprint('characters 1 to -1 is', name[1:-1])\nprint('characters start to end is', name[:])\n\n'''\n你会注意到当步长为 2 时，我们得到的是第 0、2、4…… 位项目。当步长为 3 时，我们得到\n的是第 0、3……位项目。\n'''\nprint(shoplist[::1])\nprint(shoplist[::2])\nprint(shoplist[::3])\nprint(shoplist[::-1])\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n",normalizedContent:"# python中的序列以及切片的解释\n\n\n# 切片：\n\n有一种切片（slicing）运算 符，它能够允许我们序列中的某段切片——也就是序列之中的一部分。\n\n\n# 序列\n\n# 序列  跑一下看看\n\nshoplist = ['apple', 'mango', 'carrot', 'banana']\nname = 'swaroop'\n\n# indexing or 'subscription' operation #\n# 索引或“下标（subcription）”操作符 #\nprint('item 0 is', shoplist[0])\nprint('item 1 is', shoplist[1])\nprint('item 2 is', shoplist[2])\nprint('item 3 is', shoplist[3])\nprint('item -1 is', shoplist[-1])\nprint('item -2 is', shoplist[-2])\nprint('character 0 is', name[0])\n\n# slicing on a list #\nprint('item 1 to 3 is', shoplist[1:3])\nprint('item 2 to end is', shoplist[2:])\nprint('item 1 to -1 is', shoplist[1:-1])\nprint('item start to end is', shoplist[:])\n\n# 从某一字符串中切片 #\nprint('characters 1 to 3 is', name[1:3])\nprint('characters 2 to end is', name[2:])\nprint('characters 1 to -1 is', name[1:-1])\nprint('characters start to end is', name[:])\n\n'''\n你会注意到当步长为 2 时，我们得到的是第 0、2、4…… 位项目。当步长为 3 时，我们得到\n的是第 0、3……位项目。\n'''\nprint(shoplist[::1])\nprint(shoplist[::2])\nprint(shoplist[::3])\nprint(shoplist[::-1])\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n",charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"Python中的引用和切片",frontmatter:{title:"Python中的引用和切片",date:"2018-07-07T16:04:03.000Z",categories:["Python-基础"],tags:["Python基础","引用","切片"],permalink:"/pages/037f6f/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/01.Python-%E5%9F%BA%E7%A1%80/08.Python%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8%E5%92%8C%E5%88%87%E7%89%87.html",relativePath:"02.Python/01.Python-基础/08.Python中的引用和切片.md",key:"v-f4a93384",path:"/pages/037f6f/",headers:[{level:3,title:"引用和切片造成的不同影响",slug:"引用和切片造成的不同影响",normalizedTitle:"引用和切片造成的不同影响",charIndex:2}],excerpt:'<h3 id="引用和切片造成的不同影响"><a class="header-anchor" href="#引用和切片造成的不同影响">#</a> 引用和切片造成的不同影响</h3>\n<p>当你创建了一个对象并将其分配给某个变量时，变量只会查阅（Refer）某个对象，并且它也\n不会代表对象本身。也就是说，变量名只是指向你计算机内存中存储了相应对象的那一部\n分。这叫作将名称绑定（Binding）给那一个对象。\n一般来说，你不需要去关心这个，不过由于这一引用操作困难会产生某些微妙的效果，这是\n需要你注意的：</p>\n',headersStr:"引用和切片造成的不同影响",content:"# 引用和切片造成的不同影响\n\n当你创建了一个对象并将其分配给某个变量时，变量只会查阅（Refer）某个对象，并且它也 不会代表对象本身。也就是说，变量名只是指向你计算机内存中存储了相应对象的那一部 分。这叫作将名称绑定（Binding）给那一个对象。 一般来说，你不需要去关心这个，不过由于这一引用操作困难会产生某些微妙的效果，这是 需要你注意的：\n\n'''如果直接引用对象的话，对mylist操作也会影响到原本的shoplist\n如果想要不影响原本的，必须引用的是对象的切片，切片即为副本\n'''\n\nprint('Simple Assignment')\nshoplist = ['apple', 'mango', 'carrot', 'banana']\n# mylist 只是指向同一对象的另一种名称\nmylist = shoplist\n\n# 我购买了第一项项目，所以我将其从列表中删除\ndel shoplist[0]\n\nprint('shoplist is', shoplist)\nprint('mylist is', mylist)\n# 注意到 shoplist 和 mylist 二者都\n# 打印出了其中都没有 apple 的同样的列表，以此我们确认\n# 它们指向的是同一个对象\n\nprint('Copy by making a full slice')\n# 通过生成一份完整的切片制作一份列表的副本\nmylist = shoplist[:]\n# 删除第一个项目\ndel mylist[0]\n\nprint('shoplist is', shoplist)\nprint('mylist is', mylist)\n# 注意到现在两份列表已出现不同\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n",normalizedContent:"# 引用和切片造成的不同影响\n\n当你创建了一个对象并将其分配给某个变量时，变量只会查阅（refer）某个对象，并且它也 不会代表对象本身。也就是说，变量名只是指向你计算机内存中存储了相应对象的那一部 分。这叫作将名称绑定（binding）给那一个对象。 一般来说，你不需要去关心这个，不过由于这一引用操作困难会产生某些微妙的效果，这是 需要你注意的：\n\n'''如果直接引用对象的话，对mylist操作也会影响到原本的shoplist\n如果想要不影响原本的，必须引用的是对象的切片，切片即为副本\n'''\n\nprint('simple assignment')\nshoplist = ['apple', 'mango', 'carrot', 'banana']\n# mylist 只是指向同一对象的另一种名称\nmylist = shoplist\n\n# 我购买了第一项项目，所以我将其从列表中删除\ndel shoplist[0]\n\nprint('shoplist is', shoplist)\nprint('mylist is', mylist)\n# 注意到 shoplist 和 mylist 二者都\n# 打印出了其中都没有 apple 的同样的列表，以此我们确认\n# 它们指向的是同一个对象\n\nprint('copy by making a full slice')\n# 通过生成一份完整的切片制作一份列表的副本\nmylist = shoplist[:]\n# 删除第一个项目\ndel mylist[0]\n\nprint('shoplist is', shoplist)\nprint('mylist is', mylist)\n# 注意到现在两份列表已出现不同\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n",charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"Python中的元组",frontmatter:{title:"Python中的元组",date:"2018-07-07T17:15:01.000Z",categories:["Python-基础"],tags:["Python基础","元组"],permalink:"/pages/e8270d/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/01.Python-%E5%9F%BA%E7%A1%80/09.Python%E4%B8%AD%E7%9A%84%E5%85%83%E7%BB%84.html",relativePath:"02.Python/01.Python-基础/09.Python中的元组.md",key:"v-0ad9c9b7",path:"/pages/e8270d/",headers:[{level:3,title:"元组",slug:"元组",normalizedTitle:"元组",charIndex:2},{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:204}],headersStr:"元组 代码",content:"# 元组\n\n元组（Tuple）用于将多个对象保存到一起。你可以将它们近似地看作列表，但是元组不能提供列表类能够提供给你的广泛的功能。元组的一大特征类似于字符串，它们是不可变的，也就是说，你不能编辑或更改元组。元组是通过特别指定项目来定义的，在指定项目时，你可以给它们加上括号，并在括号内部用逗号进行分隔。元组通常用于保证某一语句或某一用户定义的函数可以安全地采用一组数值，意即元组内的数值不会改变。\n\n\n# 代码\n\n# 元组\n'''\n推荐使用括号来指明元组的开始和结束\n尽管括号是一个可选选项\n明了胜过晦涩，显式优于隐式\n'''\nzoo = ('python', 'elephant', 'penguin')\nprint('Number of animals in the zoo is', len(zoo))\nnew_zoo = 'monkey', 'camel', zoo\nprint('Number of animals in the zoo is', len(new_zoo))\nprint('All animals in new zoo are', new_zoo)\nprint('Animals brought from old zoo are', new_zoo[2])\nprint('Last animal brought from old zoo is', new_zoo[2][2])\nprint('Number of animals in the new zoo is',\n      len(new_zoo) - 1 + len(new_zoo[2]))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n",normalizedContent:"# 元组\n\n元组（tuple）用于将多个对象保存到一起。你可以将它们近似地看作列表，但是元组不能提供列表类能够提供给你的广泛的功能。元组的一大特征类似于字符串，它们是不可变的，也就是说，你不能编辑或更改元组。元组是通过特别指定项目来定义的，在指定项目时，你可以给它们加上括号，并在括号内部用逗号进行分隔。元组通常用于保证某一语句或某一用户定义的函数可以安全地采用一组数值，意即元组内的数值不会改变。\n\n\n# 代码\n\n# 元组\n'''\n推荐使用括号来指明元组的开始和结束\n尽管括号是一个可选选项\n明了胜过晦涩，显式优于隐式\n'''\nzoo = ('python', 'elephant', 'penguin')\nprint('number of animals in the zoo is', len(zoo))\nnew_zoo = 'monkey', 'camel', zoo\nprint('number of animals in the zoo is', len(new_zoo))\nprint('all animals in new zoo are', new_zoo)\nprint('animals brought from old zoo are', new_zoo[2])\nprint('last animal brought from old zoo is', new_zoo[2][2])\nprint('number of animals in the new zoo is',\n      len(new_zoo) - 1 + len(new_zoo[2]))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n",charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"Python中对列表和元组的切片操作",frontmatter:{title:"Python中对列表和元组的切片操作",date:"2018-07-26T20:04:26.000Z",categories:["Python-基础"],tags:["Python基础","切片"],permalink:"/pages/bf2ef2/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/01.Python-%E5%9F%BA%E7%A1%80/10.Python%E4%B8%AD%E5%AF%B9%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84%E7%9A%84%E5%88%87%E7%89%87%E6%93%8D%E4%BD%9C.html",relativePath:"02.Python/01.Python-基础/10.Python中对列表和元组的切片操作.md",key:"v-9ede4212",path:"/pages/bf2ef2/",headers:[{level:3,title:"python中对列表和元组的切片操作",slug:"python中对列表和元组的切片操作",normalizedTitle:"python中对列表和元组的切片操作",charIndex:2},{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:25},{level:2,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:266}],headersStr:"python中对列表和元组的切片操作 代码 运行结果",content:"# python中对列表和元组的切片操作\n\n\n# 代码\n\n# 切片方法用于列表、元组,切片方法不能用于字典\nlist_tmp = [0, 1, 2, 3, 4]\ntuple_tmp = (4, 3, 2, 1, 0)\n# 列表输出\nprint([0, 1, 2, 3, 4][1:3])\nprint(list_tmp[1:3])\n# 元组输出\nprint((4, 3, 2, 1, 0)[1:3])\nprint(tuple_tmp[1:3])\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 运行结果\n\n[1, 2]\n[1, 2]\n(3, 2)\n(3, 2)\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n",normalizedContent:"# python中对列表和元组的切片操作\n\n\n# 代码\n\n# 切片方法用于列表、元组,切片方法不能用于字典\nlist_tmp = [0, 1, 2, 3, 4]\ntuple_tmp = (4, 3, 2, 1, 0)\n# 列表输出\nprint([0, 1, 2, 3, 4][1:3])\nprint(list_tmp[1:3])\n# 元组输出\nprint((4, 3, 2, 1, 0)[1:3])\nprint(tuple_tmp[1:3])\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 运行结果\n\n[1, 2]\n[1, 2]\n(3, 2)\n(3, 2)\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n",charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"Python中完整for循环的实际运用",frontmatter:{title:"Python中完整for循环的实际运用",date:"2018-07-26T09:56:03.000Z",categories:["Python-基础"],tags:["Python基础"],permalink:"/pages/7c7c36/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/01.Python-%E5%9F%BA%E7%A1%80/11.Python%E4%B8%AD%E5%AE%8C%E6%95%B4for%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%AE%9E%E9%99%85%E8%BF%90%E7%94%A8.html",relativePath:"02.Python/01.Python-基础/11.Python中完整for循环的实际运用.md",key:"v-2f68e86c",path:"/pages/7c7c36/",headers:[{level:3,title:"python中完整for循环的实际运用",slug:"python中完整for循环的实际运用",normalizedTitle:"python中完整for循环的实际运用",charIndex:2},{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:26},{level:2,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:520}],headersStr:"python中完整for循环的实际运用 代码 运行结果",content:'# python中完整for循环的实际运用\n\n\n# 代码\n\n# 完整的for循环的实际应用  for...else结构\n\nstudents = [\n    {"name": "xx"},\n    {"name": "yy"}\n]\n# 在学院列表中搜索指定的姓名\nfind_name = "SS"\n\nfor i in students:\n    print(i)\n    if i["name"] == find_name:\n        print("找到了 {}".format(find_name))\n\n        # 如果已经找到，应该直接退出循环，而不再遍历后续的元素\n    # 如果把这个else写在if语句之后的话，每次没有找到就要输出一次，这是不对的！\n        break\nelse:\n    print("没有找到{}".format(find_name))\nprint("循环结束")\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 运行结果\n\n{\'name\': \'xx\'}\n{\'name\': \'yy\'}\n没有找到SS\n循环结束\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n',normalizedContent:'# python中完整for循环的实际运用\n\n\n# 代码\n\n# 完整的for循环的实际应用  for...else结构\n\nstudents = [\n    {"name": "xx"},\n    {"name": "yy"}\n]\n# 在学院列表中搜索指定的姓名\nfind_name = "ss"\n\nfor i in students:\n    print(i)\n    if i["name"] == find_name:\n        print("找到了 {}".format(find_name))\n\n        # 如果已经找到，应该直接退出循环，而不再遍历后续的元素\n    # 如果把这个else写在if语句之后的话，每次没有找到就要输出一次，这是不对的！\n        break\nelse:\n    print("没有找到{}".format(find_name))\nprint("循环结束")\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 运行结果\n\n{\'name\': \'xx\'}\n{\'name\': \'yy\'}\n没有找到ss\n循环结束\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n',charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"Python中字典(key-value)",frontmatter:{title:"Python中字典(key-value)",date:"2018-07-07T17:25:27.000Z",categories:["Python-基础"],tags:["Python基础","字典"],permalink:"/pages/76ac47/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/01.Python-%E5%9F%BA%E7%A1%80/12.Python%E4%B8%AD%E5%AD%97%E5%85%B8(key-value).html",relativePath:"02.Python/01.Python-基础/12.Python中字典(key-value).md",key:"v-53f9261a",path:"/pages/76ac47/",headers:[{level:3,title:"字典（key-value）",slug:"字典-key-value",normalizedTitle:"字典（key-value）",charIndex:2},{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:171}],headersStr:"字典（key-value） 代码",content:"# 字典（key-value）\n\n字典就像一本地址簿，如果你知道了他或她的姓名，你就可以在这里找到其地址或是能够联 系上对方的更多详细信息，换言之，我们将键值（Keys）（即姓名）与值（Values）（即地 址等详细信息）联立到一起。在这里要注意到键值必须是唯一的，正如在现实中面对两个完 全同名的人你没办法找出有关他们的正确信息。\n\n\n# 代码\n\n# 字典\n# \"ab\"是地址（Address）薄(Book)的缩写\n\nab = {\n    'Swaroop': 'swaroop@swaroopch.com',\n    'Larry': 'larry@wall.org',\n    'Matsumoto': 'matz@ruby-lang.org',\n    'Spammer': 'spammer@hptmail.com'\n}\n\nprint(\"Swaroop's address is\", ab['Swaroop'])\n\n# 删除一对键值-值配对\ndel ab['Spammer']\n\nprint('\\nThere are {} contacts in the address-book\\n'.format(len(ab)))\n\n#我们通过使用字典的  item  方法来访问字典中的每一对键值—值配对信息，这一操作将返回一份包含元组的列表\n\nfor name, address in ab.items():\n    print('Contact {} at {}'.format(name, address))\n\n# 添加一对键值-值配对\nab['Guido'] = 'guido@python.org'\n\nif 'Guido' in ab:\n    print(\"\\nGuido's address is\", ab['Guido'])\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n",normalizedContent:"# 字典（key-value）\n\n字典就像一本地址簿，如果你知道了他或她的姓名，你就可以在这里找到其地址或是能够联 系上对方的更多详细信息，换言之，我们将键值（keys）（即姓名）与值（values）（即地 址等详细信息）联立到一起。在这里要注意到键值必须是唯一的，正如在现实中面对两个完 全同名的人你没办法找出有关他们的正确信息。\n\n\n# 代码\n\n# 字典\n# \"ab\"是地址（address）薄(book)的缩写\n\nab = {\n    'swaroop': 'swaroop@swaroopch.com',\n    'larry': 'larry@wall.org',\n    'matsumoto': 'matz@ruby-lang.org',\n    'spammer': 'spammer@hptmail.com'\n}\n\nprint(\"swaroop's address is\", ab['swaroop'])\n\n# 删除一对键值-值配对\ndel ab['spammer']\n\nprint('\\nthere are {} contacts in the address-book\\n'.format(len(ab)))\n\n#我们通过使用字典的  item  方法来访问字典中的每一对键值—值配对信息，这一操作将返回一份包含元组的列表\n\nfor name, address in ab.items():\n    print('contact {} at {}'.format(name, address))\n\n# 添加一对键值-值配对\nab['guido'] = 'guido@python.org'\n\nif 'guido' in ab:\n    print(\"\\nguido's address is\", ab['guido'])\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n",charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"Python中字符串的一些方法回顾(拆分与合并)",frontmatter:{title:"Python中字符串的一些方法回顾(拆分与合并)",date:"2018-07-26T19:40:01.000Z",categories:["Python-基础"],tags:["Python基础"],permalink:"/pages/5386bd/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/01.Python-%E5%9F%BA%E7%A1%80/13.Python%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95%E5%9B%9E%E9%A1%BE(%E6%8B%86%E5%88%86%E4%B8%8E%E5%90%88%E5%B9%B6).html",relativePath:"02.Python/01.Python-基础/13.Python中字符串的一些方法回顾(拆分与合并).md",key:"v-e957dff6",path:"/pages/5386bd/",headers:[{level:3,title:"python中字符串的一些方法回顾(拆分与合并)",slug:"python中字符串的一些方法回顾-拆分与合并",normalizedTitle:"python中字符串的一些方法回顾(拆分与合并)",charIndex:2},{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:54},{level:2,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:416}],headersStr:"python中字符串的一些方法回顾(拆分与合并) 代码 运行结果",content:"# python中字符串的一些方法回顾(拆分与合并)\n\n字符串中split函数和join函数的使用\n\n\n# 代码\n\n# 假设：以下内容是从网络上抓取的\n# 要求：\n# 1、将字符串中的空白字符全部去掉\n# 2、再使用\"  \"作为分隔符，拼接成一个整齐的字符串\npoem_str = \"登鹤鹊楼\\t 王之涣 \\t 白日依山尽 \\t\\n 黄河入海流 \\t\\t 欲穷千里目\\t\\t更上一层楼\"\n\nprint(poem_str)\n\n# 1、拆分字符串  split方法会返回列表\npoem_list = poem_str.split()\nprint(poem_list)\n\n# 2、合并字符串\nresult = \" \".join(poem_list)\nprint(result)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 运行结果\n\n原始字符串：\n 登鹤鹊楼\t 王之涣 \t 白日依山尽 \t\n 黄河入海流 \t\t 欲穷千里目\t\t更上一层楼\n拆分字符串后：\n ['登鹤鹊楼', '王之涣', '白日依山尽', '黄河入海流', '欲穷千里目', '更上一层楼']\n合并字符串后: \n 登鹤鹊楼 王之涣 白日依山尽 黄河入海流 欲穷千里目 更上一层楼\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n",normalizedContent:"# python中字符串的一些方法回顾(拆分与合并)\n\n字符串中split函数和join函数的使用\n\n\n# 代码\n\n# 假设：以下内容是从网络上抓取的\n# 要求：\n# 1、将字符串中的空白字符全部去掉\n# 2、再使用\"  \"作为分隔符，拼接成一个整齐的字符串\npoem_str = \"登鹤鹊楼\\t 王之涣 \\t 白日依山尽 \\t\\n 黄河入海流 \\t\\t 欲穷千里目\\t\\t更上一层楼\"\n\nprint(poem_str)\n\n# 1、拆分字符串  split方法会返回列表\npoem_list = poem_str.split()\nprint(poem_list)\n\n# 2、合并字符串\nresult = \" \".join(poem_list)\nprint(result)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 运行结果\n\n原始字符串：\n 登鹤鹊楼\t 王之涣 \t 白日依山尽 \t\n 黄河入海流 \t\t 欲穷千里目\t\t更上一层楼\n拆分字符串后：\n ['登鹤鹊楼', '王之涣', '白日依山尽', '黄河入海流', '欲穷千里目', '更上一层楼']\n合并字符串后: \n 登鹤鹊楼 王之涣 白日依山尽 黄河入海流 欲穷千里目 更上一层楼\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n",charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"Python中字符串的一些方法回顾(切片回顾)",frontmatter:{title:"Python中字符串的一些方法回顾(切片回顾)",date:"2018-07-26T19:40:48.000Z",categories:["Python-基础"],tags:["Python基础","切片"],permalink:"/pages/c7192a/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/01.Python-%E5%9F%BA%E7%A1%80/14.Python%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95%E5%9B%9E%E9%A1%BE(%E5%88%87%E7%89%87%E5%9B%9E%E9%A1%BE).html",relativePath:"02.Python/01.Python-基础/14.Python中字符串的一些方法回顾(切片回顾).md",key:"v-605baf28",path:"/pages/c7192a/",headers:[{level:3,title:"python中字符串的一些方法回顾(切片回顾)",slug:"python中字符串的一些方法回顾-切片回顾",normalizedTitle:"python中字符串的一些方法回顾(切片回顾)",charIndex:2},{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:30},{level:2,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:628}],headersStr:"python中字符串的一些方法回顾(切片回顾) 代码 运行结果",content:'# python中字符串的一些方法回顾(切片回顾)\n\n\n# 代码\n\n# 字符串的切片   字符串[开始索引:结束索引:步长]\n# 如果使用倒序索引的方法，那么最后一位元素是以-1开始，倒数第二位是-2\n# 切片方法适用于字符串、列表、元组\n\nnum_str = "0123456789"\n\n# 截取2-5的字符串\nprint(num_str[2:6])\n# 截取2-末尾的字符串\nprint(num_str[2:])\n# 从起始位置截取到5位置的字符串   num_str[0:6]等价\nprint(num_str[:6])\n# 生成切片的副本\nprint(num_str[:])\n# 从开始位置开始，每隔一个字符截取字符串\nprint(num_str[::2])\n# 从索引1开始，每隔一个取一个\nprint(num_str[1::2])\n# 截取从2到(末尾-1)的字符串\nprint(num_str[2:-1])\n# 截取字符串末尾两个字符\nprint(num_str[-2:])\n# 字符串的逆序   num_str[::-1]等价\nprint(num_str[-1::-1])\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 运行结果\n\n>>>2345\n>>>23456789\n>>>012345\n>>>0123456789\n>>>02468\n>>>13579\n>>>2345678\n>>>89\n>>>9876543210\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n',normalizedContent:'# python中字符串的一些方法回顾(切片回顾)\n\n\n# 代码\n\n# 字符串的切片   字符串[开始索引:结束索引:步长]\n# 如果使用倒序索引的方法，那么最后一位元素是以-1开始，倒数第二位是-2\n# 切片方法适用于字符串、列表、元组\n\nnum_str = "0123456789"\n\n# 截取2-5的字符串\nprint(num_str[2:6])\n# 截取2-末尾的字符串\nprint(num_str[2:])\n# 从起始位置截取到5位置的字符串   num_str[0:6]等价\nprint(num_str[:6])\n# 生成切片的副本\nprint(num_str[:])\n# 从开始位置开始，每隔一个字符截取字符串\nprint(num_str[::2])\n# 从索引1开始，每隔一个取一个\nprint(num_str[1::2])\n# 截取从2到(末尾-1)的字符串\nprint(num_str[2:-1])\n# 截取字符串末尾两个字符\nprint(num_str[-2:])\n# 字符串的逆序   num_str[::-1]等价\nprint(num_str[-1::-1])\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 运行结果\n\n>>>2345\n>>>23456789\n>>>012345\n>>>0123456789\n>>>02468\n>>>13579\n>>>2345678\n>>>89\n>>>9876543210\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n',charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"Python中字符串的一些方法回顾(文本对齐、去除空白)",frontmatter:{title:"Python中字符串的一些方法回顾(文本对齐、去除空白)",date:"2018-07-26T19:39:41.000Z",categories:["Python-基础"],tags:["Python基础","strip"],permalink:"/pages/a7c3f3/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/01.Python-%E5%9F%BA%E7%A1%80/15.Python%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95%E5%9B%9E%E9%A1%BE(%E6%96%87%E6%9C%AC%E5%AF%B9%E9%BD%90%E3%80%81%E5%8E%BB%E9%99%A4%E7%A9%BA%E7%99%BD).html",relativePath:"02.Python/01.Python-基础/15.Python中字符串的一些方法回顾(文本对齐、去除空白).md",key:"v-da1159c4",path:"/pages/a7c3f3/",headers:[{level:3,title:"python中字符串的一些方法回顾(文本对齐、去除空白)",slug:"python中字符串的一些方法回顾-文本对齐、去除空白",normalizedTitle:"python中字符串的一些方法回顾(文本对齐、去除空白)",charIndex:2},{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:66},{level:2,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:641}],headersStr:"python中字符串的一些方法回顾(文本对齐、去除空白) 代码 运行结果",content:'# python中字符串的一些方法回顾(文本对齐、去除空白)\n\n文本对齐的方法，以及用strip函数去除字符串的中空白字符\n\n\n# 代码\n\n# 假设：以下内容是从网络上抓取下来的\n# 要求：顺序并且居中对齐输出一下内容\npoem = ["\\t\\n登鹤鹊楼",\n        "王之涣",\n        "白日依山尽\\t\\n",\n        "黄河入海流",\n        "欲穷千里目",\n        "更上一层楼"]\n\nfor poem_str in poem:\n    # 先使用strip方法去除字符串中的空白字符\n    # 居中对齐  \n    \'\'\'\n      Python center() 返回一个原字符串居中,并使用空格填充至长度 width 的新字符串。默认填充字符为空格。\n    \'\'\'\n    print("|%s|" % poem_str.strip().center(10, "　"))\n    # 向左对齐\n    # print("|%s|" % poem_str.ljust(10, "　"))\n    # 向右对齐\n    # print("|%s|" % poem_str.rjust(10, "　"))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 运行结果\n\n|　　　登鹤鹊楼　　　|\n|　　　王之涣　　　　|\n|　　白日依山尽　　　|\n|　　黄河入海流　　　|\n|　　欲穷千里目　　　|\n|　　更上一层楼　　　|\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n',normalizedContent:'# python中字符串的一些方法回顾(文本对齐、去除空白)\n\n文本对齐的方法，以及用strip函数去除字符串的中空白字符\n\n\n# 代码\n\n# 假设：以下内容是从网络上抓取下来的\n# 要求：顺序并且居中对齐输出一下内容\npoem = ["\\t\\n登鹤鹊楼",\n        "王之涣",\n        "白日依山尽\\t\\n",\n        "黄河入海流",\n        "欲穷千里目",\n        "更上一层楼"]\n\nfor poem_str in poem:\n    # 先使用strip方法去除字符串中的空白字符\n    # 居中对齐  \n    \'\'\'\n      python center() 返回一个原字符串居中,并使用空格填充至长度 width 的新字符串。默认填充字符为空格。\n    \'\'\'\n    print("|%s|" % poem_str.strip().center(10, "　"))\n    # 向左对齐\n    # print("|%s|" % poem_str.ljust(10, "　"))\n    # 向右对齐\n    # print("|%s|" % poem_str.rjust(10, "　"))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 运行结果\n\n|　　　登鹤鹊楼　　　|\n|　　　王之涣　　　　|\n|　　白日依山尽　　　|\n|　　黄河入海流　　　|\n|　　欲穷千里目　　　|\n|　　更上一层楼　　　|\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n',charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"Python中字符串的一些方法回顾",frontmatter:{title:"Python中字符串的一些方法回顾",date:"2018-07-25T21:29:40.000Z",categories:["Python-基础"],tags:["Python基础","字符串"],permalink:"/pages/800d04/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/01.Python-%E5%9F%BA%E7%A1%80/16.Python%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95%E5%9B%9E%E9%A1%BE.html",relativePath:"02.Python/01.Python-基础/16.Python中字符串的一些方法回顾.md",key:"v-93be6cd2",path:"/pages/800d04/",headers:[{level:3,title:"python中字符串的一些方法回顾",slug:"python中字符串的一些方法回顾",normalizedTitle:"python中字符串的一些方法回顾",charIndex:2},{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:24},{level:2,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:728}],headersStr:"python中字符串的一些方法回顾 代码 运行结果",content:'# python中字符串的一些方法回顾\n\n\n# 代码\n\nhello_str = "hello world"\n\n# 1、统计字符串长度\nprint(len(hello_str))\n# 2、统计某一个小字符串出现的次数\nprint(hello_str.count("llo"))\n# 3、某一个子字符串出现的位置\nprint(hello_str.index("llo"))\n# 4、输出数学的平方\nnum_str = "\\u00b2"\nprint(num_str)\n# 5、判断是否以指定字符串开始\nprint(hello_str.startswith("hello"))\n# 6、判断是否以指定字符串结束\nprint(hello_str.endswith("world"))\n# 7、查找指定字符串\n# 在index方法中，如果指定的字符串不存在，会直接报错\n# 在find方法中，如果指定的字符串不存在，会返回-1\nprint(hello_str.find("llo"))\nprint(hello_str.find("CCC"))\n# 8、替换字符串\n# replace方法执行完成之后会返回一个新的字符串，但是不会修改原有字符串的内容\nhh = hello_str.replace("world", "python")\nprint(hh)\nprint(hello_str)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 运行结果\n\n11\n1\n2\n²\nTrue\nTrue\n2\n-1\nhello python\nhello world\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n',normalizedContent:'# python中字符串的一些方法回顾\n\n\n# 代码\n\nhello_str = "hello world"\n\n# 1、统计字符串长度\nprint(len(hello_str))\n# 2、统计某一个小字符串出现的次数\nprint(hello_str.count("llo"))\n# 3、某一个子字符串出现的位置\nprint(hello_str.index("llo"))\n# 4、输出数学的平方\nnum_str = "\\u00b2"\nprint(num_str)\n# 5、判断是否以指定字符串开始\nprint(hello_str.startswith("hello"))\n# 6、判断是否以指定字符串结束\nprint(hello_str.endswith("world"))\n# 7、查找指定字符串\n# 在index方法中，如果指定的字符串不存在，会直接报错\n# 在find方法中，如果指定的字符串不存在，会返回-1\nprint(hello_str.find("llo"))\nprint(hello_str.find("ccc"))\n# 8、替换字符串\n# replace方法执行完成之后会返回一个新的字符串，但是不会修改原有字符串的内容\nhh = hello_str.replace("world", "python")\nprint(hh)\nprint(hello_str)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 运行结果\n\n11\n1\n2\n²\ntrue\ntrue\n2\n-1\nhello python\nhello world\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n',charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"Python中字符串的一些基本操作",frontmatter:{title:"Python中字符串的一些基本操作",date:"2018-07-07T17:04:05.000Z",categories:["Python-基础"],tags:["Python基础","字符串"],permalink:"/pages/76881f/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/01.Python-%E5%9F%BA%E7%A1%80/17.Python%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.html",relativePath:"02.Python/01.Python-基础/17.Python中字符串的一些基本操作.md",key:"v-8d5a0674",path:"/pages/76881f/",headers:[{level:3,title:"python字符串的一些基本操作",slug:"python字符串的一些基本操作",normalizedTitle:"python字符串的一些基本操作",charIndex:2}],headersStr:"python字符串的一些基本操作",content:"# python字符串的一些基本操作\n\n在这里，我们会看见一此操作中包含了好多字符串方法。 startwith 方法用于查找字符串是 否以给定的字符串内容开头。 in 运算符用以检查给定的字符串是否是查询的字符串中的一 部分。 find 方法用于定位字符串中给定的子字符串的位置。如果找不到相应的子字符串， find 会返回 -1。 str 类同样还拥有一个简洁的方法用以 联结（Join） 序列中的项目，其中字符串 将会作为每一项目之间的分隔符，并以此生成并返回一串更大的字符串。\n\n# 这是一个字符串对象\nname = 'Swaroop'\n\nif name.startswith('Swa'):\n    print('Yes, the string starts with \"Swa\"')\n\nif 'a' in name:\n    print('Yes, it contains the string \"a\"')\n\nif name.find('war') != -1:\n    print('Yes,it contains the string \"war\"')\n\ndelimiter = '_*_'\nmylist = ['Brazil', 'Russia', 'India', 'China']\nprint(delimiter.join(mylist))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n",normalizedContent:"# python字符串的一些基本操作\n\n在这里，我们会看见一此操作中包含了好多字符串方法。 startwith 方法用于查找字符串是 否以给定的字符串内容开头。 in 运算符用以检查给定的字符串是否是查询的字符串中的一 部分。 find 方法用于定位字符串中给定的子字符串的位置。如果找不到相应的子字符串， find 会返回 -1。 str 类同样还拥有一个简洁的方法用以 联结（join） 序列中的项目，其中字符串 将会作为每一项目之间的分隔符，并以此生成并返回一串更大的字符串。\n\n# 这是一个字符串对象\nname = 'swaroop'\n\nif name.startswith('swa'):\n    print('yes, the string starts with \"swa\"')\n\nif 'a' in name:\n    print('yes, it contains the string \"a\"')\n\nif name.find('war') != -1:\n    print('yes,it contains the string \"war\"')\n\ndelimiter = '_*_'\nmylist = ['brazil', 'russia', 'india', 'china']\nprint(delimiter.join(mylist))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n",charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"多种方法快速交换两个变量的值",frontmatter:{title:"多种方法快速交换两个变量的值",date:"2018-07-24T09:33:48.000Z",categories:["Python-基础"],tags:["Python基础"],permalink:"/pages/e5cf66/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/01.Python-%E5%9F%BA%E7%A1%80/18.%E5%A4%9A%E7%A7%8D%E6%96%B9%E6%B3%95%E5%BF%AB%E9%80%9F%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC.html",relativePath:"02.Python/01.Python-基础/18.多种方法快速交换两个变量的值.md",key:"v-217168dc",path:"/pages/e5cf66/",headers:[{level:3,title:"使用多种方法快速交换两个变量的值",slug:"使用多种方法快速交换两个变量的值",normalizedTitle:"使用多种方法快速交换两个变量的值",charIndex:2},{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:102},{level:2,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:547}],headersStr:"使用多种方法快速交换两个变量的值 代码 运行结果",content:"# 使用多种方法快速交换两个变量的值\n\n> 1、利用元组的快速交换变量值\n> \n> 2、引入新的变量来交换\n> \n> 3、使用加减法交换变量值\n> \n> 4、利用元组从一个函数中返回两个不同的值\n\n\n# 代码\n\n# 1. 利用元组的快速交换变量值\na = 5\nb = 8\na, b = b, a\nprint(a, b)\n# 2. 引入新的变量来交换\nc = b\nb = a\na = c\nprint(a, b)\n# 3. 使用加减法交换变量值\na = a + b\nb = a - b\na = a - b\nprint(a, b)\n\n\n# 4. 利用元组从一个函数中返回两个不同的值\ndef get_error_details():\n    return (2, 'details')\n\n\nerrnum, errstr = get_error_details()\nprint(errnum)\nprint(errstr)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 运行结果\n\n8 5\n5 8\n8 5\n2\ndetails\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n",normalizedContent:"# 使用多种方法快速交换两个变量的值\n\n> 1、利用元组的快速交换变量值\n> \n> 2、引入新的变量来交换\n> \n> 3、使用加减法交换变量值\n> \n> 4、利用元组从一个函数中返回两个不同的值\n\n\n# 代码\n\n# 1. 利用元组的快速交换变量值\na = 5\nb = 8\na, b = b, a\nprint(a, b)\n# 2. 引入新的变量来交换\nc = b\nb = a\na = c\nprint(a, b)\n# 3. 使用加减法交换变量值\na = a + b\nb = a - b\na = a - b\nprint(a, b)\n\n\n# 4. 利用元组从一个函数中返回两个不同的值\ndef get_error_details():\n    return (2, 'details')\n\n\nerrnum, errstr = get_error_details()\nprint(errnum)\nprint(errstr)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 运行结果\n\n8 5\n5 8\n8 5\n2\ndetails\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n",charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"利用Python进行文件的自动备份",frontmatter:{title:"利用Python进行文件的自动备份",date:"2018-07-22T16:04:32.000Z",categories:["Python-基础"],tags:["Python基础"],permalink:"/pages/369a5f/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/01.Python-%E5%9F%BA%E7%A1%80/19.%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BD.html",relativePath:"02.Python/01.Python-基础/19.利用Python进行文件的自动备份.md",key:"v-f8ffc25c",path:"/pages/369a5f/",headers:[{level:3,title:"利用Python进行文件的自动备份（第一版）",slug:"利用python进行文件的自动备份-第一版",normalizedTitle:"利用python进行文件的自动备份（第一版）",charIndex:2},{level:2,title:"针对 Windows 用户的提示",slug:"针对-windows-用户的提示",normalizedTitle:"针对 windows 用户的提示",charIndex:117},{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:109},{level:2,title:"输出结果",slug:"输出结果",normalizedTitle:"输出结果",charIndex:1453}],headersStr:"利用Python进行文件的自动备份（第一版） 针对 Windows 用户的提示 代码 输出结果",content:"# 利用Python进行文件的自动备份（第一版）\n\nos.system 函数的命令，这一函数可以使命令像是从系统中运行的。也就是说，从 shell 中运行的——如果运行成功，它将返回 0 ，如果运行失败，将返回一个错误代码。\n\n\n# 针对 Windows 用户的提示\n\n除了使用双反斜杠转义序列，你还可以使用原始字符串。例如使用 'C:\\Documents' 或 r'C:\\Documents' 。然而，不要使用 'C:\\Documents' ，因为它将被识别为你使用了一个 未知的转义序列 \\D 来结束路径的输入。\n\n\n# 代码\n\nimport os\nimport time\n\n# 1. 需要备份的文件与目录将被\n# 指定在一个列表中。\n# 例如在 Windows 下：\nsource = [r'E:\\aaa.txt']\n# 在这里要注意到我们必须在字符串中使用双引号\n# 用以括起其中包含空格的名称。\n# 2. 备份文件必须存储在一个\n# 主备份目录中\n# 例如在 Windows 下：\ntarget_dir = 'E:\\\\Backup\\\\'\n# 要记得将这里的目录地址修改至你将使用的路径\n\n# 3.备份文件将打包压缩成zip文件\n# 4.zip压缩文件的文件名由当前日期与时间构成\n\n# 其中os.sep 表示更改操作系统中的路径分隔符\n\ntarget = target_dir + os.sep + \\\n         time.strftime('%Y%m%d%H%M%S') + '.zip'\n# 如果目标目录还不存在，则进行创建\nif not os.path.exists(target_dir):\n    os.mkdir(target_dir)  # 创建目录\n\n# 5.原本这里是使用zip命令，但是在windows环境下面这个是不是系统命令，所以解决方案如下：\n'''\n1.1.下载7-Zip并安装\n2.将安装文件中的7z.exe移至‘C:\\Windows’目录下\n3.将程序中的 zip_command = \"zip -qr '%s' %s\"%(target,''.join(source))\n改为：zip_command = \"7z a %s %s\"%(target, ' '.join(source))\n'''\nzip_command = \"7z a %s %s\" % (target, ' '.join(source))\n\n# 运行备份\nprint('Zip command is:')\nprint(zip_command)\nprint('Running:')\nif os.system(zip_command) == 0:\n    print('Successful backup to', target)\nelse:\n    print('Backup FAILED')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# 输出结果\n\n> 1 file, 10 bytes (1 KiB)\n> \n> Creating archive: E:\\Backup\\20180722160831.zip\n> \n> Add new data to archive: 1 file, 10 bytes (1 KiB)\n> \n> Files read from disk: 1\n> \n> Archive size: 158 bytes (1 KiB)\n> \n> Everything is Ok\n> \n> Successful backup to E:\\Backup\\20180722160831.zip",normalizedContent:"# 利用python进行文件的自动备份（第一版）\n\nos.system 函数的命令，这一函数可以使命令像是从系统中运行的。也就是说，从 shell 中运行的——如果运行成功，它将返回 0 ，如果运行失败，将返回一个错误代码。\n\n\n# 针对 windows 用户的提示\n\n除了使用双反斜杠转义序列，你还可以使用原始字符串。例如使用 'c:\\documents' 或 r'c:\\documents' 。然而，不要使用 'c:\\documents' ，因为它将被识别为你使用了一个 未知的转义序列 \\d 来结束路径的输入。\n\n\n# 代码\n\nimport os\nimport time\n\n# 1. 需要备份的文件与目录将被\n# 指定在一个列表中。\n# 例如在 windows 下：\nsource = [r'e:\\aaa.txt']\n# 在这里要注意到我们必须在字符串中使用双引号\n# 用以括起其中包含空格的名称。\n# 2. 备份文件必须存储在一个\n# 主备份目录中\n# 例如在 windows 下：\ntarget_dir = 'e:\\\\backup\\\\'\n# 要记得将这里的目录地址修改至你将使用的路径\n\n# 3.备份文件将打包压缩成zip文件\n# 4.zip压缩文件的文件名由当前日期与时间构成\n\n# 其中os.sep 表示更改操作系统中的路径分隔符\n\ntarget = target_dir + os.sep + \\\n         time.strftime('%y%m%d%h%m%s') + '.zip'\n# 如果目标目录还不存在，则进行创建\nif not os.path.exists(target_dir):\n    os.mkdir(target_dir)  # 创建目录\n\n# 5.原本这里是使用zip命令，但是在windows环境下面这个是不是系统命令，所以解决方案如下：\n'''\n1.1.下载7-zip并安装\n2.将安装文件中的7z.exe移至‘c:\\windows’目录下\n3.将程序中的 zip_command = \"zip -qr '%s' %s\"%(target,''.join(source))\n改为：zip_command = \"7z a %s %s\"%(target, ' '.join(source))\n'''\nzip_command = \"7z a %s %s\" % (target, ' '.join(source))\n\n# 运行备份\nprint('zip command is:')\nprint(zip_command)\nprint('running:')\nif os.system(zip_command) == 0:\n    print('successful backup to', target)\nelse:\n    print('backup failed')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# 输出结果\n\n> 1 file, 10 bytes (1 kib)\n> \n> creating archive: e:\\backup\\20180722160831.zip\n> \n> add new data to archive: 1 file, 10 bytes (1 kib)\n> \n> files read from disk: 1\n> \n> archive size: 158 bytes (1 kib)\n> \n> everything is ok\n> \n> successful backup to e:\\backup\\20180722160831.zip",charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"利用Python进行文件的自动备份(第二版)",frontmatter:{title:"利用Python进行文件的自动备份(第二版)",date:"2018-07-23T18:49:11.000Z",categories:["Python-基础"],tags:["Python基础","备份"],permalink:"/pages/04f569/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/01.Python-%E5%9F%BA%E7%A1%80/20.%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BD(%E7%AC%AC%E4%BA%8C%E7%89%88).html",relativePath:"02.Python/01.Python-基础/20.利用Python进行文件的自动备份(第二版).md",key:"v-0a4c594d",path:"/pages/04f569/",headers:[{level:3,title:"利用python进行文件的自动备份（第二版）",slug:"利用python进行文件的自动备份-第二版",normalizedTitle:"利用python进行文件的自动备份（第二版）",charIndex:2},{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:29},{level:2,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:1583}],headersStr:"利用python进行文件的自动备份（第二版） 代码 运行结果",content:"# 利用python进行文件的自动备份（第二版）\n\n\n# 代码\n\nimport os\nimport time\n\n'''\n第二版是第一版的改进，\n启用一种更好的文件命名机制——使用时间作为文件名，存储在以当前时间为名字的文件夹中，这一文件夹则照常存储在主备份目录下。\n\n'''\n\n# 例如在 Windows 下：\nsource = [r'E:\\aaa.txt']\n# 在这里要注意到我们必须在字符串中使用双引号\n# 用以括起其中包含空格的名称。\n# 2. 备份文件必须存储在一个\n# 主备份目录中\n# 例如在 Windows 下：\ntarget_dir = 'E:\\\\Backup\\\\'\n# 要记得将这里的目录地址修改至你将使用的路径\n# 如果目标目录还不存在，则进行创建\nif not os.path.exists(target_dir):\n    os.mkdir(target_dir)  # 创建目录\n\n# 3.备份文件将打包压缩成zip文件\n# 4.zip压缩文件的文件名由当前日期与时间构成\n# 其中os.sep 表示更改操作系统中的路径分隔符\ntoday = target_dir + os.sep + time.strftime('%Y%m%d')\n# 将当前时间作为zip文件的文件名\nnow = time.strftime('%H%M%S')\n\n# zip文件名称格式\ntarget = today + os.sep + now + 'zip'\n# 如果子目录尚不存在则创建一个\nif not os.path.exists(today):\n    os.mkdir(today)\n    print('Successfully created diectory', today)\n\n# 5.原本这里是使用zip命令，但是在windows环境下面这个是不是系统命令，所以解决方案如下：\n'''\n1.1.下载7-Zip并安装\n2.将安装文件中的7z.exe移至‘C:\\Windows’目录下\n3.将程序中的 zip_command = \"zip -qr '%s' %s\"%(target,''.join(source))\n改为：zip_command = \"7z a %s %s\"%(target, ' '.join(source))\n或者是\"7z a {0} {1}\".format(target, ' '.join(source))\n'''\nzip_command = \"7z a {0} {1}\".format(target, ' '.join(source))\n\n# 运行备份\nprint('Zip command is:')\nprint(zip_command)\nprint('Running:')\nif os.system(zip_command) == 0:\n    print('Successful backup to', target)\nelse:\n    print('Backup FAILED')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n\n# 运行结果\n\nZip command is:\n7z a E:\\Backup\\\\20180723\\185035zip E:\\aaa.txt\nRunning:\n\n7-Zip 18.05 (x64) : Copyright (c) 1999-2018 Igor Pavlov : 2018-04-30\n\nScanning the drive:\n1 file, 10 bytes (1 KiB)\n\nCreating archive: E:\\Backup\\\\20180723\\185035zip.7z\n\nAdd new data to archive: 1 file, 10 bytes (1 KiB)\n\n\nFiles read from disk: 1\nArchive size: 136 bytes (1 KiB)\nEverything is Ok\nSuccessful backup to E:\\Backup\\\\20180723\\185035zip\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n",normalizedContent:"# 利用python进行文件的自动备份（第二版）\n\n\n# 代码\n\nimport os\nimport time\n\n'''\n第二版是第一版的改进，\n启用一种更好的文件命名机制——使用时间作为文件名，存储在以当前时间为名字的文件夹中，这一文件夹则照常存储在主备份目录下。\n\n'''\n\n# 例如在 windows 下：\nsource = [r'e:\\aaa.txt']\n# 在这里要注意到我们必须在字符串中使用双引号\n# 用以括起其中包含空格的名称。\n# 2. 备份文件必须存储在一个\n# 主备份目录中\n# 例如在 windows 下：\ntarget_dir = 'e:\\\\backup\\\\'\n# 要记得将这里的目录地址修改至你将使用的路径\n# 如果目标目录还不存在，则进行创建\nif not os.path.exists(target_dir):\n    os.mkdir(target_dir)  # 创建目录\n\n# 3.备份文件将打包压缩成zip文件\n# 4.zip压缩文件的文件名由当前日期与时间构成\n# 其中os.sep 表示更改操作系统中的路径分隔符\ntoday = target_dir + os.sep + time.strftime('%y%m%d')\n# 将当前时间作为zip文件的文件名\nnow = time.strftime('%h%m%s')\n\n# zip文件名称格式\ntarget = today + os.sep + now + 'zip'\n# 如果子目录尚不存在则创建一个\nif not os.path.exists(today):\n    os.mkdir(today)\n    print('successfully created diectory', today)\n\n# 5.原本这里是使用zip命令，但是在windows环境下面这个是不是系统命令，所以解决方案如下：\n'''\n1.1.下载7-zip并安装\n2.将安装文件中的7z.exe移至‘c:\\windows’目录下\n3.将程序中的 zip_command = \"zip -qr '%s' %s\"%(target,''.join(source))\n改为：zip_command = \"7z a %s %s\"%(target, ' '.join(source))\n或者是\"7z a {0} {1}\".format(target, ' '.join(source))\n'''\nzip_command = \"7z a {0} {1}\".format(target, ' '.join(source))\n\n# 运行备份\nprint('zip command is:')\nprint(zip_command)\nprint('running:')\nif os.system(zip_command) == 0:\n    print('successful backup to', target)\nelse:\n    print('backup failed')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n\n# 运行结果\n\nzip command is:\n7z a e:\\backup\\\\20180723\\185035zip e:\\aaa.txt\nrunning:\n\n7-zip 18.05 (x64) : copyright (c) 1999-2018 igor pavlov : 2018-04-30\n\nscanning the drive:\n1 file, 10 bytes (1 kib)\n\ncreating archive: e:\\backup\\\\20180723\\185035zip.7z\n\nadd new data to archive: 1 file, 10 bytes (1 kib)\n\n\nfiles read from disk: 1\narchive size: 136 bytes (1 kib)\neverything is ok\nsuccessful backup to e:\\backup\\\\20180723\\185035zip\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n",charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"利用Python进行文件的自动备份(第三版和第四版)",frontmatter:{title:"利用Python进行文件的自动备份(第三版和第四版)",date:"2018-07-23T18:54:24.000Z",categories:["Python"],tags:["基本教程"],permalink:"/pages/a8d563/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/01.Python-%E5%9F%BA%E7%A1%80/21.%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BD(%E7%AC%AC%E4%B8%89%E7%89%88%E5%92%8C%E7%AC%AC%E5%9B%9B%E7%89%88).html",relativePath:"02.Python/01.Python-基础/21.利用Python进行文件的自动备份(第三版和第四版).md",key:"v-00e633de",path:"/pages/a8d563/",headers:[{level:3,title:"利用python进行文件的自动备份(第三版和第四版)",slug:"利用python进行文件的自动备份-第三版和第四版",normalizedTitle:"利用python进行文件的自动备份(第三版和第四版)",charIndex:2},{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:33},{level:2,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:1206}],headersStr:"利用python进行文件的自动备份(第三版和第四版) 代码 运行结果",content:"# 利用python进行文件的自动备份(第三版和第四版)\n\n\n# 代码\n\nimport os\nimport time\n\n'''\n第三版和第四版差别不大整合在一起，用户注释的内容可以添加到文件名中来实现\n'''\nsource = [r'E:\\aaa.txt']\n\ntarget_dir = 'E:\\\\Backup\\\\'\n\nif not os.path.exists(target_dir):\n    os.mkdir(target_dir)\n# 子目录名称\ntoday = target_dir + os.sep + time.strftime('%Y%m%d')\n# 将当前时间作为zio文件的文件名\nnow = time.strftime('%H%M%S')\n\n# 添加一条来自用户的注释以创建\n# zip文件的文件名\n\ncomment = input('Enter a comment --\x3e')\n# 检查是否有评论键入\nif len(comment) == 0:\n    target = today + os.sep + now + '.zip'\n# replace函数中前面的将被替换为后面的\nelse:\n    target = today + os.sep + now + '_' + \\\n             comment.replace(' ', '_') + '.zip'\n# 如果子目录尚不存在则创建一个\nif not os.path.exists(today):\n    os.mkdir(today)\n    print('Successfully created directory', today)\n\nzip_command = \"7z a {0} {1}\".format(target, ' '.join(source))\n\n# 运行备份\nprint('Zip command is:')\nprint(zip_command)\nprint('Running:')\nif os.system(zip_command) == 0:\n    print('Successful backup to', target)\nelse:\n    print('Backup FAILED')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# 运行结果\n\nEnter a comment --\x3eThis is my backup\nZip command is:\n7z a E:\\Backup\\\\20180723\\185735_This_is_my_backup.zip E:\\aaa.txt\nRunning:\n\n7-Zip 18.05 (x64) : Copyright (c) 1999-2018 Igor Pavlov : 2018-04-30\n\nScanning the drive:\n1 file, 10 bytes (1 KiB)\n\nCreating archive: E:\\Backup\\\\20180723\\185735_This_is_my_backup.zip\n\nAdd new data to archive: 1 file, 10 bytes (1 KiB)\n\n\nFiles read from disk: 1\nArchive size: 158 bytes (1 KiB)\nEverything is Ok\nSuccessful backup to E:\\Backup\\\\20180723\\185735_This_is_my_backup.zip\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n",normalizedContent:"# 利用python进行文件的自动备份(第三版和第四版)\n\n\n# 代码\n\nimport os\nimport time\n\n'''\n第三版和第四版差别不大整合在一起，用户注释的内容可以添加到文件名中来实现\n'''\nsource = [r'e:\\aaa.txt']\n\ntarget_dir = 'e:\\\\backup\\\\'\n\nif not os.path.exists(target_dir):\n    os.mkdir(target_dir)\n# 子目录名称\ntoday = target_dir + os.sep + time.strftime('%y%m%d')\n# 将当前时间作为zio文件的文件名\nnow = time.strftime('%h%m%s')\n\n# 添加一条来自用户的注释以创建\n# zip文件的文件名\n\ncomment = input('enter a comment --\x3e')\n# 检查是否有评论键入\nif len(comment) == 0:\n    target = today + os.sep + now + '.zip'\n# replace函数中前面的将被替换为后面的\nelse:\n    target = today + os.sep + now + '_' + \\\n             comment.replace(' ', '_') + '.zip'\n# 如果子目录尚不存在则创建一个\nif not os.path.exists(today):\n    os.mkdir(today)\n    print('successfully created directory', today)\n\nzip_command = \"7z a {0} {1}\".format(target, ' '.join(source))\n\n# 运行备份\nprint('zip command is:')\nprint(zip_command)\nprint('running:')\nif os.system(zip_command) == 0:\n    print('successful backup to', target)\nelse:\n    print('backup failed')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# 运行结果\n\nenter a comment --\x3ethis is my backup\nzip command is:\n7z a e:\\backup\\\\20180723\\185735_this_is_my_backup.zip e:\\aaa.txt\nrunning:\n\n7-zip 18.05 (x64) : copyright (c) 1999-2018 igor pavlov : 2018-04-30\n\nscanning the drive:\n1 file, 10 bytes (1 kib)\n\ncreating archive: e:\\backup\\\\20180723\\185735_this_is_my_backup.zip\n\nadd new data to archive: 1 file, 10 bytes (1 kib)\n\n\nfiles read from disk: 1\narchive size: 158 bytes (1 kib)\neverything is ok\nsuccessful backup to e:\\backup\\\\20180723\\185735_this_is_my_backup.zip\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n",charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"列表推导",frontmatter:{title:"列表推导",date:"2018-07-24T18:33:13.000Z",categories:["Python-基础"],tags:["Python基础","列表"],permalink:"/pages/f7e4b1/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/01.Python-%E5%9F%BA%E7%A1%80/22.%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC.html",relativePath:"02.Python/01.Python-基础/22.列表推导.md",key:"v-0f45791d",path:"/pages/f7e4b1/",headers:[{level:3,title:"列表推导",slug:"列表推导",normalizedTitle:"列表推导",charIndex:2},{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:125},{level:2,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:451}],headersStr:"列表推导 代码 运行结果",content:"# 列表推导\n\n列表推导（List Comprehension）用于从一份现有的列表中得到一份新列表。想象一下，现在 你已经有了一份数字列表，你想得到一个相应的列表，其中的数字在大于 2 的情况下将乘以 2。列表推导就是这类情况的理想选择。\n\n\n# 代码\n\n# 列表推导\n\n'''\n程序理解：\n当满足了某些条件时（ if i > 2 ），我们进行指定的操作（ 2*i ），以此来获\n得一份新的列表。要注意到原始列表依旧保持不变。\n'''\n\nlistone = [2, 3, 4]\nlisttwo = [2 * i for i in listone if i > 2]\nprint(listtwo)\n\n\n'''\n列表推导的优点在于，当我们使用循环来处理列表中的每个元素并将其存储到新的列表中时\n它能够减少代码量\n'''\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 运行结果\n\n> [6, 8]",normalizedContent:"# 列表推导\n\n列表推导（list comprehension）用于从一份现有的列表中得到一份新列表。想象一下，现在 你已经有了一份数字列表，你想得到一个相应的列表，其中的数字在大于 2 的情况下将乘以 2。列表推导就是这类情况的理想选择。\n\n\n# 代码\n\n# 列表推导\n\n'''\n程序理解：\n当满足了某些条件时（ if i > 2 ），我们进行指定的操作（ 2*i ），以此来获\n得一份新的列表。要注意到原始列表依旧保持不变。\n'''\n\nlistone = [2, 3, 4]\nlisttwo = [2 * i for i in listone if i > 2]\nprint(listtwo)\n\n\n'''\n列表推导的优点在于，当我们使用循环来处理列表中的每个元素并将其存储到新的列表中时\n它能够减少代码量\n'''\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 运行结果\n\n> [6, 8]",charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"在函数中接受元组与字典",frontmatter:{title:"在函数中接受元组与字典",date:"2018-07-24T18:36:49.000Z",categories:["Python-基础"],tags:["Python基础"],permalink:"/pages/f954d1/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/01.Python-%E5%9F%BA%E7%A1%80/23.%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E6%8E%A5%E5%8F%97%E5%85%83%E7%BB%84%E4%B8%8E%E5%AD%97%E5%85%B8.html",relativePath:"02.Python/01.Python-基础/23.在函数中接受元组与字典.md",key:"v-8d3daca2",path:"/pages/f954d1/",headers:[{level:3,title:"在函数中接受元组与字典",slug:"在函数中接受元组与字典",normalizedTitle:"在函数中接受元组与字典",charIndex:2},{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:95},{level:2,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:616}],headersStr:"在函数中接受元组与字典 代码 运行结果",content:"# 在函数中接受元组与字典\n\n> 有一种特殊方法，即分别使用 * 或 ** 作为元组或字典的前缀，来使它们作为一个参数为 函数所接收。当函数需要一个可变数量的实参时，这将非常有用。\n\n\n# 代码\n\n# 当args变量前面添加了一个*时，函数的所有其他的参数都将传递到args中，并作为一个元组储存\n# 如果采用的是 ** 前缀，则额外的参数将被视为字典的键值—值配对。\ndef powersum(power, *args):\n    '''Return the sum of each argument raised to the specified power.'''\n    total = 0\n    # 在for循环中，i每次获取的是args的值，也就是说初值由args而定\n    for i in args:\n        total += pow(i, power)\n    return total\n\n\n# 这里可以debug一下看下i的变化，在这里一开始的时候power=2，*args=（3，4）\n# i在初始时为3\nprint(powersum(2, 3, 4))\n# 这里i初始时为10\nprint(powersum(2, 10))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 运行结果\n\n> 25 100",normalizedContent:"# 在函数中接受元组与字典\n\n> 有一种特殊方法，即分别使用 * 或 ** 作为元组或字典的前缀，来使它们作为一个参数为 函数所接收。当函数需要一个可变数量的实参时，这将非常有用。\n\n\n# 代码\n\n# 当args变量前面添加了一个*时，函数的所有其他的参数都将传递到args中，并作为一个元组储存\n# 如果采用的是 ** 前缀，则额外的参数将被视为字典的键值—值配对。\ndef powersum(power, *args):\n    '''return the sum of each argument raised to the specified power.'''\n    total = 0\n    # 在for循环中，i每次获取的是args的值，也就是说初值由args而定\n    for i in args:\n        total += pow(i, power)\n    return total\n\n\n# 这里可以debug一下看下i的变化，在这里一开始的时候power=2，*args=（3，4）\n# i在初始时为3\nprint(powersum(2, 3, 4))\n# 这里i初始时为10\nprint(powersum(2, 10))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 运行结果\n\n> 25 100",charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"装饰器",frontmatter:{title:"装饰器",date:"2018-07-24T18:45:48.000Z",categories:["Python-基础"],tags:["Python基础"],permalink:"/pages/962777/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/01.Python-%E5%9F%BA%E7%A1%80/24.%E8%A3%85%E9%A5%B0%E5%99%A8.html",relativePath:"02.Python/01.Python-基础/24.装饰器.md",key:"v-1d080750",path:"/pages/962777/",headers:[{level:3,title:"装饰器",slug:"装饰器",normalizedTitle:"装饰器",charIndex:2},{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:47},{level:2,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:1549}],headersStr:"装饰器 代码 运行结果",content:'# 装饰器\n\n装饰器（Decorators）是应用包装函数的快捷方式。这有助于将某一功能与一些代码一遍又一 遍地“包装”。举个例子，我为自己创建了一个 retry 装饰器，这样我可以将其运用到任何函 数之中，如果在一次运行中抛出了任何错误，它就会尝试重新运行，直到最大次数 5 次，并 且每次运行期间都会有一定的延迟。这对于你在对一台远程计算机进行网络调用的情况十分 有用：\n\n\n# 代码\n\n# 从time模块引入sleep函数\nfrom time import sleep\nfrom functools import wraps\nimport logging\n\nlogging.basicConfig()\nlog = logging.getLogger("retry")\n\n\ndef retry(f):\n    @wraps(f)\n    def wrapped_f(*args, **kwargs):\n        MAX_ATTEMPTS = 5\n        for attempt in range(1, MAX_ATTEMPTS + 1):\n            try:\n                return f(*args, **kwargs)\n            except:\n                log.exception("Attempt %s %s failed : %s",\n                              attempt, MAX_ATTEMPTS, (args, kwargs))\n                sleep(10 * attempt)\n        log.critical("All %s attempts failed : %s",\n                     MAX_ATTEMPTS,\n                     (args, kwargs))\n\n    return wrapped_f\n\n\ncounter = 0\n\n\n@retry\ndef save_to_database(arg):\n    print("Write to a database or make a network call or etc.")\n    print("This will be automatically retried if exception is thrown.")\n    global counter\n    counter += 1\n    # 这将在第一次调用时抛出异常\n    # 在第二次运行时正常工作（也就是重试）\n    if counter < 2:\n        raise ValueError(arg)\n\n\n# 让你写的脚本模块既可以导入到别的模块中用，另外该模块自己也可执行。\nif __name__ == \'__main__\':\n    save_to_database("Some bad value")\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# 运行结果\n\nERROR:retry:Attempt 1 5 failed : ((\'Some bad value\',), {})\nTraceback (most recent call last):\n  File "E:/PythonProject/more/more_decorators.py", line 16, in wrapped_f\n    return f(*args, **kwargs)\n  File "E:/PythonProject/more/more_decorators.py", line 40, in save_to_database\n    raise ValueError(arg)\nValueError: Some bad value\nWrite to a database or make a network call or etc.\nThis will be automatically retried if exception is thrown.\nWrite to a database or make a network call or etc.\nThis will be automatically retried if exception is thrown.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n',normalizedContent:'# 装饰器\n\n装饰器（decorators）是应用包装函数的快捷方式。这有助于将某一功能与一些代码一遍又一 遍地“包装”。举个例子，我为自己创建了一个 retry 装饰器，这样我可以将其运用到任何函 数之中，如果在一次运行中抛出了任何错误，它就会尝试重新运行，直到最大次数 5 次，并 且每次运行期间都会有一定的延迟。这对于你在对一台远程计算机进行网络调用的情况十分 有用：\n\n\n# 代码\n\n# 从time模块引入sleep函数\nfrom time import sleep\nfrom functools import wraps\nimport logging\n\nlogging.basicconfig()\nlog = logging.getlogger("retry")\n\n\ndef retry(f):\n    @wraps(f)\n    def wrapped_f(*args, **kwargs):\n        max_attempts = 5\n        for attempt in range(1, max_attempts + 1):\n            try:\n                return f(*args, **kwargs)\n            except:\n                log.exception("attempt %s %s failed : %s",\n                              attempt, max_attempts, (args, kwargs))\n                sleep(10 * attempt)\n        log.critical("all %s attempts failed : %s",\n                     max_attempts,\n                     (args, kwargs))\n\n    return wrapped_f\n\n\ncounter = 0\n\n\n@retry\ndef save_to_database(arg):\n    print("write to a database or make a network call or etc.")\n    print("this will be automatically retried if exception is thrown.")\n    global counter\n    counter += 1\n    # 这将在第一次调用时抛出异常\n    # 在第二次运行时正常工作（也就是重试）\n    if counter < 2:\n        raise valueerror(arg)\n\n\n# 让你写的脚本模块既可以导入到别的模块中用，另外该模块自己也可执行。\nif __name__ == \'__main__\':\n    save_to_database("some bad value")\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# 运行结果\n\nerror:retry:attempt 1 5 failed : ((\'some bad value\',), {})\ntraceback (most recent call last):\n  file "e:/pythonproject/more/more_decorators.py", line 16, in wrapped_f\n    return f(*args, **kwargs)\n  file "e:/pythonproject/more/more_decorators.py", line 40, in save_to_database\n    raise valueerror(arg)\nvalueerror: some bad value\nwrite to a database or make a network call or etc.\nthis will be automatically retried if exception is thrown.\nwrite to a database or make a network call or etc.\nthis will be automatically retried if exception is thrown.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n',charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"finally异常处理",frontmatter:{title:"finally异常处理",date:"2018-07-23T19:51:46.000Z",categories:["Python-基础"],tags:["Python异常处理"],permalink:"/pages/cd9b6e/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/01.Python-%E5%9F%BA%E7%A1%80/25.finally%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html",relativePath:"02.Python/01.Python-基础/25.finally异常处理.md",key:"v-1fa6daf0",path:"/pages/cd9b6e/",headers:[{level:3,title:"finally异常处理",slug:"finally异常处理",normalizedTitle:"finally异常处理",charIndex:2},{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:18},{level:2,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:722}],headersStr:"finally异常处理 代码 运行结果",content:'# finally异常处理\n\n\n# 代码\n\nimport sys\nimport time\n\nf = None\ntry:\n    f = open("poem.txt")\n    # 我们常用的文件阅读风格\n    while True:\n        line = f.readline()\n        if len(line) == 0:\n            break\n        print(line, end=\'\')\n        sys.stdout.flush()\n        print("Press ctrl+c now")\n        # 为了确保它能运行一段时间\n        time.sleep(2)  # time.sleep 函数任意在每打印一行后插入两秒休眠\nexcept IOError:\n    print("Could not find file poem.txt")\nexcept KeyboardInterrupt:\n    print("!! You cancelled the reading from the file.")\nfinally:  # 始终执行\n    if f:\n        f.close()\n    print("(Cleaning up: Closed the file)")\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 运行结果\n\n12165456478Press ctrl+c now\n(Cleaning up: Closed the file)\n\n\n1\n2\n\n1\n2\n',normalizedContent:'# finally异常处理\n\n\n# 代码\n\nimport sys\nimport time\n\nf = none\ntry:\n    f = open("poem.txt")\n    # 我们常用的文件阅读风格\n    while true:\n        line = f.readline()\n        if len(line) == 0:\n            break\n        print(line, end=\'\')\n        sys.stdout.flush()\n        print("press ctrl+c now")\n        # 为了确保它能运行一段时间\n        time.sleep(2)  # time.sleep 函数任意在每打印一行后插入两秒休眠\nexcept ioerror:\n    print("could not find file poem.txt")\nexcept keyboardinterrupt:\n    print("!! you cancelled the reading from the file.")\nfinally:  # 始终执行\n    if f:\n        f.close()\n    print("(cleaning up: closed the file)")\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 运行结果\n\n12165456478press ctrl+c now\n(cleaning up: closed the file)\n\n\n1\n2\n\n1\n2\n',charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"Python的_name = 'main_' 的作用",frontmatter:{title:"Python的__name__ = '__main__' 的作用",date:"2018-07-24T11:05:44.000Z",categories:["Python-基础"],tags:["Python基础"],permalink:"/pages/f09b25/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/01.Python-%E5%9F%BA%E7%A1%80/26.Python%E7%9A%84main%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8.html",relativePath:"02.Python/01.Python-基础/26.Python的main函数作用.md",key:"v-a55cb270",path:"/pages/f09b25/",headers:[{level:3,title:"python的_name = 'main_' 的作用",slug:"python的-name-main-的作用",normalizedTitle:"python的_name = 'main_' 的作用",charIndex:null},{level:4,title:"让你写的脚本即可以导入别的模块中用，另外该模块自己也可以执行",slug:"让你写的脚本即可以导入别的模块中用-另外该模块自己也可以执行",normalizedTitle:"让你写的脚本即可以导入别的模块中用，另外该模块自己也可以执行",charIndex:225},{level:3,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:547}],headersStr:"python的_name = 'main_' 的作用 让你写的脚本即可以导入别的模块中用，另外该模块自己也可以执行 总结",content:"# python的__name__ = 'main' 的作用\n\n__name__ = '__main__' 的作用\n先写一个模块：\n\n#module.py\ndef main():\n  print \"we are in %s\"%__name__\nif __name__ == '__main__':\n  main()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n我们经常看到想上面代码底下的代码，其主要的意义在于：\n\n# 让你写的脚本即可以导入别的模块中用，另外该模块自己也可以执行\n\n这个函数定义了一个main函数，我们执行一下该py文件发现结果是打印出”we are in main“,说明我们的if语句中的内容被执行了，调用了main()：\n\n但是如果我们从另我一个模块导入该模块，并调用一次main()函数会是怎样的结果呢？\n\n其执行的结果是：we are in module\n\n但是没有显示\n\n”we are in __main__“\n\n\n1\n\n1\n\n\n,也就是说模块\n\n__name__ = '__main__' \n\n\n1\n\n1\n\n\n下面的函数没有执行。\n\n这样既可以让“模块”文件运行，也可以被其他模块引入，而且不会执行函数2次。这才是关键。\n\n\n# 总结\n\n如果我们是直接执行某个.py文件的时候，\n该文件中那么”__name__ == '__main__'“是True,\n但是我们如果从另外一个.py文件通过import导入该文件的时候，\n这时__name__的值就是我们这个py文件的名字而不是__main__。\n这个功能还有一个用处：调试代码的时候，在”if __name__ == '__main__'“\n中加入一些我们的调试代码，我们可以让外部模块调用的时候不执行\n我们的调试代码，但是如果我们想排查问题的时候，\n直接执行该模块文件，调试代码能够正常运行！\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n",normalizedContent:"# python的__name__ = 'main' 的作用\n\n__name__ = '__main__' 的作用\n先写一个模块：\n\n#module.py\ndef main():\n  print \"we are in %s\"%__name__\nif __name__ == '__main__':\n  main()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n我们经常看到想上面代码底下的代码，其主要的意义在于：\n\n# 让你写的脚本即可以导入别的模块中用，另外该模块自己也可以执行\n\n这个函数定义了一个main函数，我们执行一下该py文件发现结果是打印出”we are in main“,说明我们的if语句中的内容被执行了，调用了main()：\n\n但是如果我们从另我一个模块导入该模块，并调用一次main()函数会是怎样的结果呢？\n\n其执行的结果是：we are in module\n\n但是没有显示\n\n”we are in __main__“\n\n\n1\n\n1\n\n\n,也就是说模块\n\n__name__ = '__main__' \n\n\n1\n\n1\n\n\n下面的函数没有执行。\n\n这样既可以让“模块”文件运行，也可以被其他模块引入，而且不会执行函数2次。这才是关键。\n\n\n# 总结\n\n如果我们是直接执行某个.py文件的时候，\n该文件中那么”__name__ == '__main__'“是true,\n但是我们如果从另外一个.py文件通过import导入该文件的时候，\n这时__name__的值就是我们这个py文件的名字而不是__main__。\n这个功能还有一个用处：调试代码的时候，在”if __name__ == '__main__'“\n中加入一些我们的调试代码，我们可以让外部模块调用的时候不执行\n我们的调试代码，但是如果我们想排查问题的时候，\n直接执行该模块文件，调试代码能够正常运行！\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n",charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"Python的pickle模块",frontmatter:{title:"Python的pickle模块",date:"2018-07-23T19:45:46.000Z",categories:["Python-基础"],tags:["Python基础"],permalink:"/pages/ee2549/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/01.Python-%E5%9F%BA%E7%A1%80/27.Python%E7%9A%84pickle%E6%A8%A1%E5%9D%97.html",relativePath:"02.Python/01.Python-基础/27.Python的pickle模块.md",key:"v-81b73566",path:"/pages/ee2549/",headers:[{level:3,title:"python的pickle模块",slug:"python的pickle模块",normalizedTitle:"python的pickle模块",charIndex:2},{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:115},{level:2,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:959}],headersStr:"python的pickle模块 代码 运行结果",content:"# python的pickle模块\n\nPython 提供了一个叫作 Pickle 的标准模块，通过它你可以将任何纯 Python 对象存储到一个文件中，并在稍后将其取回。这叫作持久地（Persistently）存储对象。\n\n\n# 代码\n\n'''\n在Pickle模块中有2个常用的函数方法，一个叫做dump()，另一个叫做load()。\n\npickle.dump(对象, 文件，[使用协议])\n\nload()方法的作用正好与上面的dump()方法相反，上面是序列化数据，\n这个方法作用是反序列化。\n\npickle.load(文件)\n\n目的主要是为了将一些数据，如字符串、列表、字典等长期的以文件形式保存下来\n'''\nimport pickle\n\n# The name of the file where we will store the object\nshoplistfile = 'shoplist.data'\n# The list of things to buy\nshoplist = ['apple', 'mango', 'carrot']\n\n# Write to the file\nf = open(shoplistfile, 'wb')\n# Dump the object to a file\npickle.dump(shoplist, f)\nf.close()\n\n# Destroy the shoplist variable\ndel shoplist\n\n# Read back from the storage\nf = open(shoplistfile, 'rb')\n# Load the object from the file\nstoredlist = pickle.load(f)\nprint(storedlist)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 运行结果\n\n['apple', 'mango', 'carrot']\n\n\n1\n\n1\n",normalizedContent:"# python的pickle模块\n\npython 提供了一个叫作 pickle 的标准模块，通过它你可以将任何纯 python 对象存储到一个文件中，并在稍后将其取回。这叫作持久地（persistently）存储对象。\n\n\n# 代码\n\n'''\n在pickle模块中有2个常用的函数方法，一个叫做dump()，另一个叫做load()。\n\npickle.dump(对象, 文件，[使用协议])\n\nload()方法的作用正好与上面的dump()方法相反，上面是序列化数据，\n这个方法作用是反序列化。\n\npickle.load(文件)\n\n目的主要是为了将一些数据，如字符串、列表、字典等长期的以文件形式保存下来\n'''\nimport pickle\n\n# the name of the file where we will store the object\nshoplistfile = 'shoplist.data'\n# the list of things to buy\nshoplist = ['apple', 'mango', 'carrot']\n\n# write to the file\nf = open(shoplistfile, 'wb')\n# dump the object to a file\npickle.dump(shoplist, f)\nf.close()\n\n# destroy the shoplist variable\ndel shoplist\n\n# read back from the storage\nf = open(shoplistfile, 'rb')\n# load the object from the file\nstoredlist = pickle.load(f)\nprint(storedlist)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 运行结果\n\n['apple', 'mango', 'carrot']\n\n\n1\n\n1\n",charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"Python对象的实例化",frontmatter:{title:"Python对象的实例化",date:"2018-07-23T19:03:33.000Z",categories:["Python-基础"],tags:["Python基础"],permalink:"/pages/7cedd2/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/01.Python-%E5%9F%BA%E7%A1%80/28.Python%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96.html",relativePath:"02.Python/01.Python-基础/28.Python对象的实例化.md",key:"v-17e022f6",path:"/pages/7cedd2/",headers:[{level:3,title:"python对象的实例化",slug:"python对象的实例化",normalizedTitle:"python对象的实例化",charIndex:2},{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:19},{level:2,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:364}],headersStr:"python对象的实例化 代码 运行结果",content:"# python对象的实例化\n\n\n# 代码\n\n'''\n__init__ 方法会在类的对象被实例化（Instantiated）时立即运行。这一方法可以对任何你想\n进行操作的目标对象进行初始化（Initialization）操作。\n'''\nclass Person:\n    def __init__(self, name):\n        self.name = name\n\n    def say_hi(self):\n        print('Hello,my name is', self.name)\n\n\np = Person('Swaroop')\np.say_hi()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 运行结果\n\n> Hello,my name is Swaroop",normalizedContent:"# python对象的实例化\n\n\n# 代码\n\n'''\n__init__ 方法会在类的对象被实例化（instantiated）时立即运行。这一方法可以对任何你想\n进行操作的目标对象进行初始化（initialization）操作。\n'''\nclass person:\n    def __init__(self, name):\n        self.name = name\n\n    def say_hi(self):\n        print('hello,my name is', self.name)\n\n\np = person('swaroop')\np.say_hi()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 运行结果\n\n> hello,my name is swaroop",charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"Python日志模块",frontmatter:{title:"Python日志模块",date:"2018-07-23T20:03:18.000Z",categories:["Python-基础"],tags:["Python基础"],permalink:"/pages/adffdd/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/01.Python-%E5%9F%BA%E7%A1%80/29.Python%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97.html",relativePath:"02.Python/01.Python-基础/29.Python日志模块.md",key:"v-180b4631",path:"/pages/adffdd/",headers:[{level:3,title:"日志模块的应用",slug:"日志模块的应用",normalizedTitle:"日志模块的应用",charIndex:2},{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:14},{level:2,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:879}],headersStr:"日志模块的应用 代码 运行结果",content:"# 日志模块的应用\n\n\n# 代码\n\n# 日志模块\nimport os\nimport platform\nimport logging\n\n# os.getenv()获取一个环境变量，如果没有返回none\n# os.path.join()： 将多个路径组合后返回\nif platform.platform().startswith('Windows'):\n    logging_file = os.path.join(os.getenv('HOMEDRIVE'),\n                                os.getenv('HOMEPATH'),\n                                'test.log')\nelse:\n    logging_file = os.path.join(os.getenv('HOME'),\n                                'test.log')\nprint(\"Logging to\", logging_file)\n\nlogging.basicConfig(\n    level=logging.DEBUG,\n    format='%(asctime)s: %(levelname)s :%(message)s',\n    filename=logging_file,\n    filemode='w',\n)\n\n# 日志文件将存储在电脑上\nlogging.debug(\"Start of the program\")\nlogging.info(\"Doing something\")\nlogging.warning(\"Dying now\")\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 运行结果\n\nLogging to C:\\Users\\dylink\\test.log\n电脑查看该目录文件为\n2018-07-23 20:03:55,441: DEBUG :Start of the program\n2018-07-23 20:03:55,441: INFO :Doing something\n2018-07-23 20:03:55,441: WARNING :Dying now\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n",normalizedContent:"# 日志模块的应用\n\n\n# 代码\n\n# 日志模块\nimport os\nimport platform\nimport logging\n\n# os.getenv()获取一个环境变量，如果没有返回none\n# os.path.join()： 将多个路径组合后返回\nif platform.platform().startswith('windows'):\n    logging_file = os.path.join(os.getenv('homedrive'),\n                                os.getenv('homepath'),\n                                'test.log')\nelse:\n    logging_file = os.path.join(os.getenv('home'),\n                                'test.log')\nprint(\"logging to\", logging_file)\n\nlogging.basicconfig(\n    level=logging.debug,\n    format='%(asctime)s: %(levelname)s :%(message)s',\n    filename=logging_file,\n    filemode='w',\n)\n\n# 日志文件将存储在电脑上\nlogging.debug(\"start of the program\")\nlogging.info(\"doing something\")\nlogging.warning(\"dying now\")\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 运行结果\n\nlogging to c:\\users\\dylink\\test.log\n电脑查看该目录文件为\n2018-07-23 20:03:55,441: debug :start of the program\n2018-07-23 20:03:55,441: info :doing something\n2018-07-23 20:03:55,441: warning :dying now\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n",charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"Python中的_new_方法的重写",frontmatter:{title:"Python中的__new__方法的重写",date:"2018-08-08T20:56:28.000Z",description:"__new__方法的重写，单例模式前置？",categories:"Python-基础",tags:"Python基础",permalink:"/pages/985752/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/01.Python-%E5%9F%BA%E7%A1%80/30.Python%E4%B8%AD%E7%9A%84__new__%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99.html",relativePath:"02.Python/01.Python-基础/30.Python中的__new__方法的重写.md",key:"v-35ebce61",path:"/pages/985752/",headers:[{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:18},{level:2,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:477}],headersStr:"代码 运行结果",content:'new方法重写的步骤比较固定，直接上代码吧\n\n\n# 代码\n\nclass MusicPlayer(object):\n\n    # new方法的重写，是一个静态方法，必须主动传递cls参数\n    def __new__(cls, *args, **kwargs):\n        # 1.创建对象时，new方法会被自动调用\n        print("创建对象，分配空间")\n\n        # 2.为对象分配空间\n        instance = super().__new__(cls)\n        # 3.返回对象的引用\n        return instance\n\n    def __init__(self):\n        print("111")\n\n\nplayer = MusicPlayer()\nprint(player)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 运行结果\n\n创建对象，分配空间\n111\n<__main__.MusicPlayer object at 0x0000000003A0D128>\n\n\n1\n2\n3\n\n1\n2\n3\n',normalizedContent:'new方法重写的步骤比较固定，直接上代码吧\n\n\n# 代码\n\nclass musicplayer(object):\n\n    # new方法的重写，是一个静态方法，必须主动传递cls参数\n    def __new__(cls, *args, **kwargs):\n        # 1.创建对象时，new方法会被自动调用\n        print("创建对象，分配空间")\n\n        # 2.为对象分配空间\n        instance = super().__new__(cls)\n        # 3.返回对象的引用\n        return instance\n\n    def __init__(self):\n        print("111")\n\n\nplayer = musicplayer()\nprint(player)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 运行结果\n\n创建对象，分配空间\n111\n<__main__.musicplayer object at 0x0000000003a0d128>\n\n\n1\n2\n3\n\n1\n2\n3\n',charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"Python中的lambda函数",frontmatter:{title:"Python中的lambda函数",date:"2018-07-24T18:27:03.000Z",categories:["Python-基础"],tags:["Python基础"],permalink:"/pages/7235b8/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/01.Python-%E5%9F%BA%E7%A1%80/31.Python%E4%B8%AD%E7%9A%84lambda%E5%87%BD%E6%95%B0.html",relativePath:"02.Python/01.Python-基础/31.Python中的lambda函数.md",key:"v-6bfff2f1",path:"/pages/7235b8/",headers:[{level:3,title:"python中的lambda函数",slug:"python中的lambda函数",normalizedTitle:"python中的lambda函数",charIndex:2},{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:45},{level:2,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:886}],headersStr:"python中的lambda函数 代码 运行结果",content:"# python中的lambda函数\n\nlambda函数相当于定义了一个匿名的函数，减少了代码量\n\n\n# 代码\n\n# Lambda表格  也是lambda函数\npoints = [{'x': 2, 'y': 3},\n          {'x': 4, 'y': 1}]\npoints.sort(key=lambda i: i['y'])\nprint(points)\n'''\n要注意到一个 list 的 sort 方法可以获得一个 key 参数，\n用以决定列表的排序方式（通常我们只知道升序与降序）。\n在我们的案例中，我们希望进行一次自定义排序，为此我们需要编写一个函数，\n但是又不是为函数编写一个独立的 def 块，只在这一个地方使用，因此我\n们使用 Lambda 表达式来创建一个新函数。\n'''\n\n# lambda函数的其他使用方法\nadd = lambda x, y: x + y\nprint(add(1, 2))  # 结果为3\n# 需求：将列表中的元素按照绝对值大小进行升序排列\nlist1 = [3, 5, -4, -1, 0, -2, -6]\nprint(sorted(list1, key=lambda x: abs(x)))\n\n\n'''\n等价于\ndef get_abs(x):\n    return abs(x)\n\nlist1.sort(key=get_abs)\nprint(list1)\n\n或者\ndef get_abs(x):\n    return abs(x)\n    \nprint(sorted(list1, key=get_abs))\n'''\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 运行结果\n\n[{'y': 1, 'x': 4}, {'y': 3, 'x': 2}]\n3\n[0, -1, -2, 3, -4, 5, -6]\n\n\n1\n2\n3\n\n1\n2\n3\n",normalizedContent:"# python中的lambda函数\n\nlambda函数相当于定义了一个匿名的函数，减少了代码量\n\n\n# 代码\n\n# lambda表格  也是lambda函数\npoints = [{'x': 2, 'y': 3},\n          {'x': 4, 'y': 1}]\npoints.sort(key=lambda i: i['y'])\nprint(points)\n'''\n要注意到一个 list 的 sort 方法可以获得一个 key 参数，\n用以决定列表的排序方式（通常我们只知道升序与降序）。\n在我们的案例中，我们希望进行一次自定义排序，为此我们需要编写一个函数，\n但是又不是为函数编写一个独立的 def 块，只在这一个地方使用，因此我\n们使用 lambda 表达式来创建一个新函数。\n'''\n\n# lambda函数的其他使用方法\nadd = lambda x, y: x + y\nprint(add(1, 2))  # 结果为3\n# 需求：将列表中的元素按照绝对值大小进行升序排列\nlist1 = [3, 5, -4, -1, 0, -2, -6]\nprint(sorted(list1, key=lambda x: abs(x)))\n\n\n'''\n等价于\ndef get_abs(x):\n    return abs(x)\n\nlist1.sort(key=get_abs)\nprint(list1)\n\n或者\ndef get_abs(x):\n    return abs(x)\n    \nprint(sorted(list1, key=get_abs))\n'''\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 运行结果\n\n[{'y': 1, 'x': 4}, {'y': 3, 'x': 2}]\n3\n[0, -1, -2, 3, -4, 5, -6]\n\n\n1\n2\n3\n\n1\n2\n3\n",charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"Python中的静态方法、实例方法、类方法的区别",frontmatter:{title:"Python中的静态方法、实例方法、类方法的区别",date:"2018-08-08T20:34:25.000Z",description:"静态方法，实例方法，类方法的区别",categories:"Python-基础",tags:"Python-基础",permalink:"/pages/57af9e/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/01.Python-%E5%9F%BA%E7%A1%80/32.Python%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E3%80%81%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E3%80%81%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB.html",relativePath:"02.Python/01.Python-基础/32.Python中的静态方法、实例方法、类方法的区别.md",key:"v-7ba47ebe",path:"/pages/57af9e/",headers:[{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:283},{level:2,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:1147}],headersStr:"代码 运行结果",content:'实例方法\n\n定义：第一个参数必须是实例对象，该参数名一般约定为“self”，通过它来传递实例的属性和方法（也可以传类的属性和方法）；\n\n调用：只能由实例对象调用。\n\n类方法\n\n定义：使用装饰器@classmethod。第一个参数必须是当前类对象，该参数名一般约定为“cls”，通过它来传递类的属性和方法（不能传实例的属性和方法）；\n\n调用：实例对象和类对象都可以调用。\n\n静态方法\n\n定义：使用装饰器@staticmethod。参数随意，没有“self”和“cls”参数，但是方法体中不能使用类或实例的任何属性和方法；\n\n调用：实例对象和类对象都可以调用。\n\n\n# 代码\n\nimport time\n\n\nclass Tool(object):\n    count = 0\n\n    def __init__(self, name):\n        self.name = name\n        Tool.count += 1\n\n    # 定义一个实例方法，有self参数\n    def action(self):\n        print("挥动{}".format(self.name))\n\n    # 定义一个类方法，有cls参数\n    @classmethod\n    def shou_tool_count(cls):\n        print("工具对象的数量{}".format(cls.count))\n\n    # 定义一个静态方法，初始没有任何参数\n    @staticmethod\n    def showTime():\n        print(time.strftime("%H:%M:%S", time.localtime()))\n\n\n# 创建工具对象\ntool = Tool("斧头")\ntoo2 = Tool("榔头")\n# 调用类方法,逻辑上类方法一般由类自身调用，其实实例对象和类对象都可以调用\nTool.shou_tool_count()\n\n# 调用实例方法,只能由实例对象调用\ntool.action()\n\n# 调用静态方法,实例对象和类对象均可调用\ntoo2.showTime()\nTool.showTime()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# 运行结果\n\n工具对象的数量2\n挥动斧头\n20:30:46\n20:30:46\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n',normalizedContent:'实例方法\n\n定义：第一个参数必须是实例对象，该参数名一般约定为“self”，通过它来传递实例的属性和方法（也可以传类的属性和方法）；\n\n调用：只能由实例对象调用。\n\n类方法\n\n定义：使用装饰器@classmethod。第一个参数必须是当前类对象，该参数名一般约定为“cls”，通过它来传递类的属性和方法（不能传实例的属性和方法）；\n\n调用：实例对象和类对象都可以调用。\n\n静态方法\n\n定义：使用装饰器@staticmethod。参数随意，没有“self”和“cls”参数，但是方法体中不能使用类或实例的任何属性和方法；\n\n调用：实例对象和类对象都可以调用。\n\n\n# 代码\n\nimport time\n\n\nclass tool(object):\n    count = 0\n\n    def __init__(self, name):\n        self.name = name\n        tool.count += 1\n\n    # 定义一个实例方法，有self参数\n    def action(self):\n        print("挥动{}".format(self.name))\n\n    # 定义一个类方法，有cls参数\n    @classmethod\n    def shou_tool_count(cls):\n        print("工具对象的数量{}".format(cls.count))\n\n    # 定义一个静态方法，初始没有任何参数\n    @staticmethod\n    def showtime():\n        print(time.strftime("%h:%m:%s", time.localtime()))\n\n\n# 创建工具对象\ntool = tool("斧头")\ntoo2 = tool("榔头")\n# 调用类方法,逻辑上类方法一般由类自身调用，其实实例对象和类对象都可以调用\ntool.shou_tool_count()\n\n# 调用实例方法,只能由实例对象调用\ntool.action()\n\n# 调用静态方法,实例对象和类对象均可调用\ntoo2.showtime()\ntool.showtime()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# 运行结果\n\n工具对象的数量2\n挥动斧头\n20:30:46\n20:30:46\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n',charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"Python中的正则表达式",frontmatter:{title:"Python中的正则表达式",date:"2018-08-07T20:00:45.000Z",categories:["Python-基础"],tags:["Python基础"],permalink:"/pages/38b0ff/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/01.Python-%E5%9F%BA%E7%A1%80/33.Python%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html",relativePath:"02.Python/01.Python-基础/33.Python中的正则表达式.md",key:"v-11840c14",path:"/pages/38b0ff/",headers:[{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:285},{level:2,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:1580}],headersStr:"代码 运行结果",content:"主要是一些正则表达式的基本语法和部分实例\n\nre.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none\n\n> re.match(pattern, string, flag=0)\n\n参数        描述\npattern   匹配的正则表达式\nstring    要匹配的字符串\nflags     标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等\n\nre.search 扫描整个字符串并返回第一个成功的匹配\n\n> re.search(pattern, string, flag=0)\n\n\n# 代码\n\nimport re\n\n'''\ngroup() 返回被 RE 匹配的字符串\nstart() 返回匹配开始的位置\nend() 返回匹配结束的位置\nspan() 返回一个元组包含匹配 (开始,结束) 的位置\ngroup() 返回re整体匹配的字符串，可以一次输入多个组号，对应组号匹配的字符串\n'''\nprint(re.match('www', 'www.runoob.com').span())  # 在起始位置匹配\nprint(re.match('com', 'www.runoob.com'))  # 不在起始位置匹配\n\n# group(num=0)  匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。\nline = \"Cats are smarter than dogs\"\n\n# match部分\nmatchObj = re.match(r'(.*) are (.*?) .*', line, re.M | re.I)\n\nif matchObj:\n    print(\"matchObj.group():\", matchObj.group())\n    print(\"matchObj.group(1):\", matchObj.group(1))\n    print(\"matchObj.group(2):\", matchObj.group(2))\nelse:\n    print(\"No match!!\")\n\n# search部分\nsearchObj = re.search(r'(.*) are (.*?) .*', line, re.M | re.I)\n\nif searchObj:\n    print(\"searchObj.group() : \", searchObj.group())\n    print(\"searchObj.group(1) : \", searchObj.group(1))\n    print(\"searchObj.group(2) : \", searchObj.group(2))\nelse:\n    print(\"Nothing found!!\")\n# re.search 扫描整个字符串并返回第一个成功的匹配。\nprint(re.search('www', 'www.runoob.com').span())  # 在起始位置匹配\nprint(re.search('com', 'www.runoob.com').span())  # 不在起始位置匹配\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# 运行结果\n\n(0, 3)\nNone\nmatchObj.group(): Cats are smarter than dogs\nmatchObj.group(1): Cats\nmatchObj.group(2): smarter\nsearchObj.group() :  Cats are smarter than dogs\nsearchObj.group(1) :  Cats\nsearchObj.group(2) :  smarter\n(0, 3)\n(11, 14)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n",normalizedContent:"主要是一些正则表达式的基本语法和部分实例\n\nre.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none\n\n> re.match(pattern, string, flag=0)\n\n参数        描述\npattern   匹配的正则表达式\nstring    要匹配的字符串\nflags     标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等\n\nre.search 扫描整个字符串并返回第一个成功的匹配\n\n> re.search(pattern, string, flag=0)\n\n\n# 代码\n\nimport re\n\n'''\ngroup() 返回被 re 匹配的字符串\nstart() 返回匹配开始的位置\nend() 返回匹配结束的位置\nspan() 返回一个元组包含匹配 (开始,结束) 的位置\ngroup() 返回re整体匹配的字符串，可以一次输入多个组号，对应组号匹配的字符串\n'''\nprint(re.match('www', 'www.runoob.com').span())  # 在起始位置匹配\nprint(re.match('com', 'www.runoob.com'))  # 不在起始位置匹配\n\n# group(num=0)  匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。\nline = \"cats are smarter than dogs\"\n\n# match部分\nmatchobj = re.match(r'(.*) are (.*?) .*', line, re.m | re.i)\n\nif matchobj:\n    print(\"matchobj.group():\", matchobj.group())\n    print(\"matchobj.group(1):\", matchobj.group(1))\n    print(\"matchobj.group(2):\", matchobj.group(2))\nelse:\n    print(\"no match!!\")\n\n# search部分\nsearchobj = re.search(r'(.*) are (.*?) .*', line, re.m | re.i)\n\nif searchobj:\n    print(\"searchobj.group() : \", searchobj.group())\n    print(\"searchobj.group(1) : \", searchobj.group(1))\n    print(\"searchobj.group(2) : \", searchobj.group(2))\nelse:\n    print(\"nothing found!!\")\n# re.search 扫描整个字符串并返回第一个成功的匹配。\nprint(re.search('www', 'www.runoob.com').span())  # 在起始位置匹配\nprint(re.search('com', 'www.runoob.com').span())  # 不在起始位置匹配\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# 运行结果\n\n(0, 3)\nnone\nmatchobj.group(): cats are smarter than dogs\nmatchobj.group(1): cats\nmatchobj.group(2): smarter\nsearchobj.group() :  cats are smarter than dogs\nsearchobj.group(1) :  cats\nsearchobj.group(2) :  smarter\n(0, 3)\n(11, 14)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n",charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"Python中的正则表达式match和search",frontmatter:{title:"Python中的正则表达式match和search",date:"2018-08-07T20:16:00.000Z",categories:["Python-基础"],tags:["Python基础"],permalink:"/pages/ee44fe/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/01.Python-%E5%9F%BA%E7%A1%80/34.Python%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fmatch%E5%92%8Csearch.html",relativePath:"02.Python/01.Python-基础/34.Python中的正则表达式match和search.md",key:"v-25a11d4e",path:"/pages/ee44fe/",headers:[{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:80},{level:2,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:623}],headersStr:"代码 运行结果",content:"re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配\n\n\n# 代码\n\nimport re\n'''\nre.match只匹配字符串的开始，如果字符串开始不符合正则表达式，\n则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。\n'''\nline = \"Cats are smarter than dogs\";\n\nmatchObj = re.match(r'dogs', line, re.M | re.I)\nif matchObj:\n    print(\"match --\x3e matchObj.group() : \", matchObj.group())\nelse:\n    print(\"No match!!\")\n\nmatchObj = re.search(r'dogs', line, re.M | re.I)\nif matchObj:\n    print(\"search --\x3e matchObj.group() : \", matchObj.group())\nelse:\n    print(\"No match!!\")\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 运行结果\n\nNo match!!\nsearch --\x3e matchObj.group() :  dogs\n\n\n1\n2\n\n1\n2\n",normalizedContent:"re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回none；而re.search匹配整个字符串，直到找到一个匹配\n\n\n# 代码\n\nimport re\n'''\nre.match只匹配字符串的开始，如果字符串开始不符合正则表达式，\n则匹配失败，函数返回none；而re.search匹配整个字符串，直到找到一个匹配。\n'''\nline = \"cats are smarter than dogs\";\n\nmatchobj = re.match(r'dogs', line, re.m | re.i)\nif matchobj:\n    print(\"match --\x3e matchobj.group() : \", matchobj.group())\nelse:\n    print(\"no match!!\")\n\nmatchobj = re.search(r'dogs', line, re.m | re.i)\nif matchobj:\n    print(\"search --\x3e matchobj.group() : \", matchobj.group())\nelse:\n    print(\"no match!!\")\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 运行结果\n\nno match!!\nsearch --\x3e matchobj.group() :  dogs\n\n\n1\n2\n\n1\n2\n",charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"Python中面向对象比较简单的内部函数",frontmatter:{title:"Python中面向对象比较简单的内部函数",date:"2018-08-06T21:40:11.000Z",categories:["Python-基础"],tags:["Python基础"],permalink:"/pages/d79b2c/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/01.Python-%E5%9F%BA%E7%A1%80/35.Python%E4%B8%AD%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%AF%94%E8%BE%83%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E9%83%A8%E5%87%BD%E6%95%B0.html",relativePath:"02.Python/01.Python-基础/35.Python中面向对象比较简单的内部函数.md",key:"v-3c4081f6",path:"/pages/d79b2c/",headers:[{level:3,title:"比较简单的内部函数",slug:"比较简单的内部函数",normalizedTitle:"比较简单的内部函数",charIndex:2},{level:2,title:"代码部分",slug:"代码部分",normalizedTitle:"代码部分",charIndex:16},{level:2,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:634}],headersStr:"比较简单的内部函数 代码部分 运行结果",content:'# 比较简单的内部函数\n\n\n# 代码部分\n\nclass Cat:\n\n    def __init__(self, new_name):\n        self.name = new_name\n        # 定义一个私有属性\n        self.__age = 18\n        print("{}来了".format(self.name))\n\n    def __del__(self):\n        print("%s 我去了" % self.name)\n\n    def __str__(self):\n        # 必须返回一个字符串\n        # str方法定制变量输出信息，一般用来自定义内容\n        return "我是小猫{}".format(self.name)\n    # 如果定义为__secret则为私有方法\n    def secret(self):\n        print("{}的年龄是{}".format(self.name,self.__age))\n\n\ntom = Cat("Tom")\ntom.secret()\nprint(tom)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 运行结果\n\nTom来了\nTom的年龄是18\n我是小猫Tom\nTom 我去了\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n',normalizedContent:'# 比较简单的内部函数\n\n\n# 代码部分\n\nclass cat:\n\n    def __init__(self, new_name):\n        self.name = new_name\n        # 定义一个私有属性\n        self.__age = 18\n        print("{}来了".format(self.name))\n\n    def __del__(self):\n        print("%s 我去了" % self.name)\n\n    def __str__(self):\n        # 必须返回一个字符串\n        # str方法定制变量输出信息，一般用来自定义内容\n        return "我是小猫{}".format(self.name)\n    # 如果定义为__secret则为私有方法\n    def secret(self):\n        print("{}的年龄是{}".format(self.name,self.__age))\n\n\ntom = cat("tom")\ntom.secret()\nprint(tom)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 运行结果\n\ntom来了\ntom的年龄是18\n我是小猫tom\ntom 我去了\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n',charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"with open异常处理",frontmatter:{title:"with open异常处理",date:"2018-07-23T19:55:48.000Z",categories:["Python-基础"],tags:["Python异常处理"],permalink:"/pages/c20072/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/01.Python-%E5%9F%BA%E7%A1%80/36.with-open%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html",relativePath:"02.Python/01.Python-基础/36.with-open异常处理.md",key:"v-47059fc8",path:"/pages/c20072/",headers:[{level:3,title:"with open异常处理",slug:"with-open异常处理",normalizedTitle:"with open异常处理",charIndex:2},{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:20},{level:2,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:199}],headersStr:"with open异常处理 代码 运行结果",content:"# with open异常处理\n\n\n# 代码\n\nwith open(\"poem.txt\") as f:\n    for line in f:\n        print(line, end='')\n'''\n    with open能够将之前的try..finally最后执行的关闭文件的操作，交给with open自动完成\n'''\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 运行结果\n\n> poem.txt里面的内容为：12165456478\n\n>>>12165456478\n\n\n1\n\n1\n",normalizedContent:"# with open异常处理\n\n\n# 代码\n\nwith open(\"poem.txt\") as f:\n    for line in f:\n        print(line, end='')\n'''\n    with open能够将之前的try..finally最后执行的关闭文件的操作，交给with open自动完成\n'''\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 运行结果\n\n> poem.txt里面的内容为：12165456478\n\n>>>12165456478\n\n\n1\n\n1\n",charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"单例设计模式",frontmatter:{title:"单例设计模式",date:"2018-08-08T21:15:36.000Z",categories:"Python-基础",tags:"Python面向对象",permalink:"/pages/ccdd54/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/01.Python-%E5%9F%BA%E7%A1%80/37.Python%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html",relativePath:"02.Python/01.Python-基础/37.Python单例设计模式.md",key:"v-21ecc4d2",path:"/pages/ccdd54/",headers:[{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:10},{level:2,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:944}],headersStr:"代码 运行结果",content:'单例设计模式，以下是代码部分\n\n\n# 代码\n\n# object写不写都可以，在python3.X中已经默认继承了，以前区别旧式类和新式类\n# 单例设计模式\nclass MusicPlayer(object):\n    # 记录第一个被创建对象的引用\n    instance = None\n\n    # 记录是否执行过初始化方法\n    init_flag = False\n\n    def __new__(cls, *args, **kwargs):\n        # 1. 判断类属性是否是空对象\n        if cls.instance is None:\n            # 2. 调用父类的方法，为第一个对象分配空间\n            cls.instance = super().__new__(cls)\n        # 3. 返回类属性保存的对象引用\n        return cls.instance\n\n    # 让初始化方法只执行一次\n    def __init__(self):\n\n        # 1. 判断是否执行过初始化动作\n        if MusicPlayer.init_flag:\n            return\n        # 2. 如果没有执行过，执行初始化动作\n        print("111111111")\n        # 3. 修改类属性的标记\n        MusicPlayer.init_flag = True\n\n\n# 创建多个对象\nplayer1 = MusicPlayer()\nprint(player1)\nplayer2 = MusicPlayer()\nprint(player2)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 运行结果\n\n111111111\n<__main__.MusicPlayer object at 0x000000000342D0B8>\n<__main__.MusicPlayer object at 0x000000000342D0B8>\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n可以看出2次对象的创建在内存上实际是一个地址',normalizedContent:'单例设计模式，以下是代码部分\n\n\n# 代码\n\n# object写不写都可以，在python3.x中已经默认继承了，以前区别旧式类和新式类\n# 单例设计模式\nclass musicplayer(object):\n    # 记录第一个被创建对象的引用\n    instance = none\n\n    # 记录是否执行过初始化方法\n    init_flag = false\n\n    def __new__(cls, *args, **kwargs):\n        # 1. 判断类属性是否是空对象\n        if cls.instance is none:\n            # 2. 调用父类的方法，为第一个对象分配空间\n            cls.instance = super().__new__(cls)\n        # 3. 返回类属性保存的对象引用\n        return cls.instance\n\n    # 让初始化方法只执行一次\n    def __init__(self):\n\n        # 1. 判断是否执行过初始化动作\n        if musicplayer.init_flag:\n            return\n        # 2. 如果没有执行过，执行初始化动作\n        print("111111111")\n        # 3. 修改类属性的标记\n        musicplayer.init_flag = true\n\n\n# 创建多个对象\nplayer1 = musicplayer()\nprint(player1)\nplayer2 = musicplayer()\nprint(player2)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 运行结果\n\n111111111\n<__main__.musicplayer object at 0x000000000342d0b8>\n<__main__.musicplayer object at 0x000000000342d0b8>\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n可以看出2次对象的创建在内存上实际是一个地址',charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"继承的运用",frontmatter:{title:"继承的运用",date:"2018/7/23 19:19:24",categories:["Python"],tags:["Python面向对象"],permalink:"/pages/6a1778/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/01.Python-%E5%9F%BA%E7%A1%80/38.%E7%BB%A7%E6%89%BF%E7%9A%84%E8%BF%90%E7%94%A8.html",relativePath:"02.Python/01.Python-基础/38.继承的运用.md",key:"v-20ab13d4",path:"/pages/6a1778/",headers:[{level:3,title:"继承的运用",slug:"继承的运用",normalizedTitle:"继承的运用",charIndex:2},{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:12},{level:2,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:1454}],headersStr:"继承的运用 代码 运行结果",content:"# 继承的运用\n\n\n# 代码\n\n# 继承的运用\n# coding = UTF-8\nclass SchoolMember:\n    '''代表学校里的成员。'''\n\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n        print('(Initialized SchoolMember: {})'.format((self.name)))\n\n    def tell(self):\n        '''告诉我有关我的细节。'''\n        print('Name:\"{}\" Age:\"{}\"'.format(self.name, self.age), end=\" \")\n\n\nclass Teacher(SchoolMember):\n    '''代表一位老师。'''\n\n    def __init__(self, name, age, salary):\n        SchoolMember.__init__(self, name, age)\n        self.salary = salary\n        print('(Initialized Teacher: {})'.format(self.name))\n\n    def tell(self):\n        SchoolMember.tell(self)\n        print('Salary: \"{:d}\"'.format(self.salary))\n\n\nclass Student(SchoolMember):\n    '''代表一位学生。'''\n\n    def __init__(self, name, age, marks):\n        SchoolMember.__init__(self, name, age)\n        self.marks = marks\n        print('(Initialized Student: {})'.format(self.name))\n\n    def tell(self):\n        SchoolMember.tell(self)\n        print('Marks: \"{:d}\"'.format(self.marks))\n\n\nt = Teacher('Mrs. Shrividya', 40, 30000)\ns = Student('Swaroop', 25, 75)\n\nprint()\n\nmembers = [t, s]\nfor member in members:  # 对全体师生工作\n    member.tell()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n\n# 运行结果\n\n(Initialized SchoolMember: Mrs. Shrividya)\n(Initialized Teacher: Mrs. Shrividya)\n(Initialized SchoolMember: Swaroop)\n(Initialized Student: Swaroop)\n\nName:\"Mrs. Shrividya\" Age:\"40\" Salary: \"30000\"\nName:\"Swaroop\" Age:\"25\" Marks: \"75\"\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n",normalizedContent:"# 继承的运用\n\n\n# 代码\n\n# 继承的运用\n# coding = utf-8\nclass schoolmember:\n    '''代表学校里的成员。'''\n\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n        print('(initialized schoolmember: {})'.format((self.name)))\n\n    def tell(self):\n        '''告诉我有关我的细节。'''\n        print('name:\"{}\" age:\"{}\"'.format(self.name, self.age), end=\" \")\n\n\nclass teacher(schoolmember):\n    '''代表一位老师。'''\n\n    def __init__(self, name, age, salary):\n        schoolmember.__init__(self, name, age)\n        self.salary = salary\n        print('(initialized teacher: {})'.format(self.name))\n\n    def tell(self):\n        schoolmember.tell(self)\n        print('salary: \"{:d}\"'.format(self.salary))\n\n\nclass student(schoolmember):\n    '''代表一位学生。'''\n\n    def __init__(self, name, age, marks):\n        schoolmember.__init__(self, name, age)\n        self.marks = marks\n        print('(initialized student: {})'.format(self.name))\n\n    def tell(self):\n        schoolmember.tell(self)\n        print('marks: \"{:d}\"'.format(self.marks))\n\n\nt = teacher('mrs. shrividya', 40, 30000)\ns = student('swaroop', 25, 75)\n\nprint()\n\nmembers = [t, s]\nfor member in members:  # 对全体师生工作\n    member.tell()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n\n# 运行结果\n\n(initialized schoolmember: mrs. shrividya)\n(initialized teacher: mrs. shrividya)\n(initialized schoolmember: swaroop)\n(initialized student: swaroop)\n\nname:\"mrs. shrividya\" age:\"40\" salary: \"30000\"\nname:\"swaroop\" age:\"25\" marks: \"75\"\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n",charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"简单的异常处理",frontmatter:{title:"简单的异常处理",date:"2018-07-23T19:51:46.000Z",categories:["Python-基础"],tags:["Python异常处理"],permalink:"/pages/8d431d/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/01.Python-%E5%9F%BA%E7%A1%80/39.%E7%AE%80%E5%8D%95%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html",relativePath:"02.Python/01.Python-基础/39.简单的异常处理.md",key:"v-218f00a6",path:"/pages/8d431d/",headers:[{level:3,title:"简单的异常处理",slug:"简单的异常处理",normalizedTitle:"简单的异常处理",charIndex:2},{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:14},{level:2,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:297}],headersStr:"简单的异常处理 代码 运行结果",content:"# 简单的异常处理\n\n\n# 代码\n\ntry:\n    text = input('Enter someting --\x3e')\nexcept EOFError:   # 按ctrl+D\n    print('Why did you do an EOF on me?')\nexcept KeyboardInterrupt: # 按ctrl+C\n    print('You cancelled the operation.')\nelse:\n    print('You enterd {}'.format(text))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 运行结果\n\nEnter someting --\x3e^D\nWhy did you do an EOF on me?\n\n\n1\n2\n\n1\n2\n",normalizedContent:"# 简单的异常处理\n\n\n# 代码\n\ntry:\n    text = input('enter someting --\x3e')\nexcept eoferror:   # 按ctrl+d\n    print('why did you do an eof on me?')\nexcept keyboardinterrupt: # 按ctrl+c\n    print('you cancelled the operation.')\nelse:\n    print('you enterd {}'.format(text))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 运行结果\n\nenter someting --\x3e^d\nwhy did you do an eof on me?\n\n\n1\n2\n\n1\n2\n",charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"类变量与对象变量",frontmatter:{title:"类变量与对象变量",date:"2018-07-23T19:08:50.000Z",categories:["Python-基础"],tags:["Python面向对象"],permalink:"/pages/43bfe3/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/01.Python-%E5%9F%BA%E7%A1%80/40.%E7%B1%BB%E5%8F%98%E9%87%8F%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%8F%98%E9%87%8F.html",relativePath:"02.Python/01.Python-基础/40.类变量与对象变量.md",key:"v-6ed28772",path:"/pages/43bfe3/",headers:[{level:3,title:"类变量与对象变量",slug:"类变量与对象变量",normalizedTitle:"类变量与对象变量",charIndex:2},{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:15},{level:2,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:1937}],headersStr:"类变量与对象变量 代码 运行结果",content:'# 类变量与对象变量\n\n\n# 代码\n\n# coding=UTF-8,类变量与对象变量\nclass Robot:\n    """表示有一个带有名字的机器人。"""\n    # 一个类变量，用来计数机器人的数量\n    population = 0  # 这是一个类变量，属于Robot类\n\n    def __init__(self, name):  # name变量属于一个对象（通过self分配），因此它是一个对象变量\n        """初始化数据"""\n        self.name = name\n        print("(Initializing {})".format(self.name))\n\n        # 当有人被创建时，机器人会增加人口数量\n        \'\'\'\n       除了 Robot.popluation ，我们还可以使用 self.__class__.population ，因为每个对象都通过\n       self.__class__ 属性来引用它的类。 \n       \'\'\'\n        Robot.population += 1\n\n    def die(self):\n        """我挂了。"""\n        print("{} is being destroyed!".format(self.name))\n\n        Robot.population -= 1\n\n        if Robot.population == 0:\n            print("{} was the last one.".format(self.name))\n        else:\n            print("There are still {:d} robots working.".format(Robot.population))\n\n    def say_hi(self):\n        """来自机器人的诚挚问候\n\n        没问题，你做得到"""\n        print("Greetings , my masters call me {}".format(self.name))\n\n    \'\'\'\n    classmethod 修饰符对应的函数不需要实例化，不需要 self 参数，\n    但第一个参数需要是表示自身类的 cls 参数，可以来调用类的属性，类的方法，实例化对象等。\n    \'\'\'\n\n    # how_many实际上是一个属于类而非属于对象的方法\n    # classmethod(类方法)或是一个staticmethod(静态方法)\n    @classmethod  # 装饰器，等价于how_many = classmethod(how_many)\n    def how_many(cls):\n        """打印出当前的人口数量"""\n        print("We have {:d} robots.".format(cls.population))\n\n\ndroid1 = Robot("R2-D2")\ndroid1.say_hi()\nRobot.how_many()\n\ndroid2 = Robot("C-3PO")\ndroid2.say_hi()\nRobot.how_many()\nprint("\\nRobots can do some work here.\\n")\nprint("Robots have finished their work. So let\'s destroy them.")\ndroid1.die()\ndroid2.die()\n\nRobot.how_many()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n\n\n# 运行结果\n\n(Initializing R2-D2)\nGreetings , my masters call me R2-D2\nWe have 1 robots.\n(Initializing C-3PO)\nGreetings , my masters call me C-3PO\nWe have 2 robots.\n\nRobots can do some work here.\n\nRobots have finished their work. So let\'s destroy them.\nR2-D2 is being destroyed!\nThere are still 1 robots working.\nC-3PO is being destroyed!\nC-3PO was the last one.\nWe have 0 robots.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n',normalizedContent:'# 类变量与对象变量\n\n\n# 代码\n\n# coding=utf-8,类变量与对象变量\nclass robot:\n    """表示有一个带有名字的机器人。"""\n    # 一个类变量，用来计数机器人的数量\n    population = 0  # 这是一个类变量，属于robot类\n\n    def __init__(self, name):  # name变量属于一个对象（通过self分配），因此它是一个对象变量\n        """初始化数据"""\n        self.name = name\n        print("(initializing {})".format(self.name))\n\n        # 当有人被创建时，机器人会增加人口数量\n        \'\'\'\n       除了 robot.popluation ，我们还可以使用 self.__class__.population ，因为每个对象都通过\n       self.__class__ 属性来引用它的类。 \n       \'\'\'\n        robot.population += 1\n\n    def die(self):\n        """我挂了。"""\n        print("{} is being destroyed!".format(self.name))\n\n        robot.population -= 1\n\n        if robot.population == 0:\n            print("{} was the last one.".format(self.name))\n        else:\n            print("there are still {:d} robots working.".format(robot.population))\n\n    def say_hi(self):\n        """来自机器人的诚挚问候\n\n        没问题，你做得到"""\n        print("greetings , my masters call me {}".format(self.name))\n\n    \'\'\'\n    classmethod 修饰符对应的函数不需要实例化，不需要 self 参数，\n    但第一个参数需要是表示自身类的 cls 参数，可以来调用类的属性，类的方法，实例化对象等。\n    \'\'\'\n\n    # how_many实际上是一个属于类而非属于对象的方法\n    # classmethod(类方法)或是一个staticmethod(静态方法)\n    @classmethod  # 装饰器，等价于how_many = classmethod(how_many)\n    def how_many(cls):\n        """打印出当前的人口数量"""\n        print("we have {:d} robots.".format(cls.population))\n\n\ndroid1 = robot("r2-d2")\ndroid1.say_hi()\nrobot.how_many()\n\ndroid2 = robot("c-3po")\ndroid2.say_hi()\nrobot.how_many()\nprint("\\nrobots can do some work here.\\n")\nprint("robots have finished their work. so let\'s destroy them.")\ndroid1.die()\ndroid2.die()\n\nrobot.how_many()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n\n\n# 运行结果\n\n(initializing r2-d2)\ngreetings , my masters call me r2-d2\nwe have 1 robots.\n(initializing c-3po)\ngreetings , my masters call me c-3po\nwe have 2 robots.\n\nrobots can do some work here.\n\nrobots have finished their work. so let\'s destroy them.\nr2-d2 is being destroyed!\nthere are still 1 robots working.\nc-3po is being destroyed!\nc-3po was the last one.\nwe have 0 robots.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n',charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"输入输出——简单的回文判断",frontmatter:{title:"输入输出——简单的回文判断",date:"2018-07-23T19:30:11.000Z",categories:["Python-基础"],tags:["Python面向对象"],permalink:"/pages/0f3eea/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/01.Python-%E5%9F%BA%E7%A1%80/41.%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E7%9A%84%E5%9B%9E%E6%96%87%E5%88%A4%E6%96%AD.html",relativePath:"02.Python/01.Python-基础/41.输入输出——简单的回文判断.md",key:"v-73f43abd",path:"/pages/0f3eea/",headers:[{level:3,title:"输入输出——简单的回文判断",slug:"输入输出-简单的回文判断",normalizedTitle:"输入输出——简单的回文判断",charIndex:2},{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:20},{level:2,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:570}],headersStr:"输入输出——简单的回文判断 代码 运行结果",content:"# 输入输出——简单的回文判断\n\n\n# 代码\n\n'''\n可以通过使用 seq[a:b] 来从位置 a 开\n始到位置 b 结束来对序列进行切片 。我们同样可以提供第三个参数来确定切片的步长\n（Step）。默认的步长为 1 ，它会返回一份连续的文本。如果给定一个负数步长，如 -1 ，\n将返回翻转过的文本。\n'''\n\n\ndef reverse(text):\n    return text[::-1]  # 使用切片功能返回倒序\n\n\ndef is_palindrome(text):\n    return text == reverse(text)  # 如果正序和倒序相等的话，就是回文\n\n\nsomething = input(\"Enter text: \")\nif is_palindrome(something):\n    print(\"Yes,it is a palidrome\")  # 是回文\nelse:\n    print(\"No, it is not a palindrome\")  # 不是回文\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 运行结果\n\n> 如果是回文字串\n> \n> Enter text: 1221 Yes,it is a palidrome\n\n> 如果不是回文字串\n> \n> Enter text: 11111555 No, it is not a palindrome",normalizedContent:"# 输入输出——简单的回文判断\n\n\n# 代码\n\n'''\n可以通过使用 seq[a:b] 来从位置 a 开\n始到位置 b 结束来对序列进行切片 。我们同样可以提供第三个参数来确定切片的步长\n（step）。默认的步长为 1 ，它会返回一份连续的文本。如果给定一个负数步长，如 -1 ，\n将返回翻转过的文本。\n'''\n\n\ndef reverse(text):\n    return text[::-1]  # 使用切片功能返回倒序\n\n\ndef is_palindrome(text):\n    return text == reverse(text)  # 如果正序和倒序相等的话，就是回文\n\n\nsomething = input(\"enter text: \")\nif is_palindrome(something):\n    print(\"yes,it is a palidrome\")  # 是回文\nelse:\n    print(\"no, it is not a palindrome\")  # 不是回文\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 运行结果\n\n> 如果是回文字串\n> \n> enter text: 1221 yes,it is a palidrome\n\n> 如果不是回文字串\n> \n> enter text: 11111555 no, it is not a palindrome",charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"输入输出——回文字串的判断（加强版）",frontmatter:{title:"输入输出——回文字串的判断（加强版）",date:"2018-07-23T19:36:35.000Z",categories:["Python-基础"],tags:["Python面向对象"],permalink:"/pages/efd97d/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/01.Python-%E5%9F%BA%E7%A1%80/42.%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E2%80%94%E2%80%94%E5%9B%9E%E6%96%87%E5%AD%97%E4%B8%B2%E7%9A%84%E5%88%A4%E6%96%AD%EF%BC%88%E5%8A%A0%E5%BC%BA%E7%89%88%EF%BC%89.html",relativePath:"02.Python/01.Python-基础/42.输入输出——回文字串的判断（加强版）.md",key:"v-4f9430d9",path:"/pages/efd97d/",headers:[{level:3,title:"输入输出——回文字串的判断（加强版）",slug:"输入输出-回文字串的判断-加强版",normalizedTitle:"输入输出——回文字串的判断（加强版）",charIndex:2},{level:2,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:820}],headersStr:"输入输出——回文字串的判断（加强版） 运行结果",content:"# 输入输出——回文字串的判断（加强版）\n\nforbindden_word = (' ', ',', ';', '.', '!', '//', '?')\n\n# 样例字符串Rise to vote,sir.   共17长度\ndef ignore_word(text):  # 去除忽略的特殊字符\n    strdemo = list(text.lower())\n    count = 0\n    print('长度为:', len(strdemo))\n    for i in list(range(len(strdemo))):   # 遍历从0-16，共17长度 ，debug一下就懂了\n        if strdemo[i - count] in forbindden_word:\n            del strdemo[i - count]  # 删除特殊字符\n            count += 1\n    return strdemo\n\n\ndef reverse(text):\n    return text[::-1]\n\n\ndef is_reverse(text):  # 判断是否为回文\n    return text == reverse(text)\n\n\nsomething = input('随便输入点什么:')\nif is_reverse(ignore_word(something)):\n    print('恭喜！他是回文文本')\nelse:\n    print('这好像不是回文文本哦')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 运行结果\n\n随便输入点什么:Rise to vote,sir.\n长度为: 17\n恭喜！他是回文文本\n\n\n1\n2\n3\n\n1\n2\n3\n",normalizedContent:"# 输入输出——回文字串的判断（加强版）\n\nforbindden_word = (' ', ',', ';', '.', '!', '//', '?')\n\n# 样例字符串rise to vote,sir.   共17长度\ndef ignore_word(text):  # 去除忽略的特殊字符\n    strdemo = list(text.lower())\n    count = 0\n    print('长度为:', len(strdemo))\n    for i in list(range(len(strdemo))):   # 遍历从0-16，共17长度 ，debug一下就懂了\n        if strdemo[i - count] in forbindden_word:\n            del strdemo[i - count]  # 删除特殊字符\n            count += 1\n    return strdemo\n\n\ndef reverse(text):\n    return text[::-1]\n\n\ndef is_reverse(text):  # 判断是否为回文\n    return text == reverse(text)\n\n\nsomething = input('随便输入点什么:')\nif is_reverse(ignore_word(something)):\n    print('恭喜！他是回文文本')\nelse:\n    print('这好像不是回文文本哦')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 运行结果\n\n随便输入点什么:rise to vote,sir.\n长度为: 17\n恭喜！他是回文文本\n\n\n1\n2\n3\n\n1\n2\n3\n",charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"文件操作",frontmatter:{title:"文件操作",date:"2018-07-23T19:36:35.000Z",categories:["Python-基础"],tags:["Python面向对象"],permalink:"/pages/9d76ce/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/01.Python-%E5%9F%BA%E7%A1%80/43.%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C.html",relativePath:"02.Python/01.Python-基础/43.文件操作.md",key:"v-7365a2db",path:"/pages/9d76ce/",headers:[{level:3,title:"文件操作",slug:"文件操作",normalizedTitle:"文件操作",charIndex:2},{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:11},{level:2,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:628}],headersStr:"文件操作 代码 运行结果",content:"# 文件操作\n\n\n# 代码\n\npoem = '''\nProgramming is fun\nWhen the work is done\nif you wanna make your work also fun:\n    use Python!\n'''\n\n# 打开文件以编辑（'w'riting）\nf = open('poem.txt', 'w')\n# 向文件中编写文本\nf.write(poem)\n# 关闭文件\nf.close()\n\n# 如果没有特别指定\n# 将假定启用默认的阅读（'r'ead）模式\nf = open('poem.txt')\nwhile True:\n    line = f.readline()\n    # 零长度指示 EOF , 用来判断文档结尾\n    if len(line) == 0:\n        break\n    # 每行（'line'）的末尾\n    # 都已经有了换行符\n    # 因为它是从一个文件中进行读取的\n    print(line, end=' ')\n# 关闭文件\nf.close()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 运行结果\n\n Programming is fun\n When the work is done\n if you wanna make your work also fun:\n     use Python!\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n",normalizedContent:"# 文件操作\n\n\n# 代码\n\npoem = '''\nprogramming is fun\nwhen the work is done\nif you wanna make your work also fun:\n    use python!\n'''\n\n# 打开文件以编辑（'w'riting）\nf = open('poem.txt', 'w')\n# 向文件中编写文本\nf.write(poem)\n# 关闭文件\nf.close()\n\n# 如果没有特别指定\n# 将假定启用默认的阅读（'r'ead）模式\nf = open('poem.txt')\nwhile true:\n    line = f.readline()\n    # 零长度指示 eof , 用来判断文档结尾\n    if len(line) == 0:\n        break\n    # 每行（'line'）的末尾\n    # 都已经有了换行符\n    # 因为它是从一个文件中进行读取的\n    print(line, end=' ')\n# 关闭文件\nf.close()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 运行结果\n\n programming is fun\n when the work is done\n if you wanna make your work also fun:\n     use python!\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n",charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"用户自己引发的异常处理",frontmatter:{title:"用户自己引发的异常处理",date:"2018-07-23T19:58:26.000Z",categories:["Python-基础"],tags:["Python异常处理"],permalink:"/pages/74cf7d/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/01.Python-%E5%9F%BA%E7%A1%80/44.%E7%94%A8%E6%88%B7%E8%87%AA%E5%B7%B1%E5%BC%95%E5%8F%91%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html",relativePath:"02.Python/01.Python-基础/44.用户自己引发的异常处理.md",key:"v-1598588c",path:"/pages/74cf7d/",headers:[{level:3,title:"由用户自行定义的异常类处理",slug:"由用户自行定义的异常类处理",normalizedTitle:"由用户自行定义的异常类处理",charIndex:2},{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:20},{level:2,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:801}],headersStr:"由用户自行定义的异常类处理 代码 运行结果",content:"# 由用户自行定义的异常类处理\n\n\n# 代码\n\n# encoding = UTF-8\n# 用户自己引发异常\n\nclass ShortInputException(Exception):\n    '''一个由用户定义的异常类'''\n\n    def __init__(self, length, atleast):\n        Exception.__init__(self)\n        self.length = length\n        self.atleast = atleast\n\n\ntry:\n    text = input('Enter someting --\x3e')\n    if len(text) < 3:\n        raise ShortInputException(len(text), 3)\n    # 其他工作能够在此处正常运行\nexcept EOFError:\n    print('Why did you do an EOF on me?')\nexcept ShortInputException as ex:\n    print(('ShortInputException: The input was ' +\n           '{0} long,expected at least {1}')\n          .format(ex.length, ex.atleast))\nelse:\n    print('No exception was raised.')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 运行结果\n\n> 1.如果输入超过了3位数，截获错误\n\nEnter someting --\x3e88888\nNo exception was raised.\n\n\n1\n2\n\n1\n2\n\n\n> 2.如果输入没有超过3位数\n\nEnter someting --\x3e12\nShortInputException: The input was 2 long,expected at least 3\n\n\n1\n2\n\n1\n2\n",normalizedContent:"# 由用户自行定义的异常类处理\n\n\n# 代码\n\n# encoding = utf-8\n# 用户自己引发异常\n\nclass shortinputexception(exception):\n    '''一个由用户定义的异常类'''\n\n    def __init__(self, length, atleast):\n        exception.__init__(self)\n        self.length = length\n        self.atleast = atleast\n\n\ntry:\n    text = input('enter someting --\x3e')\n    if len(text) < 3:\n        raise shortinputexception(len(text), 3)\n    # 其他工作能够在此处正常运行\nexcept eoferror:\n    print('why did you do an eof on me?')\nexcept shortinputexception as ex:\n    print(('shortinputexception: the input was ' +\n           '{0} long,expected at least {1}')\n          .format(ex.length, ex.atleast))\nelse:\n    print('no exception was raised.')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 运行结果\n\n> 1.如果输入超过了3位数，截获错误\n\nenter someting --\x3e88888\nno exception was raised.\n\n\n1\n2\n\n1\n2\n\n\n> 2.如果输入没有超过3位数\n\nenter someting --\x3e12\nshortinputexception: the input was 2 long,expected at least 3\n\n\n1\n2\n\n1\n2\n",charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"正则表达式检索与替换",frontmatter:{title:"正则表达式检索与替换",date:"2018-08-07T20:43:26.000Z",categories:["Python-基础"],tags:["Python正则表达式"],permalink:"/pages/e8935b/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/01.Python-%E5%9F%BA%E7%A1%80/45.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A3%80%E7%B4%A2%E4%B8%8E%E6%9B%BF%E6%8D%A2.html",relativePath:"02.Python/01.Python-基础/45.正则表达式检索与替换.md",key:"v-5133dd93",path:"/pages/e8935b/",headers:[{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:65},{level:2,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:518}],headersStr:"代码 运行结果",content:"re.sub用于替换字符串中的匹配项\n\n> re.sub(pattern, repl, string, count=0)\n\n\n# 代码\n\nimport re\n\nphone = \"2004-959-559 # 这是一个电话号码\"\n\n# 删除注释\nnum = re.sub(r'#.*$', \"\", phone)\nprint(\"电话号码:\", num)\n\n# 移除非数字的内容\nnum = re.sub(r'\\D', \"\", phone)\nprint(\"电话号码:\", num)\n\n\n# 将匹配的数字乘以2\ndef double(matched):\n    value = int(matched.group('value'))\n    return str(value * 2)\n\n\ns = 'A23G4HFD567'\nprint(re.sub('(?P<value>\\d+)', double, s))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 运行结果\n\n电话号码: 2004-959-559 \n电话号码: 2004959559\nA46G8HFD1134\n\n\n1\n2\n3\n\n1\n2\n3\n",normalizedContent:"re.sub用于替换字符串中的匹配项\n\n> re.sub(pattern, repl, string, count=0)\n\n\n# 代码\n\nimport re\n\nphone = \"2004-959-559 # 这是一个电话号码\"\n\n# 删除注释\nnum = re.sub(r'#.*$', \"\", phone)\nprint(\"电话号码:\", num)\n\n# 移除非数字的内容\nnum = re.sub(r'\\d', \"\", phone)\nprint(\"电话号码:\", num)\n\n\n# 将匹配的数字乘以2\ndef double(matched):\n    value = int(matched.group('value'))\n    return str(value * 2)\n\n\ns = 'a23g4hfd567'\nprint(re.sub('(?p<value>\\d+)', double, s))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 运行结果\n\n电话号码: 2004-959-559 \n电话号码: 2004959559\na46g8hfd1134\n\n\n1\n2\n3\n\n1\n2\n3\n",charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"正则表达式中的compile函数",frontmatter:{title:"正则表达式中的compile函数",date:"2018-08-07T20:47:00.000Z",categories:["Python-基础"],tags:["Python正则表达式"],permalink:"/pages/270272/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/01.Python-%E5%9F%BA%E7%A1%80/46.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E7%9A%84compile%E5%87%BD%E6%95%B0.html",relativePath:"02.Python/01.Python-基础/46.正则表达式中的compile函数.md",key:"v-49e05f57",path:"/pages/270272/",headers:[{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:416},{level:2,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:1224}],headersStr:"代码 运行结果",content:"compile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。\n\n语法格式为：\n\n> re.compile(pattern[, flags])\n\n参数：\n\n * pattern : 一个字符串形式的正则表达式\n * flags 可选，表示匹配模式，比如忽略大小写，多行模式等，具体参数为：\n * re.I 忽略大小写\n   * re.L 表示特殊字符集 \\w, \\W, \\b, \\B, \\s, \\S 依赖于当前环境\n   * re.M 多行模式\n   * re.S 即为' . '并且包括换行符在内的任意字符（' . '不包括换行符）\n   * re.U 表示特殊字符集 \\w, \\W, \\b, \\B, \\d, \\D, \\s, \\S 依赖于 Unicode 字符属性数据库\n   * re.X 为了增加可读性，忽略空格和' # '后面的注释\n\n\n# 代码\n\nimport re\n\n# 列子1\npattern = re.compile(r'\\d+')  # 用于匹配至少一个数字\nm = pattern.match('one12twothree34four')  # 查找头部，没有匹配\nprint(m)\nm = pattern.match('one12twothree34four', 2, 10)  # 从'e'的位置开始匹配，没有匹配\nprint(m)\nm = pattern.match('one12twothree34four', 3, 10)  # 从'1'的位置开始匹配，正好匹配\nprint(m)  # 返回一个Match对象\nprint(m.group(0))  # 可省略0\nprint(m.start(0))  # 可省略0\nprint(m.end(0))  # 可省略0\nprint(m.span(0))  # 可省略0\n'''\n在上面，当匹配成功时返回一个 Match 对象，其中：\n\ngroup([group1, …]) 方法用于获得一个或多个分组匹配的字符串，当要获得整个匹配的子串时，可直接使用 group() 或 group(0)；\nstart([group]) 方法用于获取分组匹配的子串在整个字符串中的起始位置（子串第一个字符的索引），参数默认值为 0；\nend([group]) 方法用于获取分组匹配的子串在整个字符串中的结束位置（子串最后一个字符的索引+1），参数默认值为 0；\nspan([group]) 方法返回 (start(group), end(group))。\n'''\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 运行结果\n\nNone\nNone\n<_sre.SRE_Match object; span=(3, 5), match='12'>\n12\n3\n5\n(3, 5)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n",normalizedContent:"compile 函数用于编译正则表达式，生成一个正则表达式（ pattern ）对象，供 match() 和 search() 这两个函数使用。\n\n语法格式为：\n\n> re.compile(pattern[, flags])\n\n参数：\n\n * pattern : 一个字符串形式的正则表达式\n * flags 可选，表示匹配模式，比如忽略大小写，多行模式等，具体参数为：\n * re.i 忽略大小写\n   * re.l 表示特殊字符集 \\w, \\w, \\b, \\b, \\s, \\s 依赖于当前环境\n   * re.m 多行模式\n   * re.s 即为' . '并且包括换行符在内的任意字符（' . '不包括换行符）\n   * re.u 表示特殊字符集 \\w, \\w, \\b, \\b, \\d, \\d, \\s, \\s 依赖于 unicode 字符属性数据库\n   * re.x 为了增加可读性，忽略空格和' # '后面的注释\n\n\n# 代码\n\nimport re\n\n# 列子1\npattern = re.compile(r'\\d+')  # 用于匹配至少一个数字\nm = pattern.match('one12twothree34four')  # 查找头部，没有匹配\nprint(m)\nm = pattern.match('one12twothree34four', 2, 10)  # 从'e'的位置开始匹配，没有匹配\nprint(m)\nm = pattern.match('one12twothree34four', 3, 10)  # 从'1'的位置开始匹配，正好匹配\nprint(m)  # 返回一个match对象\nprint(m.group(0))  # 可省略0\nprint(m.start(0))  # 可省略0\nprint(m.end(0))  # 可省略0\nprint(m.span(0))  # 可省略0\n'''\n在上面，当匹配成功时返回一个 match 对象，其中：\n\ngroup([group1, …]) 方法用于获得一个或多个分组匹配的字符串，当要获得整个匹配的子串时，可直接使用 group() 或 group(0)；\nstart([group]) 方法用于获取分组匹配的子串在整个字符串中的起始位置（子串第一个字符的索引），参数默认值为 0；\nend([group]) 方法用于获取分组匹配的子串在整个字符串中的结束位置（子串最后一个字符的索引+1），参数默认值为 0；\nspan([group]) 方法返回 (start(group), end(group))。\n'''\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 运行结果\n\nnone\nnone\n<_sre.sre_match object; span=(3, 5), match='12'>\n12\n3\n5\n(3, 5)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n",charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"正则表达式中的compile函数(二)",frontmatter:{title:"正则表达式中的compile函数(二)",date:"2018-08-07T21:16:21.000Z",description:"compile函数(二)",categories:["Python-基础"],tags:["Python正则表达式"],permalink:"/pages/bff928/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/01.Python-%E5%9F%BA%E7%A1%80/47.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E7%9A%84compile%E5%87%BD%E6%95%B0(%E4%BA%8C).html",relativePath:"02.Python/01.Python-基础/47.正则表达式中的compile函数(二).md",key:"v-1c9efa1f",path:"/pages/bff928/",headers:[{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:24},{level:2,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:542}],headersStr:"代码 运行结果",content:"接着上一篇文章的compile函数实例\n\n\n# 代码\n\nimport re\n\npattern = re.compile(r'([a-z]+) ([a-z]+)', re.I)  # re.I 表示忽略大小写\nm = pattern.match('Hello World Wide Web')\nprint(m)  # 匹配成功，返回一个Match 对象\nprint(m.group(0))  # 返回匹配成功的整个子串\nprint(m.span(0))  # 返回匹配成功整个子串的索引\nprint(m.group(1))  # 返回第一个分组匹配成功的子串\nprint(m.span(1))  # 返回第一个分组匹配成功的子串的索引\nprint(m.group(2))  # 返回第二个分组匹配成功的子串\nprint(m.span(2))  # 返回第二个分组匹配成功的子串的索引\nprint(m.groups())  # 等价于(m.group(1),m.group(2), ...)\nprint(m.group(3))  # 不存在第三个分组\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 运行结果\n\nTraceback (most recent call last):\n<_sre.SRE_Match object; span=(0, 11), match='Hello World'>\n  File \"E:/PythonProject/more/test.py\", line 13, in <module>\nHello World\n    print(m.group(3))  # 不存在第三个分组\n(0, 11)\nIndexError: no such group\nHello\n(0, 5)\nWorld\n(6, 11)\n('Hello', 'World')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n",normalizedContent:"接着上一篇文章的compile函数实例\n\n\n# 代码\n\nimport re\n\npattern = re.compile(r'([a-z]+) ([a-z]+)', re.i)  # re.i 表示忽略大小写\nm = pattern.match('hello world wide web')\nprint(m)  # 匹配成功，返回一个match 对象\nprint(m.group(0))  # 返回匹配成功的整个子串\nprint(m.span(0))  # 返回匹配成功整个子串的索引\nprint(m.group(1))  # 返回第一个分组匹配成功的子串\nprint(m.span(1))  # 返回第一个分组匹配成功的子串的索引\nprint(m.group(2))  # 返回第二个分组匹配成功的子串\nprint(m.span(2))  # 返回第二个分组匹配成功的子串的索引\nprint(m.groups())  # 等价于(m.group(1),m.group(2), ...)\nprint(m.group(3))  # 不存在第三个分组\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 运行结果\n\ntraceback (most recent call last):\n<_sre.sre_match object; span=(0, 11), match='hello world'>\n  file \"e:/pythonproject/more/test.py\", line 13, in <module>\nhello world\n    print(m.group(3))  # 不存在第三个分组\n(0, 11)\nindexerror: no such group\nhello\n(0, 5)\nworld\n(6, 11)\n('hello', 'world')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n",charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"Numpy库的首次使用",frontmatter:{title:"Numpy库的首次使用",date:"2018-08-09T20:53:08.000Z",categories:["Python-机器学习"],tags:["Numpy","机器学习","矩阵"],permalink:"/pages/43f8b9/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/02.Python-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/01.Numpy%E5%BA%93%E7%9A%84%E9%A6%96%E6%AC%A1%E4%BD%BF%E7%94%A8.html",relativePath:"02.Python/02.Python-机器学习/01.Numpy库的首次使用.md",key:"v-cf53aca6",path:"/pages/43f8b9/",headers:[{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:57},{level:2,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:475}],headersStr:"代码 运行结果",content:'在pycharm中的setting安装numpy，或者在cmd里面通过pip install方法安装均可\n\n\n# 代码\n\nfrom numpy import *\n\n# 构造一个4x4的随机数组\nprint("数组:\\n",random.rand(4, 4))\n\n# 调用mat()函数将数组转化为矩阵\nrandMat = mat(random.rand(4, 4))\n# .I操作符实现了矩阵求逆的运算\nprint("矩阵求逆:\\n",randMat.I)\n# 矩阵乘以逆矩阵\ninvRandMat = randMat.I\nprint("矩阵乘以逆矩阵:\\n",randMat*invRandMat)\n\n# 函数eye(4)创建一个4x4的单位矩阵，下面是算误差\nmyEye = randMat*invRandMat\nprint("计算误差:\\n",myEye-eye(4))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 运行结果\n\n数组:\n [[ 0.46089523  0.94167701  0.76910005  0.96892095]\n [ 0.38894192  0.88828275  0.28144475  0.91774255]\n [ 0.13997437  0.7435124   0.89709322  0.68924161]\n [ 0.41461243  0.19911356  0.64856312  0.49160523]]\n矩阵求逆:\n [[-0.45014095  1.92871242  0.28217777 -0.76959459]\n [ 1.09829851 -0.9829715  -1.78955478  2.70643663]\n [ 0.95057662 -1.40675696  0.67345673 -0.70029109]\n [-1.11436955 -0.35496085  1.88297962 -0.76459429]]\n矩阵乘以逆矩阵:\n [[  1.00000000e+00   7.20736257e-17  -3.04329603e-17  -1.66886258e-17]\n [ -2.27212878e-16   1.00000000e+00   2.93001892e-17  -1.63043911e-16]\n [  8.73583235e-18  -3.06881469e-17   1.00000000e+00  -3.50839733e-17]\n [ -4.04804848e-17   1.45085950e-16  -1.23671214e-16   1.00000000e+00]]\n计算误差:\n [[ -1.11022302e-16   7.20736257e-17  -3.04329603e-17  -1.66886258e-17]\n [ -2.27212878e-16   2.22044605e-16   2.93001892e-17  -1.63043911e-16]\n [  8.73583235e-18  -3.06881469e-17  -2.22044605e-16  -3.50839733e-17]\n [ -4.04804848e-17   1.45085950e-16  -1.23671214e-16   2.22044605e-16]]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n',normalizedContent:'在pycharm中的setting安装numpy，或者在cmd里面通过pip install方法安装均可\n\n\n# 代码\n\nfrom numpy import *\n\n# 构造一个4x4的随机数组\nprint("数组:\\n",random.rand(4, 4))\n\n# 调用mat()函数将数组转化为矩阵\nrandmat = mat(random.rand(4, 4))\n# .i操作符实现了矩阵求逆的运算\nprint("矩阵求逆:\\n",randmat.i)\n# 矩阵乘以逆矩阵\ninvrandmat = randmat.i\nprint("矩阵乘以逆矩阵:\\n",randmat*invrandmat)\n\n# 函数eye(4)创建一个4x4的单位矩阵，下面是算误差\nmyeye = randmat*invrandmat\nprint("计算误差:\\n",myeye-eye(4))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 运行结果\n\n数组:\n [[ 0.46089523  0.94167701  0.76910005  0.96892095]\n [ 0.38894192  0.88828275  0.28144475  0.91774255]\n [ 0.13997437  0.7435124   0.89709322  0.68924161]\n [ 0.41461243  0.19911356  0.64856312  0.49160523]]\n矩阵求逆:\n [[-0.45014095  1.92871242  0.28217777 -0.76959459]\n [ 1.09829851 -0.9829715  -1.78955478  2.70643663]\n [ 0.95057662 -1.40675696  0.67345673 -0.70029109]\n [-1.11436955 -0.35496085  1.88297962 -0.76459429]]\n矩阵乘以逆矩阵:\n [[  1.00000000e+00   7.20736257e-17  -3.04329603e-17  -1.66886258e-17]\n [ -2.27212878e-16   1.00000000e+00   2.93001892e-17  -1.63043911e-16]\n [  8.73583235e-18  -3.06881469e-17   1.00000000e+00  -3.50839733e-17]\n [ -4.04804848e-17   1.45085950e-16  -1.23671214e-16   1.00000000e+00]]\n计算误差:\n [[ -1.11022302e-16   7.20736257e-17  -3.04329603e-17  -1.66886258e-17]\n [ -2.27212878e-16   2.22044605e-16   2.93001892e-17  -1.63043911e-16]\n [  8.73583235e-18  -3.06881469e-17  -2.22044605e-16  -3.50839733e-17]\n [ -4.04804848e-17   1.45085950e-16  -1.23671214e-16   2.22044605e-16]]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n',charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"kNN（k-近邻算法）",frontmatter:{title:"kNN（k-近邻算法）",date:"2018-08-09T21:43:52.000Z",description:"用k-近邻算法实现简单的分类",categories:"Python-机器学习",tags:["k-近邻算法","Python","机器学习"],keywords:"机器学习,Python,k-近邻算法",permalink:"/pages/b2a5ff/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/02.Python-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/02.kNN%EF%BC%88k-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95%EF%BC%89.html",relativePath:"02.Python/02.Python-机器学习/02.kNN（k-近邻算法）.md",key:"v-75da521e",path:"/pages/b2a5ff/",headers:[{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:751},{level:2,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:1950}],headersStr:"代码 运行结果",content:"**k-近邻算法（kNN），**它的工作原理是：存在一个样本数据集合，也称作训练样本集，并且样本集中每个数据都存在标签，即我们知道样本集中每一数据与所属分类的对应关系。输人没有标签的新数据后，将新数据的每个特征与样本集中数据对应的特征进行比较，然后算法提取样本集中特征最相似数据（最近邻）的分类标签。一般来说，我们只选择样本数据集中前 k个最相似的数据，这就是 k- 近邻算法中k的出处 , 通常k是不大于 20 的整数。 最后，选择k个最相似数据中出现次数最多的分类，作为新数据的分类。\n\nk-近邻算法的一般流程\n\n 1. 收集数据：可以使用任何方法。\n 2. 准备数据：距离计算所需要的数值，最好是结构化的数据格式。\n 3. 分析数据：可以使用任何方法。\n 4. 训练算法：此步驟不适用于k-近邻算法。\n 5. 测试算法：计算错误率。\n 6. 使用算法：首先需要输入样本数据和结构化的输出结果，然后运行k-近邻算法判定输入数据分别属于哪个分类，最后应用对计算出的分类执行后续的处理。\n\n使用欧氏距离公式，计算两个向量点xA和xB之间的距离：\n\n\n\n例如，点 (0 ,0) 与 (1, 2) 之间的距离计算为：\n\n\n\n如果数据集存在 4 个特征值，则点 (1 ,0, 0 ,1) 与 (7, 6, 9 ,4) 之间的距离计算为:\n\n\n\n计算完所有点之间的距离后，可以对数据按照从小到大的次序排序。然后，确定前 k 个距离最小元素所在的主要分类 , 输人k总是正整数；最后，将classCount字典分解为元组列表，然后使用程序第二行导入运算符模块的itemgetter方法 ,按照第二个元素的次序对元组进行排序。此处的排序为逆序，即按照从最大到最小次序排序，最后返回发生频率最高的元素标签。\n\n\n# 代码\n\nfrom numpy import *\nimport operator\n\n\ndef createDateSet():\n    group = array([[1.0, 1.1], [1.0, 1.0], [0, 0], [0, 0.1]])\n    labels = ['A', 'A', 'B', 'B']\n    return group, labels\n\n\n'''\n 用于分类的输人向量是inX，\n 输入的训练样本集为dataSet,\n 标签向量为labels\n 最后的参数k表示用于选择最近邻居的数目，\n 其中标签向量的元素数目和矩阵dataSet的行数相同\n'''\n\n\ndef classify0(inX, dataSet, labels, k):\n    dataSetSize = dataSet.shape[0]\n    # 距离计算\n    diffMat = tile(inX, (dataSetSize, 1)) - dataSet\n    sqDiffMat = diffMat ** 2\n    sqDistances = sqDiffMat.sum(axis=1)\n    distances = sqDistances ** 0.5\n    sortedDistIndicies = distances.argsort()\n    classCount = {}\n    # 选择距离最小的k个点\n    for i in range(k):\n        votellabel = labels[sortedDistIndicies[i]]\n        classCount[votellabel] = classCount.get(votellabel, 0) + 1\n    # 排序\n    sortedClassCount = sorted(classCount.items(), key=operator.itemgetter(1), reverse=True)\n    return sortedClassCount[0][0]\n\n\ngroup, labels = createDateSet()\nprint(classify0([1.0, 1.1], group, labels, 3))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# 运行结果\n\nA\n\n\n1\n\n1\n",normalizedContent:"**k-近邻算法（knn），**它的工作原理是：存在一个样本数据集合，也称作训练样本集，并且样本集中每个数据都存在标签，即我们知道样本集中每一数据与所属分类的对应关系。输人没有标签的新数据后，将新数据的每个特征与样本集中数据对应的特征进行比较，然后算法提取样本集中特征最相似数据（最近邻）的分类标签。一般来说，我们只选择样本数据集中前 k个最相似的数据，这就是 k- 近邻算法中k的出处 , 通常k是不大于 20 的整数。 最后，选择k个最相似数据中出现次数最多的分类，作为新数据的分类。\n\nk-近邻算法的一般流程\n\n 1. 收集数据：可以使用任何方法。\n 2. 准备数据：距离计算所需要的数值，最好是结构化的数据格式。\n 3. 分析数据：可以使用任何方法。\n 4. 训练算法：此步驟不适用于k-近邻算法。\n 5. 测试算法：计算错误率。\n 6. 使用算法：首先需要输入样本数据和结构化的输出结果，然后运行k-近邻算法判定输入数据分别属于哪个分类，最后应用对计算出的分类执行后续的处理。\n\n使用欧氏距离公式，计算两个向量点xa和xb之间的距离：\n\n\n\n例如，点 (0 ,0) 与 (1, 2) 之间的距离计算为：\n\n\n\n如果数据集存在 4 个特征值，则点 (1 ,0, 0 ,1) 与 (7, 6, 9 ,4) 之间的距离计算为:\n\n\n\n计算完所有点之间的距离后，可以对数据按照从小到大的次序排序。然后，确定前 k 个距离最小元素所在的主要分类 , 输人k总是正整数；最后，将classcount字典分解为元组列表，然后使用程序第二行导入运算符模块的itemgetter方法 ,按照第二个元素的次序对元组进行排序。此处的排序为逆序，即按照从最大到最小次序排序，最后返回发生频率最高的元素标签。\n\n\n# 代码\n\nfrom numpy import *\nimport operator\n\n\ndef createdateset():\n    group = array([[1.0, 1.1], [1.0, 1.0], [0, 0], [0, 0.1]])\n    labels = ['a', 'a', 'b', 'b']\n    return group, labels\n\n\n'''\n 用于分类的输人向量是inx，\n 输入的训练样本集为dataset,\n 标签向量为labels\n 最后的参数k表示用于选择最近邻居的数目，\n 其中标签向量的元素数目和矩阵dataset的行数相同\n'''\n\n\ndef classify0(inx, dataset, labels, k):\n    datasetsize = dataset.shape[0]\n    # 距离计算\n    diffmat = tile(inx, (datasetsize, 1)) - dataset\n    sqdiffmat = diffmat ** 2\n    sqdistances = sqdiffmat.sum(axis=1)\n    distances = sqdistances ** 0.5\n    sorteddistindicies = distances.argsort()\n    classcount = {}\n    # 选择距离最小的k个点\n    for i in range(k):\n        votellabel = labels[sorteddistindicies[i]]\n        classcount[votellabel] = classcount.get(votellabel, 0) + 1\n    # 排序\n    sortedclasscount = sorted(classcount.items(), key=operator.itemgetter(1), reverse=true)\n    return sortedclasscount[0][0]\n\n\ngroup, labels = createdateset()\nprint(classify0([1.0, 1.1], group, labels, 3))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# 运行结果\n\na\n\n\n1\n\n1\n",charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"kNN识别手写图像",frontmatter:{title:"kNN识别手写图像",date:"2018-08-16T21:03:00.000Z",categories:"Python-机器学习",tags:["k-近邻算法","Python","机器学习","Numpy"],permalink:"/pages/6c1c7d/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/02.Python-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/03.kNN%E8%AF%86%E5%88%AB%E6%89%8B%E5%86%99%E5%9B%BE%E5%83%8F.html",relativePath:"02.Python/02.Python-机器学习/03.kNN识别手写图像.md",key:"v-54191a9e",path:"/pages/6c1c7d/",headers:[{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:337},{level:2,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:3544}],headersStr:"代码 运行结果",content:"示例 ：使用k-近邻算法的手写识别系统 (1) 收集数据：提供文本文件。 (2) 准备数据：编写函数classify0(), 将图像格式转换为分类器使用的list格式。 (3) 分析数据：检查数据，确保它符合要求。 (4) 训练算法：此步驟不适用于k-近邻算法。 (5) 测试算法：编写函数使用提供的部分数据集作为测试样本，测试样本与非测试样本的区别在于测试样本是已经完成分类的数据，如果预测分类与实际类别不同，则标记为一个错误。 (6) 使用算法：本例没有完成此步骤，若你感兴趣可以构建完整的应用程序，从图像中提取数字，并完成数字识别，美国的邮件分拣系统就是一个实际运行的类似系统。\n\n提示\n\n注：由于原本数据集已经在0和1之间，所以不需要转化数字特征值。数据集\n\n\n# 代码\n\nfrom numpy import *\nfrom os import listdir\nimport operator\n\n\ndef classify0(inX, dataSet, labels, k):\n    dataSetSize = dataSet.shape[0]\n    # 距离计算\n    '''\n     tile(A，rep) \n        功能：重复A的各个维度 \n        参数类型： \n        A: Array类的都可以 \n        rep：A沿着各个维度重复的次数\n    '''\n    diffMat = tile(inX, (dataSetSize, 1)) - dataSet\n    sqDiffMat = diffMat ** 2\n    # numpy中的 axis=0表示列,向下，axis=1表示行，向右\n    # 在平时使用的sun默认的是axis=0就是普通的相加，当加入axis=1以后就是将一个矩阵的每一行向量相加\n    sqDistances = sqDiffMat.sum(axis=1)\n    distances = sqDistances ** 0.5\n    # argsort函数返回的是数组值从小到大的索引值\n    sortedDistIndicies = distances.argsort()\n    classCount = {}\n    # 选择距离最小的k个点\n    for i in range(k):\n        votellabel = labels[sortedDistIndicies[i]]\n        classCount[votellabel] = classCount.get(votellabel, 0) + 1\n    # 排序\n    sortedClassCount = sorted(classCount.items(), key=operator.itemgetter(1), reverse=True)\n    return sortedClassCount[0][0]\n\n\ndef img2vector(filename):\n    # 将图像矩阵转化为1x1024的向量\n    returnVect = zeros((1, 1024))\n    fr = open(filename)\n    # 循环读出文件的前32行\n    for i in range(32):\n        lineStr = fr.readline()\n        # 将每行的头32个字符值存储在Numpy数组中\n        for j in range(32):\n            returnVect[0, 32 * i + j] = int(lineStr[j])\n        # 返回数组\n    return returnVect\n\n\ndef handwritingClassTest():\n    hwLabels = []\n    # 获取训练数据集下目录的所有文件名的列表\n    trainingFileList = listdir('trainingDigits')\n    # 得到文件数量\n    m = len(trainingFileList)\n    # 创建m行1024列的训练矩阵\n    trainingMat = zeros((m, 1024))\n    for i in range(m):\n        # 从文件名解析分类数字\n        # 解析出0_10.txt\n        fileNameStr = trainingFileList[i]\n        # 获得0_10\n        fileStr = fileNameStr.split('.')[0]\n        # 获得0\n        classNumStr = int(fileStr.split('_')[0])\n        hwLabels.append(classNumStr)\n        trainingMat[i, :] = img2vector('trainingDigits/%s' % fileNameStr)\n    # 获得测试数据集下目录的所有文件名的列表\n    testFileList = listdir('testDigits')\n    errorCount = 0.0\n    mTest = len(testFileList)\n    for i in range(mTest):\n        fileNameStr = testFileList[i]\n        fileStr = fileNameStr.split('.')[0]\n        classNumStr = int(fileStr.split('_')[0])\n        vectorUnderTest = img2vector('testDigits/%s' % fileNameStr)\n        classifierResult = classify0(vectorUnderTest, trainingMat, hwLabels, 3)\n        print(\"the classifier came back with:%d,the real answer is:%d\" % (classifierResult, classNumStr))\n        if (classifierResult != classNumStr):\n            errorCount += 1.0\n    print(\"\\nthe total number of errors is:%d\" % errorCount)\n    print(\"\\nthe total error rate is :%f\" % (errorCount / float(mTest)))\n\n\ntestVector = img2vector('testDigits/0_13.txt')\n# X[:,  m:n]，即取二维数组中的第m到n-1列的所有数据\nprint(\"测试输出:\\n\", testVector[0, 0:31])\nhandwritingClassTest()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n\n\n\n# 运行结果\n\nthe classifier came back with:1,the real answer is:1\nthe classifier came back with:1,the real answer is:1\n\n.....\n\nthe classifier came back with:5,the real answer is:5\nthe classifier came back with:5,the real answer is:5\nthe classifier came back with:6,the real answer is:6\nthe classifier came back with:6,the real answer is:6\n\n....\n\nthe classifier came back with:9,the real answer is:9\nthe classifier came back with:9,the real answer is:9\nthe classifier came back with:9,the real answer is:9\n\nthe total number of errors is:11\n# 错误率为1.2%\nthe total error rate is :0.011628\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n",normalizedContent:"示例 ：使用k-近邻算法的手写识别系统 (1) 收集数据：提供文本文件。 (2) 准备数据：编写函数classify0(), 将图像格式转换为分类器使用的list格式。 (3) 分析数据：检查数据，确保它符合要求。 (4) 训练算法：此步驟不适用于k-近邻算法。 (5) 测试算法：编写函数使用提供的部分数据集作为测试样本，测试样本与非测试样本的区别在于测试样本是已经完成分类的数据，如果预测分类与实际类别不同，则标记为一个错误。 (6) 使用算法：本例没有完成此步骤，若你感兴趣可以构建完整的应用程序，从图像中提取数字，并完成数字识别，美国的邮件分拣系统就是一个实际运行的类似系统。\n\n提示\n\n注：由于原本数据集已经在0和1之间，所以不需要转化数字特征值。数据集\n\n\n# 代码\n\nfrom numpy import *\nfrom os import listdir\nimport operator\n\n\ndef classify0(inx, dataset, labels, k):\n    datasetsize = dataset.shape[0]\n    # 距离计算\n    '''\n     tile(a，rep) \n        功能：重复a的各个维度 \n        参数类型： \n        a: array类的都可以 \n        rep：a沿着各个维度重复的次数\n    '''\n    diffmat = tile(inx, (datasetsize, 1)) - dataset\n    sqdiffmat = diffmat ** 2\n    # numpy中的 axis=0表示列,向下，axis=1表示行，向右\n    # 在平时使用的sun默认的是axis=0就是普通的相加，当加入axis=1以后就是将一个矩阵的每一行向量相加\n    sqdistances = sqdiffmat.sum(axis=1)\n    distances = sqdistances ** 0.5\n    # argsort函数返回的是数组值从小到大的索引值\n    sorteddistindicies = distances.argsort()\n    classcount = {}\n    # 选择距离最小的k个点\n    for i in range(k):\n        votellabel = labels[sorteddistindicies[i]]\n        classcount[votellabel] = classcount.get(votellabel, 0) + 1\n    # 排序\n    sortedclasscount = sorted(classcount.items(), key=operator.itemgetter(1), reverse=true)\n    return sortedclasscount[0][0]\n\n\ndef img2vector(filename):\n    # 将图像矩阵转化为1x1024的向量\n    returnvect = zeros((1, 1024))\n    fr = open(filename)\n    # 循环读出文件的前32行\n    for i in range(32):\n        linestr = fr.readline()\n        # 将每行的头32个字符值存储在numpy数组中\n        for j in range(32):\n            returnvect[0, 32 * i + j] = int(linestr[j])\n        # 返回数组\n    return returnvect\n\n\ndef handwritingclasstest():\n    hwlabels = []\n    # 获取训练数据集下目录的所有文件名的列表\n    trainingfilelist = listdir('trainingdigits')\n    # 得到文件数量\n    m = len(trainingfilelist)\n    # 创建m行1024列的训练矩阵\n    trainingmat = zeros((m, 1024))\n    for i in range(m):\n        # 从文件名解析分类数字\n        # 解析出0_10.txt\n        filenamestr = trainingfilelist[i]\n        # 获得0_10\n        filestr = filenamestr.split('.')[0]\n        # 获得0\n        classnumstr = int(filestr.split('_')[0])\n        hwlabels.append(classnumstr)\n        trainingmat[i, :] = img2vector('trainingdigits/%s' % filenamestr)\n    # 获得测试数据集下目录的所有文件名的列表\n    testfilelist = listdir('testdigits')\n    errorcount = 0.0\n    mtest = len(testfilelist)\n    for i in range(mtest):\n        filenamestr = testfilelist[i]\n        filestr = filenamestr.split('.')[0]\n        classnumstr = int(filestr.split('_')[0])\n        vectorundertest = img2vector('testdigits/%s' % filenamestr)\n        classifierresult = classify0(vectorundertest, trainingmat, hwlabels, 3)\n        print(\"the classifier came back with:%d,the real answer is:%d\" % (classifierresult, classnumstr))\n        if (classifierresult != classnumstr):\n            errorcount += 1.0\n    print(\"\\nthe total number of errors is:%d\" % errorcount)\n    print(\"\\nthe total error rate is :%f\" % (errorcount / float(mtest)))\n\n\ntestvector = img2vector('testdigits/0_13.txt')\n# x[:,  m:n]，即取二维数组中的第m到n-1列的所有数据\nprint(\"测试输出:\\n\", testvector[0, 0:31])\nhandwritingclasstest()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n\n\n\n# 运行结果\n\nthe classifier came back with:1,the real answer is:1\nthe classifier came back with:1,the real answer is:1\n\n.....\n\nthe classifier came back with:5,the real answer is:5\nthe classifier came back with:5,the real answer is:5\nthe classifier came back with:6,the real answer is:6\nthe classifier came back with:6,the real answer is:6\n\n....\n\nthe classifier came back with:9,the real answer is:9\nthe classifier came back with:9,the real answer is:9\nthe classifier came back with:9,the real answer is:9\n\nthe total number of errors is:11\n# 错误率为1.2%\nthe total error rate is :0.011628\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n",charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"LogisticRegression(逻辑回归)",frontmatter:{title:"LogisticRegression(逻辑回归)",date:"2018-10-21T16:27:14.000Z",description:"逻辑回归原理以及代码实现",categories:"Python-机器学习",tags:["逻辑回归","Python","机器学习"],keywords:"机器学习,Python,逻辑回归",permalink:"/pages/dbeb49/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/02.Python-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/04.LogisticRegression(%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92).html",relativePath:"02.Python/02.Python-机器学习/04.LogisticRegression(逻辑回归).md",key:"v-38c3379b",path:"/pages/dbeb49/",headers:[{level:3,title:"LogisticRegression定义",slug:"logisticregression定义",normalizedTitle:"logisticregression定义",charIndex:2},{level:3,title:"构造函数h(x)",slug:"构造函数h-x",normalizedTitle:"构造函数h(x)",charIndex:249},{level:2,title:"使用极大似然估计法",slug:"使用极大似然估计法",normalizedTitle:"使用极大似然估计法",charIndex:329},{level:2,title:"梯度下降算法求J(θ)的最小值",slug:"梯度下降算法求j-θ-的最小值",normalizedTitle:"梯度下降算法求j(θ)的最小值",charIndex:501},{level:2,title:"梯度下降的向量化(vectorization)",slug:"梯度下降的向量化-vectorization",normalizedTitle:"梯度下降的向量化(vectorization)",charIndex:605},{level:3,title:"代码实现",slug:"代码实现",normalizedTitle:"代码实现",charIndex:240},{level:2,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:4474}],headersStr:"LogisticRegression定义 构造函数h(x) 使用极大似然估计法 梯度下降算法求J(θ)的最小值 梯度下降的向量化(vectorization) 代码实现 运行结果",content:"# LogisticRegression定义\n\nlogistic回归，是一种广义的线性回归分析模型，常用于数据挖掘，疾病自动诊断，经济预测等领域。例如，探讨引发疾病的危险因素，并根据危险因素预测疾病发生的概率等。以胃癌病情分析为例，选择两组人群，一组是胃癌组，一组是非胃癌组，两组人群必定具有不同的体征与生活方式等。一般来说逻辑回归用来做分类任务，本文列举的是以线性的2分类为例， 除此之外还可以拓展到多更多参数实现非线性分类，以及多分类问题等。在文章中主要写了其推导过程以及部分代码实现\n\n\n# 构造函数h(x)\n\n\n\n其中sigmoid函数形式为：\n\n\n\n对应的函数图像是一个取值在0和1之间的曲线：\n\n\n\n因为：\n\n\n\n由上两式联立可得:\n\n\n\n\n# 使用极大似然估计法\n\n取似然函数(离散型):\n\n\n\n对似然函数取ln，转换为：\n\n\n\n极大似然估计就是要求得使l(θ)取最大值时的θ，所以如果是这样的话会对应这梯度上升算法，虽然和梯度下降效果一样但是为了便于理解，将J(θ)定义为如下式子，以变化为梯度下降算法求解。\n\n\n\n因为乘以了一个负的系数，所以J(θ)取最小值时的θ是最优参数\n\n\n# 梯度下降算法求J(θ)的最小值\n\n根据梯度下降法可知，更新过程为：\n\n\n\n式中α为学习率，求偏导数步骤：\n\n\n\n所以更新过程可以写成：\n\n\n\n因为α是常量，所以1/m可以省略，最后更新过程变为：\n\n\n\n\n# 梯度下降的向量化(vectorization)\n\n约定训练数据的矩阵形式如下，x的每一行为一条训练样本，而每一列为不同的特称取值 ：\n\n\n\n约定待求的参数θ的矩阵形式为:\n\n\n\n先求x*θ并记为A :\n\n\n\n求hθ(x)-y并记为E:\n\n\n\ng(A)的参数A为一列向量，所以实现g函数时要支持列向量作为参数，并返回列向量。由上式可知hθ(x)-y可以由g(A)-y一次计算求得。\n\n更新过程可以转化为：\n\n\n\n综合起来就是:\n\n\n\n综上所述，vectorization后θ更新的步骤如下 :\n\n 1. 求A=x*θ\n 2. 求E=g(A)-y\n 3. 求θ:=θ-α.x'.E,x'表示矩阵x的转置\n\n最后，向量化的参数更新公式为:\n\n\n\n\n# 代码实现\n\n# @Time    : 2018/10/19 16:37\n# @Author  : YuanMing\n# @File    : Logistic_regression.py\n# @Software: PyCharm\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef loadDataSet():\n    \"\"\"\n    取出数据和标签\n    :return:\n    \"\"\"\n    data = np.loadtxt('testSet.txt')\n    # 取数据集的第一列到最后一列的前一列\n    dataMat = data[:, 0:-1]\n    # 取数据集的最后一列\n    lableMat = data[:, -1]\n    # 为dataMat添加一列1，代表所有theta0的参数，其中0代表第1列，1代表需要插入的数值，axis=1代表横轴（即列添加）\n    dataMat = np.insert(dataMat, 0, 1, axis=1)\n    return dataMat, lableMat\n\n\ndef sigmoid(Z):\n    \"\"\"\n    构造sigmoid函数\n    :param Z: thetaT*x\n    :return: 分类精度\n    \"\"\"\n    return 1.0 / (1 + np.exp(-Z))\n\n\ndef gradient_descent(dataMat, labelMat):\n    \"\"\"\n    梯度下降算法\n    :param dataMat: 特征数组\n    :param labelMat: 标签数组\n    :return: 最小化的theta\n    \"\"\"\n    # 将特征数组转化为矩阵形式\n    dataMatrix = np.mat(dataMat)\n    # 将标签数据转化为矩阵并取矩阵的转置\n    labelMatrix = np.mat(labelMat).transpose()\n    # 得到特征矩阵的行数和列数\n    m, n = np.shape(dataMatrix)\n    # 学习率\n    alpha = 0.001\n    # 迭代次数\n    iterations = 500\n    # 生成n行1列的全1矩阵\n    theta = np.ones((n, 1))\n    # 执行梯度下降更新\n    for k in range(iterations):\n        # 求h(x)函数\n        h = sigmoid(dataMatrix * theta)\n        # 求误差\n        error = h - labelMatrix\n        # 按照推导的迭代公式求得新的theta\n        theta = theta - alpha * dataMatrix.transpose() * error\n    return theta\n\n\ndef plotBestFIt(theta):\n    # 导入数据\n    dataMat, lableMat = loadDataSet()\n    # 获取数据行数\n    n = np.shape(dataMat)[0]\n    # 初始化坐标列表\n    xcord1 = []\n    ycord1 = []\n    xcord2 = []\n    ycord2 = []\n    for i in range(n):\n        # 如果对应的类别标签对应数值1，就添加到xcord1，ycord1中\n        if lableMat[i] == 1:\n            xcord1.append(dataMat[i][1])\n            ycord1.append(dataMat[i][2])\n        # 如果对应的类别标签对应数值0，就添加到xcord2，ycord2中\n        else:\n            xcord2.append(dataMat[i][1])\n            ycord2.append(dataMat[i][2])\n    # 创建空图\n    fig = plt.figure()\n    # 将画布分割成1行1列，图像画在从左到右从上到下的第1块\n    # 添加subplot，三种数据都画在一张图上\n    ax = fig.add_subplot(111)\n    # 1类用红色标识，形状为正方形，s为标记点大小\n    ax.scatter(xcord1, ycord1, s=30, c='red', marker='s')\n    # 0类用蓝色标识\n    ax.scatter(xcord2, ycord2, s=30, c='blue')\n    # 生成一个ndarray数组范围从-3到3，步长为0.1\n    x = np.arange(-3, 3, 0.1)\n    '''\n    这里设置了sigmoid函数的取值为1/2，也就是说取阈值为0.5来划分最后预测的结果\n    根据e(−thetaTX)=1,即-thetaTX=0，可以推出x2 = (-theta0x0 - theta1x1)/theta2\n    因为x1和x2是两个特征，没有一定的x和y关系，这里假设y是x2,x是x1，之前x0代表1\n    '''\n    y = (-theta[0, 0] - theta[1, 0] * x) / theta[2, 0]\n    # 画出拟合直线\n    ax.plot(x, y)\n    # 规定X轴标签\n    plt.xlabel('X1')\n    # 规定Y轴标签\n    plt.ylabel('X2')\n    plt.show()\n\n\nif __name__ == '__main__':\n    dataMat, labelMat = loadDataSet()\n    theta = gradient_descent(dataMat, labelMat)\n    dataMat, labelMat = loadDataSet()\n    length = len(dataMat)\n    for i in range(length):\n        print(\"分类精度:{}\".format(round(float(sigmoid(dataMat[i]*theta))*100,2))+\"%\")\n    plotBestFIt(theta)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n\n\n\n# 运行结果\n\nD:\\Anaconda3\\python.exe E:/PythonProject/MachineLeaning/logistic_regression/Logistic_regression.py\n分类精度:1.04%\n分类精度:64.06%\n分类精度:43.28%\n分类精度:28.44%\n分类精度:7.64%\n分类精度:49.0%\n分类精度:3.18%\n分类精度:21.54%\n分类精度:18.35%\n分类精度:8.94%\n分类精度:56.55%\n分类精度:3.37%\n分类精度:93.91%\n分类精度:8.76%\n分类精度:57.59%\n分类精度:97.32%\n.........\nProcess finished with exit code 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n",normalizedContent:"# logisticregression定义\n\nlogistic回归，是一种广义的线性回归分析模型，常用于数据挖掘，疾病自动诊断，经济预测等领域。例如，探讨引发疾病的危险因素，并根据危险因素预测疾病发生的概率等。以胃癌病情分析为例，选择两组人群，一组是胃癌组，一组是非胃癌组，两组人群必定具有不同的体征与生活方式等。一般来说逻辑回归用来做分类任务，本文列举的是以线性的2分类为例， 除此之外还可以拓展到多更多参数实现非线性分类，以及多分类问题等。在文章中主要写了其推导过程以及部分代码实现\n\n\n# 构造函数h(x)\n\n\n\n其中sigmoid函数形式为：\n\n\n\n对应的函数图像是一个取值在0和1之间的曲线：\n\n\n\n因为：\n\n\n\n由上两式联立可得:\n\n\n\n\n# 使用极大似然估计法\n\n取似然函数(离散型):\n\n\n\n对似然函数取ln，转换为：\n\n\n\n极大似然估计就是要求得使l(θ)取最大值时的θ，所以如果是这样的话会对应这梯度上升算法，虽然和梯度下降效果一样但是为了便于理解，将j(θ)定义为如下式子，以变化为梯度下降算法求解。\n\n\n\n因为乘以了一个负的系数，所以j(θ)取最小值时的θ是最优参数\n\n\n# 梯度下降算法求j(θ)的最小值\n\n根据梯度下降法可知，更新过程为：\n\n\n\n式中α为学习率，求偏导数步骤：\n\n\n\n所以更新过程可以写成：\n\n\n\n因为α是常量，所以1/m可以省略，最后更新过程变为：\n\n\n\n\n# 梯度下降的向量化(vectorization)\n\n约定训练数据的矩阵形式如下，x的每一行为一条训练样本，而每一列为不同的特称取值 ：\n\n\n\n约定待求的参数θ的矩阵形式为:\n\n\n\n先求x*θ并记为a :\n\n\n\n求hθ(x)-y并记为e:\n\n\n\ng(a)的参数a为一列向量，所以实现g函数时要支持列向量作为参数，并返回列向量。由上式可知hθ(x)-y可以由g(a)-y一次计算求得。\n\n更新过程可以转化为：\n\n\n\n综合起来就是:\n\n\n\n综上所述，vectorization后θ更新的步骤如下 :\n\n 1. 求a=x*θ\n 2. 求e=g(a)-y\n 3. 求θ:=θ-α.x'.e,x'表示矩阵x的转置\n\n最后，向量化的参数更新公式为:\n\n\n\n\n# 代码实现\n\n# @time    : 2018/10/19 16:37\n# @author  : yuanming\n# @file    : logistic_regression.py\n# @software: pycharm\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef loaddataset():\n    \"\"\"\n    取出数据和标签\n    :return:\n    \"\"\"\n    data = np.loadtxt('testset.txt')\n    # 取数据集的第一列到最后一列的前一列\n    datamat = data[:, 0:-1]\n    # 取数据集的最后一列\n    lablemat = data[:, -1]\n    # 为datamat添加一列1，代表所有theta0的参数，其中0代表第1列，1代表需要插入的数值，axis=1代表横轴（即列添加）\n    datamat = np.insert(datamat, 0, 1, axis=1)\n    return datamat, lablemat\n\n\ndef sigmoid(z):\n    \"\"\"\n    构造sigmoid函数\n    :param z: thetat*x\n    :return: 分类精度\n    \"\"\"\n    return 1.0 / (1 + np.exp(-z))\n\n\ndef gradient_descent(datamat, labelmat):\n    \"\"\"\n    梯度下降算法\n    :param datamat: 特征数组\n    :param labelmat: 标签数组\n    :return: 最小化的theta\n    \"\"\"\n    # 将特征数组转化为矩阵形式\n    datamatrix = np.mat(datamat)\n    # 将标签数据转化为矩阵并取矩阵的转置\n    labelmatrix = np.mat(labelmat).transpose()\n    # 得到特征矩阵的行数和列数\n    m, n = np.shape(datamatrix)\n    # 学习率\n    alpha = 0.001\n    # 迭代次数\n    iterations = 500\n    # 生成n行1列的全1矩阵\n    theta = np.ones((n, 1))\n    # 执行梯度下降更新\n    for k in range(iterations):\n        # 求h(x)函数\n        h = sigmoid(datamatrix * theta)\n        # 求误差\n        error = h - labelmatrix\n        # 按照推导的迭代公式求得新的theta\n        theta = theta - alpha * datamatrix.transpose() * error\n    return theta\n\n\ndef plotbestfit(theta):\n    # 导入数据\n    datamat, lablemat = loaddataset()\n    # 获取数据行数\n    n = np.shape(datamat)[0]\n    # 初始化坐标列表\n    xcord1 = []\n    ycord1 = []\n    xcord2 = []\n    ycord2 = []\n    for i in range(n):\n        # 如果对应的类别标签对应数值1，就添加到xcord1，ycord1中\n        if lablemat[i] == 1:\n            xcord1.append(datamat[i][1])\n            ycord1.append(datamat[i][2])\n        # 如果对应的类别标签对应数值0，就添加到xcord2，ycord2中\n        else:\n            xcord2.append(datamat[i][1])\n            ycord2.append(datamat[i][2])\n    # 创建空图\n    fig = plt.figure()\n    # 将画布分割成1行1列，图像画在从左到右从上到下的第1块\n    # 添加subplot，三种数据都画在一张图上\n    ax = fig.add_subplot(111)\n    # 1类用红色标识，形状为正方形，s为标记点大小\n    ax.scatter(xcord1, ycord1, s=30, c='red', marker='s')\n    # 0类用蓝色标识\n    ax.scatter(xcord2, ycord2, s=30, c='blue')\n    # 生成一个ndarray数组范围从-3到3，步长为0.1\n    x = np.arange(-3, 3, 0.1)\n    '''\n    这里设置了sigmoid函数的取值为1/2，也就是说取阈值为0.5来划分最后预测的结果\n    根据e(−thetatx)=1,即-thetatx=0，可以推出x2 = (-theta0x0 - theta1x1)/theta2\n    因为x1和x2是两个特征，没有一定的x和y关系，这里假设y是x2,x是x1，之前x0代表1\n    '''\n    y = (-theta[0, 0] - theta[1, 0] * x) / theta[2, 0]\n    # 画出拟合直线\n    ax.plot(x, y)\n    # 规定x轴标签\n    plt.xlabel('x1')\n    # 规定y轴标签\n    plt.ylabel('x2')\n    plt.show()\n\n\nif __name__ == '__main__':\n    datamat, labelmat = loaddataset()\n    theta = gradient_descent(datamat, labelmat)\n    datamat, labelmat = loaddataset()\n    length = len(datamat)\n    for i in range(length):\n        print(\"分类精度:{}\".format(round(float(sigmoid(datamat[i]*theta))*100,2))+\"%\")\n    plotbestfit(theta)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n\n\n\n# 运行结果\n\nd:\\anaconda3\\python.exe e:/pythonproject/machineleaning/logistic_regression/logistic_regression.py\n分类精度:1.04%\n分类精度:64.06%\n分类精度:43.28%\n分类精度:28.44%\n分类精度:7.64%\n分类精度:49.0%\n分类精度:3.18%\n分类精度:21.54%\n分类精度:18.35%\n分类精度:8.94%\n分类精度:56.55%\n分类精度:3.37%\n分类精度:93.91%\n分类精度:8.76%\n分类精度:57.59%\n分类精度:97.32%\n.........\nprocess finished with exit code 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n",charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"Ndarray对象",frontmatter:{title:"Ndarray对象",date:"2018-08-22T20:55:17.000Z",description:"Numpy中的array",categories:"Python-机器学习",tags:["Numpy","Python"],keywords:"Numpy,Python,array",permalink:"/pages/6ae370/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/02.Python-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/05.Ndarray%E5%AF%B9%E8%B1%A1.html",relativePath:"02.Python/02.Python-机器学习/05.Ndarray对象.md",key:"v-17aa954e",path:"/pages/6ae370/",headers:[{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:492},{level:2,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:925}],headersStr:"代码 运行结果",content:'NumPy 中定义的最重要的对象是称为 ndarray 的 N 维数组类型。 它描述相同类型的元素集合。 可以使用基于零的索引访问集合中的项目。ndarray 中的每个元素在内存中使用相同大小的块。基本 的 ndarray 是使用 NumPy 中的数组函数创建的，如：numpy.array\n\n它从任何暴露数组接口的对象，或从返回数组的任何方法创建一个ndarray。\n\nnumpy.array(object,dtype=None,copy=True,order=None,subok=False,ndmin=0\n\n上面的构造器接受以下参数：\n\n序号   参数及描述\n1.   object 任何暴露数组接口方法的对象都会返回一个数组或任何（嵌套）序列。\n2.   dtype 数组的所需数据类型，可选。\n3.   copy 可选，默认为true，对象是否被复制。\n4.   order C（按行）、F（按列）或A（任意，默认）。\n5.   subok 默认情况下，返回的数组被强制为基类数组。 如果为true，则返回子类。\n6.   ndimin 指定返回数组的最小维数。\n\n\n# 代码\n\nimport numpy as np\n\na = np.array([1,2,3])\nprint(a,"\\n")\n# 当维度比一维高时\nb = np.array([[1,2],[3,4]])\nprint(b,"\\n")\n# zeros(shape)将创建一个用指定形状用0填充的数组\nprint(np.zeros((2,3)),"\\n")\n# ones(shape)将创建一个用1填充的数组\nprint(np.ones((3,3)),"\\n")\n# 最小维度\nc = np.array([1,2,3,4,5],ndmin=2)\nprint(c,"\\n")\n# dtype参数\na = np.array([1,2,3],dtype=complex)\nprint(a,"\\n")\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 运行结果\n\n[1 2 3] \n\n[[1 2]\n [3 4]] \n\n[[0. 0. 0.]\n [0. 0. 0.]] \n\n[[1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]] \n\n[[1 2 3 4 5]] \n\n[1.+0.j 2.+0.j 3.+0.j] \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n',normalizedContent:'numpy 中定义的最重要的对象是称为 ndarray 的 n 维数组类型。 它描述相同类型的元素集合。 可以使用基于零的索引访问集合中的项目。ndarray 中的每个元素在内存中使用相同大小的块。基本 的 ndarray 是使用 numpy 中的数组函数创建的，如：numpy.array\n\n它从任何暴露数组接口的对象，或从返回数组的任何方法创建一个ndarray。\n\nnumpy.array(object,dtype=none,copy=true,order=none,subok=false,ndmin=0\n\n上面的构造器接受以下参数：\n\n序号   参数及描述\n1.   object 任何暴露数组接口方法的对象都会返回一个数组或任何（嵌套）序列。\n2.   dtype 数组的所需数据类型，可选。\n3.   copy 可选，默认为true，对象是否被复制。\n4.   order c（按行）、f（按列）或a（任意，默认）。\n5.   subok 默认情况下，返回的数组被强制为基类数组。 如果为true，则返回子类。\n6.   ndimin 指定返回数组的最小维数。\n\n\n# 代码\n\nimport numpy as np\n\na = np.array([1,2,3])\nprint(a,"\\n")\n# 当维度比一维高时\nb = np.array([[1,2],[3,4]])\nprint(b,"\\n")\n# zeros(shape)将创建一个用指定形状用0填充的数组\nprint(np.zeros((2,3)),"\\n")\n# ones(shape)将创建一个用1填充的数组\nprint(np.ones((3,3)),"\\n")\n# 最小维度\nc = np.array([1,2,3,4,5],ndmin=2)\nprint(c,"\\n")\n# dtype参数\na = np.array([1,2,3],dtype=complex)\nprint(a,"\\n")\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 运行结果\n\n[1 2 3] \n\n[[1 2]\n [3 4]] \n\n[[0. 0. 0.]\n [0. 0. 0.]] \n\n[[1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]] \n\n[[1 2 3 4 5]] \n\n[1.+0.j 2.+0.j 3.+0.j] \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n',charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"Numpy中的数组维度",frontmatter:{title:"Numpy中的数组维度",date:"2018-08-22T22:15:17.000Z",description:"reshape方法定义维度",categories:"Python-机器学习",tags:["Numpy","Python"],keywords:"Numpy,Python,维度",permalink:"/pages/cdba0b/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/02.Python-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/06.Numpy%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%E7%BB%B4%E5%BA%A6.html",relativePath:"02.Python/02.Python-机器学习/06.Numpy中的数组维度.md",key:"v-bbe4baae",path:"/pages/cdba0b/",headers:[{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:107},{level:2,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:467}],headersStr:"代码 运行结果",content:'在对 np.arange(24)(0, 1, 2, 3, ..., 23) 进行重新的排列时，在多维数组的多个轴的方向上，先分配最后一个轴（对于二维数组，即先分配行的方向，对于三维数组即先分配平面的方向）\n\n\n# 代码\n\nimport numpy as np\n\n# 一维数组\na = np.arange(24)\nprint("a的维度:\\n",a.ndim)\n# 现在调整其大小,2行3列4个平面\nb = np.reshape(np.arange(24), (2, 3, 4))\n# b 现在拥有三个维度\nprint("b(也是三维数组):\\n",b)\n# 分别看看每一个平面的构成\nprint("b的每一个平面的构成：\\n")\nprint(b[:, :, 0])\nprint(b[:, :, 1])\nprint(b[:, :, 2])\nprint(b[:, :, 3])\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 运行结果\n\na的维度:\n 1\nb(也是三维数组):\n [[[ 0  1  2  3]\n  [ 4  5  6  7]\n  [ 8  9 10 11]]\n\n [[12 13 14 15]\n  [16 17 18 19]\n  [20 21 22 23]]]\nb的每一个平面的构成：\n\n[[ 0  4  8]\n [12 16 20]]\n[[ 1  5  9]\n [13 17 21]]\n[[ 2  6 10]\n [14 18 22]]\n[[ 3  7 11]\n [15 19 23]]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n',normalizedContent:'在对 np.arange(24)(0, 1, 2, 3, ..., 23) 进行重新的排列时，在多维数组的多个轴的方向上，先分配最后一个轴（对于二维数组，即先分配行的方向，对于三维数组即先分配平面的方向）\n\n\n# 代码\n\nimport numpy as np\n\n# 一维数组\na = np.arange(24)\nprint("a的维度:\\n",a.ndim)\n# 现在调整其大小,2行3列4个平面\nb = np.reshape(np.arange(24), (2, 3, 4))\n# b 现在拥有三个维度\nprint("b(也是三维数组):\\n",b)\n# 分别看看每一个平面的构成\nprint("b的每一个平面的构成：\\n")\nprint(b[:, :, 0])\nprint(b[:, :, 1])\nprint(b[:, :, 2])\nprint(b[:, :, 3])\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 运行结果\n\na的维度:\n 1\nb(也是三维数组):\n [[[ 0  1  2  3]\n  [ 4  5  6  7]\n  [ 8  9 10 11]]\n\n [[12 13 14 15]\n  [16 17 18 19]\n  [20 21 22 23]]]\nb的每一个平面的构成：\n\n[[ 0  4  8]\n [12 16 20]]\n[[ 1  5  9]\n [13 17 21]]\n[[ 2  6 10]\n [14 18 22]]\n[[ 3  7 11]\n [15 19 23]]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n',charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"Numpy中花式索引和shape用法",frontmatter:{title:"Numpy中花式索引和shape用法",date:"2018-08-20T16:33:09.000Z",description:"对矩阵或者数组的花式索引，以及shape的用法",categories:"Python-机器学习",tags:["Numpy","Python"],keywords:"Python,Numpy",permalink:"/pages/92372b/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/02.Python-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/07.Numpy%E4%B8%AD%E8%8A%B1%E5%BC%8F%E7%B4%A2%E5%BC%95%E5%92%8Cshape%E7%94%A8%E6%B3%95.html",relativePath:"02.Python/02.Python-机器学习/07.Numpy中花式索引和shape用法.md",key:"v-7ae93e1c",path:"/pages/92372b/",headers:[{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:24},{level:2,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:398},{level:2,title:"代码",slug:"代码-2",normalizedTitle:"代码",charIndex:24},{level:2,title:"运行结果",slug:"运行结果-2",normalizedTitle:"运行结果",charIndex:398}],headersStr:"代码 运行结果 代码 运行结果",content:'总结一下最近学习中容易出现问题的地方️\n\n\n# 代码\n\nfrom numpy import *\n\nrandMat = random.randint(0, 10, (4, 3))\nprint("原矩阵:\\n", randMat)\n# 索引从0开始计数\nprint("输出第一行的所有数据:\\n", randMat[0, :])\nprint("输出第二列的所有数据:\\n", randMat[:, 1])\nprint("输出矩阵第1和第3行的所有数据:\\n", randMat[[0, 2], :])\nprint("行数:\\n",randMat.shape[0])\nprint("列数:\\n",randMat.shape[1])\nprint("维数:\\n",randMat.shape)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 运行结果\n\n原矩阵:\n [[3 5 1]\n [1 3 0]\n [0 2 1]\n [0 2 9]]\n输出第一行的所有数据:\n [3 5 1]\n输出第二列的所有数据:\n [5 3 2 2]\n输出矩阵第1和第3行的所有数据:\n [[3 5 1]\n [0 2 1]]\n行数:\n 4\n列数:\n 3\n维数:\n (4, 3)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n提示\n\n2018年8月22日 21:40:54更新，新增：使用shape和reshape调整数组大小\n\n\n# 代码\n\nimport numpy as np\na = np.array([[1,2,3],[4,5,6]]) \na.shape = (3,2)\nb = a.reshape(2,3)\nprint(a)\nprint(b)\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 运行结果\n\n[[1 2]\n [3 4]\n [5 6]]\n[[1 2 3]\n [4 5 6]]\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n',normalizedContent:'总结一下最近学习中容易出现问题的地方️\n\n\n# 代码\n\nfrom numpy import *\n\nrandmat = random.randint(0, 10, (4, 3))\nprint("原矩阵:\\n", randmat)\n# 索引从0开始计数\nprint("输出第一行的所有数据:\\n", randmat[0, :])\nprint("输出第二列的所有数据:\\n", randmat[:, 1])\nprint("输出矩阵第1和第3行的所有数据:\\n", randmat[[0, 2], :])\nprint("行数:\\n",randmat.shape[0])\nprint("列数:\\n",randmat.shape[1])\nprint("维数:\\n",randmat.shape)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 运行结果\n\n原矩阵:\n [[3 5 1]\n [1 3 0]\n [0 2 1]\n [0 2 9]]\n输出第一行的所有数据:\n [3 5 1]\n输出第二列的所有数据:\n [5 3 2 2]\n输出矩阵第1和第3行的所有数据:\n [[3 5 1]\n [0 2 1]]\n行数:\n 4\n列数:\n 3\n维数:\n (4, 3)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n提示\n\n2018年8月22日 21:40:54更新，新增：使用shape和reshape调整数组大小\n\n\n# 代码\n\nimport numpy as np\na = np.array([[1,2,3],[4,5,6]]) \na.shape = (3,2)\nb = a.reshape(2,3)\nprint(a)\nprint(b)\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 运行结果\n\n[[1 2]\n [3 4]\n [5 6]]\n[[1 2 3]\n [4 5 6]]\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n',charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"turtle绘图库",frontmatter:{title:"turtle绘图库",date:"2018-08-08T17:11:18.000Z",description:"使用绘图库绘制图形",categories:["Python-机器学习"],tags:["Python库"],permalink:"/pages/0779b1/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/02.Python-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/08.turtle%E7%BB%98%E5%9B%BE%E5%BA%93.html",relativePath:"02.Python/02.Python-机器学习/08.turtle绘图库.md",key:"v-3c0e1bb9",path:"/pages/0779b1/",headers:[{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:44},{level:2,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:767},{level:2,title:"代码",slug:"代码-2",normalizedTitle:"代码",charIndex:44},{level:2,title:"运行结果",slug:"运行结果-2",normalizedTitle:"运行结果",charIndex:767}],headersStr:"代码 运行结果 代码 运行结果",content:'大概学习了下turtle库的一个绘图实例= =，估计以后也用不上这个库....\n\n\n# 代码\n\n实例1：\n\n绘制一条小蛇\n\nimport turtle  # 绘图库\n\n# 绘制一条小蛇\n# 设置窗体大小及位置，但并不是必须的，依次长,宽，如果后两项不设置，则默认正中心\nturtle.setup(650, 350, 200, 200)\n# 抬起画笔\nturtle.penup()\n# turtle.fd表示向海龟的右边走，turtle.bk表示向海龟的左边走\nturtle.fd(-250)\n# 下笔\nturtle.pendown()\n# 设置画笔宽度\nturtle.pensize(25)\n# 设置画笔颜色\nturtle.pencolor("purple")\n# 改变当前行径的方向，原地转向的意思，参数为绝对角度\n# turtle.left和turtle.right表示向左边或右边改变角度\nturtle.seth(-40)\nfor i in range(4):\n    # circle表示以某一个点为圆心，向左侧运行\n    turtle.circle(40, 80)\n    turtle.circle(-40, 80)\nturtle.circle(40, 80 / 2)\nturtle.fd(40)\nturtle.circle(16, 100)\nturtle.fd(40 * 2 / 3)\nturtle.done()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 运行结果\n\n\n\n\n# 代码\n\n实例2：绘制一个Z\n\nimport turtle\n\nturtle.left(45)  # 转角度\nturtle.fd(150)  # 前进\nturtle.right(135)\nturtle.fd(300)\nturtle.left(135)\nturtle.fd(150)\nturtle.done()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 运行结果\n\n',normalizedContent:'大概学习了下turtle库的一个绘图实例= =，估计以后也用不上这个库....\n\n\n# 代码\n\n实例1：\n\n绘制一条小蛇\n\nimport turtle  # 绘图库\n\n# 绘制一条小蛇\n# 设置窗体大小及位置，但并不是必须的，依次长,宽，如果后两项不设置，则默认正中心\nturtle.setup(650, 350, 200, 200)\n# 抬起画笔\nturtle.penup()\n# turtle.fd表示向海龟的右边走，turtle.bk表示向海龟的左边走\nturtle.fd(-250)\n# 下笔\nturtle.pendown()\n# 设置画笔宽度\nturtle.pensize(25)\n# 设置画笔颜色\nturtle.pencolor("purple")\n# 改变当前行径的方向，原地转向的意思，参数为绝对角度\n# turtle.left和turtle.right表示向左边或右边改变角度\nturtle.seth(-40)\nfor i in range(4):\n    # circle表示以某一个点为圆心，向左侧运行\n    turtle.circle(40, 80)\n    turtle.circle(-40, 80)\nturtle.circle(40, 80 / 2)\nturtle.fd(40)\nturtle.circle(16, 100)\nturtle.fd(40 * 2 / 3)\nturtle.done()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 运行结果\n\n\n\n\n# 代码\n\n实例2：绘制一个z\n\nimport turtle\n\nturtle.left(45)  # 转角度\nturtle.fd(150)  # 前进\nturtle.right(135)\nturtle.fd(300)\nturtle.left(135)\nturtle.fd(150)\nturtle.done()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 运行结果\n\n',charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"第一个使用Tensorflow的程序",frontmatter:{title:"第一个使用Tensorflow的程序",date:"2018-08-24T21:41:52.000Z",description:"简单的创建第一个TensorFlow程序",categories:"Python-机器学习",tags:["Tensorflow","Python","机器学习"],permalink:"/pages/6cd0c4/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/02.Python-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/09.%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%BD%BF%E7%94%A8Tensorflow%E7%9A%84%E7%A8%8B%E5%BA%8F.html",relativePath:"02.Python/02.Python-机器学习/09.第一个使用Tensorflow的程序.md",key:"v-56e20f8a",path:"/pages/6cd0c4/",headers:[{level:3,title:"构建图",slug:"构建图",normalizedTitle:"构建图",charIndex:2},{level:3,title:"在一个会话中启动图",slug:"在一个会话中启动图",normalizedTitle:"在一个会话中启动图",charIndex:303},{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:383},{level:2,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:1390}],headersStr:"构建图 在一个会话中启动图 代码 运行结果",content:"# 构建图\n\n构建图的第一步, 是创建源 op (source op). 源 op 不需要任何输入, 例如 常量 (Constant). 源 op 的输出被传递给其它 op 做运算.\n\nPython 库中, op 构造器的返回值代表被构造出的 op 的输出, 这些返回值可以传递给其它 op 构造器作为输入.\n\nTensorFlow Python 库有一个默认图 (default graph), op 构造器可以为其增加节点\n\n默认图现在有三个节点, 两个constant()op, 和一个matmul()op. 为了真正进行矩阵相乘运算, 并得到矩阵乘法的 结果, 你必须在会话里启动这个图.\n\n\n# 在一个会话中启动图\n\n构造阶段完成后, 才能启动图. 启动图的第一步是创建一个 Session 对象, 如果无任何创建参数, 会话构造器将启动默认图.\n\n\n# 代码\n\nimport tensorflow as tf\n\n# op称为图的节点\n# 创建一个常量op，产生一个1x2矩阵，这个op被作为一个节点\n# 加到默认图中\n# 构造器的返回值代表该常量op的返回值\nmatrix1 = tf.constant([[3., 3.]])\n\n# 创建另一个常量op，产生一个 2x1矩阵\nmatrix2 = tf.constant([[2.], [2.]])\n\n# 创建一个矩阵乘法 matmul op , 把 'matrix1' 和 'matrix2' 作为输入.\n# 返回值 'product' 代表矩阵乘法的结果.\n'''\n默认图现在有三个节点, 两个 constant() op, 和一个matmul() op. 为了真正进行矩阵相乘运算, 并得到矩阵乘法的 结果, 你必须在会话里启动这个图.\n'''\nproduct = tf.matmul(matrix1, matrix2)\n\n# 启动默认图.\nsess = tf.Session()\n\n# 调用 sess 的 'run()' 方法来执行矩阵乘法 op, 传入 'product' 作为该方法的参数.\n# 上面提到, 'product' 代表了矩阵乘法 op 的输出, 传入它是向方法表明, 我们希望取回\n# 矩阵乘法 op 的输出.\n#\n# 整个执行过程是自动化的, 会话负责传递 op 所需的全部输入. op 通常是并发执行的.\n#\n# 函数调用 'run(product)' 触发了图中三个 op (两个常量 op 和一个矩阵乘法 op) 的执行.\n#\n# 返回值 'result' 是一个 numpy `ndarray` 对象.\nresult = sess.run(product)\nprint(result)\n# ==> [[ 12.]]\n\n# 任务完成, 关闭会话.\nsess.close()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# 运行结果\n\n[[12.]]\n\n\n1\n\n1\n",normalizedContent:"# 构建图\n\n构建图的第一步, 是创建源 op (source op). 源 op 不需要任何输入, 例如 常量 (constant). 源 op 的输出被传递给其它 op 做运算.\n\npython 库中, op 构造器的返回值代表被构造出的 op 的输出, 这些返回值可以传递给其它 op 构造器作为输入.\n\ntensorflow python 库有一个默认图 (default graph), op 构造器可以为其增加节点\n\n默认图现在有三个节点, 两个constant()op, 和一个matmul()op. 为了真正进行矩阵相乘运算, 并得到矩阵乘法的 结果, 你必须在会话里启动这个图.\n\n\n# 在一个会话中启动图\n\n构造阶段完成后, 才能启动图. 启动图的第一步是创建一个 session 对象, 如果无任何创建参数, 会话构造器将启动默认图.\n\n\n# 代码\n\nimport tensorflow as tf\n\n# op称为图的节点\n# 创建一个常量op，产生一个1x2矩阵，这个op被作为一个节点\n# 加到默认图中\n# 构造器的返回值代表该常量op的返回值\nmatrix1 = tf.constant([[3., 3.]])\n\n# 创建另一个常量op，产生一个 2x1矩阵\nmatrix2 = tf.constant([[2.], [2.]])\n\n# 创建一个矩阵乘法 matmul op , 把 'matrix1' 和 'matrix2' 作为输入.\n# 返回值 'product' 代表矩阵乘法的结果.\n'''\n默认图现在有三个节点, 两个 constant() op, 和一个matmul() op. 为了真正进行矩阵相乘运算, 并得到矩阵乘法的 结果, 你必须在会话里启动这个图.\n'''\nproduct = tf.matmul(matrix1, matrix2)\n\n# 启动默认图.\nsess = tf.session()\n\n# 调用 sess 的 'run()' 方法来执行矩阵乘法 op, 传入 'product' 作为该方法的参数.\n# 上面提到, 'product' 代表了矩阵乘法 op 的输出, 传入它是向方法表明, 我们希望取回\n# 矩阵乘法 op 的输出.\n#\n# 整个执行过程是自动化的, 会话负责传递 op 所需的全部输入. op 通常是并发执行的.\n#\n# 函数调用 'run(product)' 触发了图中三个 op (两个常量 op 和一个矩阵乘法 op) 的执行.\n#\n# 返回值 'result' 是一个 numpy `ndarray` 对象.\nresult = sess.run(product)\nprint(result)\n# ==> [[ 12.]]\n\n# 任务完成, 关闭会话.\nsess.close()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# 运行结果\n\n[[12.]]\n\n\n1\n\n1\n",charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"将下载下来的MNIST手写数字数据集转化成为图片",frontmatter:{title:"将下载下来的MNIST手写数字数据集转化成为图片",date:"2018-08-26T20:32:57.000Z",description:"MNIST数据集",categories:"Python-机器学习",tags:["Python","机器学习"],keywords:"机器学习,Python,MNIST",permalink:"/pages/8b335a/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/02.Python-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/10.%E5%B0%86%E4%B8%8B%E8%BD%BD%E4%B8%8B%E6%9D%A5%E7%9A%84MNIST%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E6%95%B0%E6%8D%AE%E9%9B%86%E8%BD%AC%E5%8C%96%E6%88%90%E4%B8%BA%E5%9B%BE%E7%89%87.html",relativePath:"02.Python/02.Python-机器学习/10.将下载下来的MNIST手写数字数据集转化成为图片.md",key:"v-b704fa22",path:"/pages/8b335a/",headers:[{level:2,title:"对于训练集的代码",slug:"对于训练集的代码",normalizedTitle:"对于训练集的代码",charIndex:60},{level:2,title:"对于测试集的代码",slug:"对于测试集的代码",normalizedTitle:"对于测试集的代码",charIndex:1795}],headersStr:"对于训练集的代码 对于测试集的代码",content:"解析源文件下载（总共包含60000个训练数据和10000个测试数据）\n\n 1. 训练集解析\n 2. 测试集解析\n\n\n# 对于训练集的代码\n\nimport numpy as np\nimport struct\n\nfrom PIL import Image\nimport os\n\ndata_file = 'MNIST_data\\\\train-images.idx3-ubyte'  # 需要修改的路径\n# It's 47040016B, but we should set to 47040000B\ndata_file_size = 47040016\ndata_file_size = str(data_file_size - 16) + 'B'\n\ndata_buf = open(data_file, 'rb').read()\n\nmagic, numImages, numRows, numColumns = struct.unpack_from(\n    '>IIII', data_buf, 0)\ndatas = struct.unpack_from(\n    '>' + data_file_size, data_buf, struct.calcsize('>IIII'))\ndatas = np.array(datas).astype(np.uint8).reshape(\n    numImages, 1, numRows, numColumns)\n\nlabel_file = 'MNIST_data\\\\train-labels.idx1-ubyte'  # 需要修改的路径\n\n# It's 60008B, but we should set to 60000B\nlabel_file_size = 60008\nlabel_file_size = str(label_file_size - 8) + 'B'\n\nlabel_buf = open(label_file, 'rb').read()\n\nmagic, numLabels = struct.unpack_from('>II', label_buf, 0)\nlabels = struct.unpack_from(\n    '>' + label_file_size, label_buf, struct.calcsize('>II'))\nlabels = np.array(labels).astype(np.int64)\n\ndatas_root = 'MNIST_data\\\\'  # 需要修改的路径\nif not os.path.exists(datas_root):\n    os.mkdir(datas_root)\n\nfor i in range(10):\n    file_name = datas_root + os.sep + str(i)\n    if not os.path.exists(file_name):\n        os.mkdir(file_name)\n\nfor ii in range(numLabels):\n    img = Image.fromarray(datas[ii, 0, 0:28, 0:28])\n    label = labels[ii]\n    file_name = datas_root + os.sep + str(label) + os.sep + \\\n                'mnist_train_' + str(ii) + '.png'\n    img.save(file_name)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n# 对于测试集的代码\n\nimport numpy as np\nimport struct\n\nfrom PIL import Image\nimport os\n\ndata_file = 'MNIST_data\\\\t10k-images.idx3-ubyte'  # 需要修改的路径\n\n# It's 7840016B, but we should set to 7840000B\ndata_file_size = 7840016\ndata_file_size = str(data_file_size - 16) + 'B'\n\ndata_buf = open(data_file, 'rb').read()\n\nmagic, numImages, numRows, numColumns = struct.unpack_from(\n    '>IIII', data_buf, 0)\ndatas = struct.unpack_from(\n    '>' + data_file_size, data_buf, struct.calcsize('>IIII'))\ndatas = np.array(datas).astype(np.uint8).reshape(\n    numImages, 1, numRows, numColumns)\n\nlabel_file = 'MNIST_data\\\\t10k-labels.idx1-ubyte'  # 需要修改的路径\n\n# It's 10008B, but we should set to 10000B\nlabel_file_size = 10008\nlabel_file_size = str(label_file_size - 8) + 'B'\n\nlabel_buf = open(label_file, 'rb').read()\n\nmagic, numLabels = struct.unpack_from('>II', label_buf, 0)\nlabels = struct.unpack_from(\n    '>' + label_file_size, label_buf, struct.calcsize('>II'))\nlabels = np.array(labels).astype(np.int64)\n\ndatas_root = 'MNIST_data\\\\test_dataset'  # 需要修改的路径\n\nif not os.path.exists(datas_root):\n    os.mkdir(datas_root)\n\nfor i in range(10):\n    file_name = datas_root + os.sep + str(i)\n    if not os.path.exists(file_name):\n        os.mkdir(file_name)\n\nfor ii in range(numLabels):\n    img = Image.fromarray(datas[ii, 0, 0:28, 0:28])\n    label = labels[ii]\n    file_name = datas_root + os.sep + str(label) + os.sep + \\\n                'mnist_test_' + str(ii) + '.png'\n    img.save(file_name)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n",normalizedContent:"解析源文件下载（总共包含60000个训练数据和10000个测试数据）\n\n 1. 训练集解析\n 2. 测试集解析\n\n\n# 对于训练集的代码\n\nimport numpy as np\nimport struct\n\nfrom pil import image\nimport os\n\ndata_file = 'mnist_data\\\\train-images.idx3-ubyte'  # 需要修改的路径\n# it's 47040016b, but we should set to 47040000b\ndata_file_size = 47040016\ndata_file_size = str(data_file_size - 16) + 'b'\n\ndata_buf = open(data_file, 'rb').read()\n\nmagic, numimages, numrows, numcolumns = struct.unpack_from(\n    '>iiii', data_buf, 0)\ndatas = struct.unpack_from(\n    '>' + data_file_size, data_buf, struct.calcsize('>iiii'))\ndatas = np.array(datas).astype(np.uint8).reshape(\n    numimages, 1, numrows, numcolumns)\n\nlabel_file = 'mnist_data\\\\train-labels.idx1-ubyte'  # 需要修改的路径\n\n# it's 60008b, but we should set to 60000b\nlabel_file_size = 60008\nlabel_file_size = str(label_file_size - 8) + 'b'\n\nlabel_buf = open(label_file, 'rb').read()\n\nmagic, numlabels = struct.unpack_from('>ii', label_buf, 0)\nlabels = struct.unpack_from(\n    '>' + label_file_size, label_buf, struct.calcsize('>ii'))\nlabels = np.array(labels).astype(np.int64)\n\ndatas_root = 'mnist_data\\\\'  # 需要修改的路径\nif not os.path.exists(datas_root):\n    os.mkdir(datas_root)\n\nfor i in range(10):\n    file_name = datas_root + os.sep + str(i)\n    if not os.path.exists(file_name):\n        os.mkdir(file_name)\n\nfor ii in range(numlabels):\n    img = image.fromarray(datas[ii, 0, 0:28, 0:28])\n    label = labels[ii]\n    file_name = datas_root + os.sep + str(label) + os.sep + \\\n                'mnist_train_' + str(ii) + '.png'\n    img.save(file_name)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n# 对于测试集的代码\n\nimport numpy as np\nimport struct\n\nfrom pil import image\nimport os\n\ndata_file = 'mnist_data\\\\t10k-images.idx3-ubyte'  # 需要修改的路径\n\n# it's 7840016b, but we should set to 7840000b\ndata_file_size = 7840016\ndata_file_size = str(data_file_size - 16) + 'b'\n\ndata_buf = open(data_file, 'rb').read()\n\nmagic, numimages, numrows, numcolumns = struct.unpack_from(\n    '>iiii', data_buf, 0)\ndatas = struct.unpack_from(\n    '>' + data_file_size, data_buf, struct.calcsize('>iiii'))\ndatas = np.array(datas).astype(np.uint8).reshape(\n    numimages, 1, numrows, numcolumns)\n\nlabel_file = 'mnist_data\\\\t10k-labels.idx1-ubyte'  # 需要修改的路径\n\n# it's 10008b, but we should set to 10000b\nlabel_file_size = 10008\nlabel_file_size = str(label_file_size - 8) + 'b'\n\nlabel_buf = open(label_file, 'rb').read()\n\nmagic, numlabels = struct.unpack_from('>ii', label_buf, 0)\nlabels = struct.unpack_from(\n    '>' + label_file_size, label_buf, struct.calcsize('>ii'))\nlabels = np.array(labels).astype(np.int64)\n\ndatas_root = 'mnist_data\\\\test_dataset'  # 需要修改的路径\n\nif not os.path.exists(datas_root):\n    os.mkdir(datas_root)\n\nfor i in range(10):\n    file_name = datas_root + os.sep + str(i)\n    if not os.path.exists(file_name):\n        os.mkdir(file_name)\n\nfor ii in range(numlabels):\n    img = image.fromarray(datas[ii, 0, 0:28, 0:28])\n    label = labels[ii]\n    file_name = datas_root + os.sep + str(label) + os.sep + \\\n                'mnist_test_' + str(ii) + '.png'\n    img.save(file_name)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n",charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"Tensorflow交互式使用",frontmatter:{title:"Tensorflow交互式使用",date:"2018-08-26T16:52:59.000Z",categories:"Python-机器学习",tags:["Tensorflow","Python","机器学习"],keywords:"机器学习,Python,Tensorflow",permalink:"/pages/b8d563/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/02.Python-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/11.Tensorflow%E4%BA%A4%E4%BA%92%E5%BC%8F%E4%BD%BF%E7%94%A8.html",relativePath:"02.Python/02.Python-机器学习/11.Tensorflow交互式使用.md",key:"v-e814cfd8",path:"/pages/b8d563/",headers:[{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:211},{level:2,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:559}],headersStr:"代码 运行结果",content:"文档中的 Python 示例使用一个会话 Session 来 启动图, 并调用 Session.run() 方法执行操作.\n\n为了便于使用诸如 IPython 之类的 Python 交互环境, 可以使用 InteractiveSession代替 Session 类, 使用 Tensor.eval() 和 Operation.run() 方法代替Session.run(). 这样可以避免使用一个变量来持有会话.\n\n\n# 代码\n\n# 进入一个交互式TensorFlow会话\nimport tensorflow as tf\nsess = tf.InteractiveSession()\n\nx = tf.Variable([1.0,2.0])\na = tf.constant([3.0,3.0])\n\n# 使用初始化器 initializer op 的run()方法初始化'x'\nx.initializer.run()\n\n# 增加一个减法subtract op，从'x'减去'a'，运行减法op，输出结果\nsub = tf.subtract(x,a)\nprint(sub.eval())\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 运行结果\n\n[-2. -1.]\n\n\n1\n\n1\n",normalizedContent:"文档中的 python 示例使用一个会话 session 来 启动图, 并调用 session.run() 方法执行操作.\n\n为了便于使用诸如 ipython 之类的 python 交互环境, 可以使用 interactivesession代替 session 类, 使用 tensor.eval() 和 operation.run() 方法代替session.run(). 这样可以避免使用一个变量来持有会话.\n\n\n# 代码\n\n# 进入一个交互式tensorflow会话\nimport tensorflow as tf\nsess = tf.interactivesession()\n\nx = tf.variable([1.0,2.0])\na = tf.constant([3.0,3.0])\n\n# 使用初始化器 initializer op 的run()方法初始化'x'\nx.initializer.run()\n\n# 增加一个减法subtract op，从'x'减去'a'，运行减法op，输出结果\nsub = tf.subtract(x,a)\nprint(sub.eval())\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 运行结果\n\n[-2. -1.]\n\n\n1\n\n1\n",charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"使用k-近邻算法改进约会网站的配对效果",frontmatter:{title:"使用k-近邻算法改进约会网站的配对效果",date:"2018-08-11T11:47:52.000Z",categories:"Python-机器学习",tags:["k-近邻算法","Python","机器学习","matplotlib"],permalink:"/pages/a76d65/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/02.Python-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/12.%E4%BD%BF%E7%94%A8k-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95%E6%94%B9%E8%BF%9B%E7%BA%A6%E4%BC%9A%E7%BD%91%E7%AB%99%E7%9A%84%E9%85%8D%E5%AF%B9%E6%95%88%E6%9E%9C.html",relativePath:"02.Python/02.Python-机器学习/12.使用k-近邻算法改进约会网站的配对效果.md",key:"v-5b727396",path:"/pages/a76d65/",headers:[{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:258},{level:2,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:2749},{level:2,title:"运行结果",slug:"运行结果-2",normalizedTitle:"运行结果",charIndex:2749}],headersStr:"代码 运行结果 运行结果",content:"实例：在约会网站上使用k-近邻算法\n\n(1) 收集数据: 提供文本文件。 (2) 准备数据: 使用python解析文本文件。 (3) 分析数据: 使用 Matplotlib画二维扩散图 。 (4) 训练算法: 此步驟不适用于k-近邻算法。 (5) 测试算法: 使用海伦提供的部分数据作为测试样本。 测试样本和非测试样本的区别在于：测试样本是已经完成分类的数据，如果预测分类与实际类别不同，则标记为一个错误。 (6) 使用算法: 产生简单的命令行程序，然后可以输入一些特征数据以判断对方是否为自己喜欢的类型。\n\n\n# 代码\n\nfrom numpy import *\nimport operator\nimport matplotlib\nimport matplotlib.pyplot as plt\n\ndef createDateSet():\n    group = array([[1.0, 1.1], [1.0, 1.0], [0, 0], [0, 0.1]])\n    labels = ['A', 'A', 'B', 'B']\n    return group, labels\n\n\n'''\n 用于分类的输人向量是inX，\n 输入的训练样本集为dataSet,\n 标签向量为labels\n 最后的参数k表示用于选择最近邻居的数目，\n 其中标签向量的元素数目和矩阵dataSet的行数相同\n'''\n\n\ndef classify0(inX, dataSet, labels, k):\n    dataSetSize = dataSet.shape[0]\n    # 距离计算\n    diffMat = tile(inX, (dataSetSize, 1)) - dataSet\n    sqDiffMat = diffMat ** 2\n    sqDistances = sqDiffMat.sum(axis=1)\n    distances = sqDistances ** 0.5\n    sortedDistIndicies = distances.argsort()\n    classCount = {}\n    # 选择距离最小的k个点\n    for i in range(k):\n        votellabel = labels[sortedDistIndicies[i]]\n        classCount[votellabel] = classCount.get(votellabel, 0) + 1\n    # 排序\n    sortedClassCount = sorted(classCount.items(), key=operator.itemgetter(1), reverse=True)\n    return sortedClassCount[0][0]\n\n# 将文本记录转换到Numpy的解析程序\ndef file2matrix(filename):\n    fr = open(filename)\n    arrayOLines = fr.readlines()\n    # 得到文件行数\n    numberOfLines = len(arrayOLines)\n    # 创建返回的Numpy矩阵，将该矩阵的另一维度设置为3\n    returnMat = zeros((numberOfLines, 3))\n    classLabelVector = []\n    index = 0\n    # 解析文件数据到列表，循环处理每行数据\n    for line in arrayOLines:\n        # 截取掉所有的回车字符\n        line = line.strip()\n        # 使用tab字符\\t将上一步得到的整行数据分割成一个元素列表\n        listFromLine = line.split('\\t')\n        # 选取前3个元素，将他们存储到特征矩阵中\n        returnMat[index, :] = listFromLine[0:3]\n        # -1表示列表中的最后一列元素，将最后一列元素存储到向量classLabelVector中\n        classLabelVector.append(int(listFromLine[-1]))\n        index += 1\n    return returnMat, classLabelVector\n\ndatingDataMat, datingLabels = file2matrix('datingTestSet2.txt')\nprint(\"array:\\n\", datingDataMat)\nprint(\"datingLabels[0:20]\\n\", datingLabels[0:20])\n\n# 绘制散点图\n# 定义figure\nfig = plt.figure()\n#add_subplot()返回一个axes对象，里面的参数abc表示在一个figure窗口中，有a行b列个小窗口，然后本次plot在第c个窗口中。\nax = fig.add_subplot(111)\n# 设置颜色和散点图数据\nax.scatter(datingDataMat[:, 1], datingDataMat[:, 2], 15.0 * array(datingLabels), 15.0 * array(datingLabels))\nplt.show()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n\n数据集\n\n\n# 运行结果\n\narray:\n [[  4.09200000e+04   8.32697600e+00   9.53952000e-01]\n [  1.44880000e+04   7.15346900e+00   1.67390400e+00]\n [  2.60520000e+04   1.44187100e+00   8.05124000e-01]\n ..., \n [  2.65750000e+04   1.06501020e+01   8.66627000e-01]\n [  4.81110000e+04   9.13452800e+00   7.28045000e-01]\n [  4.37570000e+04   7.88260100e+00   1.33244600e+00]]\ndatingLabels[0:20]\n [3, 2, 1, 1, 1, 1, 3, 3, 1, 3, 1, 1, 2, 1, 1, 1, 1, 1, 2, 3]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n散点图结果：\n\n\n\n提示\n\n2018年8月11日 16:49:36 新增：归一化特征值，测试代码，预测代码\n\n因为在欧氏距离中数值差值最大的属性对计算结果的影响最大，但其实多个特征都是同等重要的属性，这样如果其中一个占的权重过大，会严重影响到计算的结果\n\n所以在处理不同取值范围的特征值的时候，我们通常采用的方法是将数值归一化，如将取值范围处理为0到1或者-1到1之间。\n\n公式：newValue = （oldValue - min）/（max - min）\n\n其中min和max分别是数据集中的最小特征值和最大特征值。虽然改变数值取值范围增加了分类器的复杂度，但为了得到准确的结果，这样做是必然的\n\n# 将数字特征值转化为0到1的区间\ndef autoNorm(dataSet):\n    # 将每列的最小值放在变量minVals中，dataSet.min(0)中的参数0使得函数可以从列中选取最小值\n    minVals = dataSet.min(0)\n    # 将每列的最大值放在变量maxVals中\n    maxVals = dataSet.max(0)\n    ranges = maxVals - minVals\n    normDataSet = zeros(shape(dataSet))\n    m = dataSet.shape[0]\n    # 为了归一化特征值，必须使用当前值减去最小值，然后除以取值范围\n    # tile()函数将变量内容复制成输入矩阵同样大小的矩阵\n    normDataSet = dataSet - tile(minVals, (m, 1))\n    # 特征值相除\n    normDataSet = normDataSet / tile(ranges, (m, 1))\n    return normDataSet, ranges, minVals\n\n\n# 分类器针对约会网站的测试代码\ndef datingClassTest():\n    hoRatio = 0.10\n    # 首先使用file2matrix和autoNorm()函数从文件中读取数据并将其转换为归一化特征值\n    datingDataMat, datingLabels = file2matrix('datingTestSet2.txt')\n    normMat, ranges, minVals = autoNorm(datingDataMat)\n    # 计算测试向量的数量，决定normMat向量中哪些数据用于测试，哪些数据用于分类器的训练样本\n    m = normMat.shape[0]\n    numTestVecs = int(m * hoRatio)\n    errorCount = 0.0\n    # 将两部分数据输入到原始分类器函数classify0\n    for i in range(numTestVecs):\n        classifierResult = classify0(normMat[i, :], normMat[numTestVecs:m, :], \\\n                                     datingLabels[numTestVecs:m], 3)\n        print(\"the classifier came back with:{},the real answer is:{}\".format(classifierResult, datingLabels[i]))\n        if (classifierResult != datingLabels[i]):\n            errorCount += 1.0\n    # 计算错误率并输出结果\n    print(\"the total error rate is:{}\".format(errorCount / float(numTestVecs)))\n\n\n# 约会网站预测函数\ndef classifyPerson():\n    resultList = ['not at all', 'in small doses', 'in large doses']\n    percentTats = float(input( \\\n        \"percentage of time spent playing video games?\"))\n    ffMiles = float(input(\"frequent flier miles earned per year?\"))\n    iceCream = float(input(\"liters of ice cream consumed per year?\"))\n    datingDataMat, datingLabels = file2matrix('datingTestSet2.txt')\n    normMat, ranges, minVals = autoNorm(datingDataMat)\n    inArr = array([ffMiles, percentTats, iceCream])\n    classifierResult = classify0((inArr - \\\n                                  minVals) / ranges, normMat, datingLabels, 3)\n    print(\"You will probably like this person:\", \\\n          resultList[classifierResult - 1])\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\n测试归一化特征值、分类器、选择喜欢的人：\n\n# 测试归一化特征值\nnormMat, ranges, minVals = autoNorm(datingDataMat)\nprint(\"array:\\n\", normMat)\nprint(\"array:\", ranges)\nprint(\"array:\", minVals)\n# 测试分类器\ndatingClassTest()\n# 选择喜欢的人\nclassifyPerson()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 运行结果\n\n# normMat\narray:\n [[ 0.44832535  0.39805139  0.56233353]\n [ 0.15873259  0.34195467  0.98724416]\n [ 0.28542943  0.06892523  0.47449629]\n ..., \n [ 0.29115949  0.50910294  0.51079493]\n [ 0.52711097  0.43665451  0.4290048 ]\n [ 0.47940793  0.3768091   0.78571804]]\n# ranges\narray: [  9.12730000e+04   2.09193490e+01   1.69436100e+00]\n# minVals\narray: [ 0.        0.        0.001156]\n# 测试分类器(数据太多了这里截取部分)\nthe classifier came back with:3,the real answer is:3\nthe classifier came back with:2,the real answer is:2\n......\nthe classifier came back with:2,the real answer is:2\nthe classifier came back with:1,the real answer is:1\nthe classifier came back with:3,the real answer is:1\n# 分类器处理约会数据集的错误率为5%（书上为2.4%....不知道怎么回事）\nthe total error rate is:0.05\n# 输入各个属性，得到最佳约会伙伴\npercentage of time spent playing video games?10\nfrequent flier miles earned per year?10000\nliters of ice cream consumed per year?0.5\nYou will probably like this person: in small doses\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n",normalizedContent:"实例：在约会网站上使用k-近邻算法\n\n(1) 收集数据: 提供文本文件。 (2) 准备数据: 使用python解析文本文件。 (3) 分析数据: 使用 matplotlib画二维扩散图 。 (4) 训练算法: 此步驟不适用于k-近邻算法。 (5) 测试算法: 使用海伦提供的部分数据作为测试样本。 测试样本和非测试样本的区别在于：测试样本是已经完成分类的数据，如果预测分类与实际类别不同，则标记为一个错误。 (6) 使用算法: 产生简单的命令行程序，然后可以输入一些特征数据以判断对方是否为自己喜欢的类型。\n\n\n# 代码\n\nfrom numpy import *\nimport operator\nimport matplotlib\nimport matplotlib.pyplot as plt\n\ndef createdateset():\n    group = array([[1.0, 1.1], [1.0, 1.0], [0, 0], [0, 0.1]])\n    labels = ['a', 'a', 'b', 'b']\n    return group, labels\n\n\n'''\n 用于分类的输人向量是inx，\n 输入的训练样本集为dataset,\n 标签向量为labels\n 最后的参数k表示用于选择最近邻居的数目，\n 其中标签向量的元素数目和矩阵dataset的行数相同\n'''\n\n\ndef classify0(inx, dataset, labels, k):\n    datasetsize = dataset.shape[0]\n    # 距离计算\n    diffmat = tile(inx, (datasetsize, 1)) - dataset\n    sqdiffmat = diffmat ** 2\n    sqdistances = sqdiffmat.sum(axis=1)\n    distances = sqdistances ** 0.5\n    sorteddistindicies = distances.argsort()\n    classcount = {}\n    # 选择距离最小的k个点\n    for i in range(k):\n        votellabel = labels[sorteddistindicies[i]]\n        classcount[votellabel] = classcount.get(votellabel, 0) + 1\n    # 排序\n    sortedclasscount = sorted(classcount.items(), key=operator.itemgetter(1), reverse=true)\n    return sortedclasscount[0][0]\n\n# 将文本记录转换到numpy的解析程序\ndef file2matrix(filename):\n    fr = open(filename)\n    arrayolines = fr.readlines()\n    # 得到文件行数\n    numberoflines = len(arrayolines)\n    # 创建返回的numpy矩阵，将该矩阵的另一维度设置为3\n    returnmat = zeros((numberoflines, 3))\n    classlabelvector = []\n    index = 0\n    # 解析文件数据到列表，循环处理每行数据\n    for line in arrayolines:\n        # 截取掉所有的回车字符\n        line = line.strip()\n        # 使用tab字符\\t将上一步得到的整行数据分割成一个元素列表\n        listfromline = line.split('\\t')\n        # 选取前3个元素，将他们存储到特征矩阵中\n        returnmat[index, :] = listfromline[0:3]\n        # -1表示列表中的最后一列元素，将最后一列元素存储到向量classlabelvector中\n        classlabelvector.append(int(listfromline[-1]))\n        index += 1\n    return returnmat, classlabelvector\n\ndatingdatamat, datinglabels = file2matrix('datingtestset2.txt')\nprint(\"array:\\n\", datingdatamat)\nprint(\"datinglabels[0:20]\\n\", datinglabels[0:20])\n\n# 绘制散点图\n# 定义figure\nfig = plt.figure()\n#add_subplot()返回一个axes对象，里面的参数abc表示在一个figure窗口中，有a行b列个小窗口，然后本次plot在第c个窗口中。\nax = fig.add_subplot(111)\n# 设置颜色和散点图数据\nax.scatter(datingdatamat[:, 1], datingdatamat[:, 2], 15.0 * array(datinglabels), 15.0 * array(datinglabels))\nplt.show()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n\n数据集\n\n\n# 运行结果\n\narray:\n [[  4.09200000e+04   8.32697600e+00   9.53952000e-01]\n [  1.44880000e+04   7.15346900e+00   1.67390400e+00]\n [  2.60520000e+04   1.44187100e+00   8.05124000e-01]\n ..., \n [  2.65750000e+04   1.06501020e+01   8.66627000e-01]\n [  4.81110000e+04   9.13452800e+00   7.28045000e-01]\n [  4.37570000e+04   7.88260100e+00   1.33244600e+00]]\ndatinglabels[0:20]\n [3, 2, 1, 1, 1, 1, 3, 3, 1, 3, 1, 1, 2, 1, 1, 1, 1, 1, 2, 3]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n散点图结果：\n\n\n\n提示\n\n2018年8月11日 16:49:36 新增：归一化特征值，测试代码，预测代码\n\n因为在欧氏距离中数值差值最大的属性对计算结果的影响最大，但其实多个特征都是同等重要的属性，这样如果其中一个占的权重过大，会严重影响到计算的结果\n\n所以在处理不同取值范围的特征值的时候，我们通常采用的方法是将数值归一化，如将取值范围处理为0到1或者-1到1之间。\n\n公式：newvalue = （oldvalue - min）/（max - min）\n\n其中min和max分别是数据集中的最小特征值和最大特征值。虽然改变数值取值范围增加了分类器的复杂度，但为了得到准确的结果，这样做是必然的\n\n# 将数字特征值转化为0到1的区间\ndef autonorm(dataset):\n    # 将每列的最小值放在变量minvals中，dataset.min(0)中的参数0使得函数可以从列中选取最小值\n    minvals = dataset.min(0)\n    # 将每列的最大值放在变量maxvals中\n    maxvals = dataset.max(0)\n    ranges = maxvals - minvals\n    normdataset = zeros(shape(dataset))\n    m = dataset.shape[0]\n    # 为了归一化特征值，必须使用当前值减去最小值，然后除以取值范围\n    # tile()函数将变量内容复制成输入矩阵同样大小的矩阵\n    normdataset = dataset - tile(minvals, (m, 1))\n    # 特征值相除\n    normdataset = normdataset / tile(ranges, (m, 1))\n    return normdataset, ranges, minvals\n\n\n# 分类器针对约会网站的测试代码\ndef datingclasstest():\n    horatio = 0.10\n    # 首先使用file2matrix和autonorm()函数从文件中读取数据并将其转换为归一化特征值\n    datingdatamat, datinglabels = file2matrix('datingtestset2.txt')\n    normmat, ranges, minvals = autonorm(datingdatamat)\n    # 计算测试向量的数量，决定normmat向量中哪些数据用于测试，哪些数据用于分类器的训练样本\n    m = normmat.shape[0]\n    numtestvecs = int(m * horatio)\n    errorcount = 0.0\n    # 将两部分数据输入到原始分类器函数classify0\n    for i in range(numtestvecs):\n        classifierresult = classify0(normmat[i, :], normmat[numtestvecs:m, :], \\\n                                     datinglabels[numtestvecs:m], 3)\n        print(\"the classifier came back with:{},the real answer is:{}\".format(classifierresult, datinglabels[i]))\n        if (classifierresult != datinglabels[i]):\n            errorcount += 1.0\n    # 计算错误率并输出结果\n    print(\"the total error rate is:{}\".format(errorcount / float(numtestvecs)))\n\n\n# 约会网站预测函数\ndef classifyperson():\n    resultlist = ['not at all', 'in small doses', 'in large doses']\n    percenttats = float(input( \\\n        \"percentage of time spent playing video games?\"))\n    ffmiles = float(input(\"frequent flier miles earned per year?\"))\n    icecream = float(input(\"liters of ice cream consumed per year?\"))\n    datingdatamat, datinglabels = file2matrix('datingtestset2.txt')\n    normmat, ranges, minvals = autonorm(datingdatamat)\n    inarr = array([ffmiles, percenttats, icecream])\n    classifierresult = classify0((inarr - \\\n                                  minvals) / ranges, normmat, datinglabels, 3)\n    print(\"you will probably like this person:\", \\\n          resultlist[classifierresult - 1])\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\n测试归一化特征值、分类器、选择喜欢的人：\n\n# 测试归一化特征值\nnormmat, ranges, minvals = autonorm(datingdatamat)\nprint(\"array:\\n\", normmat)\nprint(\"array:\", ranges)\nprint(\"array:\", minvals)\n# 测试分类器\ndatingclasstest()\n# 选择喜欢的人\nclassifyperson()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 运行结果\n\n# normmat\narray:\n [[ 0.44832535  0.39805139  0.56233353]\n [ 0.15873259  0.34195467  0.98724416]\n [ 0.28542943  0.06892523  0.47449629]\n ..., \n [ 0.29115949  0.50910294  0.51079493]\n [ 0.52711097  0.43665451  0.4290048 ]\n [ 0.47940793  0.3768091   0.78571804]]\n# ranges\narray: [  9.12730000e+04   2.09193490e+01   1.69436100e+00]\n# minvals\narray: [ 0.        0.        0.001156]\n# 测试分类器(数据太多了这里截取部分)\nthe classifier came back with:3,the real answer is:3\nthe classifier came back with:2,the real answer is:2\n......\nthe classifier came back with:2,the real answer is:2\nthe classifier came back with:1,the real answer is:1\nthe classifier came back with:3,the real answer is:1\n# 分类器处理约会数据集的错误率为5%（书上为2.4%....不知道怎么回事）\nthe total error rate is:0.05\n# 输入各个属性，得到最佳约会伙伴\npercentage of time spent playing video games?10\nfrequent flier miles earned per year?10000\nliters of ice cream consumed per year?0.5\nyou will probably like this person: in small doses\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n",charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"Numpy数据类型和arange方法、astype方法的使用",frontmatter:{title:"Numpy数据类型和arange方法、astype方法的使用",date:"2018-08-22T20:55:17.000Z",description:"Numpy中的数据类型",categories:"Python-机器学习",tags:["Numpy","Python"],keywords:"Numpy,Python,arange,astype",permalink:"/pages/f66019/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/02.Python-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/13.Numpy%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8Carange%E6%96%B9%E6%B3%95_astype%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8.html",relativePath:"02.Python/02.Python-机器学习/13.Numpy数据类型和arange方法_astype方法的使用.md",key:"v-72a0dc64",path:"/pages/f66019/",headers:[{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:887},{level:2,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:1351}],headersStr:"代码 运行结果",content:"Numpy支持比Python更多的数字类型\n\n数据类型         描述\nbool_        布尔（True或False），存储为一个字节\nint_         默认整数类型（与Clong相同；通常是int64或int32）\nINTC         与Cint（通常为int32或int64）相同\nINTP         用于索引的整数（与Cssize_t相同；通常是int32或int64）\nINT8         字节（-128至127）\nINT16        整数（-32768至32767）\nINT32        整数（-2147483648至2147483647）\nInt64的       整数（-9223372036854775808至9223372036854775807）\nUINT8        无符号整数（0到255）\nUINT16       无符号整数（0到65535）\nUINT32       无符号整数（0到4294967295）\nUINT64       无符号整数（0到18446744073709551615）\nfloat_       float64的简写。\nfloat16      半精度浮点：符号位，5位指数，10位尾数\nFLOAT32      单精度浮点数：符号位，8位指数，23位尾数\nfloat64      双精度浮点：符号位，11位指数，52位尾数\ncomplex_     complex128的简写。\ncomplex64    复数，由两个32位浮点数（实部和虚部）\ncomplex128   复数，由两个64位浮点数（实部和虚部）\n\n除了intc之外，还定义了平台相关的C整数类型short，long，longlong。\n\n提示\n\narange函数用于创建等差数组，使用频率非常高，arange非常类似range函数 ,两者的区别仅仅是arange返回的是一个数据，而range返回的是list 。要转换数组的类型，请使用.astype()方法（首选）或类型本身作为函数\n\n\n# 代码\n\nimport numpy as np\n\nz = np.arange(5)\nprint(z)\nprint(z.dtype)\nprint(50*'*')\n# 转化数据类型为float64\nfloar_arr = z.astype(np.float64)\nprint(floar_arr)\nprint(floar_arr.dtype)\nprint(50*'*')\n# 如果将浮点数转换为整数，则小数部分会被截断\nz2 = np.array([5.1,9.2,8.3,7.4,3.3214])\nprint(z2)\nprint(z2.astype(np.int32))\nprint(50*'*')\n# arange的用法\nprint(np.arange(1, 5))\nprint(np.arange(0, 10, 2))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 运行结果\n\n[0 1 2 3 4]\nint32\n**************************************************\n[0. 1. 2. 3. 4.]\nfloat64\n**************************************************\n[5.1    9.2    8.3    7.4    3.3214]\n[5 9 8 7 3]\n**************************************************\n[1 2 3 4]\n[0 2 4 6 8]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n",normalizedContent:"numpy支持比python更多的数字类型\n\n数据类型         描述\nbool_        布尔（true或false），存储为一个字节\nint_         默认整数类型（与clong相同；通常是int64或int32）\nintc         与cint（通常为int32或int64）相同\nintp         用于索引的整数（与cssize_t相同；通常是int32或int64）\nint8         字节（-128至127）\nint16        整数（-32768至32767）\nint32        整数（-2147483648至2147483647）\nint64的       整数（-9223372036854775808至9223372036854775807）\nuint8        无符号整数（0到255）\nuint16       无符号整数（0到65535）\nuint32       无符号整数（0到4294967295）\nuint64       无符号整数（0到18446744073709551615）\nfloat_       float64的简写。\nfloat16      半精度浮点：符号位，5位指数，10位尾数\nfloat32      单精度浮点数：符号位，8位指数，23位尾数\nfloat64      双精度浮点：符号位，11位指数，52位尾数\ncomplex_     complex128的简写。\ncomplex64    复数，由两个32位浮点数（实部和虚部）\ncomplex128   复数，由两个64位浮点数（实部和虚部）\n\n除了intc之外，还定义了平台相关的c整数类型short，long，longlong。\n\n提示\n\narange函数用于创建等差数组，使用频率非常高，arange非常类似range函数 ,两者的区别仅仅是arange返回的是一个数据，而range返回的是list 。要转换数组的类型，请使用.astype()方法（首选）或类型本身作为函数\n\n\n# 代码\n\nimport numpy as np\n\nz = np.arange(5)\nprint(z)\nprint(z.dtype)\nprint(50*'*')\n# 转化数据类型为float64\nfloar_arr = z.astype(np.float64)\nprint(floar_arr)\nprint(floar_arr.dtype)\nprint(50*'*')\n# 如果将浮点数转换为整数，则小数部分会被截断\nz2 = np.array([5.1,9.2,8.3,7.4,3.3214])\nprint(z2)\nprint(z2.astype(np.int32))\nprint(50*'*')\n# arange的用法\nprint(np.arange(1, 5))\nprint(np.arange(0, 10, 2))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 运行结果\n\n[0 1 2 3 4]\nint32\n**************************************************\n[0. 1. 2. 3. 4.]\nfloat64\n**************************************************\n[5.1    9.2    8.3    7.4    3.3214]\n[5 9 8 7 3]\n**************************************************\n[1 2 3 4]\n[0 2 4 6 8]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n",charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"一些TensorFlow的基本操作",frontmatter:{title:"一些TensorFlow的基本操作",date:"2018-08-26T16:55:33.000Z",categories:"Python-机器学习",tags:["Tensorflow","Python","机器学习"],keywords:"机器学习,Python,Tensorflow",permalink:"/pages/f9a151/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/02.Python/02.Python-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/14.%E4%B8%80%E4%BA%9BTensorFlow%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.html",relativePath:"02.Python/02.Python-机器学习/14.一些TensorFlow的基本操作.md",key:"v-638b756f",path:"/pages/f9a151/",headers:[{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:3},{level:2,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:1924}],headersStr:"代码 运行结果",content:"简单用代码说明Tensor,变量,Fetch,Feed的使用\n\n\n# Tensor\n\nTensorFlow 程序使用 tensor 数据结构来代表所有的数据, 计算图中, 操作间传递的数据都是 tensor. 你可以把 TensorFlow tensor 看作是一个 n 维的数组或列表. 一个 tensor 包含一个静态类型 rank, 和 一个 shape.\n\n\n# 代码\n\n# @Time    : 2018/8/26 16:08\n# @Author  : YuanMing\n# @File    : 变量.py\n# @Software: PyCharm\nimport tensorflow as tf\n\n# 创建一个变量，初始化变量0\nstate = tf.Variable(0, name=\"counter\")\n# 创建一个op，其作用是使state增加1\none = tf.constant(1)\nnew_value = tf.add(state, one)\n'''\n代码中 assign() 操作是图所描绘的表达式的一部分, 正如 add() 操作一样. 所以在调用 run() 执行表达式之前, 它并不会真正执行赋值操作.\n'''\nupdate = tf.assign(state, new_value)\n\n# 启动图后，变量必须先经过'初始化'（init）op初始化\n# 首先必须增加一个'初始化'op到图中\ninit_op = tf.initialize_all_variables()\n\n# 启动图，运行op\nwith tf.Session() as sess:\n    # 运行'init' op\n    sess.run(init_op)\n    # 打印'state'的初始值\n    print(sess.run(state))\n    # 运行op,更新'state'，并打印'state'\n    for _ in range(3):\n        sess.run(update)\n        print(sess.run(state))\n'''\nFetch\n为了取回操作的输出内容, 可以在使用 Session 对象的 run() 调用 执行图时, 传入一些 tensor, 这些 tensor 会帮助你取回结果. 在之前的例子里, 我们只取回了单个节点 state, 但是你也可以取回多tensor:\n'''\ninput1 = tf.constant(3.0)\ninput2 = tf.constant(2.0)\ninput3 = tf.constant(5.0)\nintermed = tf.add(input2, input3)\nmul = tf.multiply(input1, intermed)\n\nwith tf.Session() as sess:\n    result = sess.run([mul, intermed])\n    print(result)\n\n'''\nFeed\nfeed 机制, 该机制 可以临时替代图中的任意操作中的 tensor可以对图中任何操作提交补丁, 直接插入一个 tensor.最常见的用例是将某些特殊的操作指定为 \"feed\" 操作, 标记的方法是使用 tf.placeholder() 为这些操作创建占位符.\n'''\ninput1 = tf.placeholder(tf.float32)\ninput2 = tf.placeholder(tf.float32)\noutput = tf.multiply(input1, input2)\n\nwith tf.Session() as sess:\n  print(sess.run([output], feed_dict={input1:[7.], input2:[2.]}))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n\n# 运行结果\n\n0\n1\n2\n3\n[21.0, 7.0]\n[array([14.], dtype=float32)]\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n",normalizedContent:"简单用代码说明tensor,变量,fetch,feed的使用\n\n\n# tensor\n\ntensorflow 程序使用 tensor 数据结构来代表所有的数据, 计算图中, 操作间传递的数据都是 tensor. 你可以把 tensorflow tensor 看作是一个 n 维的数组或列表. 一个 tensor 包含一个静态类型 rank, 和 一个 shape.\n\n\n# 代码\n\n# @time    : 2018/8/26 16:08\n# @author  : yuanming\n# @file    : 变量.py\n# @software: pycharm\nimport tensorflow as tf\n\n# 创建一个变量，初始化变量0\nstate = tf.variable(0, name=\"counter\")\n# 创建一个op，其作用是使state增加1\none = tf.constant(1)\nnew_value = tf.add(state, one)\n'''\n代码中 assign() 操作是图所描绘的表达式的一部分, 正如 add() 操作一样. 所以在调用 run() 执行表达式之前, 它并不会真正执行赋值操作.\n'''\nupdate = tf.assign(state, new_value)\n\n# 启动图后，变量必须先经过'初始化'（init）op初始化\n# 首先必须增加一个'初始化'op到图中\ninit_op = tf.initialize_all_variables()\n\n# 启动图，运行op\nwith tf.session() as sess:\n    # 运行'init' op\n    sess.run(init_op)\n    # 打印'state'的初始值\n    print(sess.run(state))\n    # 运行op,更新'state'，并打印'state'\n    for _ in range(3):\n        sess.run(update)\n        print(sess.run(state))\n'''\nfetch\n为了取回操作的输出内容, 可以在使用 session 对象的 run() 调用 执行图时, 传入一些 tensor, 这些 tensor 会帮助你取回结果. 在之前的例子里, 我们只取回了单个节点 state, 但是你也可以取回多tensor:\n'''\ninput1 = tf.constant(3.0)\ninput2 = tf.constant(2.0)\ninput3 = tf.constant(5.0)\nintermed = tf.add(input2, input3)\nmul = tf.multiply(input1, intermed)\n\nwith tf.session() as sess:\n    result = sess.run([mul, intermed])\n    print(result)\n\n'''\nfeed\nfeed 机制, 该机制 可以临时替代图中的任意操作中的 tensor可以对图中任何操作提交补丁, 直接插入一个 tensor.最常见的用例是将某些特殊的操作指定为 \"feed\" 操作, 标记的方法是使用 tf.placeholder() 为这些操作创建占位符.\n'''\ninput1 = tf.placeholder(tf.float32)\ninput2 = tf.placeholder(tf.float32)\noutput = tf.multiply(input1, input2)\n\nwith tf.session() as sess:\n  print(sess.run([output], feed_dict={input1:[7.], input2:[2.]}))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n\n# 运行结果\n\n0\n1\n2\n3\n[21.0, 7.0]\n[array([14.], dtype=float32)]\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n",charsets:{cjk:!0},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"概览",frontmatter:{title:"概览",article:!1,tags:[null],date:"2022-04-17T18:56:03.000Z",permalink:"/pages/b53b0f/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/03.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/01.Kafka/01.%E6%A6%82%E8%A7%88.html",relativePath:"03.分布式与中间件/01.Kafka/01.概览.md",key:"v-15bb3d7d",path:"/pages/b53b0f/",headersStr:null,content:"提示\n\n正在路上...",normalizedContent:"提示\n\n正在路上...",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"Redis实现共享Session",frontmatter:{title:"Redis实现共享Session",date:"2020-06-25T16:30:43.000Z",description:"使用总结",tags:["Redis","Java"],keywords:"Redis,Java",permalink:"/pages/847591/",categories:["分布式与中间件","Redis"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/03.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/02.Redis/01.Redis%E5%AE%9E%E7%8E%B0%E5%85%B1%E4%BA%ABSession.html",relativePath:"03.分布式与中间件/02.Redis/01.Redis实现共享Session.md",key:"v-046c9608",path:"/pages/847591/",headers:[{level:2,title:"Redis实现共享Session",slug:"redis实现共享session",normalizedTitle:"redis实现共享session",charIndex:2},{level:3,title:"代码实现",slug:"代码实现",normalizedTitle:"代码实现",charIndex:681}],headersStr:"Redis实现共享Session 代码实现",content:'# Redis实现共享Session\n\nSession共享，一般有一个这样的场景。以往单机的项目，数据请求都是在一个服务器上，session保存在这个服务器上自然是没有问题的。但是如果项目需要部署在多台服务器上的时候，session就会存在共享的问题\n\n举一个例子：\n\n假如现在有两台服务器同时运行，分别是ServerA和ServerB。\n\n假设第一次请求(登陆请求)被分配到了A进行处理，A收到请求之后会生成一个sessionId并保存到内存中，然后返回给用户(浏览器)，浏览器会把sessionId保存到cookie中，第一次请求完成。如果之后每一次请求还是由A来进行处理，那么一切正常。如果A服务器挂掉了，这时候请求被分配到B，B拿到的sessionId是由A生成的，两边就对不上了。于是用户会发现，需要重新登陆了。\n\n那么这样的问题应该怎么样去解决呢？\n\n首先，问题的根源出在sessionId无法共享上，想要把sessionId共享，一个简单的思路就是把sessionId保存到数据库中(这里选择redis)，这样验证的时候就不再从当前服务器获取sessionId了，而改为了从redis中获取\n\n实现思路如下：\n\n 1. 登陆页面提交用户名密码\n 2. 登陆成功之后生成token。Token相当于原来的sessionId，字符串等，可以使用UUID\n 3. 把用户信息保存到redis中。Key就是token，value就是userId\n 4. 设置key的过期时间。模拟Session的过期时间\n 5. 拦截器请求校验sessionId\n\n\n# 代码实现\n\n登陆成功，生成sessionId存入redis\n\n@Service\npublic class UserServiceImpl implements UserService {\n\n    @Autowired\n    private SysUserMapper sysUserMapper;\n\n    @Autowired\n    private RedisService redisService;\n\n    @Override\n    public LoginRespVo login(LoginReqVo vo) {\n        SysUser sysUser = sysUserMapper.selectByUsername(vo.getUsername());\n        if(sysUser==null){\n            throw new BusinessException(4001005,"不存在该用户,请先注册");\n        }\n        if(sysUser.getStatus()==2){\n            throw new BusinessException(4001006,"该帐号已被禁用");\n        }\n        if(!PasswordUtils.matches(sysUser.getSalt(),vo.getPassword(),sysUser.getPassword())){\n            throw new BusinessException(4001007,"用户名密码不匹配");\n        }\n        String token = UUID.randomUUID().toString();\n        LoginRespVo respVo = new LoginRespVo();\n        respVo.setUserId(sysUser.getId());\n        respVo.setToken(token);\n        redisService.set(token,sysUser.getId(),60, TimeUnit.MINUTES);\n        redisService.set(sysUser.getId(),token,60,TimeUnit.MINUTES);\n        return respVo;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n其中LoginRespVo类为\n\npackage com.cqupt.lesson.vo.req;\n\nimport io.swagger.annotations.ApiModelProperty;\nimport lombok.Data;\n\n@Data\npublic class LoginReqVo {\n    @ApiModelProperty(value = "用户名")\n    private String username;\n\n    @ApiModelProperty(value = "密码")\n    private String password;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nSessionInterceptor拦截器校验sessionId，拦截器实现HandlerInterceptor的preHandle方法，可以获取从头部获取token或者从cookie获取token，之后进行token的验证\n\npackage com.cqupt.lesson.interceptor;\n\nimport com.cqupt.lesson.exception.BusinessException;\nimport com.cqupt.lesson.service.RedisService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.util.StringUtils;\nimport org.springframework.web.servlet.HandlerInterceptor;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class TokenInterceptor implements HandlerInterceptor {\n\n    @Autowired\n    private RedisService redisService;\n\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        String token = request.getHeader("token");\n        if(StringUtils.isEmpty(token)){\n            throw new BusinessException(4001002,"用户凭证不能为空");\n        }else {\n            if(!redisService.hasKey(token)){\n                throw new BusinessException(4001002,"用户凭证无效");\n            }\n            String userId = (String) redisService.get(token);\n            if(redisService.hasKey(userId)&&!token.equals(redisService.get(userId))){\n                throw new BusinessException(4001002,"帐号已在异地登陆");\n            }\n        }\n        return true;\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n之后设置一个web拦截器，并注入自定义的拦截器\n\npackage com.cqupt.lesson.config;\n\nimport com.cqupt.lesson.interceptor.TokenInterceptor;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.config.annotation.InterceptorRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurer;\n\n@Configuration\npublic class WebAppConfig implements WebMvcConfigurer {\n    @Bean\n    public TokenInterceptor tokenInterceptor(){\n        return new TokenInterceptor();\n    }\n\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(tokenInterceptor()).addPathPatterns("/api/**").excludePathPatterns("/api/user/login","/api/user/register","/api/user/code/*");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n登陆Service代码实现\n\n@Service\npublic class UserServiceImpl implements UserService {\n\n    @Autowired\n    private SysUserMapper sysUserMapper;\n\n    @Autowired\n    private RedisService redisService;\n\n    @Override\n    public LoginRespVo login(LoginReqVo vo) {\n        SysUser sysUser = sysUserMapper.selectByUsername(vo.getUsername());\n        if(sysUser==null){\n            throw new BusinessException(4001005,"不存在该用户,请先注册");\n        }\n        if(sysUser.getStatus()==2){\n            throw new BusinessException(4001006,"该帐号已被禁用");\n        }\n        if(!PasswordUtils.matches(sysUser.getSalt(),vo.getPassword(),sysUser.getPassword())){\n            throw new BusinessException(4001007,"用户名密码不匹配");\n        }\n        String token = UUID.randomUUID().toString();\n        LoginRespVo respVo = new LoginRespVo();\n        respVo.setUserId(sysUser.getId());\n        respVo.setToken(token);\n        redisService.set(token,sysUser.getId(),60, TimeUnit.MINUTES);\n        redisService.set(sysUser.getId(),token,60,TimeUnit.MINUTES);\n        return respVo;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n登陆Controller实现\n\n@RestController\n@RequestMapping("/api")\n@Api(tags = "用户模块",description = "用户模块相关接口")\npublic class UserController {\n\n    @Autowired\n    private UserService userService;\n\n    @PostMapping("/user/login")\n    @ApiModelProperty(value = "用户登陆接口")\n    public LoginRespVo login(@RequestBody LoginReqVo vo){\n        return userService.login(vo);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n',normalizedContent:'# redis实现共享session\n\nsession共享，一般有一个这样的场景。以往单机的项目，数据请求都是在一个服务器上，session保存在这个服务器上自然是没有问题的。但是如果项目需要部署在多台服务器上的时候，session就会存在共享的问题\n\n举一个例子：\n\n假如现在有两台服务器同时运行，分别是servera和serverb。\n\n假设第一次请求(登陆请求)被分配到了a进行处理，a收到请求之后会生成一个sessionid并保存到内存中，然后返回给用户(浏览器)，浏览器会把sessionid保存到cookie中，第一次请求完成。如果之后每一次请求还是由a来进行处理，那么一切正常。如果a服务器挂掉了，这时候请求被分配到b，b拿到的sessionid是由a生成的，两边就对不上了。于是用户会发现，需要重新登陆了。\n\n那么这样的问题应该怎么样去解决呢？\n\n首先，问题的根源出在sessionid无法共享上，想要把sessionid共享，一个简单的思路就是把sessionid保存到数据库中(这里选择redis)，这样验证的时候就不再从当前服务器获取sessionid了，而改为了从redis中获取\n\n实现思路如下：\n\n 1. 登陆页面提交用户名密码\n 2. 登陆成功之后生成token。token相当于原来的sessionid，字符串等，可以使用uuid\n 3. 把用户信息保存到redis中。key就是token，value就是userid\n 4. 设置key的过期时间。模拟session的过期时间\n 5. 拦截器请求校验sessionid\n\n\n# 代码实现\n\n登陆成功，生成sessionid存入redis\n\n@service\npublic class userserviceimpl implements userservice {\n\n    @autowired\n    private sysusermapper sysusermapper;\n\n    @autowired\n    private redisservice redisservice;\n\n    @override\n    public loginrespvo login(loginreqvo vo) {\n        sysuser sysuser = sysusermapper.selectbyusername(vo.getusername());\n        if(sysuser==null){\n            throw new businessexception(4001005,"不存在该用户,请先注册");\n        }\n        if(sysuser.getstatus()==2){\n            throw new businessexception(4001006,"该帐号已被禁用");\n        }\n        if(!passwordutils.matches(sysuser.getsalt(),vo.getpassword(),sysuser.getpassword())){\n            throw new businessexception(4001007,"用户名密码不匹配");\n        }\n        string token = uuid.randomuuid().tostring();\n        loginrespvo respvo = new loginrespvo();\n        respvo.setuserid(sysuser.getid());\n        respvo.settoken(token);\n        redisservice.set(token,sysuser.getid(),60, timeunit.minutes);\n        redisservice.set(sysuser.getid(),token,60,timeunit.minutes);\n        return respvo;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n其中loginrespvo类为\n\npackage com.cqupt.lesson.vo.req;\n\nimport io.swagger.annotations.apimodelproperty;\nimport lombok.data;\n\n@data\npublic class loginreqvo {\n    @apimodelproperty(value = "用户名")\n    private string username;\n\n    @apimodelproperty(value = "密码")\n    private string password;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nsessioninterceptor拦截器校验sessionid，拦截器实现handlerinterceptor的prehandle方法，可以获取从头部获取token或者从cookie获取token，之后进行token的验证\n\npackage com.cqupt.lesson.interceptor;\n\nimport com.cqupt.lesson.exception.businessexception;\nimport com.cqupt.lesson.service.redisservice;\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.util.stringutils;\nimport org.springframework.web.servlet.handlerinterceptor;\n\nimport javax.servlet.http.httpservletrequest;\nimport javax.servlet.http.httpservletresponse;\n\npublic class tokeninterceptor implements handlerinterceptor {\n\n    @autowired\n    private redisservice redisservice;\n\n    @override\n    public boolean prehandle(httpservletrequest request, httpservletresponse response, object handler) throws exception {\n        string token = request.getheader("token");\n        if(stringutils.isempty(token)){\n            throw new businessexception(4001002,"用户凭证不能为空");\n        }else {\n            if(!redisservice.haskey(token)){\n                throw new businessexception(4001002,"用户凭证无效");\n            }\n            string userid = (string) redisservice.get(token);\n            if(redisservice.haskey(userid)&&!token.equals(redisservice.get(userid))){\n                throw new businessexception(4001002,"帐号已在异地登陆");\n            }\n        }\n        return true;\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n之后设置一个web拦截器，并注入自定义的拦截器\n\npackage com.cqupt.lesson.config;\n\nimport com.cqupt.lesson.interceptor.tokeninterceptor;\nimport org.springframework.context.annotation.bean;\nimport org.springframework.context.annotation.configuration;\nimport org.springframework.web.servlet.config.annotation.interceptorregistry;\nimport org.springframework.web.servlet.config.annotation.webmvcconfigurer;\n\n@configuration\npublic class webappconfig implements webmvcconfigurer {\n    @bean\n    public tokeninterceptor tokeninterceptor(){\n        return new tokeninterceptor();\n    }\n\n    @override\n    public void addinterceptors(interceptorregistry registry) {\n        registry.addinterceptor(tokeninterceptor()).addpathpatterns("/api/**").excludepathpatterns("/api/user/login","/api/user/register","/api/user/code/*");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n登陆service代码实现\n\n@service\npublic class userserviceimpl implements userservice {\n\n    @autowired\n    private sysusermapper sysusermapper;\n\n    @autowired\n    private redisservice redisservice;\n\n    @override\n    public loginrespvo login(loginreqvo vo) {\n        sysuser sysuser = sysusermapper.selectbyusername(vo.getusername());\n        if(sysuser==null){\n            throw new businessexception(4001005,"不存在该用户,请先注册");\n        }\n        if(sysuser.getstatus()==2){\n            throw new businessexception(4001006,"该帐号已被禁用");\n        }\n        if(!passwordutils.matches(sysuser.getsalt(),vo.getpassword(),sysuser.getpassword())){\n            throw new businessexception(4001007,"用户名密码不匹配");\n        }\n        string token = uuid.randomuuid().tostring();\n        loginrespvo respvo = new loginrespvo();\n        respvo.setuserid(sysuser.getid());\n        respvo.settoken(token);\n        redisservice.set(token,sysuser.getid(),60, timeunit.minutes);\n        redisservice.set(sysuser.getid(),token,60,timeunit.minutes);\n        return respvo;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n登陆controller实现\n\n@restcontroller\n@requestmapping("/api")\n@api(tags = "用户模块",description = "用户模块相关接口")\npublic class usercontroller {\n\n    @autowired\n    private userservice userservice;\n\n    @postmapping("/user/login")\n    @apimodelproperty(value = "用户登陆接口")\n    public loginrespvo login(@requestbody loginreqvo vo){\n        return userservice.login(vo);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"自定义RedisTemplate",frontmatter:{title:"自定义RedisTemplate",date:"2020-06-25T15:36:22.000Z",description:"使用总结",tags:["Redis","Java"],keywords:"Redis,Java",permalink:"/pages/b185b0/",categories:["分布式与中间件","Redis"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/03.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/02.Redis/02.%E8%87%AA%E5%AE%9A%E4%B9%89RedisTemplate.html",relativePath:"03.分布式与中间件/02.Redis/02.自定义RedisTemplate.md",key:"v-a3238f7a",path:"/pages/b185b0/",headers:[{level:2,title:"自定义RedisTemplate",slug:"自定义redistemplate",normalizedTitle:"自定义redistemplate",charIndex:2},{level:3,title:"Redis基本数据结构",slug:"redis基本数据结构",normalizedTitle:"redis基本数据结构",charIndex:196},{level:3,title:"自定义redis序列化工具类",slug:"自定义redis序列化工具类",normalizedTitle:"自定义redis序列化工具类",charIndex:3733}],headersStr:"自定义RedisTemplate Redis基本数据结构 自定义redis序列化工具类",content:'# 自定义RedisTemplate\n\n在Spring Data Redis中，有一个高度封装的RedisTemplate类，实现了对Redis客户端的操作，其中提供了针对数据的StringRedisSerializer序列化方式，但这只能序列化String类型的Key和Value。在日常的数据处理中，通常会面对存储一个对象数据的任务，所以需要定义一个自己的序列化和反序列化方法。\n\n\n# Redis基本数据结构\n\nRedisTemplate中定义了对应的redis五种数据结构操作：\n\n * opsForValue();//操作字符串\n * opsForHash();//操作hash\n * opsForList(); //操作list\n * opsForSet(); //操作set\n * opsForZSet();//操作有序set\n\nRedisTemplate可以直接通过@Autowired获取对象引用，为什么能够直接声明获取引用呢？\n\n * 在spring boot启动后会向spring 注入两个bean RedisTemplate、StringRedisTemplate\n * 源码中StringRedisTemplate继承自RedisTemplate\n * RedisTemplate是一个泛型类，而StringRedisTemplate则不是\n * StringRedisTemplate只能对key=String，value=String的键值对进行操作，RedisTemplate可以对任何类型的key-value键值对操作\n * 他们各自序列化的方式不同，但最终都是得到了一个字节数组，殊途同归，StringRedisTemplate使用的是 StringRedisSerializer类；RedisTemplate使用的是JdkSerializationRedisSerializer类。反序列化，则是一个得到String，一个得到Object\n\nRedisTemplate在操作数据的时候，存入数据会将数据先序列化成字节数组然后在存入Redis数据库(默认 JdkSerializationRedisSerializer:这个序列化方法就是Jdk提供的了,首先要求我们要被序列化的类继承自Serializeable接口，然后通过Jdk对象序列化的方法保存)，这个时候打开Redis查看的时候，你会看到你的数据不是以可读的形式，展现的，而是以字节数组显示。\n\n而StringRedisSerializer在操作数据的时候就是通过String.getBytes()来实现的。而且在Redis中，所有存储的值都是字符串类型的。所以这种方法保存后，通过Redis-cli控制台或者Redis-Desktop-Manager图形化工具，是可以清楚的查看到我们保存了什么key,value是什么。\n\n如当我们从以前的项目升级为RedisTemplate在不指定序列化方式的时候取不到原来的值\n\n@Autowired\n  private RedisTemplate  redisTemplate;\n  @Test\n  public void testRedisTemplate() {\n    System.out.println(redisTemplate.opsForValue().get("username"));\n }\n \n 输出：null\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n这是因为升级成RedisTemplate他的默认使用序列化是JdkSerializationRedisSerializer，所以当需要获取数据的时候就找不到数据了(因为拿key去匹配的时候两种序列化得到的byte数组是不一样的)。\n\n我们把RedisTemplate序列化方式设置成StringRedisSerializer看看效果\n\n@Autowired\n  @Test\n  public void testRedisTemplate() {\n    stringRedisTemplate.opsForValue().set("username","张三");\n    StringRedisSerializer stringRedisSerializer=new StringRedisSerializer();\n    redisTemplate.setKeySerializer(stringRedisSerializer);\n    redisTemplate.setValueSerializer(stringRedisSerializer);\n    System.out.println(redisTemplate.opsForValue().get("username"));\n }\n输出：张三\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n当我们指定使用StringRedisSerializer做value的序列化时，StringRedisSerializer的泛型指定的是String，传其他对象就会报类不能转换为String的异常\n\n我们希望redis能够保存对象数据，就应该要自定义StringRedisSerializer\n\n在StringRedisSerializer的源码中，它继承了RedisSerializer<String>，如下所示：\n\n//\n// Source code recreated from a .class file by IntelliJ IDEA\n// (powered by Fernflower decompiler)\n//\npackage org.springframework.data.redis.serializer;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport org.springframework.lang.Nullable;\nimport org.springframework.util.Assert;\npublic class StringRedisSerializer implements RedisSerializer<String> {\n  private final Charset charset;\n  public static final StringRedisSerializer US_ASCII;\n  public static final StringRedisSerializer ISO_8859_1;\n  public static final StringRedisSerializer UTF_8;\n  public StringRedisSerializer() {\n    this(StandardCharsets.UTF_8);\n }\n  public StringRedisSerializer(Charset charset) {\n    Assert.notNull(charset, "Charset must not be null!");\n    this.charset = charset;\n }\n  public String deserialize(@Nullable byte[] bytes) {\n    return bytes == null ? null : new String(bytes, this.charset);\n }\n  public byte[] serialize(@Nullable String string) {\n    return string == null ? null : string.getBytes(this.charset);\n }\n  static {\n    US_ASCII = new StringRedisSerializer(StandardCharsets.US_ASCII);\n    ISO_8859_1 = new StringRedisSerializer(StandardCharsets.ISO_8859_1);\n    UTF_8 = new StringRedisSerializer(StandardCharsets.UTF_8);\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 自定义redis序列化工具类\n\n将传入的Object对象转化为JSON字符串，之后再变为字节数组\n\npackage com.cqupt.lesson.serializer;\n\nimport com.alibaba.fastjson.JSON;\nimport org.springframework.data.redis.serializer.RedisSerializer;\nimport org.springframework.data.redis.serializer.SerializationException;\nimport org.springframework.util.Assert;\n\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\n\npublic class MyStringRedisSerializer implements RedisSerializer<Object> {\n\n    private final Charset charset;\n\n    public MyStringRedisSerializer() {\n        this(StandardCharsets.UTF_8);\n    }\n\n    public MyStringRedisSerializer(Charset charset) {\n        Assert.notNull(charset, "Charset must not be null!");\n        this.charset = charset;\n    }\n\n    @Override\n    public byte[] serialize(Object object) throws SerializationException {\n        if(object==null){\n            return new byte[0];\n        }\n        if(object instanceof String){\n            return object.toString().getBytes(charset);\n        }else{\n            String string = JSON.toJSONString(object);\n            return string.getBytes(charset);\n        }\n    }\n\n    @Override\n    public Object deserialize(byte[] bytes) throws SerializationException {\n        return (bytes == null ? null : new String(bytes, charset));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n同时需要加入fastjson依赖，创建一个RedisConfig配置类，设置2种key-value的序列化方式\n\npackage com.cqupt.lesson.config;\n\nimport com.cqupt.lesson.serializer.MyStringRedisSerializer;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.redis.connection.RedisConnectionFactory;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\n\n@Configuration\npublic class RedisConfig {\n\n    @Bean\n    public RedisTemplate<String,Object> redisTemplate(RedisConnectionFactory redisConnectionFactory){\n        RedisTemplate<String,Object> redisTemplate = new RedisTemplate<>();\n        redisTemplate.setConnectionFactory(redisConnectionFactory);\n        redisTemplate.setKeySerializer(new StringRedisSerializer());\n        redisTemplate.setHashKeySerializer(new StringRedisSerializer());\n        redisTemplate.setValueSerializer(new MyStringRedisSerializer());\n        redisTemplate.setHashValueSerializer(new MyStringRedisSerializer());\n        return redisTemplate;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n之后自定义一个RedisService类，接管RedisTemplate的功能，并在此基础上进行一点判空修改(代码过长，只贴一部分)\n\n@Service\npublic class RedisService {\n    @Autowired\n    private RedisTemplate<String,Object> redisTemplate;\n    /** -------------------key相关操作--------------------- */\n\n    /**\n     * 是否存在key\n     * @Author:      YuanMing\n     * @UpdateUser:\n     * @Version:     0.0.1\n     * @param key\n     * @return       java.lang.Boolean\n     * @throws\n     */\n    public Boolean hasKey(String key) {\n        if (null==key){\n            return false;\n        }\n        return redisTemplate.hasKey(key);\n    }\n\n    /**\n     * 删除key\n     * @Author:      YuanMing\n     * @UpdateUser:\n     * @Version:     0.0.1\n     * @param key\n     * @return       Boolean  成功返回true 失败返回false\n     * @throws\n     */\n    public Boolean delete(String key) {\n        if (null==key){\n            return false;\n        }\n        return redisTemplate.delete(key);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n',normalizedContent:'# 自定义redistemplate\n\n在spring data redis中，有一个高度封装的redistemplate类，实现了对redis客户端的操作，其中提供了针对数据的stringredisserializer序列化方式，但这只能序列化string类型的key和value。在日常的数据处理中，通常会面对存储一个对象数据的任务，所以需要定义一个自己的序列化和反序列化方法。\n\n\n# redis基本数据结构\n\nredistemplate中定义了对应的redis五种数据结构操作：\n\n * opsforvalue();//操作字符串\n * opsforhash();//操作hash\n * opsforlist(); //操作list\n * opsforset(); //操作set\n * opsforzset();//操作有序set\n\nredistemplate可以直接通过@autowired获取对象引用，为什么能够直接声明获取引用呢？\n\n * 在spring boot启动后会向spring 注入两个bean redistemplate、stringredistemplate\n * 源码中stringredistemplate继承自redistemplate\n * redistemplate是一个泛型类，而stringredistemplate则不是\n * stringredistemplate只能对key=string，value=string的键值对进行操作，redistemplate可以对任何类型的key-value键值对操作\n * 他们各自序列化的方式不同，但最终都是得到了一个字节数组，殊途同归，stringredistemplate使用的是 stringredisserializer类；redistemplate使用的是jdkserializationredisserializer类。反序列化，则是一个得到string，一个得到object\n\nredistemplate在操作数据的时候，存入数据会将数据先序列化成字节数组然后在存入redis数据库(默认 jdkserializationredisserializer:这个序列化方法就是jdk提供的了,首先要求我们要被序列化的类继承自serializeable接口，然后通过jdk对象序列化的方法保存)，这个时候打开redis查看的时候，你会看到你的数据不是以可读的形式，展现的，而是以字节数组显示。\n\n而stringredisserializer在操作数据的时候就是通过string.getbytes()来实现的。而且在redis中，所有存储的值都是字符串类型的。所以这种方法保存后，通过redis-cli控制台或者redis-desktop-manager图形化工具，是可以清楚的查看到我们保存了什么key,value是什么。\n\n如当我们从以前的项目升级为redistemplate在不指定序列化方式的时候取不到原来的值\n\n@autowired\n  private redistemplate  redistemplate;\n  @test\n  public void testredistemplate() {\n    system.out.println(redistemplate.opsforvalue().get("username"));\n }\n \n 输出：null\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n这是因为升级成redistemplate他的默认使用序列化是jdkserializationredisserializer，所以当需要获取数据的时候就找不到数据了(因为拿key去匹配的时候两种序列化得到的byte数组是不一样的)。\n\n我们把redistemplate序列化方式设置成stringredisserializer看看效果\n\n@autowired\n  @test\n  public void testredistemplate() {\n    stringredistemplate.opsforvalue().set("username","张三");\n    stringredisserializer stringredisserializer=new stringredisserializer();\n    redistemplate.setkeyserializer(stringredisserializer);\n    redistemplate.setvalueserializer(stringredisserializer);\n    system.out.println(redistemplate.opsforvalue().get("username"));\n }\n输出：张三\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n当我们指定使用stringredisserializer做value的序列化时，stringredisserializer的泛型指定的是string，传其他对象就会报类不能转换为string的异常\n\n我们希望redis能够保存对象数据，就应该要自定义stringredisserializer\n\n在stringredisserializer的源码中，它继承了redisserializer<string>，如下所示：\n\n//\n// source code recreated from a .class file by intellij idea\n// (powered by fernflower decompiler)\n//\npackage org.springframework.data.redis.serializer;\nimport java.nio.charset.charset;\nimport java.nio.charset.standardcharsets;\nimport org.springframework.lang.nullable;\nimport org.springframework.util.assert;\npublic class stringredisserializer implements redisserializer<string> {\n  private final charset charset;\n  public static final stringredisserializer us_ascii;\n  public static final stringredisserializer iso_8859_1;\n  public static final stringredisserializer utf_8;\n  public stringredisserializer() {\n    this(standardcharsets.utf_8);\n }\n  public stringredisserializer(charset charset) {\n    assert.notnull(charset, "charset must not be null!");\n    this.charset = charset;\n }\n  public string deserialize(@nullable byte[] bytes) {\n    return bytes == null ? null : new string(bytes, this.charset);\n }\n  public byte[] serialize(@nullable string string) {\n    return string == null ? null : string.getbytes(this.charset);\n }\n  static {\n    us_ascii = new stringredisserializer(standardcharsets.us_ascii);\n    iso_8859_1 = new stringredisserializer(standardcharsets.iso_8859_1);\n    utf_8 = new stringredisserializer(standardcharsets.utf_8);\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 自定义redis序列化工具类\n\n将传入的object对象转化为json字符串，之后再变为字节数组\n\npackage com.cqupt.lesson.serializer;\n\nimport com.alibaba.fastjson.json;\nimport org.springframework.data.redis.serializer.redisserializer;\nimport org.springframework.data.redis.serializer.serializationexception;\nimport org.springframework.util.assert;\n\nimport java.nio.charset.charset;\nimport java.nio.charset.standardcharsets;\n\npublic class mystringredisserializer implements redisserializer<object> {\n\n    private final charset charset;\n\n    public mystringredisserializer() {\n        this(standardcharsets.utf_8);\n    }\n\n    public mystringredisserializer(charset charset) {\n        assert.notnull(charset, "charset must not be null!");\n        this.charset = charset;\n    }\n\n    @override\n    public byte[] serialize(object object) throws serializationexception {\n        if(object==null){\n            return new byte[0];\n        }\n        if(object instanceof string){\n            return object.tostring().getbytes(charset);\n        }else{\n            string string = json.tojsonstring(object);\n            return string.getbytes(charset);\n        }\n    }\n\n    @override\n    public object deserialize(byte[] bytes) throws serializationexception {\n        return (bytes == null ? null : new string(bytes, charset));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n同时需要加入fastjson依赖，创建一个redisconfig配置类，设置2种key-value的序列化方式\n\npackage com.cqupt.lesson.config;\n\nimport com.cqupt.lesson.serializer.mystringredisserializer;\nimport org.springframework.context.annotation.bean;\nimport org.springframework.context.annotation.configuration;\nimport org.springframework.data.redis.connection.redisconnectionfactory;\nimport org.springframework.data.redis.core.redistemplate;\nimport org.springframework.data.redis.serializer.stringredisserializer;\n\n@configuration\npublic class redisconfig {\n\n    @bean\n    public redistemplate<string,object> redistemplate(redisconnectionfactory redisconnectionfactory){\n        redistemplate<string,object> redistemplate = new redistemplate<>();\n        redistemplate.setconnectionfactory(redisconnectionfactory);\n        redistemplate.setkeyserializer(new stringredisserializer());\n        redistemplate.sethashkeyserializer(new stringredisserializer());\n        redistemplate.setvalueserializer(new mystringredisserializer());\n        redistemplate.sethashvalueserializer(new mystringredisserializer());\n        return redistemplate;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n之后自定义一个redisservice类，接管redistemplate的功能，并在此基础上进行一点判空修改(代码过长，只贴一部分)\n\n@service\npublic class redisservice {\n    @autowired\n    private redistemplate<string,object> redistemplate;\n    /** -------------------key相关操作--------------------- */\n\n    /**\n     * 是否存在key\n     * @author:      yuanming\n     * @updateuser:\n     * @version:     0.0.1\n     * @param key\n     * @return       java.lang.boolean\n     * @throws\n     */\n    public boolean haskey(string key) {\n        if (null==key){\n            return false;\n        }\n        return redistemplate.haskey(key);\n    }\n\n    /**\n     * 删除key\n     * @author:      yuanming\n     * @updateuser:\n     * @version:     0.0.1\n     * @param key\n     * @return       boolean  成功返回true 失败返回false\n     * @throws\n     */\n    public boolean delete(string key) {\n        if (null==key){\n            return false;\n        }\n        return redistemplate.delete(key);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"Redis哨兵",frontmatter:{title:"Redis哨兵",date:"2022-01-07T20:15:23.000Z",tags:["Java","Redis"],permalink:"/pages/3aa0a8/",categories:["分布式与中间件","Redis"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/03.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/02.Redis/03.Redis%E5%93%A8%E5%85%B5.html",relativePath:"03.分布式与中间件/02.Redis/03.Redis哨兵.md",key:"v-889b9680",path:"/pages/3aa0a8/",headers:[{level:3,title:"Redis哨兵的作用",slug:"redis哨兵的作用",normalizedTitle:"redis哨兵的作用",charIndex:2},{level:4,title:"哨兵的结构如图所示",slug:"哨兵的结构如图所示",normalizedTitle:"哨兵的结构如图所示",charIndex:151},{level:4,title:"服务状态监控",slug:"服务状态监控",normalizedTitle:"服务状态监控",charIndex:370},{level:4,title:"选举新的master",slug:"选举新的master",normalizedTitle:"选举新的master",charIndex:646},{level:4,title:"故障转移步骤",slug:"故障转移步骤",normalizedTitle:"故障转移步骤",charIndex:997},{level:3,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:1318}],headersStr:"Redis哨兵的作用 哨兵的结构如图所示 服务状态监控 选举新的master 故障转移步骤 总结",content:"# Redis哨兵的作用\n\nRedis提供了哨兵(Sentinel)机制来实现主从集群的自动故障恢复。 主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。\n\n# 哨兵的结构如图所示\n\n\n\n通常而言，哨兵需要部署至少3个节点，保证哨兵集群的高可用。 其作用可概述为：\n\n * 监控：哨兵会不断检查master和slave是否按期工作\n * 自动故障恢复：如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主\n * 通知：Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端\n\n# 服务状态监控\n\nSentinel基于心跳机制监测服务状态，每隔1秒向集群的每个实例发送ping命令：\n\n * 主观下线：如果某sentinel节点发现某实例未在规定时间响应，则认为该实例主观下线。(主观下线不一定是真正的下线了，可能由于网络阻塞等原因，导致实例访问超时)\n * 客观下线：若超过指定数量（quorum）的sentinel都认为该实例主观下线，则该实例客观下线。quorum值最好超过Sentinel实例数量的一半。即多数sentinel认为主观下线。\n\n\n\n当sentinel认为实例客观下线时，就需要重新选举master节点。\n\n# 选举新的master\n\n一旦发现master故障，sentinel需要在slave中选择一个作为新的master，选择依据如下：\n\n * 首先会判断slave节点与master节点断开时间长短，如果超过指定值（down-after-milliseconds * 10）则会排除该slave节点\n * 然后判断slave节点的slave-priority值，越小优先级越高，如果是0则永不参与选举，默认为100(replica-priority)\n * 如果slave-prority一样，则判断slave节点的offset值，越大说明数据越新，优先级越高\n * 最后是判断slave节点的运行id大小，越小优先级越高。 选择好新的slave作为master后，就需要对redis集群进行故障转移\n\n# 故障转移步骤\n\n例如选中了slave1为新的master后，故障的转移的步骤如下：\n\n * sentinel给备选的slave1节点发送slaveof no one命令，让该节点成为master\n * sentinel给所有其它slave发送slaveof 192.168.150.101 7002 命令，让这些slave成为新master的从节点，开始从新的master上同步数据。\n * 最后，针对故障的节点sentinel会强制修改其对应的配置文件标记为slave，当故障节点恢复后会自动成为新的master的slave节点。\n\n如图所示，master从中间的节点变为了最左的节点，原本的master重启后变成了slave\n\n\n\n\n# 总结\n\nSentinel的作用：\n\n * 监控\n * 故障转移\n * 通知\n\nSentinel如何判断一个redis实例是否健康？\n\n * 每隔1秒发送一次ping命令，如果超过一定时间没有相向则认为是主观下线\n * 如果大多数sentinel都认为实例主观下线，则判定服务下线\n\n故障转移步骤有哪些？\n\n * 首先选定一个slave作为新的master，执行slaveof no one\n * 然后让所有节点都执行slaveof 新master\n * 修改故障节点配置，添加slaveof 新master",normalizedContent:"# redis哨兵的作用\n\nredis提供了哨兵(sentinel)机制来实现主从集群的自动故障恢复。 主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。\n\n# 哨兵的结构如图所示\n\n\n\n通常而言，哨兵需要部署至少3个节点，保证哨兵集群的高可用。 其作用可概述为：\n\n * 监控：哨兵会不断检查master和slave是否按期工作\n * 自动故障恢复：如果master故障，sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主\n * 通知：sentinel充当redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给redis的客户端\n\n# 服务状态监控\n\nsentinel基于心跳机制监测服务状态，每隔1秒向集群的每个实例发送ping命令：\n\n * 主观下线：如果某sentinel节点发现某实例未在规定时间响应，则认为该实例主观下线。(主观下线不一定是真正的下线了，可能由于网络阻塞等原因，导致实例访问超时)\n * 客观下线：若超过指定数量（quorum）的sentinel都认为该实例主观下线，则该实例客观下线。quorum值最好超过sentinel实例数量的一半。即多数sentinel认为主观下线。\n\n\n\n当sentinel认为实例客观下线时，就需要重新选举master节点。\n\n# 选举新的master\n\n一旦发现master故障，sentinel需要在slave中选择一个作为新的master，选择依据如下：\n\n * 首先会判断slave节点与master节点断开时间长短，如果超过指定值（down-after-milliseconds * 10）则会排除该slave节点\n * 然后判断slave节点的slave-priority值，越小优先级越高，如果是0则永不参与选举，默认为100(replica-priority)\n * 如果slave-prority一样，则判断slave节点的offset值，越大说明数据越新，优先级越高\n * 最后是判断slave节点的运行id大小，越小优先级越高。 选择好新的slave作为master后，就需要对redis集群进行故障转移\n\n# 故障转移步骤\n\n例如选中了slave1为新的master后，故障的转移的步骤如下：\n\n * sentinel给备选的slave1节点发送slaveof no one命令，让该节点成为master\n * sentinel给所有其它slave发送slaveof 192.168.150.101 7002 命令，让这些slave成为新master的从节点，开始从新的master上同步数据。\n * 最后，针对故障的节点sentinel会强制修改其对应的配置文件标记为slave，当故障节点恢复后会自动成为新的master的slave节点。\n\n如图所示，master从中间的节点变为了最左的节点，原本的master重启后变成了slave\n\n\n\n\n# 总结\n\nsentinel的作用：\n\n * 监控\n * 故障转移\n * 通知\n\nsentinel如何判断一个redis实例是否健康？\n\n * 每隔1秒发送一次ping命令，如果超过一定时间没有相向则认为是主观下线\n * 如果大多数sentinel都认为实例主观下线，则判定服务下线\n\n故障转移步骤有哪些？\n\n * 首先选定一个slave作为新的master，执行slaveof no one\n * 然后让所有节点都执行slaveof 新master\n * 修改故障节点配置，添加slaveof 新master",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"Redis持久化RDB",frontmatter:{title:"Redis持久化RDB",date:"2022-01-09T14:20:38.000Z",tags:["Java","Redis"],permalink:"/pages/2f1bf8/",categories:["分布式与中间件","Redis"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/03.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/02.Redis/04.Redis%E6%8C%81%E4%B9%85%E5%8C%96RDB.html",relativePath:"03.分布式与中间件/02.Redis/04.Redis持久化RDB.md",key:"v-34f103b2",path:"/pages/2f1bf8/",headers:[{level:3,title:"Redis持久化RDB",slug:"redis持久化rdb",normalizedTitle:"redis持久化rdb",charIndex:2},{level:4,title:"什么是RDB",slug:"什么是rdb",normalizedTitle:"什么是rdb",charIndex:71},{level:4,title:"RDB原理",slug:"rdb原理",normalizedTitle:"rdb原理",charIndex:656},{level:4,title:"写时复制技术",slug:"写时复制技术",normalizedTitle:"写时复制技术",charIndex:998},{level:4,title:"总结-RDB的优势和劣势",slug:"总结-rdb的优势和劣势",normalizedTitle:"总结-rdb的优势和劣势",charIndex:1367}],headersStr:"Redis持久化RDB 什么是RDB RDB原理 写时复制技术 总结-RDB的优势和劣势",content:"# Redis持久化RDB\n\nRedis主要包含2中持久化方式，即RDB和AOF，本文主要介绍RDB，AOF详见Redis持久化AOF\n\n# 什么是RDB\n\nRDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。 快照文件称为RDB文件，默认是保存在当前运行目录。在redis中执行save命令即可(由redis主进程执行命令，会阻塞其他所有命令)，也可以采用bgsave命令进行后台运行(使用子进程执行RDB，主进程不受影响)。 同时，服务在停机时会自动执行RDB，存储一份redis文件到本地磁盘中，当再次启动redis时，数据将从RDB自动恢复。 通常来说，RDB应该隔一段时间便执行一次，在redis.conf中可以配置相应的参数。比如\n\n# 表示900秒内，如果至少有1个key被修改，则执行bgsave\nsave 900 1  \n# 表示300秒内，如果至少有10个key被修改，则执行bgsave\nsave 300 10  \n# 是否压缩 ,建议不开启，压缩也会消耗cpu，磁盘的话不值钱\nrdbcompression yes\n# RDB文件名称\ndbfilename dump.rdb  \n# 文件保存的路径目录\ndir ./ \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# RDB原理\n\nbgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入 RDB 文件。 虽然子进程执行过程是异步的，但fork的过程是阻塞的，流程如下图所示。\n\n\n\n由于在linux系统中，进程无法直接操作物理内存，操作系统将分配虚拟内存给每个进程，并维护虚拟内存到物理内存的映射表。进程通过操作虚拟内存，虚拟内存通过页表到物理内存进行真正的读写。在子进程进行fork时，不是将物理内存的数据进行拷贝，而是复制主进程的页表，所以当子进程操作复制的页表时，其能够映射到和主进程相同的物理内存区域，从而实现子进程和主进程内存空间的共享。子进程读取内存数据，写入RDB文件，当子进程完成新RDB文件的写入时，会将旧的备份文件替换掉。\n\n# 写时复制技术\n\n思考一下，子进程是异步执行的，如果在子进程读取内存数据并写RDB的时候，主进程接受到了新的命令修改了内存中的数据，而此时子进程执行的读数据，两者是冲突的容易产生脏数据，且子进程需要同步主进程修改后的数据。为了解决这个问题的方法，redis的fork采用了写时复制技术:\n\n * 当主进程执行读操作时，访问共享内存；\n * 当主进程执行写操作时，则会拷贝一份数据，执行写操作。 具体来说fork会将共享内存标记为read-only，任何进程仅能够读数据，不能够写数据。如下图所示，\n\n\n\n假设要修改的数据是数据B，redis首先会拷贝一份数据B副本，写入时操作数据副本B，同时将页表关系读操作从读取数据B改为读取数据B的副本。在极端情况下，如果内存中的数据在RDB时都被修改过，那么此时RDB所需要的内存就会膨胀翻倍\n\n# 总结-RDB的优势和劣势\n\n优势：\n\n * 适合大规模的数据恢复\n * 对数据完整性和一致性要求不高更适合使用\n * 节省磁盘空间\n * 恢复速度快\n\n劣势：\n\n * Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑\n * 虽然Redis在fork时使用了写时拷贝技术,但是如果数据庞大时还是比较消耗性能。\n * 在备份周期在一定间隔时间做一次备份，所以如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改。",normalizedContent:"# redis持久化rdb\n\nredis主要包含2中持久化方式，即rdb和aof，本文主要介绍rdb，aof详见redis持久化aof\n\n# 什么是rdb\n\nrdb全称redis database backup file（redis数据备份文件），也被叫做redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当redis实例故障重启后，从磁盘读取快照文件，恢复数据。 快照文件称为rdb文件，默认是保存在当前运行目录。在redis中执行save命令即可(由redis主进程执行命令，会阻塞其他所有命令)，也可以采用bgsave命令进行后台运行(使用子进程执行rdb，主进程不受影响)。 同时，服务在停机时会自动执行rdb，存储一份redis文件到本地磁盘中，当再次启动redis时，数据将从rdb自动恢复。 通常来说，rdb应该隔一段时间便执行一次，在redis.conf中可以配置相应的参数。比如\n\n# 表示900秒内，如果至少有1个key被修改，则执行bgsave\nsave 900 1  \n# 表示300秒内，如果至少有10个key被修改，则执行bgsave\nsave 300 10  \n# 是否压缩 ,建议不开启，压缩也会消耗cpu，磁盘的话不值钱\nrdbcompression yes\n# rdb文件名称\ndbfilename dump.rdb  \n# 文件保存的路径目录\ndir ./ \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# rdb原理\n\nbgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入 rdb 文件。 虽然子进程执行过程是异步的，但fork的过程是阻塞的，流程如下图所示。\n\n\n\n由于在linux系统中，进程无法直接操作物理内存，操作系统将分配虚拟内存给每个进程，并维护虚拟内存到物理内存的映射表。进程通过操作虚拟内存，虚拟内存通过页表到物理内存进行真正的读写。在子进程进行fork时，不是将物理内存的数据进行拷贝，而是复制主进程的页表，所以当子进程操作复制的页表时，其能够映射到和主进程相同的物理内存区域，从而实现子进程和主进程内存空间的共享。子进程读取内存数据，写入rdb文件，当子进程完成新rdb文件的写入时，会将旧的备份文件替换掉。\n\n# 写时复制技术\n\n思考一下，子进程是异步执行的，如果在子进程读取内存数据并写rdb的时候，主进程接受到了新的命令修改了内存中的数据，而此时子进程执行的读数据，两者是冲突的容易产生脏数据，且子进程需要同步主进程修改后的数据。为了解决这个问题的方法，redis的fork采用了写时复制技术:\n\n * 当主进程执行读操作时，访问共享内存；\n * 当主进程执行写操作时，则会拷贝一份数据，执行写操作。 具体来说fork会将共享内存标记为read-only，任何进程仅能够读数据，不能够写数据。如下图所示，\n\n\n\n假设要修改的数据是数据b，redis首先会拷贝一份数据b副本，写入时操作数据副本b，同时将页表关系读操作从读取数据b改为读取数据b的副本。在极端情况下，如果内存中的数据在rdb时都被修改过，那么此时rdb所需要的内存就会膨胀翻倍\n\n# 总结-rdb的优势和劣势\n\n优势：\n\n * 适合大规模的数据恢复\n * 对数据完整性和一致性要求不高更适合使用\n * 节省磁盘空间\n * 恢复速度快\n\n劣势：\n\n * fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑\n * 虽然redis在fork时使用了写时拷贝技术,但是如果数据庞大时还是比较消耗性能。\n * 在备份周期在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改。",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"Redis持久化AOF",frontmatter:{title:"Redis持久化AOF",date:"2022-01-09T15:47:38.000Z",tags:["Java","Redis"],permalink:"/pages/c48db1/",categories:["分布式与中间件","Redis"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/03.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/02.Redis/05.Redis%E6%8C%81%E4%B9%85%E5%8C%96AOF.html",relativePath:"03.分布式与中间件/02.Redis/05.Redis持久化AOF.md",key:"v-79d665d6",path:"/pages/c48db1/",headers:[{level:3,title:"Redis持久化AOF",slug:"redis持久化aof",normalizedTitle:"redis持久化aof",charIndex:2},{level:4,title:"什么是AOF",slug:"什么是aof",normalizedTitle:"什么是aof",charIndex:78},{level:4,title:"重写原理，如何实现重写",slug:"重写原理-如何实现重写",normalizedTitle:"重写原理，如何实现重写",charIndex:985},{level:5,title:"重写流程",slug:"重写流程",normalizedTitle:"重写流程",charIndex:1327},{level:4,title:"AOF持久化流程",slug:"aof持久化流程",normalizedTitle:"aof持久化流程",charIndex:1662},{level:4,title:"总结-与RDB对比",slug:"总结-与rdb对比",normalizedTitle:"总结-与rdb对比",charIndex:1866}],headersStr:"Redis持久化AOF 什么是AOF 重写原理，如何实现重写 重写流程 AOF持久化流程 总结-与RDB对比",content:'# Redis持久化AOF\n\nRedis主要包含2中持久化方式，即RDB和AOF，本文主要介绍AOF，RDB见本站的另一篇博客Redis持久化RDB\n\n# 什么是AOF\n\nAOF全称为Append Only File（追加文件）。Redis处理的每一个写命令都会记录在AOF文件，可以看做是命令日志文件。 AOF默认是关闭的，需要修改redis.conf配置文件来开启AOF：\n\n# 是否开启AOF功能，默认是no\nappendonly yes\n# AOF文件的名称\nappendfilename "appendonly.aof"\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\nAOF的命令记录的频率也可以通过redis.conf文件来配：\n\n# 表示每执行一次写命令，立即记录到AOF文件\nappendfsync always \n# 写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案\nappendfsync everysec \n# 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘\nappendfsync no\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n配置项对比\n\n配置项        刷盘时机     优点            缺点\nAlways     同步刷盘     可靠性高，几乎不丢数据   性能影响大\neverysec   每秒刷盘     性能适中          最多丢失1秒数据\nno         操作系统控制   性能最好          可靠性较差，可能丢失大量数据\n\n因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行bgrewriteaof命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。\n\n\n\nRedis也会在触发阈值时自动去重写AOF文件。阈值也可以在redis.conf中配置：\n\n# AOF文件比上次文件 增长超过多少百分比则触发重写\nauto-aof-rewrite-percentage 100\n# AOF文件体积最小多大以上才触发重写\nauto-aof-rewrite-min-size 64mb \n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n# 重写原理，如何实现重写\n\nAOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，redis4.0版本后的重写，是指上就是把rdb 的快照，以二级制的形式附在新的aof头部，作为已有的历史数据，替换掉原来的流水账操作。 关键命令no-appendfsync-on-rewrite\n\n * 如果no-appendfsync-on-rewrite=yes,不写入aof文件只写入缓存，用户请求不会阻塞，但是在这段时间如果宕机会丢失这段时间的缓存数据。（降低数据安全性，提高性能）\n * 如果no-appendfsync-on-rewrite=no, 还是会把数据往磁盘里刷，但是遇到重写操作，可能会发生阻塞。（数据安全，但是性能降低）\n\n# 重写流程\n\n 1. bgrewriteaof触发重写，判断是否当前有bgsave或bgrewriteaof在运行，如果有，则等待该命令结束后再继续执行。\n 2. 主进程fork出子进程执行重写操作，保证主进程不会阻塞。\n 3. 子进程遍历redis内存中数据到临时文件，客户端的写请求同时写入aof_buf缓冲区和aof_rewrite_buf重写缓冲区保证原AOF文件完整以及新AOF文件生成期间的新的数据修改动作不会丢失。\n 4. (1).子进程写完新的AOF文件后，向主进程发信号，父进程更新统计信息。(2).主进程把aof_rewrite_buf中的数据写入到新的AOF文件。\n 5. 使用新的AOF文件覆盖旧的AOF文件，完成AOF重写。 如图所示\n\n\n\n# AOF持久化流程\n\n 1. 客户端的请求写命令会被append追加到AOF缓冲区内；\n 2. AOF缓冲区根据AOF持久化策略[always,everysec,no]将操作sync同步到磁盘的AOF文件中；\n 3. AOF文件大小超过重写策略或手动重写时，会对AOF文件rewrite重写，压缩AOF文件容量；\n 4. Redis服务重启时，会重新load加载AOF文件中的写操作达到数据恢复的目的；\n\n# 总结-与RDB对比\n\nRDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会结合两者来使用。\n\n          RDB                      AOF\n持久化方式     定时对整个内存做快照               记录每一次执行的命令\n数据完整性     不完整，两次备份之间会丢失            相对完整，取决于刷盘策略\n文件大小      会有压缩，文件体积小               记录命令，文件体积很大\n宕机恢复速度    很快                       慢\n数据恢复优先级   低，因为数据完整性不如AOF           高，因为数据完整性更高\n系统资源占用    高，大量CPU和内存消耗             低，主要是磁盘IO资源 但AOF重写时会占用大量CPU和内存资源\n使用场景      可以容忍数分钟的数据丢失，追求更快的启动速度   对数据安全性要求较高常见',normalizedContent:'# redis持久化aof\n\nredis主要包含2中持久化方式，即rdb和aof，本文主要介绍aof，rdb见本站的另一篇博客redis持久化rdb\n\n# 什么是aof\n\naof全称为append only file（追加文件）。redis处理的每一个写命令都会记录在aof文件，可以看做是命令日志文件。 aof默认是关闭的，需要修改redis.conf配置文件来开启aof：\n\n# 是否开启aof功能，默认是no\nappendonly yes\n# aof文件的名称\nappendfilename "appendonly.aof"\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\naof的命令记录的频率也可以通过redis.conf文件来配：\n\n# 表示每执行一次写命令，立即记录到aof文件\nappendfsync always \n# 写命令执行完先放入aof缓冲区，然后表示每隔1秒将缓冲区数据写到aof文件，是默认方案\nappendfsync everysec \n# 写命令执行完先放入aof缓冲区，由操作系统决定何时将缓冲区内容写回磁盘\nappendfsync no\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n配置项对比\n\n配置项        刷盘时机     优点            缺点\nalways     同步刷盘     可靠性高，几乎不丢数据   性能影响大\neverysec   每秒刷盘     性能适中          最多丢失1秒数据\nno         操作系统控制   性能最好          可靠性较差，可能丢失大量数据\n\n因为是记录命令，aof文件会比rdb文件大的多。而且aof会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行bgrewriteaof命令，可以让aof文件执行重写功能，用最少的命令达到相同效果。\n\n\n\nredis也会在触发阈值时自动去重写aof文件。阈值也可以在redis.conf中配置：\n\n# aof文件比上次文件 增长超过多少百分比则触发重写\nauto-aof-rewrite-percentage 100\n# aof文件体积最小多大以上才触发重写\nauto-aof-rewrite-min-size 64mb \n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n# 重写原理，如何实现重写\n\naof文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，redis4.0版本后的重写，是指上就是把rdb 的快照，以二级制的形式附在新的aof头部，作为已有的历史数据，替换掉原来的流水账操作。 关键命令no-appendfsync-on-rewrite\n\n * 如果no-appendfsync-on-rewrite=yes,不写入aof文件只写入缓存，用户请求不会阻塞，但是在这段时间如果宕机会丢失这段时间的缓存数据。（降低数据安全性，提高性能）\n * 如果no-appendfsync-on-rewrite=no, 还是会把数据往磁盘里刷，但是遇到重写操作，可能会发生阻塞。（数据安全，但是性能降低）\n\n# 重写流程\n\n 1. bgrewriteaof触发重写，判断是否当前有bgsave或bgrewriteaof在运行，如果有，则等待该命令结束后再继续执行。\n 2. 主进程fork出子进程执行重写操作，保证主进程不会阻塞。\n 3. 子进程遍历redis内存中数据到临时文件，客户端的写请求同时写入aof_buf缓冲区和aof_rewrite_buf重写缓冲区保证原aof文件完整以及新aof文件生成期间的新的数据修改动作不会丢失。\n 4. (1).子进程写完新的aof文件后，向主进程发信号，父进程更新统计信息。(2).主进程把aof_rewrite_buf中的数据写入到新的aof文件。\n 5. 使用新的aof文件覆盖旧的aof文件，完成aof重写。 如图所示\n\n\n\n# aof持久化流程\n\n 1. 客户端的请求写命令会被append追加到aof缓冲区内；\n 2. aof缓冲区根据aof持久化策略[always,everysec,no]将操作sync同步到磁盘的aof文件中；\n 3. aof文件大小超过重写策略或手动重写时，会对aof文件rewrite重写，压缩aof文件容量；\n 4. redis服务重启时，会重新load加载aof文件中的写操作达到数据恢复的目的；\n\n# 总结-与rdb对比\n\nrdb和aof各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会结合两者来使用。\n\n          rdb                      aof\n持久化方式     定时对整个内存做快照               记录每一次执行的命令\n数据完整性     不完整，两次备份之间会丢失            相对完整，取决于刷盘策略\n文件大小      会有压缩，文件体积小               记录命令，文件体积很大\n宕机恢复速度    很快                       慢\n数据恢复优先级   低，因为数据完整性不如aof           高，因为数据完整性更高\n系统资源占用    高，大量cpu和内存消耗             低，主要是磁盘io资源 但aof重写时会占用大量cpu和内存资源\n使用场景      可以容忍数分钟的数据丢失，追求更快的启动速度   对数据安全性要求较高常见',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"Redis分片集群",frontmatter:{title:"Redis分片集群",date:"2022-01-26T21:02:48.000Z",tags:["Java","Redis"],permalink:"/pages/20361f/",categories:["分布式与中间件","Redis"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/03.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/02.Redis/06.Redis%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4.html",relativePath:"03.分布式与中间件/02.Redis/06.Redis分片集群.md",key:"v-159cd9c6",path:"/pages/20361f/",headers:[{level:3,title:"Redis分片集群",slug:"redis分片集群",normalizedTitle:"redis分片集群",charIndex:2},{level:4,title:"分片集群的作用",slug:"分片集群的作用",normalizedTitle:"分片集群的作用",charIndex:148},{level:4,title:"散列插槽",slug:"散列插槽",normalizedTitle:"散列插槽",charIndex:417}],headersStr:"Redis分片集群 分片集群的作用 散列插槽",content:'# Redis分片集群\n\n分片集群是将多个Redis主从结构联合起来，每个主从结构具有一个主实例和多个从实例。Redis的分片集群可以在数据量不断增大的情况下进行水平扩容，将键值放在指定的实例中，以此来降低系统对单主节点的依赖，从而提高Redis服务的读写性能。分片集群的结构图如下。\n\n\n\n# 分片集群的作用\n\n主从和哨兵可以解决高可用、高并发读的问题。但是依然有两个问题没有解决：\n\n * 海量数据存储问题\n * 高并发写的问题 哨兵模式本质是依旧是主从模式，在主从模式下我们可以增加slave节点来拓展读并发能力，但是没办法扩展写能力和存储能力。 使用分片集群可以解决上述问题，分片集群特征：\n * 集群中有多个master，每个master保存不同数据\n * 每个master都可以有多个slave节点\n * master之间通过ping监测彼此健康状态\n * 客户端请求可以访问集群任意节点，最终都会被转发到正确节点\n\n# 散列插槽\n\nRedis会把每一个master节点映射到0~16383共16384个插槽(hash slot)上。哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中，具体执行过程分为两大步：\n\n * 根据键值对的key，按照CRC16算法计算一个16bit的值\n * 再用16bit值对16384取模，得到0~16383范围内的模数，每个模数代表一个相应编号的哈希槽 每个Redis节点负责处理一部分槽位，假如集群中有master节点ABC，每个节点负责的槽位范围如下：\n\nMASTER节点   处理槽位\nA          0-5460\nB          5461-10922\nC          10923-16383\n\n查看集群信息时就能看到：\n\n\n\n注意，数据key不是与节点绑定，而是与插槽绑定。这样绑定的好处是，当集群发生扩容增加节点或者宕机减少了master节点，Redis能够更加方便的将插槽转移到仍然存活的节点上，数据跟随插槽转移，使得我们能够找到原本数据所在的位置。Redis会根据key的有效部分计算插槽值，分两种情况：\n\n * key中包含"{}"，且"{}"中至少包含1个字符，"{}"中的部分是有效部分\n\n * key中不包含"{}"，整个key都是有效部分\n\n第一种情况可以应对如下问题\n\n如何将同一类数据固定的保存在同一个Redis实例？\n\n这一类数据使用相同的有效部分，例如key都以{typeId}为前缀[/card] 例如：key是num，那么就根据num计算，如果是{test}num，则根据test计算。计算方式是利用CRC16算法得到一个hash值，然后对16384取余，得到的结果就是slot值。\n\n\n\n如上图所示，当连接7001节点时，存入num为key的数据正好散列在7001，看起来操作没有变化。当存入a为key的数据时，它散列在了7003节点上，可以看到重定向的消息。此时已经定向到了7003节点，在该节点获取7001节点存入的num时，又会重定向到7001节点。 需要注意的是：集群操作时，需要给redis-cli加上-c参数才可以，如redis-cli -c -p 7001，否则set方法会报如下错误\n\n',normalizedContent:'# redis分片集群\n\n分片集群是将多个redis主从结构联合起来，每个主从结构具有一个主实例和多个从实例。redis的分片集群可以在数据量不断增大的情况下进行水平扩容，将键值放在指定的实例中，以此来降低系统对单主节点的依赖，从而提高redis服务的读写性能。分片集群的结构图如下。\n\n\n\n# 分片集群的作用\n\n主从和哨兵可以解决高可用、高并发读的问题。但是依然有两个问题没有解决：\n\n * 海量数据存储问题\n * 高并发写的问题 哨兵模式本质是依旧是主从模式，在主从模式下我们可以增加slave节点来拓展读并发能力，但是没办法扩展写能力和存储能力。 使用分片集群可以解决上述问题，分片集群特征：\n * 集群中有多个master，每个master保存不同数据\n * 每个master都可以有多个slave节点\n * master之间通过ping监测彼此健康状态\n * 客户端请求可以访问集群任意节点，最终都会被转发到正确节点\n\n# 散列插槽\n\nredis会把每一个master节点映射到0~16383共16384个插槽(hash slot)上。哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中，具体执行过程分为两大步：\n\n * 根据键值对的key，按照crc16算法计算一个16bit的值\n * 再用16bit值对16384取模，得到0~16383范围内的模数，每个模数代表一个相应编号的哈希槽 每个redis节点负责处理一部分槽位，假如集群中有master节点abc，每个节点负责的槽位范围如下：\n\nmaster节点   处理槽位\na          0-5460\nb          5461-10922\nc          10923-16383\n\n查看集群信息时就能看到：\n\n\n\n注意，数据key不是与节点绑定，而是与插槽绑定。这样绑定的好处是，当集群发生扩容增加节点或者宕机减少了master节点，redis能够更加方便的将插槽转移到仍然存活的节点上，数据跟随插槽转移，使得我们能够找到原本数据所在的位置。redis会根据key的有效部分计算插槽值，分两种情况：\n\n * key中包含"{}"，且"{}"中至少包含1个字符，"{}"中的部分是有效部分\n\n * key中不包含"{}"，整个key都是有效部分\n\n第一种情况可以应对如下问题\n\n如何将同一类数据固定的保存在同一个redis实例？\n\n这一类数据使用相同的有效部分，例如key都以{typeid}为前缀[/card] 例如：key是num，那么就根据num计算，如果是{test}num，则根据test计算。计算方式是利用crc16算法得到一个hash值，然后对16384取余，得到的结果就是slot值。\n\n\n\n如上图所示，当连接7001节点时，存入num为key的数据正好散列在7001，看起来操作没有变化。当存入a为key的数据时，它散列在了7003节点上，可以看到重定向的消息。此时已经定向到了7003节点，在该节点获取7001节点存入的num时，又会重定向到7001节点。 需要注意的是：集群操作时，需要给redis-cli加上-c参数才可以，如redis-cli -c -p 7001，否则set方法会报如下错误\n\n',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"事务的特性、CAP定理、BASE理论",frontmatter:{title:"事务的特性、CAP定理、BASE理论",date:"2022-02-20T21:25:48.000Z",categories:["Java"],tags:["Java","事务"],permalink:"/pages/aaed8c/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/03.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/03.%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/01.%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%89%B9%E6%80%A7%E3%80%81CAP%E5%AE%9A%E7%90%86%E3%80%81BASE%E7%90%86%E8%AE%BA.html",relativePath:"03.分布式与中间件/03.分布式事务/01.事务的特性、CAP定理、BASE理论.md",key:"v-9a7ceb4e",path:"/pages/aaed8c/",headers:[{level:3,title:"事务的四大特性(ACID)",slug:"事务的四大特性-acid",normalizedTitle:"事务的四大特性(acid)",charIndex:2},{level:3,title:"CAP定理",slug:"cap定理",normalizedTitle:"cap定理",charIndex:259},{level:3,title:"BASE理论",slug:"base理论",normalizedTitle:"base理论",charIndex:569}],headersStr:"事务的四大特性(ACID) CAP定理 BASE理论",content:"# 事务的四大特性(ACID)\n\n * 原子性(Atomicity):事务中的所有操作，要么全部成功，要么全部失败\n * 一致性(Consistency):事务前后数据的完整性必须保持一致\n * 隔离性(Isolation):事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。\n * 持久性(Durability):持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响\n\n\n# CAP定理\n\n分布式系统有三个指标\n\n * Consistency(一致性)：用户访问分布式系统中的任意节点，得到的数据必须一致\n * Availability(可用性)：用户访问集群中的任意健康节点，必须能得到响应，而不是超时或拒绝\n * Partition tolerance(分区容错性)：因为网络故障或其它原因导致分布式系统中的部分节点与其它节点失去连接，形成独立分区。在集群出现分区时，整个系统也要持续对外提供服务 分布式系统无法同时满足这三个指标。分布式系统节点通过网络连接，一定会出现分区问题(P)，当分区出现时，系统的一致性(C)和可用性(A)就无法同时满足，这个结论就叫做 CAP 定理。\n\n\n\n\n# BASE理论\n\nBASE理论是对CAP的一种解决思路，包含三个思想：\n\n * Basically Available(基本可用)：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。\n * Soft State(软状态)：在一定时间内，允许出现中间状态，比如临时的不一致状态。\n * Eventually Consistent(最终一致性)：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致。\n\n而分布式事务最大的问题是各个子事务的一致性问题，因此可以借鉴CAP定理和BASE理论： AP模式：各子事务分别执行和提交，允许出现结果不一致，然后采用弥补措施恢复数据即可，实现最终一致。 CP模式：各个子事务执行后互相等待，同时提交，同时回滚，达成强一致。但事务等待过程中，处于弱可用状态。",normalizedContent:"# 事务的四大特性(acid)\n\n * 原子性(atomicity):事务中的所有操作，要么全部成功，要么全部失败\n * 一致性(consistency):事务前后数据的完整性必须保持一致\n * 隔离性(isolation):事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。\n * 持久性(durability):持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响\n\n\n# cap定理\n\n分布式系统有三个指标\n\n * consistency(一致性)：用户访问分布式系统中的任意节点，得到的数据必须一致\n * availability(可用性)：用户访问集群中的任意健康节点，必须能得到响应，而不是超时或拒绝\n * partition tolerance(分区容错性)：因为网络故障或其它原因导致分布式系统中的部分节点与其它节点失去连接，形成独立分区。在集群出现分区时，整个系统也要持续对外提供服务 分布式系统无法同时满足这三个指标。分布式系统节点通过网络连接，一定会出现分区问题(p)，当分区出现时，系统的一致性(c)和可用性(a)就无法同时满足，这个结论就叫做 cap 定理。\n\n\n\n\n# base理论\n\nbase理论是对cap的一种解决思路，包含三个思想：\n\n * basically available(基本可用)：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。\n * soft state(软状态)：在一定时间内，允许出现中间状态，比如临时的不一致状态。\n * eventually consistent(最终一致性)：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致。\n\n而分布式事务最大的问题是各个子事务的一致性问题，因此可以借鉴cap定理和base理论： ap模式：各子事务分别执行和提交，允许出现结果不一致，然后采用弥补措施恢复数据即可，实现最终一致。 cp模式：各个子事务执行后互相等待，同时提交，同时回滚，达成强一致。但事务等待过程中，处于弱可用状态。",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"分布式事务XA、AT、TCC、SAGA",frontmatter:{title:"分布式事务XA、AT、TCC、SAGA",date:"2022-02-20T21:40:48.000Z",categories:["Java"],tags:["Java","事务","分布式事务","Seata","XA","TCC","AT","SAGA"],permalink:"/pages/e8a7fb/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/03.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/03.%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1XA%E3%80%81AT%E3%80%81TCC%E3%80%81SAGA.html",relativePath:"03.分布式与中间件/03.分布式事务/02.分布式事务XA、AT、TCC、SAGA.md",key:"v-72ef87c1",path:"/pages/e8a7fb/",headers:[{level:3,title:"分布式事务",slug:"分布式事务",normalizedTitle:"分布式事务",charIndex:2},{level:3,title:"问题背景",slug:"问题背景",normalizedTitle:"问题背景",charIndex:12},{level:4,title:"分布式事务模型",slug:"分布式事务模型",normalizedTitle:"分布式事务模型",charIndex:118},{level:4,title:"Seata分布式事务架构",slug:"seata分布式事务架构",normalizedTitle:"seata分布式事务架构",charIndex:376},{level:4,title:"XA模式原理",slug:"xa模式原理",normalizedTitle:"xa模式原理",charIndex:933},{level:5,title:"XA模式总结",slug:"xa模式总结",normalizedTitle:"xa模式总结",charIndex:1450},{level:4,title:"AT模式原理",slug:"at模式原理",normalizedTitle:"at模式原理",charIndex:1565},{level:5,title:"AT模式总结",slug:"at模式总结",normalizedTitle:"at模式总结",charIndex:1961},{level:4,title:"TCC模式原理",slug:"tcc模式原理",normalizedTitle:"tcc模式原理",charIndex:2209},{level:5,title:"TCC模式总结",slug:"tcc模式总结",normalizedTitle:"tcc模式总结",charIndex:2546},{level:4,title:"SAGA模式",slug:"saga模式",normalizedTitle:"saga模式",charIndex:911},{level:4,title:"四种模式对比",slug:"四种模式对比",normalizedTitle:"四种模式对比",charIndex:3104}],headersStr:"分布式事务 问题背景 分布式事务模型 Seata分布式事务架构 XA模式原理 XA模式总结 AT模式原理 AT模式总结 TCC模式原理 TCC模式总结 SAGA模式 四种模式对比",content:"# 分布式事务\n\n\n# 问题背景\n\n假设系统中有3个服务，分别是订单服务、账户服务、库存服务，用户在下一个订单之后会扣除用户的余额，同时扣减库存容量。在这样的场景下扣款和扣库存需要强一致性保证。就可能会使用到分布式事务解决方案。\n\n# 分布式事务模型\n\n解决分布式事务，各个子系统之间必须能感知到彼此的事务状态，才能保证状态一致，因此需要一个事务协调者来协调每一个事务的参与者（子系统事务）。这里的子系统事务，称为分支事务；有关联的各个分支事务在一起称为全局事务\n\n\n\n名词解析：\n\n * 全局事务：整个分布式事务\n * 分支事务：分布式事务中包含的每个子系统的事务\n * 最终一致性：各分支事务分别执行并提交，如果有不一致的情况，想办法补偿恢复，达到数据的最终一致性\n * 强一致性：各事务执行完业务不要提交，等待彼此结束，之后统一提交或回滚\n\n# Seata分布式事务架构\n\nSeata事务管理中有三个重要的角色：\n\n * TC(Transaction Coordinator)-事务协调者：维护全局和分支事务的状态，协调全局事务提交或回滚。\n * TM(Transaction Manager)-事务管理器：定义全局事务的范围、开始全局事务、提交或回滚全局事务。\n * RM(Resource Manager)-资源管理器：管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。\n\n\n\nTM会首先注册全局事务，之后业务调用各个微服务，由各自的RM向TC发起分支事务的注册，之后执行各个分支事务的sql，执行完毕之后RM会向TC报告分支事务的状态，所有分支事务执行完毕之后，TM向TC发起提交或回滚全局事务，此时TC会检查分支事务的状态来决定是提交还是回滚发送给RM。 以上只是Seata分布式事务的基本模型。 Seata提供了4中不同的分布式事务解决方案：\n\n * XA模式：强一致性分阶段事务模式，牺牲了一定的可用性，无业务侵入\n * TCC模式：最终一致的分阶段事务模式，有业务侵入\n * AT模式：最终一致的分阶段事务模式，无业务侵入，也是Seata的默认模式\n * SAGA模式：长事务模式，有业务侵入\n\n# XA模式原理\n\nXA规范是X/Open组织定义的分布式事务处理(DTP，Distributed Transaction Processing)标准，XA规范描述了全局的TM与局部的RM之间的接口，几乎所有主流的数据库都对XA规范提供了支持。 标准的XA模式为两阶段提交：\n\n * 第一阶段由事务协调者向RM(XA模式下一般由数据库实现)发起事务准备请求，RM执行完毕之后，并不直接提交事务，而是将执行的结果告知事务协调者。\n * 第二阶段由事务协调者判断RM的返回结果，如果分支事务都成功了，向RM发起提交请求，RM执行事务提交并返回已提交请求 具体过程如下图所示\n\n\n\n但是，如果在事务执行过程中有一个失败了，事务协调者则会回滚所有已执行事务\n\n\n\nSeata在实现XA模式时进行了一定的调整，但大体上相似： RM一阶段工作：\n\n 1. 注册分支事务到TC\n 2. 执行分支业务SQL但不提交\n 3. 报告执行状态到TC\n\nTC二阶段工作：\n\n * TC检测各分支事务执行状态\n\n 1. 如果都成功，通知所有RM提交事务\n 2. 如果有失败，通知所有RM回滚事务\n\nRM二阶段工作：\n\n * 接受TC指令，提交或回滚事务\n\n\n\n# XA模式总结\n\n优点：\n\n * 事务强一致性，满足ACID原则\n * 常用数据库都支持，实现简单，没有代码侵入 缺点：\n * 因为一阶段需要锁定数据库资源，等待二阶段结束才释放，所以性能较差\n * 依赖关系型数据库实现事务\n\n# AT模式原理\n\nAT模式同样是分阶段提交的事务模型，不过缺弥补了XA模型中资源锁定周期过长的缺陷。\n\n\n\nAT模式在执行完sql之后会直接提交事务，而不是进行等待，在执行的同时RM拦截本次执行，记录更新前后的快照到数据库的undo_log中。与XA的不同之处在于 阶段一RM的工作：\n\n * 注册分支事务\n * 记录undo-log(数据快照)\n * 执行业务sql并提交\n * 报告事务状态\n\n阶段二提交时RM的工作：\n\n * 删除undo-log即可\n\n阶段二回滚时RM的工作：\n\n * 根据undo-log回复数据到更新前\n\n具体案例：例如，一个分支业务的SQL是这样的：update tb_account set money = money - 10 where id = 1\n\n\n\n如果这条sql执行成功，那么money字段自然是90，如果执行失败，则根据数据快照恢复数据。\n\n# AT模式总结\n\n与XA模式最大的区别是：\n\n * XA模式一阶段不提交事务，锁定资源；AT模式一阶段直接提交，不锁定资源。\n * XA模式依赖数据库机制实现回滚；AT模式利用数据快照实现数据回滚。\n * XA模式强一致；AT模式最终一致\n\n优点：\n\n * 一阶段完成直接提交事务，释放数据库资源，性能比较好\n * 利用全局锁实现读写隔离\n * 没有代码侵入，框架自动完成回滚和提交\n\n缺点：\n\n * 两阶段之间属于软状态，属于最终一致\n * 框架的快照功能会影响性能，但比XA模式要好很多\n\n# TCC模式原理\n\nTCC模式与AT模式非常相似，每阶段都是独立事务，不同的是TCC通过人工编码来实现数据恢复。需要实现三个方法：\n\n * Try：资源的检测和预留；\n * Confirm：完成资源操作业务；要求Try成功Confirm一定要能成功。\n * Cancel：预留资源释放，可以理解为Try的反向操作。 举例，一个扣减用户余额的业务。假设账户A原来余额是100，需要余额扣减30元。\n * 阶段一(Try): 检查余额是否充足，如果充足则冻结金额增加30元，可用余额扣除30\n\n\n * 阶段二：假如要提交（Confirm），则冻结金额扣减30\n\n\n * 阶段三：如果要回滚（Cancel），则冻结金额扣减30，可用余额增加30\n\n\n\nTCC工作模型图：\n\n\n\n# TCC模式总结\n\nTCC模式的每个阶段是做什么的？\n\n * Try：资源检查和预留\n * Confirm：业务执行和提交\n * Cancel：预留资源的释放\n\nTCC的优点是什么？\n\n * 一阶段完成直接提交事务，释放数据库资源，性能好\n * 相比AT模型，无需生成快照，无需使用全局锁，性能最强\n * 不依赖数据库事务，而是依赖补偿操作，可以用于非事务型数据库\n\nTCC的缺点是什么？\n\n * 有代码侵入，需要人为编写try、Confirm和Cancel接口\n * 软状态，事务是最终一致\n * 需要考虑Confirm和Cancel的失败情况，做好幂等处理\n\n# SAGA模式\n\nSaga模式是SEATA提供的长事务解决方案。也分为两个阶段：\n\n * 一阶段：直接提交本地事务(TCC是预留)\n * 二阶段：成功则什么都不做；失败则通过编写补偿业务来回滚\n\nSaga模式优点：\n\n * 事务参与者可以基于事件驱动实现异步调用，吞吐高\n * 一阶段直接提交事务，无锁，性能好\n * 不用编写TCC中的三个阶段，实现简单\n\n缺点：\n\n * 软状态持续时间不确定，时效性差\n * 没有锁，没有事务隔离，会有脏写 如图所示，SAGA模式下，事务一旦有一个出现问题，则反向按照事务调用顺序进行补偿，从而保证一致性\n\n\n\n# 四种模式对比\n\n-      XA                AT                       TCC                         SAGA\n一致性    强一致               弱一致                      弱一致                         最终一致\n隔离性    完全隔离              基于全局锁隔离                  基于资源预留隔离                    无隔离\n代码侵入   无                 无                        有，需要编写3个接口                  有，需要编写状态机和补偿业务\n性能     差                 好                        非常好                         非常好\n场景     对一致性、隔离性有高要求的业务   基于关系型数据库的大多数分布式事务场景都可以   对性能要求较高的事务；有非关系型数据库要参与的事务   业务流程长、业务流程多；参与者包含其它公司或遗留系统服务，无法提供TCC模式要求的三个接口",normalizedContent:"# 分布式事务\n\n\n# 问题背景\n\n假设系统中有3个服务，分别是订单服务、账户服务、库存服务，用户在下一个订单之后会扣除用户的余额，同时扣减库存容量。在这样的场景下扣款和扣库存需要强一致性保证。就可能会使用到分布式事务解决方案。\n\n# 分布式事务模型\n\n解决分布式事务，各个子系统之间必须能感知到彼此的事务状态，才能保证状态一致，因此需要一个事务协调者来协调每一个事务的参与者（子系统事务）。这里的子系统事务，称为分支事务；有关联的各个分支事务在一起称为全局事务\n\n\n\n名词解析：\n\n * 全局事务：整个分布式事务\n * 分支事务：分布式事务中包含的每个子系统的事务\n * 最终一致性：各分支事务分别执行并提交，如果有不一致的情况，想办法补偿恢复，达到数据的最终一致性\n * 强一致性：各事务执行完业务不要提交，等待彼此结束，之后统一提交或回滚\n\n# seata分布式事务架构\n\nseata事务管理中有三个重要的角色：\n\n * tc(transaction coordinator)-事务协调者：维护全局和分支事务的状态，协调全局事务提交或回滚。\n * tm(transaction manager)-事务管理器：定义全局事务的范围、开始全局事务、提交或回滚全局事务。\n * rm(resource manager)-资源管理器：管理分支事务处理的资源，与tc交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。\n\n\n\ntm会首先注册全局事务，之后业务调用各个微服务，由各自的rm向tc发起分支事务的注册，之后执行各个分支事务的sql，执行完毕之后rm会向tc报告分支事务的状态，所有分支事务执行完毕之后，tm向tc发起提交或回滚全局事务，此时tc会检查分支事务的状态来决定是提交还是回滚发送给rm。 以上只是seata分布式事务的基本模型。 seata提供了4中不同的分布式事务解决方案：\n\n * xa模式：强一致性分阶段事务模式，牺牲了一定的可用性，无业务侵入\n * tcc模式：最终一致的分阶段事务模式，有业务侵入\n * at模式：最终一致的分阶段事务模式，无业务侵入，也是seata的默认模式\n * saga模式：长事务模式，有业务侵入\n\n# xa模式原理\n\nxa规范是x/open组织定义的分布式事务处理(dtp，distributed transaction processing)标准，xa规范描述了全局的tm与局部的rm之间的接口，几乎所有主流的数据库都对xa规范提供了支持。 标准的xa模式为两阶段提交：\n\n * 第一阶段由事务协调者向rm(xa模式下一般由数据库实现)发起事务准备请求，rm执行完毕之后，并不直接提交事务，而是将执行的结果告知事务协调者。\n * 第二阶段由事务协调者判断rm的返回结果，如果分支事务都成功了，向rm发起提交请求，rm执行事务提交并返回已提交请求 具体过程如下图所示\n\n\n\n但是，如果在事务执行过程中有一个失败了，事务协调者则会回滚所有已执行事务\n\n\n\nseata在实现xa模式时进行了一定的调整，但大体上相似： rm一阶段工作：\n\n 1. 注册分支事务到tc\n 2. 执行分支业务sql但不提交\n 3. 报告执行状态到tc\n\ntc二阶段工作：\n\n * tc检测各分支事务执行状态\n\n 1. 如果都成功，通知所有rm提交事务\n 2. 如果有失败，通知所有rm回滚事务\n\nrm二阶段工作：\n\n * 接受tc指令，提交或回滚事务\n\n\n\n# xa模式总结\n\n优点：\n\n * 事务强一致性，满足acid原则\n * 常用数据库都支持，实现简单，没有代码侵入 缺点：\n * 因为一阶段需要锁定数据库资源，等待二阶段结束才释放，所以性能较差\n * 依赖关系型数据库实现事务\n\n# at模式原理\n\nat模式同样是分阶段提交的事务模型，不过缺弥补了xa模型中资源锁定周期过长的缺陷。\n\n\n\nat模式在执行完sql之后会直接提交事务，而不是进行等待，在执行的同时rm拦截本次执行，记录更新前后的快照到数据库的undo_log中。与xa的不同之处在于 阶段一rm的工作：\n\n * 注册分支事务\n * 记录undo-log(数据快照)\n * 执行业务sql并提交\n * 报告事务状态\n\n阶段二提交时rm的工作：\n\n * 删除undo-log即可\n\n阶段二回滚时rm的工作：\n\n * 根据undo-log回复数据到更新前\n\n具体案例：例如，一个分支业务的sql是这样的：update tb_account set money = money - 10 where id = 1\n\n\n\n如果这条sql执行成功，那么money字段自然是90，如果执行失败，则根据数据快照恢复数据。\n\n# at模式总结\n\n与xa模式最大的区别是：\n\n * xa模式一阶段不提交事务，锁定资源；at模式一阶段直接提交，不锁定资源。\n * xa模式依赖数据库机制实现回滚；at模式利用数据快照实现数据回滚。\n * xa模式强一致；at模式最终一致\n\n优点：\n\n * 一阶段完成直接提交事务，释放数据库资源，性能比较好\n * 利用全局锁实现读写隔离\n * 没有代码侵入，框架自动完成回滚和提交\n\n缺点：\n\n * 两阶段之间属于软状态，属于最终一致\n * 框架的快照功能会影响性能，但比xa模式要好很多\n\n# tcc模式原理\n\ntcc模式与at模式非常相似，每阶段都是独立事务，不同的是tcc通过人工编码来实现数据恢复。需要实现三个方法：\n\n * try：资源的检测和预留；\n * confirm：完成资源操作业务；要求try成功confirm一定要能成功。\n * cancel：预留资源释放，可以理解为try的反向操作。 举例，一个扣减用户余额的业务。假设账户a原来余额是100，需要余额扣减30元。\n * 阶段一(try): 检查余额是否充足，如果充足则冻结金额增加30元，可用余额扣除30\n\n\n * 阶段二：假如要提交（confirm），则冻结金额扣减30\n\n\n * 阶段三：如果要回滚（cancel），则冻结金额扣减30，可用余额增加30\n\n\n\ntcc工作模型图：\n\n\n\n# tcc模式总结\n\ntcc模式的每个阶段是做什么的？\n\n * try：资源检查和预留\n * confirm：业务执行和提交\n * cancel：预留资源的释放\n\ntcc的优点是什么？\n\n * 一阶段完成直接提交事务，释放数据库资源，性能好\n * 相比at模型，无需生成快照，无需使用全局锁，性能最强\n * 不依赖数据库事务，而是依赖补偿操作，可以用于非事务型数据库\n\ntcc的缺点是什么？\n\n * 有代码侵入，需要人为编写try、confirm和cancel接口\n * 软状态，事务是最终一致\n * 需要考虑confirm和cancel的失败情况，做好幂等处理\n\n# saga模式\n\nsaga模式是seata提供的长事务解决方案。也分为两个阶段：\n\n * 一阶段：直接提交本地事务(tcc是预留)\n * 二阶段：成功则什么都不做；失败则通过编写补偿业务来回滚\n\nsaga模式优点：\n\n * 事务参与者可以基于事件驱动实现异步调用，吞吐高\n * 一阶段直接提交事务，无锁，性能好\n * 不用编写tcc中的三个阶段，实现简单\n\n缺点：\n\n * 软状态持续时间不确定，时效性差\n * 没有锁，没有事务隔离，会有脏写 如图所示，saga模式下，事务一旦有一个出现问题，则反向按照事务调用顺序进行补偿，从而保证一致性\n\n\n\n# 四种模式对比\n\n-      xa                at                       tcc                         saga\n一致性    强一致               弱一致                      弱一致                         最终一致\n隔离性    完全隔离              基于全局锁隔离                  基于资源预留隔离                    无隔离\n代码侵入   无                 无                        有，需要编写3个接口                  有，需要编写状态机和补偿业务\n性能     差                 好                        非常好                         非常好\n场景     对一致性、隔离性有高要求的业务   基于关系型数据库的大多数分布式事务场景都可以   对性能要求较高的事务；有非关系型数据库要参与的事务   业务流程长、业务流程多；参与者包含其它公司或遗留系统服务，无法提供tcc模式要求的三个接口",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"分布式事务AT模式的脏写问题",frontmatter:{title:"分布式事务AT模式的脏写问题",date:"2022-02-23T22:24:48.000Z",categories:["Java"],tags:["Java","事务","分布式事务","AT"],permalink:"/pages/81dbd1/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/03.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/03.%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/03.%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1AT%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%84%8F%E5%86%99%E9%97%AE%E9%A2%98.html",relativePath:"03.分布式与中间件/03.分布式事务/03.分布式事务AT模式的脏写问题.md",key:"v-f7e5f00a",path:"/pages/81dbd1/",headers:[{level:3,title:"分布式事务AT模式的脏写问题",slug:"分布式事务at模式的脏写问题",normalizedTitle:"分布式事务at模式的脏写问题",charIndex:2},{level:4,title:"AT模式原理",slug:"at模式原理",normalizedTitle:"at模式原理",charIndex:20},{level:4,title:"AT模式的脏写问题",slug:"at模式的脏写问题",normalizedTitle:"at模式的脏写问题",charIndex:7},{level:4,title:"AT模式的写隔离机制",slug:"at模式的写隔离机制",normalizedTitle:"at模式的写隔离机制",charIndex:860},{level:5,title:"两个事务都被Seata管理的情况",slug:"两个事务都被seata管理的情况",normalizedTitle:"两个事务都被seata管理的情况",charIndex:1012},{level:5,title:"仅有一个事务被Seata管理，另一个非Seata管理",slug:"仅有一个事务被seata管理-另一个非seata管理",normalizedTitle:"仅有一个事务被seata管理，另一个非seata管理",charIndex:1688}],headersStr:"分布式事务AT模式的脏写问题 AT模式原理 AT模式的脏写问题 AT模式的写隔离机制 两个事务都被Seata管理的情况 仅有一个事务被Seata管理，另一个非Seata管理",content:'# 分布式事务AT模式的脏写问题\n\n# AT模式原理\n\n首先回顾一下AT模式的原理 AT模式同样是分阶段提交的事务模型，不过缺弥补了XA模型中资源锁定周期过长的缺陷。\n\n\n\nAT模式在执行完sql之后会直接提交事务，而不是进行等待，在执行的同时RM拦截本次执行，记录更新前后的快照到数据库的undo_log中。与XA的不同之处在于 阶段一RM的工作：\n\n * 注册分支事务\n * 记录undo-log(数据快照)\n * 执行业务sql并提交\n * 报告事务状态\n\n阶段二提交时RM的工作：\n\n * 删除undo-log即可\n\n阶段二回滚时RM的工作：\n\n * 根据undo-log回复数据到更新前\n\n具体案例：例如，一个分支业务的SQL是这样的：update tb_account set money = money - 10 where id = 1\n\n\n\n如果这条sql执行成功，那么money字段自然是90，如果执行失败，则根据数据快照恢复数据。\n\n# AT模式的脏写问题\n\n如前文所提，AT模式的性能好是因为执行完SQL之后会直接提交事务，但由于这个原因AT模式在并发情况下可能会出现安全性问题。接下来通过一个例子详细解释 比如当前有一张表，内容为id=1，money=100，业务是修改当前余额减10\n\n\n\n此时有一个线程1开始执行业务，按照左图中事务1的1.1-1.3顺序执行，同一时刻线程2也开始执行业务，但由于事务1中持有DB锁，事务2必须等待，直到事务1释放锁。当事务1执行完毕之后，此时的money被修改为90，事务2按照右图1.1-1.3步骤执行。假设此时，事务1发生异常，按照AT模式的要求需要按照数据快照进行回滚，而此时的事务的快照为money=100，执行左图的2.1步骤，将会使事务1和事务2的操作什么都没有发生，等于事务2付款成功，但没有真正的扣除余额。这就出现了问题。\n\n\n\n发生上面这种问题的根本原因就是因为，事务之间没有做到隔离，如果说能做到隔离性，那么就不会存在这种问题。\n\n# AT模式的写隔离机制\n\n为了解决这个问题AT模式引入了全局锁 [card title="全局锁" color="info"]全局锁即是由TC记录当前正在操作某行数据的事务，该事务持有全局锁，具备执行权。[/card] 全局锁是由数据表实现，包含事务的xid，操作的表名table，操作行的主键pk\n\n# 两个事务都被Seata管理的情况\n\n分两种情况讨论： 第一种情况——两个事务都被Seata管理 下图展示了，引入全局锁之后事务的执行过程\n\n\n\n还是和之前一样的过程，这次当事务1执行完毕业务sql之后，会获取全局锁，提交完事务之后，将DB锁释放掉。事务2进行业务sql执行，尝试获取全局锁，但此时全局锁由事务1持有。假设此时，事务1发生了异常需要回滚，事务1会尝试获取DB锁，但这时候的DB锁被事务2持有，于是就出现了，事务1等待事务2释放DB锁，事务2等待事务1释放全局锁，形成了死锁关系。在AT模式下，尝试获取全局锁会默认重试30次，每10ms进行一次重试，当死锁发生了，事务2长时间获取不到全局锁，任务就会超时，事务2会进行回滚并释放DB锁。也就是说事务2的操作失败了，此时事务1可以重新拿到DB锁进行快照恢复，money重新回到了100，恢复快照之后，事务1释放全局锁即可。这一次事务2并没有执行成功，保证了数据的一致性。 [card title="与XA模式的区别" color="danger"]到这里看起来和XA模式就很像了，在高度竞争的情况下，同样需要锁，但区别点在于，XA模式下执行完毕SQL后并不提交事务，持有的是数据库锁，而在AT模式下，全局锁是由TC实现。数据库锁不释放，那么任何其他操作都会被互斥等待。TC是由Seata管理，假设此时有另外的一个事务，不被Seata管理，仅仅是操作这个表中的其他字段，这时由于AT模式执行完SQL就会提交事务释放数据库锁，此时并不会产生互斥等待，这是XA模式所做不到的。[/card]\n\n# 仅有一个事务被Seata管理，另一个非Seata管理\n\n第二种情况——一个事务被Seata管理，另一个非Seata管理 上面这个假设是非Seata管理的事务(以下称为事务2)操作的字段和事务1不同的情况，但如果当事务2操作的和事务1相同时，那不又出现脏写问题了吗，虽然这个概率很低，但依然是有可能发生的。\n\n\n\n如图所示，事务1依旧按照1.1-1.3执行，在释放了DB锁之后，事务2开始执行。事务2执行完SQL之后，由于其并非由Seata管理，所以1.2之后不需要获取全局锁，直接提交事务释放DB锁。我们依旧假设此时事务1发生异常需要回滚，按照数据快照来看，事务1记录的money是100，而当事务2执行完毕之后money已经变为了80，此时如果直接回滚，那么又发生了脏写问题。 为了防止这个问题，Seata在保存快照时实际上会记录2份快照，一份是修改之前的快照，一份是修改之后的快照，在恢复快照数据时，会将更新后的快照值90和当前数据库的实际值80进行比对(类似CAS过程)，如果数值不匹配则说明在此期间有另外的事务修改了数据，此时直接释放全局锁，事务1记录异常，发送告警信息让人工介入。如果一致则恢复数据，释放全局锁即可。',normalizedContent:'# 分布式事务at模式的脏写问题\n\n# at模式原理\n\n首先回顾一下at模式的原理 at模式同样是分阶段提交的事务模型，不过缺弥补了xa模型中资源锁定周期过长的缺陷。\n\n\n\nat模式在执行完sql之后会直接提交事务，而不是进行等待，在执行的同时rm拦截本次执行，记录更新前后的快照到数据库的undo_log中。与xa的不同之处在于 阶段一rm的工作：\n\n * 注册分支事务\n * 记录undo-log(数据快照)\n * 执行业务sql并提交\n * 报告事务状态\n\n阶段二提交时rm的工作：\n\n * 删除undo-log即可\n\n阶段二回滚时rm的工作：\n\n * 根据undo-log回复数据到更新前\n\n具体案例：例如，一个分支业务的sql是这样的：update tb_account set money = money - 10 where id = 1\n\n\n\n如果这条sql执行成功，那么money字段自然是90，如果执行失败，则根据数据快照恢复数据。\n\n# at模式的脏写问题\n\n如前文所提，at模式的性能好是因为执行完sql之后会直接提交事务，但由于这个原因at模式在并发情况下可能会出现安全性问题。接下来通过一个例子详细解释 比如当前有一张表，内容为id=1，money=100，业务是修改当前余额减10\n\n\n\n此时有一个线程1开始执行业务，按照左图中事务1的1.1-1.3顺序执行，同一时刻线程2也开始执行业务，但由于事务1中持有db锁，事务2必须等待，直到事务1释放锁。当事务1执行完毕之后，此时的money被修改为90，事务2按照右图1.1-1.3步骤执行。假设此时，事务1发生异常，按照at模式的要求需要按照数据快照进行回滚，而此时的事务的快照为money=100，执行左图的2.1步骤，将会使事务1和事务2的操作什么都没有发生，等于事务2付款成功，但没有真正的扣除余额。这就出现了问题。\n\n\n\n发生上面这种问题的根本原因就是因为，事务之间没有做到隔离，如果说能做到隔离性，那么就不会存在这种问题。\n\n# at模式的写隔离机制\n\n为了解决这个问题at模式引入了全局锁 [card title="全局锁" color="info"]全局锁即是由tc记录当前正在操作某行数据的事务，该事务持有全局锁，具备执行权。[/card] 全局锁是由数据表实现，包含事务的xid，操作的表名table，操作行的主键pk\n\n# 两个事务都被seata管理的情况\n\n分两种情况讨论： 第一种情况——两个事务都被seata管理 下图展示了，引入全局锁之后事务的执行过程\n\n\n\n还是和之前一样的过程，这次当事务1执行完毕业务sql之后，会获取全局锁，提交完事务之后，将db锁释放掉。事务2进行业务sql执行，尝试获取全局锁，但此时全局锁由事务1持有。假设此时，事务1发生了异常需要回滚，事务1会尝试获取db锁，但这时候的db锁被事务2持有，于是就出现了，事务1等待事务2释放db锁，事务2等待事务1释放全局锁，形成了死锁关系。在at模式下，尝试获取全局锁会默认重试30次，每10ms进行一次重试，当死锁发生了，事务2长时间获取不到全局锁，任务就会超时，事务2会进行回滚并释放db锁。也就是说事务2的操作失败了，此时事务1可以重新拿到db锁进行快照恢复，money重新回到了100，恢复快照之后，事务1释放全局锁即可。这一次事务2并没有执行成功，保证了数据的一致性。 [card title="与xa模式的区别" color="danger"]到这里看起来和xa模式就很像了，在高度竞争的情况下，同样需要锁，但区别点在于，xa模式下执行完毕sql后并不提交事务，持有的是数据库锁，而在at模式下，全局锁是由tc实现。数据库锁不释放，那么任何其他操作都会被互斥等待。tc是由seata管理，假设此时有另外的一个事务，不被seata管理，仅仅是操作这个表中的其他字段，这时由于at模式执行完sql就会提交事务释放数据库锁，此时并不会产生互斥等待，这是xa模式所做不到的。[/card]\n\n# 仅有一个事务被seata管理，另一个非seata管理\n\n第二种情况——一个事务被seata管理，另一个非seata管理 上面这个假设是非seata管理的事务(以下称为事务2)操作的字段和事务1不同的情况，但如果当事务2操作的和事务1相同时，那不又出现脏写问题了吗，虽然这个概率很低，但依然是有可能发生的。\n\n\n\n如图所示，事务1依旧按照1.1-1.3执行，在释放了db锁之后，事务2开始执行。事务2执行完sql之后，由于其并非由seata管理，所以1.2之后不需要获取全局锁，直接提交事务释放db锁。我们依旧假设此时事务1发生异常需要回滚，按照数据快照来看，事务1记录的money是100，而当事务2执行完毕之后money已经变为了80，此时如果直接回滚，那么又发生了脏写问题。 为了防止这个问题，seata在保存快照时实际上会记录2份快照，一份是修改之前的快照，一份是修改之后的快照，在恢复快照数据时，会将更新后的快照值90和当前数据库的实际值80进行比对(类似cas过程)，如果数值不匹配则说明在此期间有另外的事务修改了数据，此时直接释放全局锁，事务1记录异常，发送告警信息让人工介入。如果一致则恢复数据，释放全局锁即可。',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"分布式事务TCC模式的空回滚和业务悬挂问题",frontmatter:{title:"分布式事务TCC模式的空回滚和业务悬挂问题",date:"2022-02-26T12:43:48.000Z",categories:["Java"],tags:["Java","事务","分布式事务","TCC"],permalink:"/pages/f256e0/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/03.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/03.%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/04.%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1TCC%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%A9%BA%E5%9B%9E%E6%BB%9A%E5%92%8C%E4%B8%9A%E5%8A%A1%E6%82%AC%E6%8C%82%E9%97%AE%E9%A2%98.html",relativePath:"03.分布式与中间件/03.分布式事务/04.分布式事务TCC模式的空回滚和业务悬挂问题.md",key:"v-3039e03b",path:"/pages/f256e0/",headers:[{level:3,title:"TCC模式的空回滚和业务悬挂问题",slug:"tcc模式的空回滚和业务悬挂问题",normalizedTitle:"tcc模式的空回滚和业务悬挂问题",charIndex:2},{level:4,title:"TCC模式原理",slug:"tcc模式原理",normalizedTitle:"tcc模式原理",charIndex:35},{level:4,title:"空回滚和业务悬挂问题",slug:"空回滚和业务悬挂问题",normalizedTitle:"空回滚和业务悬挂问题",charIndex:8},{level:4,title:"实现方法",slug:"实现方法",normalizedTitle:"实现方法",charIndex:1257},{level:4,title:"TCC标准接口声明",slug:"tcc标准接口声明",normalizedTitle:"tcc标准接口声明",charIndex:2085},{level:4,title:"在account-service中的具体实现",slug:"在account-service中的具体实现",normalizedTitle:"在account-service中的具体实现",charIndex:2859}],headersStr:"TCC模式的空回滚和业务悬挂问题 TCC模式原理 空回滚和业务悬挂问题 实现方法 TCC标准接口声明 在account-service中的具体实现",content:'# TCC模式的空回滚和业务悬挂问题\n\n首先回顾一下TCC模式\n\n# TCC模式原理\n\nTCC模式与AT模式非常相似，每阶段都是独立事务，不同的是TCC通过人工编码来实现数据恢复。需要实现三个方法：\n\n * Try：资源的检测和预留；\n * Confirm：完成资源操作业务；要求Try成功Confirm一定要能成功。\n * Cancel：预留资源释放，可以理解为Try的反向操作。 举例，一个扣减用户余额的业务。假设账户A原来余额是100，需要余额扣减30元。\n * 阶段一(Try): 检查余额是否充足，如果充足则冻结金额增加30元，可用余额扣除30\n\n\n * 阶段二：假如要提交（Confirm），则冻结金额扣减30\n\n\n * 阶段三：如果要回滚（Cancel），则冻结金额扣减30，可用余额增加30\n\n\n\nTCC工作模型图：\n\n\n\n# 空回滚和业务悬挂问题\n\n以代码中的account—service服务为例，利用TCC实现分布式事务需要完成以下逻辑：\n\n * 修改account-service，编写try、confirm、cancel逻辑\n * try业务：添加冻结金额，扣减可用金额\n * confirm业务：删除冻结金额\n * cancel业务：删除冻结金额，恢复可用金额\n * 保证confirm、cancel接口的幂等性\n * 允许空回滚\n * 拒绝业务悬挂\n\n幂等性就是无论接口调用多少次，返回的结果应该具有一致性。那么什么是控回滚和业务悬挂呢？ 空回滚：当某分支事务的try阶段阻塞时，可能导致全局事务超时而触发二阶段的cancel操作。在未执行try操作时先执行了cancel操作，这时cancel不能做回滚，就是空回滚。 业务悬挂：对于已经空回滚的业务，如果以后继续执行try，就永远不可能confirm或cancel，这就是业务悬挂。应当阻止执行空回滚后的try操作，避免悬挂。 如下图所示\n\n\n\n空回滚情况： 上方调用分支按照TCC流程正常执行，此时下方调用分支因为某种原因而阻塞了，由于长时间没有执行，这个分支发生了超时错误，由TM经过2.1步骤发送超时错误，回滚全局事务的指令给TC，TC检查分支状态2.2，发现确实有一只分支超时，发送2.3回滚指令到各分支的RM，由RM执行2.4cancel操作。 此时对于第一个分支而言，执行cancel没有问题，因为流程正常。但对于第二个分支而言，他并没有执行第一步的try，所以此时第二个分支不能真正的执行cancel，需要执行空回滚，也就是说返回一个正常状态，且不报错。需要在cancel之前查看是否有前置的try，如果没有执行try则需要空回滚。\n\n\n\n业务悬挂情况： 假设在上方的基础上，下方分支的阻塞畅通了，此时他执行1.4去锁定资源(try)，但整个事务都已经回滚结束了，所以他不会执行第二阶段，但冻结了资源，这种情况应该进行避免。需要在try操作之前查看当前分支是否已经回滚过，如果已经回滚过则不能在执行try命令。\n\n# 实现方法\n\n为了实现空回滚、防止业务悬挂，以及幂等性要求。我们必须在数据库记录冻结金额的同时，记录当前事务id和执行状态，为此我们设计了一张表：\n\nCREATE TABLE `account_freeze_tbl` (\n  `xid` varchar(128) NOT NULL COMMENT \'事务id\',\n  `user_id` varchar(255) DEFAULT NULL COMMENT \'用户id\',\n  `freeze_money` int(11) unsigned DEFAULT \'0\' COMMENT \'冻结金额\',\n  `state` int(1) DEFAULT NULL COMMENT \'事务状态，0:try，1:confirm，2:cancel\',\n  PRIMARY KEY (`xid`) USING BTREE\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n 1. Try业务\n\n * 记录冻结金额和事务状态0到account_freeze表\n * 扣减account表可用金额\n\n 2. Confirm业务\n\n * 根据xid删除account_freeze表的冻结记录(因为如果一个事务confirm那么记录就没有意义了)\n\n 3. Cancel业务\n\n * 修改account_freeze表，冻结金额为0，state为2\n * 修改account表，恢复可用金额\n\n 4. 如何判断是否空回滚\n\n * cancel业务中，根据xid查询account_freeze，如果为null则说明try还没做，需要空回滚\n\n 5. 如何避免业务悬挂\n\n * try业务中，根据xid查询account_freeze ，如果已经存在则证明Cancel已经执行，拒绝执行try业务\n\n# TCC标准接口声明\n\nTCC的Try、Confirm、Cancel方法都需要在接口中基于注解来声明，语法如下：\n\n@LocalTCC\npublic interface TCCService {\n    /**\n     * Try逻辑，@TwoPhaseBusinessAction中的name属性要与当前方法名一致，用于指定Try逻辑对应的方法\n     */\n    @TwoPhaseBusinessAction(name = "prepare", commitMethod = "confirm", rollbackMethod = "cancel")\n    /**\n     * 二阶段confirm确认方法、可以另命名，但要保证与commitMethod一致\n     *\n     * @param context 上下文,可以传递try方法的参数\n     * @return boolean 执行是否成功 \n     */\n    void prepare(@BusinessActionContextParameter(paramName = "param") String param);\n    /**\n     * 二阶段回滚方法，要保证与rollbackMethod一致\n     */\n    boolean confirm(BusinessActionContext context);\n\n    boolean cancel(BusinessActionContext context);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n# 在account-service中的具体实现\n\nAccountTCCService.java\n\n@LocalTCC\npublic interface AccountTCCService {\n\n    // try阶段\n    @TwoPhaseBusinessAction(name = "deduct", commitMethod = "confirm", rollbackMethod = "cancel")\n    void deduct(@BusinessActionContextParameter(paramName = "userId") String userId,\n                @BusinessActionContextParameter(paramName = "money") int money);\n    // confirm阶段\n    boolean confirm(BusinessActionContext context);\n    // cancel阶段\n    boolean cancel(BusinessActionContext context);\n    \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nAccountTCCServiceImpl.java\n\n@Slf4j\n@Service\npublic class AccountTCCServiceImpl implements AccountTCCService {\n\n    @Resource\n    private AccountMapper accountMapper;\n\n    @Resource\n    private AccountFreezeMapper freezeMapper;\n\n    @Override\n    @Transactional\n    public void deduct(String userId, int money) {\n        // 数据库的money是unsigned字段，不可能为负数，所以这里不用检测余额\n        // 直接扣减为负数会抛出异常，这里的事务注解回滚\n        // 0. 获取事务id\n        String xid = RootContext.getXID();\n        // 业务悬挂处理，防止已经发起回滚操作后，阻塞的try恢复，进行扣减\n        // 导致无法confirm也无法cancel\n        // 1. 判断freeze中是否有冻结记录，如果有，一定是CANCEL执行过，需要拒绝业务\n        AccountFreeze oldFreeze = freezeMapper.selectById(xid);\n        if (oldFreeze != null) {\n            // 拒绝\n            return;\n        }\n        // 1. 扣减可用余额\n        accountMapper.deduct(userId, money);\n        // 2. 记录冻结金额，事务状态\n        AccountFreeze freeze = new AccountFreeze();\n        freeze.setUserId(userId);\n        freeze.setFreezeMoney(money);\n        freeze.setState(AccountFreeze.State.TRY);\n        freeze.setXid(xid);\n        freezeMapper.insert(freeze);\n    }\n\n    @Override\n    public boolean confirm(BusinessActionContext context) {\n        // 因为try获取成功后进入confirm，意味着分支状态检查通过\n        // 发起了事务提交指令，free表的数据就没有意义了，直接删除即可\n        // 1. 获取事务id\n        String xid = context.getXid();\n        // 2. 根据id删除冻结记录\n        int count = freezeMapper.deleteById(xid);\n        return count == 1;\n    }\n\n    @Override\n    public boolean cancel(BusinessActionContext context) {\n        String xid = context.getXid();\n        // 0. 查询冻结记录，可以走数据库，也可以走上下文\n        AccountFreeze freeze = freezeMapper.selectById(xid);\n        String userId = context.getActionContext("userId").toString();\n        // 1. 空回滚判断，判断freeze是否为null，为null证明try没执行，需要空回滚\n        if (freeze == null) {\n            // 证明try没执行，需要空回滚，记录一下这个回滚的信息\n            freeze = new AccountFreeze();\n            freeze.setUserId(userId);\n            freeze.setFreezeMoney(0);\n            freeze.setState(AccountFreeze.State.CANCEL);\n            freeze.setXid(xid);\n            freezeMapper.insert(freeze);\n            return true;\n        }\n        // 2. 幂等判断，只要cancel执行了，这个状态一定是CANCEL\n        // 所以判断这个值就可以知道是否幂等，防止上一轮cancel超时后重复执行cancel\n        if (freeze.getState() == AccountFreeze.State.CANCEL) {\n            // 已经处理过一次CANCEL了，无需重复处理\n            return true;\n        }\n        // 1. 恢复可用余额\n        accountMapper.refund(freeze.getUserId(), freeze.getFreezeMoney());\n        // 2. 将冻结金额清零，状态改为CANCEL\n        freeze.setFreezeMoney(0);\n        freeze.setState(AccountFreeze.State.CANCEL);\n        int count = freezeMapper.updateById(freeze);\n        return count == 1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n',normalizedContent:'# tcc模式的空回滚和业务悬挂问题\n\n首先回顾一下tcc模式\n\n# tcc模式原理\n\ntcc模式与at模式非常相似，每阶段都是独立事务，不同的是tcc通过人工编码来实现数据恢复。需要实现三个方法：\n\n * try：资源的检测和预留；\n * confirm：完成资源操作业务；要求try成功confirm一定要能成功。\n * cancel：预留资源释放，可以理解为try的反向操作。 举例，一个扣减用户余额的业务。假设账户a原来余额是100，需要余额扣减30元。\n * 阶段一(try): 检查余额是否充足，如果充足则冻结金额增加30元，可用余额扣除30\n\n\n * 阶段二：假如要提交（confirm），则冻结金额扣减30\n\n\n * 阶段三：如果要回滚（cancel），则冻结金额扣减30，可用余额增加30\n\n\n\ntcc工作模型图：\n\n\n\n# 空回滚和业务悬挂问题\n\n以代码中的account—service服务为例，利用tcc实现分布式事务需要完成以下逻辑：\n\n * 修改account-service，编写try、confirm、cancel逻辑\n * try业务：添加冻结金额，扣减可用金额\n * confirm业务：删除冻结金额\n * cancel业务：删除冻结金额，恢复可用金额\n * 保证confirm、cancel接口的幂等性\n * 允许空回滚\n * 拒绝业务悬挂\n\n幂等性就是无论接口调用多少次，返回的结果应该具有一致性。那么什么是控回滚和业务悬挂呢？ 空回滚：当某分支事务的try阶段阻塞时，可能导致全局事务超时而触发二阶段的cancel操作。在未执行try操作时先执行了cancel操作，这时cancel不能做回滚，就是空回滚。 业务悬挂：对于已经空回滚的业务，如果以后继续执行try，就永远不可能confirm或cancel，这就是业务悬挂。应当阻止执行空回滚后的try操作，避免悬挂。 如下图所示\n\n\n\n空回滚情况： 上方调用分支按照tcc流程正常执行，此时下方调用分支因为某种原因而阻塞了，由于长时间没有执行，这个分支发生了超时错误，由tm经过2.1步骤发送超时错误，回滚全局事务的指令给tc，tc检查分支状态2.2，发现确实有一只分支超时，发送2.3回滚指令到各分支的rm，由rm执行2.4cancel操作。 此时对于第一个分支而言，执行cancel没有问题，因为流程正常。但对于第二个分支而言，他并没有执行第一步的try，所以此时第二个分支不能真正的执行cancel，需要执行空回滚，也就是说返回一个正常状态，且不报错。需要在cancel之前查看是否有前置的try，如果没有执行try则需要空回滚。\n\n\n\n业务悬挂情况： 假设在上方的基础上，下方分支的阻塞畅通了，此时他执行1.4去锁定资源(try)，但整个事务都已经回滚结束了，所以他不会执行第二阶段，但冻结了资源，这种情况应该进行避免。需要在try操作之前查看当前分支是否已经回滚过，如果已经回滚过则不能在执行try命令。\n\n# 实现方法\n\n为了实现空回滚、防止业务悬挂，以及幂等性要求。我们必须在数据库记录冻结金额的同时，记录当前事务id和执行状态，为此我们设计了一张表：\n\ncreate table `account_freeze_tbl` (\n  `xid` varchar(128) not null comment \'事务id\',\n  `user_id` varchar(255) default null comment \'用户id\',\n  `freeze_money` int(11) unsigned default \'0\' comment \'冻结金额\',\n  `state` int(1) default null comment \'事务状态，0:try，1:confirm，2:cancel\',\n  primary key (`xid`) using btree\n) engine=innodb default charset=utf8 row_format=compact;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n 1. try业务\n\n * 记录冻结金额和事务状态0到account_freeze表\n * 扣减account表可用金额\n\n 2. confirm业务\n\n * 根据xid删除account_freeze表的冻结记录(因为如果一个事务confirm那么记录就没有意义了)\n\n 3. cancel业务\n\n * 修改account_freeze表，冻结金额为0，state为2\n * 修改account表，恢复可用金额\n\n 4. 如何判断是否空回滚\n\n * cancel业务中，根据xid查询account_freeze，如果为null则说明try还没做，需要空回滚\n\n 5. 如何避免业务悬挂\n\n * try业务中，根据xid查询account_freeze ，如果已经存在则证明cancel已经执行，拒绝执行try业务\n\n# tcc标准接口声明\n\ntcc的try、confirm、cancel方法都需要在接口中基于注解来声明，语法如下：\n\n@localtcc\npublic interface tccservice {\n    /**\n     * try逻辑，@twophasebusinessaction中的name属性要与当前方法名一致，用于指定try逻辑对应的方法\n     */\n    @twophasebusinessaction(name = "prepare", commitmethod = "confirm", rollbackmethod = "cancel")\n    /**\n     * 二阶段confirm确认方法、可以另命名，但要保证与commitmethod一致\n     *\n     * @param context 上下文,可以传递try方法的参数\n     * @return boolean 执行是否成功 \n     */\n    void prepare(@businessactioncontextparameter(paramname = "param") string param);\n    /**\n     * 二阶段回滚方法，要保证与rollbackmethod一致\n     */\n    boolean confirm(businessactioncontext context);\n\n    boolean cancel(businessactioncontext context);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n# 在account-service中的具体实现\n\naccounttccservice.java\n\n@localtcc\npublic interface accounttccservice {\n\n    // try阶段\n    @twophasebusinessaction(name = "deduct", commitmethod = "confirm", rollbackmethod = "cancel")\n    void deduct(@businessactioncontextparameter(paramname = "userid") string userid,\n                @businessactioncontextparameter(paramname = "money") int money);\n    // confirm阶段\n    boolean confirm(businessactioncontext context);\n    // cancel阶段\n    boolean cancel(businessactioncontext context);\n    \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\naccounttccserviceimpl.java\n\n@slf4j\n@service\npublic class accounttccserviceimpl implements accounttccservice {\n\n    @resource\n    private accountmapper accountmapper;\n\n    @resource\n    private accountfreezemapper freezemapper;\n\n    @override\n    @transactional\n    public void deduct(string userid, int money) {\n        // 数据库的money是unsigned字段，不可能为负数，所以这里不用检测余额\n        // 直接扣减为负数会抛出异常，这里的事务注解回滚\n        // 0. 获取事务id\n        string xid = rootcontext.getxid();\n        // 业务悬挂处理，防止已经发起回滚操作后，阻塞的try恢复，进行扣减\n        // 导致无法confirm也无法cancel\n        // 1. 判断freeze中是否有冻结记录，如果有，一定是cancel执行过，需要拒绝业务\n        accountfreeze oldfreeze = freezemapper.selectbyid(xid);\n        if (oldfreeze != null) {\n            // 拒绝\n            return;\n        }\n        // 1. 扣减可用余额\n        accountmapper.deduct(userid, money);\n        // 2. 记录冻结金额，事务状态\n        accountfreeze freeze = new accountfreeze();\n        freeze.setuserid(userid);\n        freeze.setfreezemoney(money);\n        freeze.setstate(accountfreeze.state.try);\n        freeze.setxid(xid);\n        freezemapper.insert(freeze);\n    }\n\n    @override\n    public boolean confirm(businessactioncontext context) {\n        // 因为try获取成功后进入confirm，意味着分支状态检查通过\n        // 发起了事务提交指令，free表的数据就没有意义了，直接删除即可\n        // 1. 获取事务id\n        string xid = context.getxid();\n        // 2. 根据id删除冻结记录\n        int count = freezemapper.deletebyid(xid);\n        return count == 1;\n    }\n\n    @override\n    public boolean cancel(businessactioncontext context) {\n        string xid = context.getxid();\n        // 0. 查询冻结记录，可以走数据库，也可以走上下文\n        accountfreeze freeze = freezemapper.selectbyid(xid);\n        string userid = context.getactioncontext("userid").tostring();\n        // 1. 空回滚判断，判断freeze是否为null，为null证明try没执行，需要空回滚\n        if (freeze == null) {\n            // 证明try没执行，需要空回滚，记录一下这个回滚的信息\n            freeze = new accountfreeze();\n            freeze.setuserid(userid);\n            freeze.setfreezemoney(0);\n            freeze.setstate(accountfreeze.state.cancel);\n            freeze.setxid(xid);\n            freezemapper.insert(freeze);\n            return true;\n        }\n        // 2. 幂等判断，只要cancel执行了，这个状态一定是cancel\n        // 所以判断这个值就可以知道是否幂等，防止上一轮cancel超时后重复执行cancel\n        if (freeze.getstate() == accountfreeze.state.cancel) {\n            // 已经处理过一次cancel了，无需重复处理\n            return true;\n        }\n        // 1. 恢复可用余额\n        accountmapper.refund(freeze.getuserid(), freeze.getfreezemoney());\n        // 2. 将冻结金额清零，状态改为cancel\n        freeze.setfreezemoney(0);\n        freeze.setstate(accountfreeze.state.cancel);\n        int count = freezemapper.updatebyid(freeze);\n        return count == 1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"MySQL索引原理及应用场景",frontmatter:{title:"MySQL索引原理及应用场景",description:"MySQL索引总结",categories:["MySQL"],tags:["MySQL","索引","B+树"],keywords:"MySQL,索引,B+树",date:"2022-08-02T18:56:07.000Z",permalink:"/pages/0f7e8e/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/04.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MySQL/01.MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF.html",relativePath:"04.数据库/01.MySQL/01.MySQL索引原理及应用场景.md",key:"v-fbb6475a",path:"/pages/0f7e8e/",headers:[{level:2,title:"什么是索引",slug:"什么是索引",normalizedTitle:"什么是索引",charIndex:2},{level:2,title:"索引分类",slug:"索引分类",normalizedTitle:"索引分类",charIndex:115},{level:2,title:"索引数据结构",slug:"索引数据结构",normalizedTitle:"索引数据结构",charIndex:920},{level:2,title:"B+Tree的查询过程",slug:"b-tree的查询过程",normalizedTitle:"b+tree的查询过程",charIndex:2597},{level:2,title:"聚簇索引与非聚簇索引",slug:"聚簇索引与非聚簇索引",normalizedTitle:"聚簇索引与非聚簇索引",charIndex:2781},{level:2,title:"索引优化",slug:"索引优化",normalizedTitle:"索引优化",charIndex:3323},{level:3,title:"回表",slug:"回表",normalizedTitle:"回表",charIndex:3332},{level:3,title:"索引覆盖",slug:"索引覆盖",normalizedTitle:"索引覆盖",charIndex:3576},{level:3,title:"联合索引",slug:"联合索引",normalizedTitle:"联合索引",charIndex:558},{level:3,title:"最左前缀原则",slug:"最左前缀原则",normalizedTitle:"最左前缀原则",charIndex:4333},{level:3,title:"索引下推",slug:"索引下推",normalizedTitle:"索引下推",charIndex:4809},{level:3,title:"索引分析—执行计划",slug:"索引分析-执行计划",normalizedTitle:"索引分析—执行计划",charIndex:5447},{level:3,title:"索引失效场景",slug:"索引失效场景",normalizedTitle:"索引失效场景",charIndex:17942},{level:4,title:"使用原则",slug:"使用原则",normalizedTitle:"使用原则",charIndex:17952},{level:4,title:"失效场景",slug:"失效场景",normalizedTitle:"失效场景",charIndex:17944},{level:3,title:"小表驱动大表",slug:"小表驱动大表",normalizedTitle:"小表驱动大表",charIndex:19130},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:19746},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:19888}],headersStr:"什么是索引 索引分类 索引数据结构 B+Tree的查询过程 聚簇索引与非聚簇索引 索引优化 回表 索引覆盖 联合索引 最左前缀原则 索引下推 索引分析—执行计划 索引失效场景 使用原则 失效场景 小表驱动大表 总结 参考文章",content:"# 什么是索引\n\n在工作当中，涉及到MySQL的查询，我们经常会遇到给某个表某个字段加索引的诉求，加上索引能够让我们的sql得到查询速度上的提升。但索引的原理是什么呢，他又是怎么工作的，需要开发者对基础知识有一定的了解。\n\n\n# 索引分类\n\n索引通过特定的一些数据结构，将数据组织有序，将随机I/O变为顺序I/O，有效减少查询一条数据所需要扫描的数据量，加快查询的速度。\n\n从使用者的角度而言，MySQL索引主要为以下几种。\n\n主键索引\n\n根据数据表主键建立的索引，不允许重复和空值。主键索引列全表唯一\n\nalter table 'table_name' add primary key pk_index_name('col_name');\n\n\n1\n\n1\n\n\n唯一索引\n\n用于确保建立索引列内的值是唯一的，允许空值。比如同样为age字段，不能出现2个age为10的数据\n\nalter table 'table_name' add unique unique_index_name('col_name');\n\n\n1\n\n1\n\n\n普通索引\n\n用于表中的普通列构建的索引，没有特殊限制\n\nalter table 'table_name' add index index_name('col_name');\n\n\n1\n\n1\n\n\n联合索引\n\n采用多个列组合构建的索引，用于组合搜索\n\nalter table 'table_name' add index index_name('col1_name','col2_name');\n\n\n1\n\n1\n\n\n全文索引\n\n用于大文本对象的列构建索引\n\nalter table 'table_name' add fulltext index full_index_name('col_name');\n\n\n1\n\n1\n\n\n空间索引\n\n用于GIS地图数据的索引，MySQL中的空间数据类型有GEOMETRY、POINT、LINESTRING、POLYGON\n\nalter table 'table_name' add spatial index spa_index_name('col_name');\n\n\n1\n\n1\n\n\n\n# 索引数据结构\n\n根据数据结构的不同，MySQL的索引可分为哈希索引、BTree索引、B+Tree索引。\n\n哈希索引\n\n哈希索引通过hash表实现，通过将hash函数计算出的hash值存储在索引中，来完成key-value的快速查询\n\n\n\n通常而言当发生hash碰撞之后(即两个key在经过hash函数之后值为同一个)，采用链地址法解决冲突，如上图中小刘到小王的连接线，获取key找到索引地址之后，顺序遍历地址内的链表，获得最终结果。\n\n哈希索引的特点和hashmap类似，适合于精确查找，但不适合范围查找，hash码并不具有规律性，所以存储hash索引时顺序性是无法保障的。\n\nBTree索引\n\n关于平衡二叉搜索树的概念和意义可以详见我的另一篇文章👉二叉搜索树及AVL树详解。\n\nB树实际上是一棵多叉平衡搜索树。其具有以下特点\n\n笔记\n\n根节点左侧数值小于根节点，根节点右侧数值大于根节点\n\n每个叶子节点高度一致\n\n指针p存储节点的地址信息\n\n非叶子节点为[key,data]二元组，其中key表示作为索引的键，data为key值所在行的数据\n\nB树的结构如下图所示\n\n\n\n在B树的结构图中，可以发现每个节点不仅仅包含数据的Key值，还有data值。\n\n而每页的存储空间是有限的，如果data比较大，会导致每个节点的Key存储较少。\n\n当数据量扩大时，B树只能往下进行分裂，导致树深的增高，增加了磁盘I/O的次数，影响查询效率。\n\nB+Tree索引\n\n为了解决B树的效率问题，B+树做了如下改进\n\n笔记\n\n非叶子节点只存储键值信息，不再存储数据\n\n所有叶子节点之间都有一个链指针，指向下一个叶子节点\n\n数据都存放在叶子节点中\n\nB+树的结构如下图所示\n\n\n\n为了更详细的描述B+树，图中的指针写明了存储的磁盘块名称，最底下一层含有数据的磁盘块被称为数据页，数据页之间通过双向链表进行连接，非叶子节点的磁盘块被称为索引页\n\n将上图中磁盘块2与磁盘块5、6、7拿出来进行细分，我们展开各磁盘块，查看单个磁盘块内数据的排列方式\n\n\n\nMySQL在存储数据时以数据页为最小单位，且数据在数据页中的存储是连续的，数据页中的数据是按照主键排序(如没有主键则由MySQL自身维护的ROW_ID排序)，而数据页与数据页之间则采用双向链表关联，数据与数据之间通过单向链表关联。\n\n在每个数据页中，必然存在最小主键，每个数据页的最小主键+磁盘块地址会形成一个主键目录，多个主键目录会形成一个索引页(如磁盘块2结构所示)。\n\n提示\n\n索引页的出现就是为了解决数据页记录过多，导致主键目录特别大，影响二分查找效率的问题。\n\n与数据页类似，如果一张数据页/索引页存储空间不够，则继续分裂到下一张，即结构图中展示的磁盘块1、2、3、4均为索引页\n\n那么索引页和数据页到底是多大的大小呢？\n\n引用一下网络中的解释\n\n> 计算机在存储数据的时候，最小存储单元是扇区，一个扇区的大小是 512 字节，而文件系统（例如 XFS/EXT4）最小单元是块，一个块的大小是 4KB。InnoDB 引擎存储数据的时候，是以页为单位的，每个数据页的大小默认是 16KB，即四个块。\n\n基于该理论，我们可以大致算出B+树能够存储的数据。\n\n假设数据库中一条记录是1KB，那么一个页就可以存16条数据（叶子结点）；对于非叶子结点存储的则是键值+指针，在InnoDB中，一个指针的大小是6个字节，假设我们的主键是bigint ，那么主键占8个字节，忽略一些其他的头信息大小，大致计算可以得到：\n\n16*1024/(8+6)=1170\n\n即一个非叶子节点可以指向1170个页，那么一个三层的B+树可以存储的数据量为：\n\n1170*1170*16=21902400\n\n大约2100万条数据。\n\n在InnoDB存储引擎中，B+树的高度一般为2-4 层，这就可以满足千万级的数据的存储，查找数据的时候，一次页的查找代表一次I/O，那我们通过主键索引查询的时候，其实最多只需要2-4次I/O操作就可以了。\n\n\n# B+Tree的查询过程\n\n还是基于B+树的结构图\n\n假设我们要查询key=16的数据，通过最顶层索引页的条件，我们知道需要从磁盘块2的索引页进行查询。\n\n依次比较磁盘块2中的key值，能够知道key>=12的数据均在p6指针指向的磁盘块内。\n\n于是我们可以定位到磁盘块7对应的数据页，通过顺序遍历数据页内的单向链表，最终找到key=16对应的data数据行。\n\n\n# 聚簇索引与非聚簇索引\n\n作为非常高频的知识点，这两种索引通常会有如下解释\n\n笔记\n\n聚簇索引的叶子节点存储的是键值对应的数据本身\n\n非聚簇索引的叶子节点存储的是键值对应的数据的主键键值\n\n在Innodb中聚簇索引一般默认以主键建立，也称为主键索引\n\n非聚簇索引则以其他非主键字段建立，也称为辅助索引\n\n以下列数据表为例\n\n\n\n如果采用聚簇索引的存储方式(主键为ID)，则对应的索引结构为\n\n\n\n可以看出聚簇索引的数据和索引存储在一起，根据Id索引能够找到对应的数据行，比如where Id = 7这样的条件，聚簇索引能够查到对应主键，获得对应的叶子节点上的行数据。\n\n如果以Name字段建立索引，则对应的辅助索引结构为\n\n\n\n可以看出非聚簇索引的数据和索引，并非存储在一起，根据Name索引只能找到Name对应的主键Id，比如where Name = 张三，非聚簇索引需要通过两个步骤才能获取行数据。\n\n * 第一步，在非聚簇索引的B+树中查询对应Name，获得叶子节点上匹配的Name的主键。\n\n * 第二步，根据匹配的主键Id在聚簇索引B+树上再执行一次检索，获取叶子节点上的行数据。\n\n整个过程可如下图所示\n\n\n\n两者的主要区别在于非聚簇索引会多一次查询聚簇索引的过程\n\n\n# 索引优化\n\n\n# 回表\n\n回表是什么？\n\n假设有如下Sql执行\n\nselect * from student where name = '张三';\n\n\n1\n\n1\n\n\n由于查询键为name，所以查询时走辅助索引树，很快就定位到了Name=张三的叶子节点，但由于查询条件为select *，辅助索引树中并没有包含全表字段，所以会再次根据Name=张三的主键Id查询主键索引树。\n\n这个过程和刚才非聚簇索引的查询过程相同，通过辅助索引查询到字段，但仍需要走主键索引补全select信息的过程，叫做回表。\n\n\n# 索引覆盖\n\n索引覆盖就是执行的sql查询的字段刚好可以命中索引，不需要额外回表\n\n例如\n\nselect id from student where id = 123\n\n\n1\n\n1\n\n\n这样的查询能够命中索引，且索引字段和查询字段匹配\n\n而例如\n\nselect id, name from student where id = 123\n\n\n1\n\n1\n\n\n这样的查询则会回表\n\n\n# 联合索引\n\n作为下文的基础，这里先说一下联合索引。\n\n假设现在有如下场景，按照市民的身份证号去查询他的家庭地址，这个查询需求在业务中出现的概率不高，但我们也不能让他直接走全表扫描。\n\n如果单独的为一个不频繁的查询请求创建一个索引，感觉又有点浪费资源，这时候就可以通过建立联合索引，减少开销。\n\n假设以数据库的a字段和b字段建立联合索引，a和b均为int类型字段\n\nalter table 'table_name' add index index_name('a','b');\n\n\n1\n\n1\n\n\n则生成的联合索引B+树会以联合索引字段共同建立，即联合索引的键值对大于1个\n\n\n\n将索引的叶子节点按照字段拿出来进行分析，从左至右\n\na的顺序为: 1, 1, 2, 2, 3, 3\n\nb的顺序为: 1, 2, 1, 4, 1, 2\n\n大家可以发现a字段是有序排列，b字段是无序排列(因为B+树只能选择一个字段来构建有序的树)\n\n同时通过观察还可以发现，在a相等的情况下，b字段是有序的，即此时a=1时，b=1，2，b保持相对有序。\n\n在平时的sql中，我们经常会有个共识，当要对两个字段进行排序时，首先会按照第一个字段排序，如果第一个字段相等，则用第二个字段排序。\n\n这种共识的原理就是因为，联合多字段建树时B+树的独特构建方式。\n\n\n# 最左前缀原则\n\n有了联合索引的概念，最左前缀原则就好理解了，由于B+树的建树方式，只有叶子节点存储数据，且叶子节点从左往右排序保持顺序，是最左前缀匹配的根本原因。\n\n如果要查询a字段所有以1开头的数据，则对应的SQL条件为where a like '1%'。这个时候索引能够用上，查找到第一个符合条件的记录为ID-1,然后一直向后遍历，直到不满足条件为止。\n\n再举一个能走联合索引的例子，如select * from student where a=1 and b=2。\n\n * 首先a字段在B+树上是有序的，所以我们通过二分查找来定位到a=1的位置，其次在a确定的情况下，b是相对有序的。因为有序，所以我们同样可以通过二分查找找到b=2的位置。此时索引是有效的。\n\n再举一个不能走联合索引的例子，如select * from student where b=2。\n\n * b字段有序的前提是：在a确定的情况下，现在查询条件中并没有规定a的范围，所以也无法确定b的顺序，在一棵无序的B+树上是无法用二分查找来定位到b字段的，这个时候索引失效。\n\n\n# 索引下推\n\n最左前缀可以用在索引中定位记录，那么那些不符合最左前缀的部分会怎么样呢？\n\n还是以联合索引(a, b)为例，假设现在表内有a,b,c,d...多个字段，如果现在有一个需求：检索出表中a字段第一个数字为1，且b字段为2，c字段为3的所有数据。那么这条Sql语句则是这么写的：\n\nselect * from student where a like '1%' and b=2 and c=3;\n\n\n1\n\n1\n\n\n根据前缀规则，这个语句在搜索索引树时，只能用1，找到第一个满足条件的记录ID-1。\n\n之后则需要判断其他条件是否满足。在MySQL5.6之前，只能从ID1开始一个个回表。到主键索引上找出数据行，再对比字段值。\n\n而MySQL5.6引入的索引下推优化(index condition pushdown)，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。\n\n这两个过程可如下图所示。\n\n无索引下推过程，均需要回表\n\n\n\n索引下推过程\n\n\n\n在这两个图中，每个箭头表示回表一次\n\n在无索引下推过程中，InnoDB只需要观察a字段的值，按顺序把a字段第一个数值为1的记录一条条取出来进行回表，所以总计需要回表2次。\n\n索引下推过程的区别在于，InnoDB在(a, b)索引内部就判断了b字段是否等于2，对于不等于2的记录，直接判断并跳过。在这个例子中，只需要对ID-2这一条记录回表取数据判断，只需要回表1次。\n\n\n# 索引分析—执行计划\n\n说了这么多，对于一条SQL，我们分析的思路应该是怎么样的呢？\n\nMySQL提供了explain命令，可以用于对SQL的分析，根据分析出的结果，开发者可以针对性的进行优化\n\n提示\n\n后续操作基于如下数据表\n\ncreate table if not exists testIndex.t_users\n(\n\tid bigint auto_increment comment '自增ID'\n\t\tprimary key,\n\tname varchar(50) not null comment '姓名',\n\tsex int not null comment '性别，0女，1男',\n\tage int not null comment '年龄',\n\tinfo json null comment '信息'\n);\n\nINSERT INTO testIndex.t_users (id, name, sex, age, info) VALUES (1, '张三', 1, 15, '{\"text\": \"我是张三\"}');\nINSERT INTO testIndex.t_users (id, name, sex, age, info) VALUES (2, '李四', 1, 16, '{\"text\": \"我是李四\"}');\nINSERT INTO testIndex.t_users (id, name, sex, age, info) VALUES (3, '王五', 0, 12, '{\"text\": \"我是王五\"}');\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n如何使用？\n\n在需要执行的SQL前加上explain命令执行即可，如：\n\nmysql> explain select * from t_users where id < 2 \\G;\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: t_users\n   partitions: NULL\n         type: range\npossible_keys: PRIMARY\n          key: PRIMARY\n      key_len: 8\n          ref: NULL\n         rows: 1\n     filtered: 100.00\n        Extra: Using where\n1 row in set, 1 warning (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n在explain输出的内容中，重点关注select_type，type，key，rows，Extra\n\n 1. select_type: 表示查询类型, 常见值表格如下\n\n查询类型                 解释\nSIMPLE               表示查询语句不包含子查询或者union\nPRIMARY              表示此查询最外层的查询\nUNION                表示此查询是union的第二个或者后续的查询\nDEPENDENT UNION      union中的第二个或者后续的查询语句使用了外面的查询结果\nUNION RESULR         union的结果\nSUNQUERY             select子查询语句\nDEPENDENT SUBQUERY   select子查询语句依赖外层的查询结果\n\n 2. type: 表示存储引擎查询数据时采用的方式。是一个比较重要的属性，通过它可以判断出查询是全表扫描还是基于索引的部分扫描。\n    \n    它的常见属性如下(从上到下，查询效率依次增强)\n\n * ALL: 全表扫描\n\nmysql> explain select * from t_users \\G;\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: t_users\n   partitions: NULL\n         type: ALL\npossible_keys: NULL\n          key: NULL\n      key_len: NULL\n          ref: NULL\n         rows: 3\n     filtered: 100.00\n        Extra: NULL\n1 row in set, 1 warning (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * index: 基于索引的全表扫描，先扫描索引再扫描全表(在排序上性能优于ALL)\n\nmysql> explain select id from t_users \\G;\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: t_users\n   partitions: NULL\n         type: index\npossible_keys: NULL\n          key: PRIMARY\n      key_len: 8\n          ref: NULL\n         rows: 3\n     filtered: 100.00\n        Extra: Using index\n1 row in set, 1 warning (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * range: 表示使用索引的范围查询。用>,>=,<,<=等\n\nmysql> explain select * from t_users where id > 0 \\G;\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: t_users\n   partitions: NULL\n         type: range\npossible_keys: PRIMARY\n          key: PRIMARY\n      key_len: 8\n          ref: NULL\n         rows: 3\n     filtered: 100.00\n        Extra: Using where\n1 row in set, 1 warning (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * ref: 表示使用非唯一索引进行单值查询\n\n先为age字段创建索引\n\nmysql> alter table t_users add index `idx_t_user_age` (`age`);\nQuery OK, 0 rows affected (0.21 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n\nmysql> explain select * from t_users where age = 15 \\G;\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: t_users\n   partitions: NULL\n         type: ref\npossible_keys: idx_t_user_age\n          key: idx_t_user_age\n      key_len: 4\n          ref: const\n         rows: 1\n     filtered: 100.00\n        Extra: NULL\n1 row in set, 1 warning (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * eq_ref: 一般情况下出现在多表join查询，表示前面表的每一行记录，都只能匹配后面表的一行结果\n\n创建成绩表t_exam\n\ncreate table if not exists testIndex.t_exam\n(\n\tid bigint auto_increment comment '自增ID'\n\t\tprimary key,\n\tuser_id bigint not null comment '用户ID',\n\tscore int null comment '成绩'\n);\n\nINSERT INTO testIndex.t_exam (id, user_id, score) VALUES (1, 1, 96);\nINSERT INTO testIndex.t_exam (id, user_id, score) VALUES (2, 2, 86);\nINSERT INTO testIndex.t_exam (id, user_id, score) VALUES (3, 3, 76);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n采用多表join查询\n\nmysql> explain select * from t_users tu left join t_exam te on tu.id = te.user_id where te.score = 96;\n+----+-------------+-------+------------+--------+---------------+---------+---------+----------------------+------+----------+-------------+\n| id | select_type | table | partitions | type   | possible_keys | key     | key_len | ref                  | rows | filtered | Extra       |\n+----+-------------+-------+------------+--------+---------------+---------+---------+----------------------+------+----------+-------------+\n|  1 | SIMPLE      | te    | NULL       | ALL    | NULL          | NULL    | NULL    | NULL                 |    3 |    33.33 | Using where |\n|  1 | SIMPLE      | tu    | NULL       | eq_ref | PRIMARY       | PRIMARY | 8       | testIndex.te.user_id |    1 |   100.00 | NULL        |\n+----+-------------+-------+------------+--------+---------------+---------+---------+----------------------+------+----------+-------------+\n2 rows in set, 1 warning (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * const: 表示使用主键或者卫衣索引做等值查询\n\nmysql> explain select * from t_users where id = 1 \\G;\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: t_users\n   partitions: NULL\n         type: const\npossible_keys: PRIMARY\n          key: PRIMARY\n      key_len: 8\n          ref: const\n         rows: 1\n     filtered: 100.00\n        Extra: NULL\n1 row in set, 1 warning (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * null: 表示不用访问表，速度最快\n\nmysql> explain select 1;\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+\n| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+\n|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | No tables used |\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+\n1 row in set, 1 warning (0.00 sec)\n\nmysql> explain select now();\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+\n| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+\n|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | No tables used |\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+\n1 row in set, 1 warning (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n 3. possible_keys: 表示查询时能够使用到的索引，并不一定会真的使用，显示的是索引名称\n\n 4. key: 表示查询时真正用到的索引，显示的是索引名称\n\n 5. rows: MySQL查询优化器根据统计信息，估算要查询到结果需要扫描多少行记录。原则上rows越少效率越高。\n\n 6. key_len: 表示查询使用了索引的字节数量。可以判断是否全部使用了联合索引。\n\n 7. extra: 表示额外信息，通常有以下表现\n\n * using where: 表示查询需要通过索引回表查询数据。即通过普通索引查询出主键，再通过主键查询出数据。\n\nmysql> explain select age from t_users where age = 15 and name = '张三';\n+----+-------------+---------+------------+------+----------------+----------------+---------+-------+------+----------+-------------+\n| id | select_type | table   | partitions | type | possible_keys  | key            | key_len | ref   | rows | filtered | Extra       |\n+----+-------------+---------+------------+------+----------------+----------------+---------+-------+------+----------+-------------+\n|  1 | SIMPLE      | t_users | NULL       | ref  | idx_t_user_age | idx_t_user_age | 4       | const |    1 |    33.33 | Using where |\n+----+-------------+---------+------------+------+----------------+----------------+---------+-------+------+----------+-------------+\n1 row in set, 1 warning (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n * using index: 表示通过索引就能查询出所需要的数据。效率最高\n\nmysql> explain select age from t_users where age=1;\n+----+-------------+---------+------------+------+----------------+----------------+---------+-------+------+----------+-------------+\n| id | select_type | table   | partitions | type | possible_keys  | key            | key_len | ref   | rows | filtered | Extra       |\n+----+-------------+---------+------------+------+----------------+----------------+---------+-------+------+----------+-------------+\n|  1 | SIMPLE      | t_users | NULL       | ref  | idx_t_user_age | idx_t_user_age | 4       | const |    1 |   100.00 | Using index |\n+----+-------------+---------+------------+------+----------------+----------------+---------+-------+------+----------+-------------+\n1 row in set, 1 warning (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n * using filesort: 表示查询结果需要额外排序，数据量小在内存，数据量大在磁盘。如果出现这个字段，建议优化SQL\n\nmysql> explain select * from t_users order by id;\n+----+-------------+---------+------------+-------+---------------+---------+---------+------+------+----------+-------+\n| id | select_type | table   | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra |\n+----+-------------+---------+------------+-------+---------------+---------+---------+------+------+----------+-------+\n|  1 | SIMPLE      | t_users | NULL       | index | NULL          | PRIMARY | 8       | NULL |    3 |   100.00 | NULL  |\n+----+-------------+---------+------------+-------+---------------+---------+---------+------+------+----------+-------+\n1 row in set, 1 warning (0.00 sec)\n\nmysql> explain select * from t_users order by id,age;\n+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+----------------+\n| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |\n+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+----------------+\n|  1 | SIMPLE      | t_users | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |   100.00 | Using filesort |\n+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+----------------+\n1 row in set, 1 warning (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * using temproary: 表示查询用到了临时表，一般出现在去重、分组等操作\n\nmysql> explain select distinct name from t_users;\n+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-----------------+\n| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra           |\n+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-----------------+\n|  1 | SIMPLE      | t_users | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |   100.00 | Using temporary |\n+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-----------------+\n1 row in set, 1 warning (0.00 sec)\n\nmysql> explain select name, count(*) name from t_users group by name;\n+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-----------------+\n| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra           |\n+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-----------------+\n|  1 | SIMPLE      | t_users | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |   100.00 | Using temporary |\n+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-----------------+\n1 row in set, 2 warnings (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 索引失效场景\n\n# 使用原则\n\n 1. 使用联合索引应满足最左匹配原则\n\n 2. 匹配数据从左至右，遇到范围查询(>、<、between、like)会停止匹配\n\n 3. 尽量选择高区分度的字段作为索引\n\n区分度公式：count(distinct col) / count(*)，表示字段不重复的比例，比例越大扫描的记录数越少。\n\n 4. 索引尽量不用在高频更新的字段上，最好用在高频查询字段\n\n# 失效场景\n\n 1. like '%xx'\n\nselect * from t_users where name like '%张';\n\n\n1\n\n1\n\n\n首字母有序时，后续相对有序，但无法确定首字符时，查询是乱序的。\n\n 2. 使用函数\n\n比如将索引列放入函数计算中，就无法走索引，比如max(age)。其原因在于，B+树需要把所有元素都应用在函数中才能比较。\n\n 3. or\n\n比如a,b,c三个字段，a和b建了索引，c没有建索引\n\n当执行如下SQL时，能使用索引\n\nselect * from test where a = 1 or b = 2;\n\n\n1\n\n1\n\n\n当执行如下SQL时，不能使用索引，a和b的索引失效\n\nselect * from test where a = 1 or b = 2 or c = 3;\n\n\n1\n\n1\n\n 4. 使用select *\n\nselect *会采用全表扫描，即使建立了索引，索引也会进行回表，效率低下\n\n 5. 字段类型不同\n\n比如有个字段age，原本是varchar，但SQL查询时用的int类型传参，虽然查询能够成功，但实际上走的全表扫描，MySQL通过字段的隐式转换保证了SQL执行成功\n\nselect * from test where age = 123;\n\n\n1\n\n1\n\n 6. 不等于\n\n普通索引的不等于不会走索引\n\nselect * from test where name !='张三';\n\n\n1\n\n1\n\n\n主键索引的不等于会走索引\n\nselect * from test where id ! = 123;\n\n\n1\n\n1\n\n 7. order by\n\norder by排序条件为索引，则select字段必须也是索引字段，否则无法命中索引\n\n如果对主键排序，则还是能够走索引\n\nselect * from test order by id desc;\n\n\n1\n\n1\n\n 8. 范围查询\n\n比如a,b,c三个字段，a、b、c都建了索引\n\nselect * from test where a = 1 and b > 2 and c = 3\n\n\n1\n\n1\n\n\n只有a和b能够走索引，c不能走索引，范围查询就是索引截断处，原因和联合索引一致，在无法确定b有多少数量时，无法保证b的顺序性，在这个前提下导致c无法确定\n\n\n# 小表驱动大表\n\n这里补充一个额外的知识，小表驱动大表。\n\n首先引入一张网络中流传的经典图，了解left join, inner join, right join等常见结果\n\n\n\n所谓的小表驱动大表，可以理解为用小的数据集去匹配大的数据集。\n\n比如表A中有10条数据，表B中有10w条数据，外部执行一次连接，内部要执行多次\n\n按照小表驱动大表，A驱动B，则伪代码可写为\n\nfor (10条) {\n    for (10w条) {\n        ...\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n大表驱动小表，即B驱动A，伪代码可写为\n\nfor (10w条) {\n    for (10条) {\n        ...\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n两者的主要区别在于：小的循环在外层，表连接需要10次；大的循环在外层，表连接需要10w次。\n\n小表驱动大表的目的是为了减少连接创建的次数，加快查询速度。\n\n如何判断驱动表和非驱动表？\n\n1 LEFT JOIN左连接, 左边为驱动表, 右边为被驱动表\n\n2 RIGHT JOIN右连接, 右边为驱动表, 左边为被驱动表\n\n3 INNER JOIN内连接, MySQL会选择数据量比较小的表作为驱动表，大表作为被驱动表\n\n4 可通过EXPLANIN查看SQL语句的执行计划, EXPLANIN分析的第一行的表即是驱动表\n\n\n# 总结\n\n相信读完这篇文章，读者能够对索引和B+树的原理有一定的了解，在开发过程中解决慢SQL最为基本的分析方式可以采用explain，加上索引能够最简单有效的加快查询效率\n\n除此之外还可以从网络、MySQL架构(读写分离/冷热备)等方向进行考虑，由于篇幅原因这里暂不介绍了~\n\n\n# 参考文章\n\n> 《MySQL45讲》\n> \n> https://www.cnblogs.com/aaabbbcccddd/p/14864982.html\n> \n> https://www.jb51.net/article/229580.htm\n> \n> https://mp.weixin.qq.com/s/SSHWKcuGK5x4Uf7ZBC7stQ\n> \n> https://blog.csdn.net/q736317048/article/details/114415571\n> \n> https://www.cnblogs.com/heishuichenzhou/p/10813463.html\n> \n> https://mp.weixin.qq.com/s/tD_yDXBYfmLqN3BHmhOnfQ\n> \n> https://blog.csdn.net/ABestRookie/article/details/117059948",normalizedContent:"# 什么是索引\n\n在工作当中，涉及到mysql的查询，我们经常会遇到给某个表某个字段加索引的诉求，加上索引能够让我们的sql得到查询速度上的提升。但索引的原理是什么呢，他又是怎么工作的，需要开发者对基础知识有一定的了解。\n\n\n# 索引分类\n\n索引通过特定的一些数据结构，将数据组织有序，将随机i/o变为顺序i/o，有效减少查询一条数据所需要扫描的数据量，加快查询的速度。\n\n从使用者的角度而言，mysql索引主要为以下几种。\n\n主键索引\n\n根据数据表主键建立的索引，不允许重复和空值。主键索引列全表唯一\n\nalter table 'table_name' add primary key pk_index_name('col_name');\n\n\n1\n\n1\n\n\n唯一索引\n\n用于确保建立索引列内的值是唯一的，允许空值。比如同样为age字段，不能出现2个age为10的数据\n\nalter table 'table_name' add unique unique_index_name('col_name');\n\n\n1\n\n1\n\n\n普通索引\n\n用于表中的普通列构建的索引，没有特殊限制\n\nalter table 'table_name' add index index_name('col_name');\n\n\n1\n\n1\n\n\n联合索引\n\n采用多个列组合构建的索引，用于组合搜索\n\nalter table 'table_name' add index index_name('col1_name','col2_name');\n\n\n1\n\n1\n\n\n全文索引\n\n用于大文本对象的列构建索引\n\nalter table 'table_name' add fulltext index full_index_name('col_name');\n\n\n1\n\n1\n\n\n空间索引\n\n用于gis地图数据的索引，mysql中的空间数据类型有geometry、point、linestring、polygon\n\nalter table 'table_name' add spatial index spa_index_name('col_name');\n\n\n1\n\n1\n\n\n\n# 索引数据结构\n\n根据数据结构的不同，mysql的索引可分为哈希索引、btree索引、b+tree索引。\n\n哈希索引\n\n哈希索引通过hash表实现，通过将hash函数计算出的hash值存储在索引中，来完成key-value的快速查询\n\n\n\n通常而言当发生hash碰撞之后(即两个key在经过hash函数之后值为同一个)，采用链地址法解决冲突，如上图中小刘到小王的连接线，获取key找到索引地址之后，顺序遍历地址内的链表，获得最终结果。\n\n哈希索引的特点和hashmap类似，适合于精确查找，但不适合范围查找，hash码并不具有规律性，所以存储hash索引时顺序性是无法保障的。\n\nbtree索引\n\n关于平衡二叉搜索树的概念和意义可以详见我的另一篇文章👉二叉搜索树及avl树详解。\n\nb树实际上是一棵多叉平衡搜索树。其具有以下特点\n\n笔记\n\n根节点左侧数值小于根节点，根节点右侧数值大于根节点\n\n每个叶子节点高度一致\n\n指针p存储节点的地址信息\n\n非叶子节点为[key,data]二元组，其中key表示作为索引的键，data为key值所在行的数据\n\nb树的结构如下图所示\n\n\n\n在b树的结构图中，可以发现每个节点不仅仅包含数据的key值，还有data值。\n\n而每页的存储空间是有限的，如果data比较大，会导致每个节点的key存储较少。\n\n当数据量扩大时，b树只能往下进行分裂，导致树深的增高，增加了磁盘i/o的次数，影响查询效率。\n\nb+tree索引\n\n为了解决b树的效率问题，b+树做了如下改进\n\n笔记\n\n非叶子节点只存储键值信息，不再存储数据\n\n所有叶子节点之间都有一个链指针，指向下一个叶子节点\n\n数据都存放在叶子节点中\n\nb+树的结构如下图所示\n\n\n\n为了更详细的描述b+树，图中的指针写明了存储的磁盘块名称，最底下一层含有数据的磁盘块被称为数据页，数据页之间通过双向链表进行连接，非叶子节点的磁盘块被称为索引页\n\n将上图中磁盘块2与磁盘块5、6、7拿出来进行细分，我们展开各磁盘块，查看单个磁盘块内数据的排列方式\n\n\n\nmysql在存储数据时以数据页为最小单位，且数据在数据页中的存储是连续的，数据页中的数据是按照主键排序(如没有主键则由mysql自身维护的row_id排序)，而数据页与数据页之间则采用双向链表关联，数据与数据之间通过单向链表关联。\n\n在每个数据页中，必然存在最小主键，每个数据页的最小主键+磁盘块地址会形成一个主键目录，多个主键目录会形成一个索引页(如磁盘块2结构所示)。\n\n提示\n\n索引页的出现就是为了解决数据页记录过多，导致主键目录特别大，影响二分查找效率的问题。\n\n与数据页类似，如果一张数据页/索引页存储空间不够，则继续分裂到下一张，即结构图中展示的磁盘块1、2、3、4均为索引页\n\n那么索引页和数据页到底是多大的大小呢？\n\n引用一下网络中的解释\n\n> 计算机在存储数据的时候，最小存储单元是扇区，一个扇区的大小是 512 字节，而文件系统（例如 xfs/ext4）最小单元是块，一个块的大小是 4kb。innodb 引擎存储数据的时候，是以页为单位的，每个数据页的大小默认是 16kb，即四个块。\n\n基于该理论，我们可以大致算出b+树能够存储的数据。\n\n假设数据库中一条记录是1kb，那么一个页就可以存16条数据（叶子结点）；对于非叶子结点存储的则是键值+指针，在innodb中，一个指针的大小是6个字节，假设我们的主键是bigint ，那么主键占8个字节，忽略一些其他的头信息大小，大致计算可以得到：\n\n16*1024/(8+6)=1170\n\n即一个非叶子节点可以指向1170个页，那么一个三层的b+树可以存储的数据量为：\n\n1170*1170*16=21902400\n\n大约2100万条数据。\n\n在innodb存储引擎中，b+树的高度一般为2-4 层，这就可以满足千万级的数据的存储，查找数据的时候，一次页的查找代表一次i/o，那我们通过主键索引查询的时候，其实最多只需要2-4次i/o操作就可以了。\n\n\n# b+tree的查询过程\n\n还是基于b+树的结构图\n\n假设我们要查询key=16的数据，通过最顶层索引页的条件，我们知道需要从磁盘块2的索引页进行查询。\n\n依次比较磁盘块2中的key值，能够知道key>=12的数据均在p6指针指向的磁盘块内。\n\n于是我们可以定位到磁盘块7对应的数据页，通过顺序遍历数据页内的单向链表，最终找到key=16对应的data数据行。\n\n\n# 聚簇索引与非聚簇索引\n\n作为非常高频的知识点，这两种索引通常会有如下解释\n\n笔记\n\n聚簇索引的叶子节点存储的是键值对应的数据本身\n\n非聚簇索引的叶子节点存储的是键值对应的数据的主键键值\n\n在innodb中聚簇索引一般默认以主键建立，也称为主键索引\n\n非聚簇索引则以其他非主键字段建立，也称为辅助索引\n\n以下列数据表为例\n\n\n\n如果采用聚簇索引的存储方式(主键为id)，则对应的索引结构为\n\n\n\n可以看出聚簇索引的数据和索引存储在一起，根据id索引能够找到对应的数据行，比如where id = 7这样的条件，聚簇索引能够查到对应主键，获得对应的叶子节点上的行数据。\n\n如果以name字段建立索引，则对应的辅助索引结构为\n\n\n\n可以看出非聚簇索引的数据和索引，并非存储在一起，根据name索引只能找到name对应的主键id，比如where name = 张三，非聚簇索引需要通过两个步骤才能获取行数据。\n\n * 第一步，在非聚簇索引的b+树中查询对应name，获得叶子节点上匹配的name的主键。\n\n * 第二步，根据匹配的主键id在聚簇索引b+树上再执行一次检索，获取叶子节点上的行数据。\n\n整个过程可如下图所示\n\n\n\n两者的主要区别在于非聚簇索引会多一次查询聚簇索引的过程\n\n\n# 索引优化\n\n\n# 回表\n\n回表是什么？\n\n假设有如下sql执行\n\nselect * from student where name = '张三';\n\n\n1\n\n1\n\n\n由于查询键为name，所以查询时走辅助索引树，很快就定位到了name=张三的叶子节点，但由于查询条件为select *，辅助索引树中并没有包含全表字段，所以会再次根据name=张三的主键id查询主键索引树。\n\n这个过程和刚才非聚簇索引的查询过程相同，通过辅助索引查询到字段，但仍需要走主键索引补全select信息的过程，叫做回表。\n\n\n# 索引覆盖\n\n索引覆盖就是执行的sql查询的字段刚好可以命中索引，不需要额外回表\n\n例如\n\nselect id from student where id = 123\n\n\n1\n\n1\n\n\n这样的查询能够命中索引，且索引字段和查询字段匹配\n\n而例如\n\nselect id, name from student where id = 123\n\n\n1\n\n1\n\n\n这样的查询则会回表\n\n\n# 联合索引\n\n作为下文的基础，这里先说一下联合索引。\n\n假设现在有如下场景，按照市民的身份证号去查询他的家庭地址，这个查询需求在业务中出现的概率不高，但我们也不能让他直接走全表扫描。\n\n如果单独的为一个不频繁的查询请求创建一个索引，感觉又有点浪费资源，这时候就可以通过建立联合索引，减少开销。\n\n假设以数据库的a字段和b字段建立联合索引，a和b均为int类型字段\n\nalter table 'table_name' add index index_name('a','b');\n\n\n1\n\n1\n\n\n则生成的联合索引b+树会以联合索引字段共同建立，即联合索引的键值对大于1个\n\n\n\n将索引的叶子节点按照字段拿出来进行分析，从左至右\n\na的顺序为: 1, 1, 2, 2, 3, 3\n\nb的顺序为: 1, 2, 1, 4, 1, 2\n\n大家可以发现a字段是有序排列，b字段是无序排列(因为b+树只能选择一个字段来构建有序的树)\n\n同时通过观察还可以发现，在a相等的情况下，b字段是有序的，即此时a=1时，b=1，2，b保持相对有序。\n\n在平时的sql中，我们经常会有个共识，当要对两个字段进行排序时，首先会按照第一个字段排序，如果第一个字段相等，则用第二个字段排序。\n\n这种共识的原理就是因为，联合多字段建树时b+树的独特构建方式。\n\n\n# 最左前缀原则\n\n有了联合索引的概念，最左前缀原则就好理解了，由于b+树的建树方式，只有叶子节点存储数据，且叶子节点从左往右排序保持顺序，是最左前缀匹配的根本原因。\n\n如果要查询a字段所有以1开头的数据，则对应的sql条件为where a like '1%'。这个时候索引能够用上，查找到第一个符合条件的记录为id-1,然后一直向后遍历，直到不满足条件为止。\n\n再举一个能走联合索引的例子，如select * from student where a=1 and b=2。\n\n * 首先a字段在b+树上是有序的，所以我们通过二分查找来定位到a=1的位置，其次在a确定的情况下，b是相对有序的。因为有序，所以我们同样可以通过二分查找找到b=2的位置。此时索引是有效的。\n\n再举一个不能走联合索引的例子，如select * from student where b=2。\n\n * b字段有序的前提是：在a确定的情况下，现在查询条件中并没有规定a的范围，所以也无法确定b的顺序，在一棵无序的b+树上是无法用二分查找来定位到b字段的，这个时候索引失效。\n\n\n# 索引下推\n\n最左前缀可以用在索引中定位记录，那么那些不符合最左前缀的部分会怎么样呢？\n\n还是以联合索引(a, b)为例，假设现在表内有a,b,c,d...多个字段，如果现在有一个需求：检索出表中a字段第一个数字为1，且b字段为2，c字段为3的所有数据。那么这条sql语句则是这么写的：\n\nselect * from student where a like '1%' and b=2 and c=3;\n\n\n1\n\n1\n\n\n根据前缀规则，这个语句在搜索索引树时，只能用1，找到第一个满足条件的记录id-1。\n\n之后则需要判断其他条件是否满足。在mysql5.6之前，只能从id1开始一个个回表。到主键索引上找出数据行，再对比字段值。\n\n而mysql5.6引入的索引下推优化(index condition pushdown)，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。\n\n这两个过程可如下图所示。\n\n无索引下推过程，均需要回表\n\n\n\n索引下推过程\n\n\n\n在这两个图中，每个箭头表示回表一次\n\n在无索引下推过程中，innodb只需要观察a字段的值，按顺序把a字段第一个数值为1的记录一条条取出来进行回表，所以总计需要回表2次。\n\n索引下推过程的区别在于，innodb在(a, b)索引内部就判断了b字段是否等于2，对于不等于2的记录，直接判断并跳过。在这个例子中，只需要对id-2这一条记录回表取数据判断，只需要回表1次。\n\n\n# 索引分析—执行计划\n\n说了这么多，对于一条sql，我们分析的思路应该是怎么样的呢？\n\nmysql提供了explain命令，可以用于对sql的分析，根据分析出的结果，开发者可以针对性的进行优化\n\n提示\n\n后续操作基于如下数据表\n\ncreate table if not exists testindex.t_users\n(\n\tid bigint auto_increment comment '自增id'\n\t\tprimary key,\n\tname varchar(50) not null comment '姓名',\n\tsex int not null comment '性别，0女，1男',\n\tage int not null comment '年龄',\n\tinfo json null comment '信息'\n);\n\ninsert into testindex.t_users (id, name, sex, age, info) values (1, '张三', 1, 15, '{\"text\": \"我是张三\"}');\ninsert into testindex.t_users (id, name, sex, age, info) values (2, '李四', 1, 16, '{\"text\": \"我是李四\"}');\ninsert into testindex.t_users (id, name, sex, age, info) values (3, '王五', 0, 12, '{\"text\": \"我是王五\"}');\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n如何使用？\n\n在需要执行的sql前加上explain命令执行即可，如：\n\nmysql> explain select * from t_users where id < 2 \\g;\n*************************** 1. row ***************************\n           id: 1\n  select_type: simple\n        table: t_users\n   partitions: null\n         type: range\npossible_keys: primary\n          key: primary\n      key_len: 8\n          ref: null\n         rows: 1\n     filtered: 100.00\n        extra: using where\n1 row in set, 1 warning (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n在explain输出的内容中，重点关注select_type，type，key，rows，extra\n\n 1. select_type: 表示查询类型, 常见值表格如下\n\n查询类型                 解释\nsimple               表示查询语句不包含子查询或者union\nprimary              表示此查询最外层的查询\nunion                表示此查询是union的第二个或者后续的查询\ndependent union      union中的第二个或者后续的查询语句使用了外面的查询结果\nunion resulr         union的结果\nsunquery             select子查询语句\ndependent subquery   select子查询语句依赖外层的查询结果\n\n 2. type: 表示存储引擎查询数据时采用的方式。是一个比较重要的属性，通过它可以判断出查询是全表扫描还是基于索引的部分扫描。\n    \n    它的常见属性如下(从上到下，查询效率依次增强)\n\n * all: 全表扫描\n\nmysql> explain select * from t_users \\g;\n*************************** 1. row ***************************\n           id: 1\n  select_type: simple\n        table: t_users\n   partitions: null\n         type: all\npossible_keys: null\n          key: null\n      key_len: null\n          ref: null\n         rows: 3\n     filtered: 100.00\n        extra: null\n1 row in set, 1 warning (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * index: 基于索引的全表扫描，先扫描索引再扫描全表(在排序上性能优于all)\n\nmysql> explain select id from t_users \\g;\n*************************** 1. row ***************************\n           id: 1\n  select_type: simple\n        table: t_users\n   partitions: null\n         type: index\npossible_keys: null\n          key: primary\n      key_len: 8\n          ref: null\n         rows: 3\n     filtered: 100.00\n        extra: using index\n1 row in set, 1 warning (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * range: 表示使用索引的范围查询。用>,>=,<,<=等\n\nmysql> explain select * from t_users where id > 0 \\g;\n*************************** 1. row ***************************\n           id: 1\n  select_type: simple\n        table: t_users\n   partitions: null\n         type: range\npossible_keys: primary\n          key: primary\n      key_len: 8\n          ref: null\n         rows: 3\n     filtered: 100.00\n        extra: using where\n1 row in set, 1 warning (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * ref: 表示使用非唯一索引进行单值查询\n\n先为age字段创建索引\n\nmysql> alter table t_users add index `idx_t_user_age` (`age`);\nquery ok, 0 rows affected (0.21 sec)\nrecords: 0  duplicates: 0  warnings: 0\n\nmysql> explain select * from t_users where age = 15 \\g;\n*************************** 1. row ***************************\n           id: 1\n  select_type: simple\n        table: t_users\n   partitions: null\n         type: ref\npossible_keys: idx_t_user_age\n          key: idx_t_user_age\n      key_len: 4\n          ref: const\n         rows: 1\n     filtered: 100.00\n        extra: null\n1 row in set, 1 warning (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * eq_ref: 一般情况下出现在多表join查询，表示前面表的每一行记录，都只能匹配后面表的一行结果\n\n创建成绩表t_exam\n\ncreate table if not exists testindex.t_exam\n(\n\tid bigint auto_increment comment '自增id'\n\t\tprimary key,\n\tuser_id bigint not null comment '用户id',\n\tscore int null comment '成绩'\n);\n\ninsert into testindex.t_exam (id, user_id, score) values (1, 1, 96);\ninsert into testindex.t_exam (id, user_id, score) values (2, 2, 86);\ninsert into testindex.t_exam (id, user_id, score) values (3, 3, 76);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n采用多表join查询\n\nmysql> explain select * from t_users tu left join t_exam te on tu.id = te.user_id where te.score = 96;\n+----+-------------+-------+------------+--------+---------------+---------+---------+----------------------+------+----------+-------------+\n| id | select_type | table | partitions | type   | possible_keys | key     | key_len | ref                  | rows | filtered | extra       |\n+----+-------------+-------+------------+--------+---------------+---------+---------+----------------------+------+----------+-------------+\n|  1 | simple      | te    | null       | all    | null          | null    | null    | null                 |    3 |    33.33 | using where |\n|  1 | simple      | tu    | null       | eq_ref | primary       | primary | 8       | testindex.te.user_id |    1 |   100.00 | null        |\n+----+-------------+-------+------------+--------+---------------+---------+---------+----------------------+------+----------+-------------+\n2 rows in set, 1 warning (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * const: 表示使用主键或者卫衣索引做等值查询\n\nmysql> explain select * from t_users where id = 1 \\g;\n*************************** 1. row ***************************\n           id: 1\n  select_type: simple\n        table: t_users\n   partitions: null\n         type: const\npossible_keys: primary\n          key: primary\n      key_len: 8\n          ref: const\n         rows: 1\n     filtered: 100.00\n        extra: null\n1 row in set, 1 warning (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * null: 表示不用访问表，速度最快\n\nmysql> explain select 1;\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+\n| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | extra          |\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+\n|  1 | simple      | null  | null       | null | null          | null | null    | null | null |     null | no tables used |\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+\n1 row in set, 1 warning (0.00 sec)\n\nmysql> explain select now();\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+\n| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | extra          |\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+\n|  1 | simple      | null  | null       | null | null          | null | null    | null | null |     null | no tables used |\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+\n1 row in set, 1 warning (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n 3. possible_keys: 表示查询时能够使用到的索引，并不一定会真的使用，显示的是索引名称\n\n 4. key: 表示查询时真正用到的索引，显示的是索引名称\n\n 5. rows: mysql查询优化器根据统计信息，估算要查询到结果需要扫描多少行记录。原则上rows越少效率越高。\n\n 6. key_len: 表示查询使用了索引的字节数量。可以判断是否全部使用了联合索引。\n\n 7. extra: 表示额外信息，通常有以下表现\n\n * using where: 表示查询需要通过索引回表查询数据。即通过普通索引查询出主键，再通过主键查询出数据。\n\nmysql> explain select age from t_users where age = 15 and name = '张三';\n+----+-------------+---------+------------+------+----------------+----------------+---------+-------+------+----------+-------------+\n| id | select_type | table   | partitions | type | possible_keys  | key            | key_len | ref   | rows | filtered | extra       |\n+----+-------------+---------+------------+------+----------------+----------------+---------+-------+------+----------+-------------+\n|  1 | simple      | t_users | null       | ref  | idx_t_user_age | idx_t_user_age | 4       | const |    1 |    33.33 | using where |\n+----+-------------+---------+------------+------+----------------+----------------+---------+-------+------+----------+-------------+\n1 row in set, 1 warning (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n * using index: 表示通过索引就能查询出所需要的数据。效率最高\n\nmysql> explain select age from t_users where age=1;\n+----+-------------+---------+------------+------+----------------+----------------+---------+-------+------+----------+-------------+\n| id | select_type | table   | partitions | type | possible_keys  | key            | key_len | ref   | rows | filtered | extra       |\n+----+-------------+---------+------------+------+----------------+----------------+---------+-------+------+----------+-------------+\n|  1 | simple      | t_users | null       | ref  | idx_t_user_age | idx_t_user_age | 4       | const |    1 |   100.00 | using index |\n+----+-------------+---------+------------+------+----------------+----------------+---------+-------+------+----------+-------------+\n1 row in set, 1 warning (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n * using filesort: 表示查询结果需要额外排序，数据量小在内存，数据量大在磁盘。如果出现这个字段，建议优化sql\n\nmysql> explain select * from t_users order by id;\n+----+-------------+---------+------------+-------+---------------+---------+---------+------+------+----------+-------+\n| id | select_type | table   | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | extra |\n+----+-------------+---------+------------+-------+---------------+---------+---------+------+------+----------+-------+\n|  1 | simple      | t_users | null       | index | null          | primary | 8       | null |    3 |   100.00 | null  |\n+----+-------------+---------+------------+-------+---------------+---------+---------+------+------+----------+-------+\n1 row in set, 1 warning (0.00 sec)\n\nmysql> explain select * from t_users order by id,age;\n+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+----------------+\n| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | extra          |\n+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+----------------+\n|  1 | simple      | t_users | null       | all  | null          | null | null    | null |    3 |   100.00 | using filesort |\n+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+----------------+\n1 row in set, 1 warning (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * using temproary: 表示查询用到了临时表，一般出现在去重、分组等操作\n\nmysql> explain select distinct name from t_users;\n+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-----------------+\n| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | extra           |\n+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-----------------+\n|  1 | simple      | t_users | null       | all  | null          | null | null    | null |    3 |   100.00 | using temporary |\n+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-----------------+\n1 row in set, 1 warning (0.00 sec)\n\nmysql> explain select name, count(*) name from t_users group by name;\n+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-----------------+\n| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | extra           |\n+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-----------------+\n|  1 | simple      | t_users | null       | all  | null          | null | null    | null |    3 |   100.00 | using temporary |\n+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-----------------+\n1 row in set, 2 warnings (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 索引失效场景\n\n# 使用原则\n\n 1. 使用联合索引应满足最左匹配原则\n\n 2. 匹配数据从左至右，遇到范围查询(>、<、between、like)会停止匹配\n\n 3. 尽量选择高区分度的字段作为索引\n\n区分度公式：count(distinct col) / count(*)，表示字段不重复的比例，比例越大扫描的记录数越少。\n\n 4. 索引尽量不用在高频更新的字段上，最好用在高频查询字段\n\n# 失效场景\n\n 1. like '%xx'\n\nselect * from t_users where name like '%张';\n\n\n1\n\n1\n\n\n首字母有序时，后续相对有序，但无法确定首字符时，查询是乱序的。\n\n 2. 使用函数\n\n比如将索引列放入函数计算中，就无法走索引，比如max(age)。其原因在于，b+树需要把所有元素都应用在函数中才能比较。\n\n 3. or\n\n比如a,b,c三个字段，a和b建了索引，c没有建索引\n\n当执行如下sql时，能使用索引\n\nselect * from test where a = 1 or b = 2;\n\n\n1\n\n1\n\n\n当执行如下sql时，不能使用索引，a和b的索引失效\n\nselect * from test where a = 1 or b = 2 or c = 3;\n\n\n1\n\n1\n\n 4. 使用select *\n\nselect *会采用全表扫描，即使建立了索引，索引也会进行回表，效率低下\n\n 5. 字段类型不同\n\n比如有个字段age，原本是varchar，但sql查询时用的int类型传参，虽然查询能够成功，但实际上走的全表扫描，mysql通过字段的隐式转换保证了sql执行成功\n\nselect * from test where age = 123;\n\n\n1\n\n1\n\n 6. 不等于\n\n普通索引的不等于不会走索引\n\nselect * from test where name !='张三';\n\n\n1\n\n1\n\n\n主键索引的不等于会走索引\n\nselect * from test where id ! = 123;\n\n\n1\n\n1\n\n 7. order by\n\norder by排序条件为索引，则select字段必须也是索引字段，否则无法命中索引\n\n如果对主键排序，则还是能够走索引\n\nselect * from test order by id desc;\n\n\n1\n\n1\n\n 8. 范围查询\n\n比如a,b,c三个字段，a、b、c都建了索引\n\nselect * from test where a = 1 and b > 2 and c = 3\n\n\n1\n\n1\n\n\n只有a和b能够走索引，c不能走索引，范围查询就是索引截断处，原因和联合索引一致，在无法确定b有多少数量时，无法保证b的顺序性，在这个前提下导致c无法确定\n\n\n# 小表驱动大表\n\n这里补充一个额外的知识，小表驱动大表。\n\n首先引入一张网络中流传的经典图，了解left join, inner join, right join等常见结果\n\n\n\n所谓的小表驱动大表，可以理解为用小的数据集去匹配大的数据集。\n\n比如表a中有10条数据，表b中有10w条数据，外部执行一次连接，内部要执行多次\n\n按照小表驱动大表，a驱动b，则伪代码可写为\n\nfor (10条) {\n    for (10w条) {\n        ...\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n大表驱动小表，即b驱动a，伪代码可写为\n\nfor (10w条) {\n    for (10条) {\n        ...\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n两者的主要区别在于：小的循环在外层，表连接需要10次；大的循环在外层，表连接需要10w次。\n\n小表驱动大表的目的是为了减少连接创建的次数，加快查询速度。\n\n如何判断驱动表和非驱动表？\n\n1 left join左连接, 左边为驱动表, 右边为被驱动表\n\n2 right join右连接, 右边为驱动表, 左边为被驱动表\n\n3 inner join内连接, mysql会选择数据量比较小的表作为驱动表，大表作为被驱动表\n\n4 可通过explanin查看sql语句的执行计划, explanin分析的第一行的表即是驱动表\n\n\n# 总结\n\n相信读完这篇文章，读者能够对索引和b+树的原理有一定的了解，在开发过程中解决慢sql最为基本的分析方式可以采用explain，加上索引能够最简单有效的加快查询效率\n\n除此之外还可以从网络、mysql架构(读写分离/冷热备)等方向进行考虑，由于篇幅原因这里暂不介绍了~\n\n\n# 参考文章\n\n> 《mysql45讲》\n> \n> https://www.cnblogs.com/aaabbbcccddd/p/14864982.html\n> \n> https://www.jb51.net/article/229580.htm\n> \n> https://mp.weixin.qq.com/s/sshwkcugk5x4uf7zbc7stq\n> \n> https://blog.csdn.net/q736317048/article/details/114415571\n> \n> https://www.cnblogs.com/heishuichenzhou/p/10813463.html\n> \n> https://mp.weixin.qq.com/s/td_ydxbyfmlqn3bhmhonfq\n> \n> https://blog.csdn.net/abestrookie/article/details/117059948",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"概览",frontmatter:{title:"概览",article:!1,tags:[null],date:"2022-04-17T18:56:09.000Z",permalink:"/pages/6e0b99/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/05.%E6%A1%86%E6%9E%B6/01.Spring/01.SpringIOC/01.%E6%A6%82%E8%A7%88.html",relativePath:"05.框架/01.Spring/01.SpringIOC/01.概览.md",key:"v-cdef8cd4",path:"/pages/6e0b99/",headersStr:null,content:"提示\n\n正在路上...",normalizedContent:"提示\n\n正在路上...",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"利用AOP实现操作日志",frontmatter:{title:"利用AOP实现操作日志",date:"2020-06-26T10:54:58.000Z",description:"使用总结",categories:["SpringAOP"],tags:["AOP","Java"],keywords:"AOP,Java",permalink:"/pages/a657d3/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/05.%E6%A1%86%E6%9E%B6/01.Spring/02.SpringAOP/01.%E5%88%A9%E7%94%A8AOP%E5%AE%9E%E7%8E%B0%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97.html",relativePath:"05.框架/01.Spring/02.SpringAOP/01.利用AOP实现操作日志.md",key:"v-00f38f3a",path:"/pages/a657d3/",headers:[{level:2,title:"利用AOP实现操作日志",slug:"利用aop实现操作日志",normalizedTitle:"利用aop实现操作日志",charIndex:2}],headersStr:"利用AOP实现操作日志",content:'# 利用AOP实现操作日志\n\nAOP能够实现一些前置或者后置任务，作为一个切面，来完成例如日志记录、性能统计、安全控制、事务处理、异常处理等任务。这篇文章主要是总结自己利用AOP去实现全局操作日志记录功能的步骤。\n\n要完成日志功能的记录和查询首先需要一个数据库表，命名为sysLog\n\n包含id、visitTime、username、ip、url、executionTime、method字段\n\n分别代表主键、访问时间、操作者用户名、访问ip、访问资源url、执行时长、访问方法。\n\n创建一个对应的实体类\n\npublic class SysLog {\n    private String id;\n    private Date visitTime;\n    private String visitTimeStr;\n    private String username;\n    private String ip;\n    private String url;\n    private Long executionTime;\n    private String method;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n创建AOP切面\n\n 1. 前置通知：\n    \n    开始时间的获取直接new Date()即可\n    \n    利用JoinPoint对象的getTarget()方法可以获得被代理的对象，之后通过getClass()获取要访问的类\n    \n    那么如何去获得类中的方法名称呢？\n    \n    JoinPoint中还有一个方法叫getSignature()用于获取封装了署名信息的对象，在该对象中可以获取到目标方\n    \n    法名，所属类的Class等信息\n    \n    除此之外还可以通过getArgs()方法获取传入目标方法的参数对象\n\n 2. 后置通知：\n    \n    结束时间可以直接用new Date().getTime()减去开始时间，即可获得访问时长了\n    \n    我们还想要获取Controller中执行注解的url，有一下几个步骤：\n    \n    当访问的类、访问的方法不为空且当前的类不是AOP这个类的时候，进行反射url获取\n    \n    我们可以通过getAnnotation(xxx.class)获取class的注解，并通过.value()找到对应的RequesMapping映\n    \n    射值，在这里我们分别通过clazz.getAnnotation和method.getAnnotation获取对应的类和方法上的url\n    \n    之后进行字符串拼接即可得到完整的操作路径。\n    \n    如何获取IP地址呢？如果我们能够拿到request对象，那么获取ip地址就比较容易，这里采用了Spring提供的\n    \n    org.springframework.web.context.request.RequestContextListener，在LogAop中我们可以注入一\n    \n    个HttpServletRequest request，通过request.getRemoteAddr()获取ip地址。\n    \n    由于当前的用户受到SpringSecurity的控制，所以获取操作用户的对象，也必须从SpringSecurity的上下文中获取\n    \n    具体代码如下，获取的User非用户定义，而是SpringSecurity中提供的User；\n    \n    或者通过request.getSession().getAttribute("SPRING_SECURITY_CONTEXT")也可以获取User对象\n    \n    SecurityContext context = SecurityContextHolder.getContext();// 从上下文中获取当前登陆的用户\n    User user = (User) context.getAuthentication().getPrincipal();\n    String username = user.getUsername();\n    \n    \n    1\n    2\n    3\n    \n    1\n    2\n    3\n    \n    \n    之后可以对上面的信息进行数据存储，或者查询操作\n\n@Component\n@Aspect\npublic class LogAop {\n\n    @Autowired\n    private HttpServletRequest request;\n\n    @Autowired\n    private ISysLogService sysLogService;\n\n    private Date visitTime; // 开始时间\n    private Class clazz;// 访问的类\n    private Method method;// 访问的方法\n\n    //前置通知 主要是获取开始时间，执行的类是哪一个，执行的是哪一个方法\n    @Before("execution(* com.cqupt.lesson.controller.*.*(..))")\n    public void doBefore(JoinPoint jp) throws NoSuchMethodException {\n        visitTime = new Date();// 当前时间是就是开始访问的时间\n        clazz = jp.getTarget().getClass();// 具体要访问的类\n        String methodName = jp.getSignature().getName();// 获取访问的方法的名称\n        Object[] args = jp.getArgs();// 获取访问的方法的参数\n        // 获取具体执行方法的Method对象\n        if (args == null || args.length == 0) {\n            method = clazz.getMethod(methodName);// 只能获取无参数的方法\n        } else {\n            // 构建Class[]数组\n            Class[] classArgs = new Class[args.length];\n            for (int i = 0; i < args.length; i++) {\n                classArgs[i] = args[i].getClass();\n            }\n            clazz.getMethod(methodName, classArgs);// 获取有参的方法\n        }\n    }\n\n    //后置通知\n    //通过反射完成方法体的寻找\n    @After("execution(* com.cqupt.lesson.controller.*.*(..))")\n    public void doAfter(JoinPoint jp) throws Exception {\n        long time = new Date().getTime() - visitTime.getTime();// 获取访问时长\n\n        String url = "";\n        // 获取url\n        if (clazz != null && method != null && clazz != LogAop.class) {\n\n            //1、获取类上的@RequestMapping("/orders")\n            RequestMapping classAnnotation = (RequestMapping) clazz.getAnnotation(RequestMapping.class);\n            if (classAnnotation != null) {\n                String[] classValue = classAnnotation.value();\n\n                //2、获取方法上的@RequestMapping("/findAll")\n                RequestMapping methodAnnotation = method.getAnnotation(RequestMapping.class);\n                if (methodAnnotation != null) {\n                    String[] methodValue = methodAnnotation.value();\n                    url = classValue[0] + methodValue[0];\n                    // 获取访问的ip地址\n                    String ip = request.getRemoteAddr();\n\n                    // 获取当前操作的用户\n                    SecurityContext context = SecurityContextHolder.getContext();// 从上下文中获取当前登陆的用户\n                    User user = (User) context.getAuthentication().getPrincipal();\n                    String username = user.getUsername();\n\n                    //将日志相关信息封装到SysLog对象\n                    SysLog sysLog = new SysLog();\n                    sysLog.setExecutionTime(time);//执行时长\n                    sysLog.setIp(ip);\n                    sysLog.setMethod("[类名] " + clazz.getName() + "[方法名] " + method.getName());\n                    sysLog.setUrl(url);\n                    sysLog.setUsername(username);\n                    sysLog.setVisitTime(visitTime);\n\n                    //调用Service完成操作\n                    sysLogService.save(sysLog);\n                }\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n',normalizedContent:'# 利用aop实现操作日志\n\naop能够实现一些前置或者后置任务，作为一个切面，来完成例如日志记录、性能统计、安全控制、事务处理、异常处理等任务。这篇文章主要是总结自己利用aop去实现全局操作日志记录功能的步骤。\n\n要完成日志功能的记录和查询首先需要一个数据库表，命名为syslog\n\n包含id、visittime、username、ip、url、executiontime、method字段\n\n分别代表主键、访问时间、操作者用户名、访问ip、访问资源url、执行时长、访问方法。\n\n创建一个对应的实体类\n\npublic class syslog {\n    private string id;\n    private date visittime;\n    private string visittimestr;\n    private string username;\n    private string ip;\n    private string url;\n    private long executiontime;\n    private string method;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n创建aop切面\n\n 1. 前置通知：\n    \n    开始时间的获取直接new date()即可\n    \n    利用joinpoint对象的gettarget()方法可以获得被代理的对象，之后通过getclass()获取要访问的类\n    \n    那么如何去获得类中的方法名称呢？\n    \n    joinpoint中还有一个方法叫getsignature()用于获取封装了署名信息的对象，在该对象中可以获取到目标方\n    \n    法名，所属类的class等信息\n    \n    除此之外还可以通过getargs()方法获取传入目标方法的参数对象\n\n 2. 后置通知：\n    \n    结束时间可以直接用new date().gettime()减去开始时间，即可获得访问时长了\n    \n    我们还想要获取controller中执行注解的url，有一下几个步骤：\n    \n    当访问的类、访问的方法不为空且当前的类不是aop这个类的时候，进行反射url获取\n    \n    我们可以通过getannotation(xxx.class)获取class的注解，并通过.value()找到对应的requesmapping映\n    \n    射值，在这里我们分别通过clazz.getannotation和method.getannotation获取对应的类和方法上的url\n    \n    之后进行字符串拼接即可得到完整的操作路径。\n    \n    如何获取ip地址呢？如果我们能够拿到request对象，那么获取ip地址就比较容易，这里采用了spring提供的\n    \n    org.springframework.web.context.request.requestcontextlistener，在logaop中我们可以注入一\n    \n    个httpservletrequest request，通过request.getremoteaddr()获取ip地址。\n    \n    由于当前的用户受到springsecurity的控制，所以获取操作用户的对象，也必须从springsecurity的上下文中获取\n    \n    具体代码如下，获取的user非用户定义，而是springsecurity中提供的user；\n    \n    或者通过request.getsession().getattribute("spring_security_context")也可以获取user对象\n    \n    securitycontext context = securitycontextholder.getcontext();// 从上下文中获取当前登陆的用户\n    user user = (user) context.getauthentication().getprincipal();\n    string username = user.getusername();\n    \n    \n    1\n    2\n    3\n    \n    1\n    2\n    3\n    \n    \n    之后可以对上面的信息进行数据存储，或者查询操作\n\n@component\n@aspect\npublic class logaop {\n\n    @autowired\n    private httpservletrequest request;\n\n    @autowired\n    private isyslogservice syslogservice;\n\n    private date visittime; // 开始时间\n    private class clazz;// 访问的类\n    private method method;// 访问的方法\n\n    //前置通知 主要是获取开始时间，执行的类是哪一个，执行的是哪一个方法\n    @before("execution(* com.cqupt.lesson.controller.*.*(..))")\n    public void dobefore(joinpoint jp) throws nosuchmethodexception {\n        visittime = new date();// 当前时间是就是开始访问的时间\n        clazz = jp.gettarget().getclass();// 具体要访问的类\n        string methodname = jp.getsignature().getname();// 获取访问的方法的名称\n        object[] args = jp.getargs();// 获取访问的方法的参数\n        // 获取具体执行方法的method对象\n        if (args == null || args.length == 0) {\n            method = clazz.getmethod(methodname);// 只能获取无参数的方法\n        } else {\n            // 构建class[]数组\n            class[] classargs = new class[args.length];\n            for (int i = 0; i < args.length; i++) {\n                classargs[i] = args[i].getclass();\n            }\n            clazz.getmethod(methodname, classargs);// 获取有参的方法\n        }\n    }\n\n    //后置通知\n    //通过反射完成方法体的寻找\n    @after("execution(* com.cqupt.lesson.controller.*.*(..))")\n    public void doafter(joinpoint jp) throws exception {\n        long time = new date().gettime() - visittime.gettime();// 获取访问时长\n\n        string url = "";\n        // 获取url\n        if (clazz != null && method != null && clazz != logaop.class) {\n\n            //1、获取类上的@requestmapping("/orders")\n            requestmapping classannotation = (requestmapping) clazz.getannotation(requestmapping.class);\n            if (classannotation != null) {\n                string[] classvalue = classannotation.value();\n\n                //2、获取方法上的@requestmapping("/findall")\n                requestmapping methodannotation = method.getannotation(requestmapping.class);\n                if (methodannotation != null) {\n                    string[] methodvalue = methodannotation.value();\n                    url = classvalue[0] + methodvalue[0];\n                    // 获取访问的ip地址\n                    string ip = request.getremoteaddr();\n\n                    // 获取当前操作的用户\n                    securitycontext context = securitycontextholder.getcontext();// 从上下文中获取当前登陆的用户\n                    user user = (user) context.getauthentication().getprincipal();\n                    string username = user.getusername();\n\n                    //将日志相关信息封装到syslog对象\n                    syslog syslog = new syslog();\n                    syslog.setexecutiontime(time);//执行时长\n                    syslog.setip(ip);\n                    syslog.setmethod("[类名] " + clazz.getname() + "[方法名] " + method.getname());\n                    syslog.seturl(url);\n                    syslog.setusername(username);\n                    syslog.setvisittime(visittime);\n\n                    //调用service完成操作\n                    syslogservice.save(syslog);\n                }\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"01背包问题详解",frontmatter:{title:"01背包问题详解",date:"2020-08-25T15:26:04.000Z",description:"01背包问题详解",tags:["数组","DP","背包问题","Java","Medium"],keywords:"数组,DP,背包问题,Java,Medium,LeetCode",permalink:"/pages/83cdcf/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/00.01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3.html",relativePath:"06.算法/01.剑指Offer/00.01背包问题详解.md",key:"v-218946b4",path:"/pages/83cdcf/",headers:[{level:2,title:"01背包问题详解",slug:"_01背包问题详解",normalizedTitle:"01背包问题详解",charIndex:2},{level:4,title:"01背包问题的另一种风格描述",slug:"_01背包问题的另一种风格描述",normalizedTitle:"01背包问题的另一种风格描述",charIndex:597},{level:4,title:"暴力解法",slug:"暴力解法",normalizedTitle:"暴力解法",charIndex:678},{level:4,title:"动态规划",slug:"动态规划",normalizedTitle:"动态规划",charIndex:479},{level:4,title:"1. 吉他行",slug:"_1-吉他行",normalizedTitle:"1. 吉他行",charIndex:1170},{level:4,title:"2. 音响行",slug:"_2-音响行",normalizedTitle:"2. 音响行",charIndex:1697},{level:4,title:"3. 笔记本电脑行",slug:"_3-笔记本电脑行",normalizedTitle:"3. 笔记本电脑行",charIndex:2082},{level:4,title:"4. 等等，再增加一件商品将如何变化呢？",slug:"_4-等等-再增加一件商品将如何变化呢",normalizedTitle:"4. 等等，再增加一件商品将如何变化呢？",charIndex:2788},{level:3,title:"DP代码实现如下",slug:"dp代码实现如下",normalizedTitle:"dp代码实现如下",charIndex:3899},{level:3,title:"递归代码实现",slug:"递归代码实现",normalizedTitle:"递归代码实现",charIndex:7005},{level:3,title:"记忆化搜索",slug:"记忆化搜索",normalizedTitle:"记忆化搜索",charIndex:8209}],headersStr:"01背包问题详解 01背包问题的另一种风格描述 暴力解法 动态规划 1. 吉他行 2. 音响行 3. 笔记本电脑行 4. 等等，再增加一件商品将如何变化呢？ DP代码实现如下 递归代码实现 记忆化搜索",content:"# 01背包问题详解\n\n问题描述：\n\n提示\n\n给定 n 件物品，物品的重量为 w[i]，物品的价值为 c[i]。现挑选物品放入背包中，假定背包能承受的最大重量为 V，问应该如何选择装入背包中的物品，使得装入背包中物品的总价值最大？\n\n输入：\n\n4 4\n1 1500\n4 3000\n3 2000\n1 2000\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n输出：\n\n4000\n\n\n1\n\n1\n\n\n解释：输入的第一行n，W分别代表接下来有n组输入数据，背包的总容量为W；在接下来的n行中，每一行2个数字，分别表示为wi和vi，代表第n个物品的重量和价值。\n\n----------------------------------------\n\n参考链接\n\n> https://www.jianshu.com/p/a66d5ce49df5\n\n> https://www.cnblogs.com/kkbill/p/12081172.html\n\n> https://blog.csdn.net/chanmufeng/article/details/82955730\n\n动态规划类的问题，最重要的是如何去定义状态，找到问题的子问题，从而定义出状态转移方程。背包问题是一类经典的动态规划题目，01背包问题是其中最为基础的一个。本文结合多个题解，给出01背包问题的直观解释，以及多种求解方法的代码实现。\n\n# 01背包问题的另一种风格描述\n\n假设你是一个小偷，背着一个可装下4磅东西的背包，你可以偷窃的物品如下：\n\n\n\n为了让偷窃的商品价值最高，你该选择哪些商品？\n\n# 暴力解法\n\n最简单的算法是：尝试各种可能的商品组合，并找出价值最高的组合。\n\n\n\n这样显然是可行的，但是速度非常慢。在只有3件商品的情况下，你需要计算8个不同的集合；当有4件商品的时候，你需要计算16个不同的集合。每增加一件商品，需要计算的集合数都将翻倍！对于每一件商品，都有选或不选两种可能，即这种算法的运行时间是O(2ⁿ)。\n\n# 动态规划\n\n解决这样问题的答案就是使用动态规划！下面来看看动态规划的工作原理。动态规划先解决子问题，再逐步解决大问题。\n\n对于背包问题，你先解决小背包（子背包）问题，再逐步解决原来的问题。\n\n\n\n比较有趣的一句话是：每个动态规划都从一个网格开始。 （所以学会网格的推导至关重要，而有些题解之所以写的不好，就是因为没有给出网格的推导过程，或者说，没有说清楚为什么要”这样“设计网格。本文恰是解决了我这方面长久以来的困惑！）\n\n背包问题的网格如下：\n\n\n\n网格的各行表示商品，各列代表不同容量（1~4磅）的背包。所有这些列你都需要，因为它们将帮助你计算子背包的价值。\n\n网格最初是空的。你将填充其中的每个单元格，网格填满后，就找到了问题的答案！\n\n# 1. 吉他行\n\n后面会列出计算这个网格中单元格值得公式，但现在我们先来一步一步做。首先来看第一行。\n\n\n\n这是吉他行，意味着你将尝试将吉他装入背包。在每个单元格，都需要做一个简单的决定：偷不偷吉他？别忘了，你要找出一个价值最高的商品集合。\n\n第一个单元格表示背包的的容量为1磅。吉他的重量也是1磅，这意味着它能装入背包！因此这个单元格包含吉他，价值为1500美元。\n\n下面来填充网格。\n\n\n\n与这个单元格一样，每个单元格都将包含当前可装入背包的所有商品。\n\n来看下一个单元格。这个单元格表示背包容量为2磅，完全能够装下吉他！\n\n\n\n这行的其他单元格也一样。别忘了，这是第一行，只有吉他可供你选择，换而言之，你假装现在还没发偷窃其他两件商品。\n\n\n\n此时你很可能心存疑惑：原来的问题说的是4磅的背包，我们为何要考虑容量为1磅、2磅等得背包呢？前面说过，动态规划从子问题着手，逐步解决大问题。这里解决的子问题将帮助你解决大问题。\n\n\n\n别忘了，你要做的是让背包中商品的价值最大。这行表示的是当前的最大价值。它指出，如果你有一个容量4磅的背包，可在其中装入的商品的最大价值为1500美元。\n\n你知道这不是最终解。随着算法往下执行，你将逐步修改最大价值。\n\n# 2. 音响行\n\n我们来填充下一行——音响行。你现在处于第二行，可以偷窃的商品有吉他和音响。\n\n我们先来看第一个单元格，它表示容量为1磅的背包。在此之前，可装入1磅背包的商品最大价值为1500美元。\n\n\n\n该不该偷音响呢？\n\n背包的容量为1磅，显然不能装下音响。由于容量为1磅的背包装不下音响，因此最大价值依然是1500美元。\n\n\n\n接下来的两个单元格的情况与此相同。在这些单元格中，背包的容量分别为2磅和3磅，而以前的最大价值为1500美元。由于这些背包装不下音响，因此最大的价值保持不变。\n\n\n\n背包容量为4磅呢？终于能够装下音响了！原来最大价值为1500美元，但如果在背包中装入音响而不是吉他，价值将为3000美元！因此还是偷音响吧。\n\n\n\n你更新了最大价值。如果背包的容量为4磅，就能装入价值至少3000美元的商品。在这个网格中，你逐步地更新最大价值。\n\n\n\n# 3. 笔记本电脑行\n\n下面以同样的方式处理笔记本电脑。笔记本电脑重3磅，没法将其装入1磅或者2磅的背包，因此前两个单元格的最大价值仍然是1500美元。\n\n\n\n对于容量为3磅的背包，原来的最大价值为1500美元，但现在你可以选择偷窃价值2000美元的笔记本电脑而不是吉他，这样新的最大价值将为2000美元。\n\n\n\n对于容量为4磅的背包，情况很有趣。这是非常重要的部分。当前的最大价值为3000美元，你可不偷音响，而偷笔记本电脑，但它只值2000美元。\n\n\n\n价值没有原来高，但是等一等，笔记本电脑的重量只有3磅，背包还有1磅的重量没用！\n\n\n\n在1磅的容量中，可装入的商品的最大价值是多少呢？ 你之前计算过！\n\n\n\n根据之前计算的最大价值可知，在1磅的容量中可装入吉他，价值1500美元。因此，你需要做如下的比较：\n\n\n\n你可能始终心存疑惑：为何计算小背包可装入的商品的最大价值呢？但愿你现在明白了其中的原因！当出现部分剩余空间时，你可根据这些子问题的答案来确定余下的空间可装入哪些商品。笔记本电脑和吉他的总价值为3500美元，因此偷它们是更好的选择。\n\n最终的网格类似于下面这样。\n\n\n\n答案如下：将吉他和笔记本电脑装入背包时价值更高，为3500美元。\n\n你可能认为，计算最后一个单元格的价值时，我使用了不同的公式。那是因为填充之前的单元格时，我故意避开了一些复杂的因素。其实，计算每个单元格的价值时，使用的公式都相同。这个公式如下。\n\n\n\n你可以使用这个公式来计算每个单元格的价值，最终的网格将与前一个网格相同。现在你明白了为何要求解子问题了吧？——因为你可以合并两个子问题的解来得到更大问题的解。\n\n\n\n# 4. 等等，再增加一件商品将如何变化呢？\n\n假设你发现还有第四件商品可偷——一个iPhone！（或许你会毫不犹豫的拿走，但是请别忘了问题的本身是要拿走价值最大的商品）\n\n\n\n此时需要重新执行前面所做的计算吗？不需要。别忘了，动态规划逐步计算最大价值。到目前为止，计算出的最大价值如下：\n\n\n\n这意味着背包容量为4磅时，你最多可偷价值3500美元的商品。但这是以前的情况，下面再添加表示iPhone的行。\n\n\n\n我们还是从第一个单元格开始。iPhone可装入容量为1磅的背包。之前的最大价值为1500美元，但iPhone价值2000美元，因此该偷iPhone而不是吉他。\n\n\n\n在下一个单元格中，你可装入iPhone和吉他。\n\n\n\n对于第三个单元格，也没有比装入iPhone和吉他更好的选择了。\n\n对于最后一个单元格，情况比较有趣。当前的最大价值为3500美元，但你可以偷iPhone，这将余下3磅的容量。\n\n\n\n3磅容量的最大价值为2000美元！再加上iPhone价值2000美元，总价值为4000美元。新的最大价值诞生了！\n\n最终的网格如下：\n\n\n\n----------------------------------------\n\n现在回到问题本身，给定n个重量为w1,w2,w3,....,wn，价值为v1,v2,v3,...,vn的物品和容量为W的背包，问应该如何选择装入背包中的物品，使得装入背包中的物品的总价值最大？每个物品只能使用一次(01背包特点)\n\n依然用上文的3个物品为例，物品的重量weight[]={1,3,1}，对应的价值为value[]={15,30,20}，现挑选物品放入背包中，假定背包的最大重量W=4\n\n令 dp[i][w] 表示前 i 件物品放入容量为 w 的背包中可获得的最大价值。为了方便处理，我们约定下标从 1 开始。初始时，网格如下：\n\n\n\n根据之前已经引出的状态转移方程，我们再来理解一遍，对于编号为 i 的物品：\n\n * 如果选择它，那么，当前背包的最大价值等于” i 号物品的价值“ 加上 ”减去 i 号物品占用的空间后剩余的背包空间所能存放的最大价值“，即dp[i][k] = value[i] + dp[i-1][k-weight[i]]；\n * 如果不选择它，那么，当前背包的价值就等于前 i-1 个物品存放在背包中的最大价值，即dp[i][k] = dp[i-1][k]\n\ndp[i][k]的结果取两者的较大值，即：\n\ndp[i][k] = max(value[i] + dp[i-1][k-weight[i]], dp[i-1][k])\n\n\n1\n\n1\n\n\n\n# DP代码实现如下\n\n动态规划+二维数组：\n\npublic class Package_01 {\n    public static void main(String[] args) {\n        int[] weights = {1, 4, 3, 1};\n        int[] value = {1500, 3000, 2000, 2000};\n        int W = 4;\n        System.out.println(maxValue(weights, value, W));\n    }\n\n    public int maxValue(int[] weight, int[] value, int W) {\n        int n = weight.length;\n        if (n == 0) return 0;\n\n        int[][] dp = new int[n][W + 1];\n        // 先初始化第 0 行，也就是尝试把 0 号物品放入容量为 k 的背包中\n        for (int k = 1; k <= W; k++) {\n            if (k >= weight[0]) dp[0][k] = value[0];\n        }\n\n        for (int i = 1; i < n; i++) {\n            for (int k = 1; k <= W; k++) {\n                // 存放 i 号物品（前提是放得下这件物品）\n                int valueWith_i = (k-weight[i] >= 0) ? (value[i] + dp[i-1][k-weight[i]]) : 0;\n                // 不存放 i 号物品\n                int valueWithout_i = dp[i-1][k];\n                dp[i][k] = Math.max(valueWith_i, valueWithout_i);\n            }\n        }\n        return dp[n-1][W];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n时间复杂度：O(nW)；空间复杂度O(nW)\n\n动态规划+压缩空间：\n\n观察上面的代码，会发现，当更新dp[i][..]时，只与dp[i-1][..]有关，也就是说，我们没有必要使用O(n*W)的空间，而是只使用O(W)的空间即可。下面先给出代码，再结合图例进行说明。\n\npublic int maxValue(int[] weight, int[] value, int W) {\n    int n = weight.length;\n    if (n == 0) return 0;\n    // 辅助空间只需要O(W)即可\n    int[] dp = new int[W + 1];\n    for (int i = 0; i < n; i++) {\n        // 注意这里必须从后向前！！！\n        for (int k = W; k >= 1; k--) {\n            int valueWith_i = (k - weight[i] >= 0) ? (dp[k - weight[i]] + value[i]) : 0;\n            int valueWithout_i = dp[k];\n            dp[k] = Math.max(valueWith_i, valueWithout_i);\n        }\n    }\n    return dp[W];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n这里的状态转移方程变成了：dp[k](新值) = max(value[i]+dp[k-weight[i]](旧值), dp[k](旧值))\n\n为什么说这里必须反向遍历来更新dp[]数组的值呢？原因是索引较小的元素可能会被覆盖。我们来看例子，假设我们已经遍历完了第 i=1 个元素（即weight=3, value=30），如下图所示：\n\n\n\n现在要更新第 i=2 个元素（即weight=1, value=20），由于我们只申请了一维空间的数组，因此对dp[]数组的修改会覆盖上一轮dp[]数组的值，这里用浅色代表上一轮的值，深色代表当前这一轮的值。\n\n\n\n鉴于上面出现的问题，因此必须采用反向遍历来回避这个问题。仍然假设第 i=1 个元素已经更新完毕，现在更新第 i=2 个元素。示意图如下：\n\n\n\n可以看到，反向遍历就可以避免这个问题了！\n\n事实上，我们还可以进一步简化上面的代码，如下：\n\npublic int maxValue(int[] weight, int[] value, int W) {\n    int n = weight.length;\n    if (n == 0) return 0;\n    int[] dp = new int[W + 1];\n    for (int i = 0; i < n; i++) {\n        //只要确保 k>=weight[i] 即可，而不是 k>=1，从而减少遍历的次数\n        for (int k = W; k >= weight[i]; k--) {\n            dp[k] = Math.max(dp[k - weight[i]] + value[i], dp[k]);\n        }\n    }\n    return dp[W];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n为什么可以这样简化呢？我们重新看一下这段代码：\n\nfor (int k = W; k >= 1; k--) {\n    int valueWith_i = (k - weight[i] >= 0) ? (dp[k - weight[i]] + value[i]) : 0;\n    int valueWithout_i = dp[k];\n    dp[k] = Math.max(valueWith_i, valueWithout_i);\n}\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n如果k>=weight[i] 不成立，则valueWith_i 的值为0，那么显然有：\n\ndp[k] = Math.max(valueWith_i, valueWithout_i) = max(0, dp[k]) = dp[k] \n\n\n1\n\n1\n\n\n也就是dp[k]没有更新过，它的值还是上一轮的值，因此就没必要执行了，可以提前退出循环！\n\n\n# 递归代码实现\n\n这类问题同样可以采用递归的方式来解决\n\n我们用F(n,W)表示将前n个物品放进容量为W的背包中，得到的最大的价值\n\n我们用自顶向下的角度来看，假如我们已经进行到了最后一步(即求解将n个物品放到背包里获得的最大价值)，此时我们便有两种选择\n\n 1. 不放第n个物品，此时总价值为F(n-1,W)\n 2. 放置第n个物品，此时总价值为vn+F(n-1,W-wn)\n\n两种选择中总价值最大的方案就是我们的方案，转移方程为：\n\n                F(i,W) = max(F(i-1,W),vi+F(i-1,W-wi))\n\n\n1\n\n1\n\n\n编程实现如下：\n\npublic class Solution {\n    public static void main(String[] args) {\n        int[] weights = {1, 4, 3, 1};\n        int[] value = {1500, 3000, 2000, 2000};\n        int W = 4;\n        int index = weights.length - 1;\n        System.out.println(maxValue3(weights, value, index, W));\n    }\n\n    private static int maxValue3(int[] weights, int[] value, int index, int W) {\n        // 如果索引无效或者容量不足，直接返回当前价值0\n        if (index < 0 || W <= 0) {\n            return 0;\n        }\n        // 不放第index个物品所得价值\n        int res = maxValue3(weights, value, index - 1, W);\n        // 放第index个物品所得价值(前提是：第index个物品可以放得下)\n        if (weights[index] <= W) {\n            res = Math.max(res, value[index] + maxValue3(weights, value, index - 1, W - weights[index]));\n        }\n        return res;\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 记忆化搜索\n\n递归的代码可以很清晰的对照转移方程，不过因为重复计算太多，递归基本上会超时，效率十分低下\n\n我们可以将已经求得的子问题的结果保存下来，这样对子问题只会求解一次，这便是记忆化搜索。在递归的代码基础上，进行改进\n\n\npublic class Solution {\n\n    private static int[][] memo;\n\n    public static void main(String[] args) {\n        int[] weights = {1, 4, 3, 1};\n        int[] value = {1500, 3000, 2000, 2000};\n        int W = 4;\n        int index = weights.length - 1;\n        memo = new int[weights.length][W + 1];\n        System.out.println(maxValue4(weights, value, index, W));\n    }\n\n    private static int maxValue4(int[] weights, int[] value, int index, int W) {\n        // 如果索引无效或者容量不足，直接返回当前价值0\n        if (index < 0 || W <= 0) {\n            return 0;\n        }\n        // 如果此子问题已经求解过，则直接返回上次求解的结果\n        if (memo[index][W] != 0) {\n            return memo[index][W];\n        }\n\n        // 不放第index个物品所得价值\n        int res = maxValue4(weights, value, index - 1, W);\n        // 放第index个物品所得价值(前提是：第index个物品可以放得下)\n        if (weights[index] <= W) {\n            res = Math.max(res, value[index] + maxValue4(weights, value, index - 1, W - weights[index]));\n        }\n        // 添加子问题的解，便于下次直接使用\n        memo[index][W] = res;\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n",normalizedContent:"# 01背包问题详解\n\n问题描述：\n\n提示\n\n给定 n 件物品，物品的重量为 w[i]，物品的价值为 c[i]。现挑选物品放入背包中，假定背包能承受的最大重量为 v，问应该如何选择装入背包中的物品，使得装入背包中物品的总价值最大？\n\n输入：\n\n4 4\n1 1500\n4 3000\n3 2000\n1 2000\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n输出：\n\n4000\n\n\n1\n\n1\n\n\n解释：输入的第一行n，w分别代表接下来有n组输入数据，背包的总容量为w；在接下来的n行中，每一行2个数字，分别表示为wi和vi，代表第n个物品的重量和价值。\n\n----------------------------------------\n\n参考链接\n\n> https://www.jianshu.com/p/a66d5ce49df5\n\n> https://www.cnblogs.com/kkbill/p/12081172.html\n\n> https://blog.csdn.net/chanmufeng/article/details/82955730\n\n动态规划类的问题，最重要的是如何去定义状态，找到问题的子问题，从而定义出状态转移方程。背包问题是一类经典的动态规划题目，01背包问题是其中最为基础的一个。本文结合多个题解，给出01背包问题的直观解释，以及多种求解方法的代码实现。\n\n# 01背包问题的另一种风格描述\n\n假设你是一个小偷，背着一个可装下4磅东西的背包，你可以偷窃的物品如下：\n\n\n\n为了让偷窃的商品价值最高，你该选择哪些商品？\n\n# 暴力解法\n\n最简单的算法是：尝试各种可能的商品组合，并找出价值最高的组合。\n\n\n\n这样显然是可行的，但是速度非常慢。在只有3件商品的情况下，你需要计算8个不同的集合；当有4件商品的时候，你需要计算16个不同的集合。每增加一件商品，需要计算的集合数都将翻倍！对于每一件商品，都有选或不选两种可能，即这种算法的运行时间是o(2ⁿ)。\n\n# 动态规划\n\n解决这样问题的答案就是使用动态规划！下面来看看动态规划的工作原理。动态规划先解决子问题，再逐步解决大问题。\n\n对于背包问题，你先解决小背包（子背包）问题，再逐步解决原来的问题。\n\n\n\n比较有趣的一句话是：每个动态规划都从一个网格开始。 （所以学会网格的推导至关重要，而有些题解之所以写的不好，就是因为没有给出网格的推导过程，或者说，没有说清楚为什么要”这样“设计网格。本文恰是解决了我这方面长久以来的困惑！）\n\n背包问题的网格如下：\n\n\n\n网格的各行表示商品，各列代表不同容量（1~4磅）的背包。所有这些列你都需要，因为它们将帮助你计算子背包的价值。\n\n网格最初是空的。你将填充其中的每个单元格，网格填满后，就找到了问题的答案！\n\n# 1. 吉他行\n\n后面会列出计算这个网格中单元格值得公式，但现在我们先来一步一步做。首先来看第一行。\n\n\n\n这是吉他行，意味着你将尝试将吉他装入背包。在每个单元格，都需要做一个简单的决定：偷不偷吉他？别忘了，你要找出一个价值最高的商品集合。\n\n第一个单元格表示背包的的容量为1磅。吉他的重量也是1磅，这意味着它能装入背包！因此这个单元格包含吉他，价值为1500美元。\n\n下面来填充网格。\n\n\n\n与这个单元格一样，每个单元格都将包含当前可装入背包的所有商品。\n\n来看下一个单元格。这个单元格表示背包容量为2磅，完全能够装下吉他！\n\n\n\n这行的其他单元格也一样。别忘了，这是第一行，只有吉他可供你选择，换而言之，你假装现在还没发偷窃其他两件商品。\n\n\n\n此时你很可能心存疑惑：原来的问题说的是4磅的背包，我们为何要考虑容量为1磅、2磅等得背包呢？前面说过，动态规划从子问题着手，逐步解决大问题。这里解决的子问题将帮助你解决大问题。\n\n\n\n别忘了，你要做的是让背包中商品的价值最大。这行表示的是当前的最大价值。它指出，如果你有一个容量4磅的背包，可在其中装入的商品的最大价值为1500美元。\n\n你知道这不是最终解。随着算法往下执行，你将逐步修改最大价值。\n\n# 2. 音响行\n\n我们来填充下一行——音响行。你现在处于第二行，可以偷窃的商品有吉他和音响。\n\n我们先来看第一个单元格，它表示容量为1磅的背包。在此之前，可装入1磅背包的商品最大价值为1500美元。\n\n\n\n该不该偷音响呢？\n\n背包的容量为1磅，显然不能装下音响。由于容量为1磅的背包装不下音响，因此最大价值依然是1500美元。\n\n\n\n接下来的两个单元格的情况与此相同。在这些单元格中，背包的容量分别为2磅和3磅，而以前的最大价值为1500美元。由于这些背包装不下音响，因此最大的价值保持不变。\n\n\n\n背包容量为4磅呢？终于能够装下音响了！原来最大价值为1500美元，但如果在背包中装入音响而不是吉他，价值将为3000美元！因此还是偷音响吧。\n\n\n\n你更新了最大价值。如果背包的容量为4磅，就能装入价值至少3000美元的商品。在这个网格中，你逐步地更新最大价值。\n\n\n\n# 3. 笔记本电脑行\n\n下面以同样的方式处理笔记本电脑。笔记本电脑重3磅，没法将其装入1磅或者2磅的背包，因此前两个单元格的最大价值仍然是1500美元。\n\n\n\n对于容量为3磅的背包，原来的最大价值为1500美元，但现在你可以选择偷窃价值2000美元的笔记本电脑而不是吉他，这样新的最大价值将为2000美元。\n\n\n\n对于容量为4磅的背包，情况很有趣。这是非常重要的部分。当前的最大价值为3000美元，你可不偷音响，而偷笔记本电脑，但它只值2000美元。\n\n\n\n价值没有原来高，但是等一等，笔记本电脑的重量只有3磅，背包还有1磅的重量没用！\n\n\n\n在1磅的容量中，可装入的商品的最大价值是多少呢？ 你之前计算过！\n\n\n\n根据之前计算的最大价值可知，在1磅的容量中可装入吉他，价值1500美元。因此，你需要做如下的比较：\n\n\n\n你可能始终心存疑惑：为何计算小背包可装入的商品的最大价值呢？但愿你现在明白了其中的原因！当出现部分剩余空间时，你可根据这些子问题的答案来确定余下的空间可装入哪些商品。笔记本电脑和吉他的总价值为3500美元，因此偷它们是更好的选择。\n\n最终的网格类似于下面这样。\n\n\n\n答案如下：将吉他和笔记本电脑装入背包时价值更高，为3500美元。\n\n你可能认为，计算最后一个单元格的价值时，我使用了不同的公式。那是因为填充之前的单元格时，我故意避开了一些复杂的因素。其实，计算每个单元格的价值时，使用的公式都相同。这个公式如下。\n\n\n\n你可以使用这个公式来计算每个单元格的价值，最终的网格将与前一个网格相同。现在你明白了为何要求解子问题了吧？——因为你可以合并两个子问题的解来得到更大问题的解。\n\n\n\n# 4. 等等，再增加一件商品将如何变化呢？\n\n假设你发现还有第四件商品可偷——一个iphone！（或许你会毫不犹豫的拿走，但是请别忘了问题的本身是要拿走价值最大的商品）\n\n\n\n此时需要重新执行前面所做的计算吗？不需要。别忘了，动态规划逐步计算最大价值。到目前为止，计算出的最大价值如下：\n\n\n\n这意味着背包容量为4磅时，你最多可偷价值3500美元的商品。但这是以前的情况，下面再添加表示iphone的行。\n\n\n\n我们还是从第一个单元格开始。iphone可装入容量为1磅的背包。之前的最大价值为1500美元，但iphone价值2000美元，因此该偷iphone而不是吉他。\n\n\n\n在下一个单元格中，你可装入iphone和吉他。\n\n\n\n对于第三个单元格，也没有比装入iphone和吉他更好的选择了。\n\n对于最后一个单元格，情况比较有趣。当前的最大价值为3500美元，但你可以偷iphone，这将余下3磅的容量。\n\n\n\n3磅容量的最大价值为2000美元！再加上iphone价值2000美元，总价值为4000美元。新的最大价值诞生了！\n\n最终的网格如下：\n\n\n\n----------------------------------------\n\n现在回到问题本身，给定n个重量为w1,w2,w3,....,wn，价值为v1,v2,v3,...,vn的物品和容量为w的背包，问应该如何选择装入背包中的物品，使得装入背包中的物品的总价值最大？每个物品只能使用一次(01背包特点)\n\n依然用上文的3个物品为例，物品的重量weight[]={1,3,1}，对应的价值为value[]={15,30,20}，现挑选物品放入背包中，假定背包的最大重量w=4\n\n令 dp[i][w] 表示前 i 件物品放入容量为 w 的背包中可获得的最大价值。为了方便处理，我们约定下标从 1 开始。初始时，网格如下：\n\n\n\n根据之前已经引出的状态转移方程，我们再来理解一遍，对于编号为 i 的物品：\n\n * 如果选择它，那么，当前背包的最大价值等于” i 号物品的价值“ 加上 ”减去 i 号物品占用的空间后剩余的背包空间所能存放的最大价值“，即dp[i][k] = value[i] + dp[i-1][k-weight[i]]；\n * 如果不选择它，那么，当前背包的价值就等于前 i-1 个物品存放在背包中的最大价值，即dp[i][k] = dp[i-1][k]\n\ndp[i][k]的结果取两者的较大值，即：\n\ndp[i][k] = max(value[i] + dp[i-1][k-weight[i]], dp[i-1][k])\n\n\n1\n\n1\n\n\n\n# dp代码实现如下\n\n动态规划+二维数组：\n\npublic class package_01 {\n    public static void main(string[] args) {\n        int[] weights = {1, 4, 3, 1};\n        int[] value = {1500, 3000, 2000, 2000};\n        int w = 4;\n        system.out.println(maxvalue(weights, value, w));\n    }\n\n    public int maxvalue(int[] weight, int[] value, int w) {\n        int n = weight.length;\n        if (n == 0) return 0;\n\n        int[][] dp = new int[n][w + 1];\n        // 先初始化第 0 行，也就是尝试把 0 号物品放入容量为 k 的背包中\n        for (int k = 1; k <= w; k++) {\n            if (k >= weight[0]) dp[0][k] = value[0];\n        }\n\n        for (int i = 1; i < n; i++) {\n            for (int k = 1; k <= w; k++) {\n                // 存放 i 号物品（前提是放得下这件物品）\n                int valuewith_i = (k-weight[i] >= 0) ? (value[i] + dp[i-1][k-weight[i]]) : 0;\n                // 不存放 i 号物品\n                int valuewithout_i = dp[i-1][k];\n                dp[i][k] = math.max(valuewith_i, valuewithout_i);\n            }\n        }\n        return dp[n-1][w];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n时间复杂度：o(nw)；空间复杂度o(nw)\n\n动态规划+压缩空间：\n\n观察上面的代码，会发现，当更新dp[i][..]时，只与dp[i-1][..]有关，也就是说，我们没有必要使用o(n*w)的空间，而是只使用o(w)的空间即可。下面先给出代码，再结合图例进行说明。\n\npublic int maxvalue(int[] weight, int[] value, int w) {\n    int n = weight.length;\n    if (n == 0) return 0;\n    // 辅助空间只需要o(w)即可\n    int[] dp = new int[w + 1];\n    for (int i = 0; i < n; i++) {\n        // 注意这里必须从后向前！！！\n        for (int k = w; k >= 1; k--) {\n            int valuewith_i = (k - weight[i] >= 0) ? (dp[k - weight[i]] + value[i]) : 0;\n            int valuewithout_i = dp[k];\n            dp[k] = math.max(valuewith_i, valuewithout_i);\n        }\n    }\n    return dp[w];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n这里的状态转移方程变成了：dp[k](新值) = max(value[i]+dp[k-weight[i]](旧值), dp[k](旧值))\n\n为什么说这里必须反向遍历来更新dp[]数组的值呢？原因是索引较小的元素可能会被覆盖。我们来看例子，假设我们已经遍历完了第 i=1 个元素（即weight=3, value=30），如下图所示：\n\n\n\n现在要更新第 i=2 个元素（即weight=1, value=20），由于我们只申请了一维空间的数组，因此对dp[]数组的修改会覆盖上一轮dp[]数组的值，这里用浅色代表上一轮的值，深色代表当前这一轮的值。\n\n\n\n鉴于上面出现的问题，因此必须采用反向遍历来回避这个问题。仍然假设第 i=1 个元素已经更新完毕，现在更新第 i=2 个元素。示意图如下：\n\n\n\n可以看到，反向遍历就可以避免这个问题了！\n\n事实上，我们还可以进一步简化上面的代码，如下：\n\npublic int maxvalue(int[] weight, int[] value, int w) {\n    int n = weight.length;\n    if (n == 0) return 0;\n    int[] dp = new int[w + 1];\n    for (int i = 0; i < n; i++) {\n        //只要确保 k>=weight[i] 即可，而不是 k>=1，从而减少遍历的次数\n        for (int k = w; k >= weight[i]; k--) {\n            dp[k] = math.max(dp[k - weight[i]] + value[i], dp[k]);\n        }\n    }\n    return dp[w];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n为什么可以这样简化呢？我们重新看一下这段代码：\n\nfor (int k = w; k >= 1; k--) {\n    int valuewith_i = (k - weight[i] >= 0) ? (dp[k - weight[i]] + value[i]) : 0;\n    int valuewithout_i = dp[k];\n    dp[k] = math.max(valuewith_i, valuewithout_i);\n}\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n如果k>=weight[i] 不成立，则valuewith_i 的值为0，那么显然有：\n\ndp[k] = math.max(valuewith_i, valuewithout_i) = max(0, dp[k]) = dp[k] \n\n\n1\n\n1\n\n\n也就是dp[k]没有更新过，它的值还是上一轮的值，因此就没必要执行了，可以提前退出循环！\n\n\n# 递归代码实现\n\n这类问题同样可以采用递归的方式来解决\n\n我们用f(n,w)表示将前n个物品放进容量为w的背包中，得到的最大的价值\n\n我们用自顶向下的角度来看，假如我们已经进行到了最后一步(即求解将n个物品放到背包里获得的最大价值)，此时我们便有两种选择\n\n 1. 不放第n个物品，此时总价值为f(n-1,w)\n 2. 放置第n个物品，此时总价值为vn+f(n-1,w-wn)\n\n两种选择中总价值最大的方案就是我们的方案，转移方程为：\n\n                f(i,w) = max(f(i-1,w),vi+f(i-1,w-wi))\n\n\n1\n\n1\n\n\n编程实现如下：\n\npublic class solution {\n    public static void main(string[] args) {\n        int[] weights = {1, 4, 3, 1};\n        int[] value = {1500, 3000, 2000, 2000};\n        int w = 4;\n        int index = weights.length - 1;\n        system.out.println(maxvalue3(weights, value, index, w));\n    }\n\n    private static int maxvalue3(int[] weights, int[] value, int index, int w) {\n        // 如果索引无效或者容量不足，直接返回当前价值0\n        if (index < 0 || w <= 0) {\n            return 0;\n        }\n        // 不放第index个物品所得价值\n        int res = maxvalue3(weights, value, index - 1, w);\n        // 放第index个物品所得价值(前提是：第index个物品可以放得下)\n        if (weights[index] <= w) {\n            res = math.max(res, value[index] + maxvalue3(weights, value, index - 1, w - weights[index]));\n        }\n        return res;\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 记忆化搜索\n\n递归的代码可以很清晰的对照转移方程，不过因为重复计算太多，递归基本上会超时，效率十分低下\n\n我们可以将已经求得的子问题的结果保存下来，这样对子问题只会求解一次，这便是记忆化搜索。在递归的代码基础上，进行改进\n\n\npublic class solution {\n\n    private static int[][] memo;\n\n    public static void main(string[] args) {\n        int[] weights = {1, 4, 3, 1};\n        int[] value = {1500, 3000, 2000, 2000};\n        int w = 4;\n        int index = weights.length - 1;\n        memo = new int[weights.length][w + 1];\n        system.out.println(maxvalue4(weights, value, index, w));\n    }\n\n    private static int maxvalue4(int[] weights, int[] value, int index, int w) {\n        // 如果索引无效或者容量不足，直接返回当前价值0\n        if (index < 0 || w <= 0) {\n            return 0;\n        }\n        // 如果此子问题已经求解过，则直接返回上次求解的结果\n        if (memo[index][w] != 0) {\n            return memo[index][w];\n        }\n\n        // 不放第index个物品所得价值\n        int res = maxvalue4(weights, value, index - 1, w);\n        // 放第index个物品所得价值(前提是：第index个物品可以放得下)\n        if (weights[index] <= w) {\n            res = math.max(res, value[index] + maxvalue4(weights, value, index - 1, w - weights[index]));\n        }\n        // 添加子问题的解，便于下次直接使用\n        memo[index][w] = res;\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题17-打印从1到最大的n位数",frontmatter:{title:"LeetCode-面试题17-打印从1到最大的n位数",date:"2020-04-14T18:45:52.000Z",tags:["大数问题","Java","Medium","剑指Offer"],permalink:"/pages/f411af/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/01.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9817-%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0.html",relativePath:"06.算法/01.剑指Offer/01.LeetCode-面试题17-打印从1到最大的n位数.md",key:"v-69c850bd",path:"/pages/f411af/",headers:[{level:2,title:"LeetCode-面试题17-打印从1到最大的n位数",slug:"leetcode-面试题17-打印从1到最大的n位数",normalizedTitle:"leetcode-面试题17-打印从1到最大的n位数",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:185},{level:3,title:"Java代码1",slug:"java代码1",normalizedTitle:"java代码1",charIndex:443},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:729}],headersStr:"LeetCode-面试题17-打印从1到最大的n位数 解题思路 Java代码1 Java代码2",content:"# LeetCode-面试题17-打印从1到最大的n位数\n\n输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。\n\n示例1\n\n输入: n = 1\n输出: [1,2,3,4,5,6,7,8,9]\n\n\n1\n2\n\n1\n2\n\n\n说明:\n\n * 用返回一个整数列表来代替打印\n * n 为正整数\n\n\n# 解题思路\n\n这题本身是个大数问题，先写个不是大数的偷懒版本，10的n次方-1就是n位数的最大数，依次遍历存储即可。\n\n大数解法：n位所有十进制数都是09的数字的全排列，对于不足两位的数字前面补0，固定首位，从09调整后面一位。用递归来进行表达，结束条件是设置了数字的最后一位。\n\n抽象成树就是第一行表示数字首位09的节点，比如n=1，则根节点只有一个0。n=2，根节点有2个，一个是0，一个是1，先从0开始深度搜，再固定第一位是1，往下从09深度搜。直到9出现（即当前设置位=数组长度）表示设置了最后一位。\n\n\n# Java代码1\n\nclass Solution {\n    public int[] printNumbers(int n) {\n        int sum = (int)Math.pow(10,n);\n        int[] num = new int[sum-1];\n        for(int i=0;i<sum-1;i++){\n            num[i]=i+1;\n        }\n        return num;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# Java代码2\n\nclass Solution {\n    public int[] printNumbers(int n) {\n        char[] num = new char[n];\n        List<Integer> res = new ArrayList<>();\n        // 数组初始化\n        for(int i =0;i < n;i++){\n            num[i] = '0';\n        }\n        DFS(num,res,0);\n        // 去除1位数情况开始的0\n        res.remove(0);\n        int[] resInt = res.stream().mapToInt(Integer::valueOf).toArray();\n        return resInt;\n    }\n\n    public void DFS(char[] num,List<Integer> res,int index){\n        // 终止条件\n        if(index == num.length){\n            int n = save(num);\n            res.add(n);\n            return;\n        }\n        for(int i=0;i<10;i++){\n            // 首数字初始化\n            num[index] = (char)(i+'0');\n            // 固定首数字，找个位数可能性\n            DFS(num,res,index+1);\n        }\n            \n    }\n\n    public int save(char[] num){\n        int n = 0;\n        for(int i=0;i<num.length;i++){\n            // 首位不是补齐的0时，即位数！=1\n            if(num[i]!='0'){\n                for(int j=i;j<num.length;j++){\n                    n = n*10+num[j]-'0';\n                }\n                break;\n            }\n        }\n        return n;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n",normalizedContent:"# leetcode-面试题17-打印从1到最大的n位数\n\n输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。\n\n示例1\n\n输入: n = 1\n输出: [1,2,3,4,5,6,7,8,9]\n\n\n1\n2\n\n1\n2\n\n\n说明:\n\n * 用返回一个整数列表来代替打印\n * n 为正整数\n\n\n# 解题思路\n\n这题本身是个大数问题，先写个不是大数的偷懒版本，10的n次方-1就是n位数的最大数，依次遍历存储即可。\n\n大数解法：n位所有十进制数都是09的数字的全排列，对于不足两位的数字前面补0，固定首位，从09调整后面一位。用递归来进行表达，结束条件是设置了数字的最后一位。\n\n抽象成树就是第一行表示数字首位09的节点，比如n=1，则根节点只有一个0。n=2，根节点有2个，一个是0，一个是1，先从0开始深度搜，再固定第一位是1，往下从09深度搜。直到9出现（即当前设置位=数组长度）表示设置了最后一位。\n\n\n# java代码1\n\nclass solution {\n    public int[] printnumbers(int n) {\n        int sum = (int)math.pow(10,n);\n        int[] num = new int[sum-1];\n        for(int i=0;i<sum-1;i++){\n            num[i]=i+1;\n        }\n        return num;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# java代码2\n\nclass solution {\n    public int[] printnumbers(int n) {\n        char[] num = new char[n];\n        list<integer> res = new arraylist<>();\n        // 数组初始化\n        for(int i =0;i < n;i++){\n            num[i] = '0';\n        }\n        dfs(num,res,0);\n        // 去除1位数情况开始的0\n        res.remove(0);\n        int[] resint = res.stream().maptoint(integer::valueof).toarray();\n        return resint;\n    }\n\n    public void dfs(char[] num,list<integer> res,int index){\n        // 终止条件\n        if(index == num.length){\n            int n = save(num);\n            res.add(n);\n            return;\n        }\n        for(int i=0;i<10;i++){\n            // 首数字初始化\n            num[index] = (char)(i+'0');\n            // 固定首数字，找个位数可能性\n            dfs(num,res,index+1);\n        }\n            \n    }\n\n    public int save(char[] num){\n        int n = 0;\n        for(int i=0;i<num.length;i++){\n            // 首位不是补齐的0时，即位数！=1\n            if(num[i]!='0'){\n                for(int j=i;j<num.length;j++){\n                    n = n*10+num[j]-'0';\n                }\n                break;\n            }\n        }\n        return n;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题03-不修改数组找出重复的数字",frontmatter:{title:"LeetCode-面试题03-不修改数组找出重复的数字",date:"2020-04-03T11:18:56.000Z",tags:["数组","剑指Offer","Java","Python","Easy"],permalink:"/pages/e68fc1/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/02.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9803-%E4%B8%8D%E4%BF%AE%E6%94%B9%E6%95%B0%E7%BB%84%E6%89%BE%E5%87%BA%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97.html",relativePath:"06.算法/01.剑指Offer/02.LeetCode-面试题03-不修改数组找出重复的数字.md",key:"v-64669de5",path:"/pages/e68fc1/",headers:[{level:2,title:"LeetCode-面试题03-不修改数组找出重复的数字",slug:"leetcode-面试题03-不修改数组找出重复的数字",normalizedTitle:"leetcode-面试题03-不修改数组找出重复的数字",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:217},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:609}],headersStr:"LeetCode-面试题03-不修改数组找出重复的数字 解题思路 Java代码",content:"# LeetCode-面试题03-不修改数组找出重复的数字\n\n在一个长度为n+1的数组里的所有数字都在1~n的范围内，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。\n\n示例 1：\n\n输入：\n\n[2, 3, 1, 0, 2, 5, 3]\n\n输出：2 或 3 \n\n限制：\n\n2 <= n <= 100000\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 解题思路\n\n这个题和上一个题类似，但是不能修改输入的数组，可以沿用上一个题的方法，创建一个数组来复制原数组。代价是需要O(n)的辅助空间。这里主要尝试避免使用O(n)辅助空间的解法。\n\n方法1、利用一个hash表，从头到尾扫描每个数字，不在表内的数字会成功添加，在表内的数字添加的时候会告诉已经存在，这个已经存在的数字就是要返回的数字了\n\n方法2、假如没有重复的数组，那么在从1n的范围里只有n个数字。由于数组里包含超过n个数字，所以一定包含了重复的数字。把从1n的数字从中间的数字m分为两部分，前面一半为1m，后面一半为m+1n，如果1m的数字的数目超过m，那么这一半的区间里一定包含重复的数字；否则，另一半m+1n的区间里一定包含重复的数字。我们可以继续把包含重复数字的区间一分为二，直到找到一个重复的数字。这个过程和二分查找算法类似，只是多了一步统计区间里数字的数目。\n\n\n# Java代码\n\nclass Solution {\n    public static int findRepeatNumber(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return -1;\n        }\n        int start = 1;\n        int end = nums.length - 1;\n        // 先划区域，在统计次数\n        while (end >= start) {\n            int middle = ((end - start) >> 1) + start;\n            int count = countRange(nums, nums.length, start, middle);\n            if (end == start) {\n                if (count > 1)\n                    return start;\n                else\n                    break;\n            }\n            if (count > (middle - start + 1))\n                end = middle;\n            else\n                start = middle + 1;\n        }\n        return -1;\n    }\n\n    public static int countRange(int[] nums, int length, int start, int end) {\n        if (nums == null) {\n            return 0;\n        }\n        int count = 0;\n        for (int i : nums) {\n            if (i >= start && i <= end)\n                ++count;\n        }\n        return count;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n",normalizedContent:"# leetcode-面试题03-不修改数组找出重复的数字\n\n在一个长度为n+1的数组里的所有数字都在1~n的范围内，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。\n\n示例 1：\n\n输入：\n\n[2, 3, 1, 0, 2, 5, 3]\n\n输出：2 或 3 \n\n限制：\n\n2 <= n <= 100000\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 解题思路\n\n这个题和上一个题类似，但是不能修改输入的数组，可以沿用上一个题的方法，创建一个数组来复制原数组。代价是需要o(n)的辅助空间。这里主要尝试避免使用o(n)辅助空间的解法。\n\n方法1、利用一个hash表，从头到尾扫描每个数字，不在表内的数字会成功添加，在表内的数字添加的时候会告诉已经存在，这个已经存在的数字就是要返回的数字了\n\n方法2、假如没有重复的数组，那么在从1n的范围里只有n个数字。由于数组里包含超过n个数字，所以一定包含了重复的数字。把从1n的数字从中间的数字m分为两部分，前面一半为1m，后面一半为m+1n，如果1m的数字的数目超过m，那么这一半的区间里一定包含重复的数字；否则，另一半m+1n的区间里一定包含重复的数字。我们可以继续把包含重复数字的区间一分为二，直到找到一个重复的数字。这个过程和二分查找算法类似，只是多了一步统计区间里数字的数目。\n\n\n# java代码\n\nclass solution {\n    public static int findrepeatnumber(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return -1;\n        }\n        int start = 1;\n        int end = nums.length - 1;\n        // 先划区域，在统计次数\n        while (end >= start) {\n            int middle = ((end - start) >> 1) + start;\n            int count = countrange(nums, nums.length, start, middle);\n            if (end == start) {\n                if (count > 1)\n                    return start;\n                else\n                    break;\n            }\n            if (count > (middle - start + 1))\n                end = middle;\n            else\n                start = middle + 1;\n        }\n        return -1;\n    }\n\n    public static int countrange(int[] nums, int length, int start, int end) {\n        if (nums == null) {\n            return 0;\n        }\n        int count = 0;\n        for (int i : nums) {\n            if (i >= start && i <= end)\n                ++count;\n        }\n        return count;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题03-数组中重复的数字",frontmatter:{title:"LeetCode-面试题03-数组中重复的数字",date:"2020-04-02T22:08:11.000Z",tags:["数组","剑指Offer","Java","Python","Easy"],permalink:"/pages/2f843e/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/03.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9803-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97.html",relativePath:"06.算法/01.剑指Offer/03.LeetCode-面试题03-数组中重复的数字.md",key:"v-1f7c083a",path:"/pages/2f843e/",headers:[{level:2,title:"LeetCode-面试题03-数组中重复的数字",slug:"leetcode-面试题03-数组中重复的数字",normalizedTitle:"leetcode-面试题03-数组中重复的数字",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:247},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:618},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:988}],headersStr:"LeetCode-面试题03-数组中重复的数字 解题思路 Java代码 Python代码",content:'# LeetCode-面试题03-数组中重复的数字\n\n找出数组中重复的数字。\n\n在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。\n\n示例 1：\n\n输入：\n\n[2, 3, 1, 0, 2, 5, 3]\n\n输出：2 或 3 \n\n限制：\n\n2 <= n <= 100000\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 解题思路\n\n方法1、利用一个hash表，从头到尾扫描每个数字，不在表内的数字会成功添加，在表内的数字添加的时候会告诉已经存在，这个已经存在的数字就是要返回的数字了\n\n方法2、这个思想很巧妙，也是剑指offer上的最优解，数组的数字都在0~n-1的范围内。如果这个数组中没有重复的数字，那么当数组排序之后数字i将会出现在下标为i的位置。从头到尾依次扫描这个数组中的数字，当扫描到下标为i的数字时，首先比较这个数字(用m表示)是不是等于i。如果是，则接着扫描下一个数字；如果不是，则再拿它和第m个数字进行比较。如果它和第m个数字相等，就找到了第一个重复的数字(该数字在下标为i和m的位置都出现了)；如果它和第m个数字不相等，就把第i个数字和第m个数字交换，把m放到属于它的位置。接下来再重复这个比较、交换的过程，直到发现一个重复的数字。\n\n\n# Java代码\n\nclass Solution {\n    public int findRepeatNumber(int[] nums) {\n        Set<Integer> s = new HashSet<>();\n        int result = -1;\n        for (int i : nums) {\n            if (!s.add(i)) {\n                result = i;\n                break;\n            }\n        }\n        return result;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# Python代码\n\nclass Solution(object):\n    def findRepeatNumber(self, nums):\n        """\n        :type nums: List[int]\n        :rtype: int\n        """\n        for index, i in enumerate(nums):\n            while (index != i):\n                if (i == nums[index]):\n                    return i\n                temp = i\n                i = nums[i]\n                nums[i] = temp\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n',normalizedContent:'# leetcode-面试题03-数组中重复的数字\n\n找出数组中重复的数字。\n\n在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。\n\n示例 1：\n\n输入：\n\n[2, 3, 1, 0, 2, 5, 3]\n\n输出：2 或 3 \n\n限制：\n\n2 <= n <= 100000\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 解题思路\n\n方法1、利用一个hash表，从头到尾扫描每个数字，不在表内的数字会成功添加，在表内的数字添加的时候会告诉已经存在，这个已经存在的数字就是要返回的数字了\n\n方法2、这个思想很巧妙，也是剑指offer上的最优解，数组的数字都在0~n-1的范围内。如果这个数组中没有重复的数字，那么当数组排序之后数字i将会出现在下标为i的位置。从头到尾依次扫描这个数组中的数字，当扫描到下标为i的数字时，首先比较这个数字(用m表示)是不是等于i。如果是，则接着扫描下一个数字；如果不是，则再拿它和第m个数字进行比较。如果它和第m个数字相等，就找到了第一个重复的数字(该数字在下标为i和m的位置都出现了)；如果它和第m个数字不相等，就把第i个数字和第m个数字交换，把m放到属于它的位置。接下来再重复这个比较、交换的过程，直到发现一个重复的数字。\n\n\n# java代码\n\nclass solution {\n    public int findrepeatnumber(int[] nums) {\n        set<integer> s = new hashset<>();\n        int result = -1;\n        for (int i : nums) {\n            if (!s.add(i)) {\n                result = i;\n                break;\n            }\n        }\n        return result;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# python代码\n\nclass solution(object):\n    def findrepeatnumber(self, nums):\n        """\n        :type nums: list[int]\n        :rtype: int\n        """\n        for index, i in enumerate(nums):\n            while (index != i):\n                if (i == nums[index]):\n                    return i\n                temp = i\n                i = nums[i]\n                nums[i] = temp\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题04-二维数组中的查找",frontmatter:{title:"LeetCode-面试题04-二维数组中的查找",date:"2020-04-03T14:59:24.000Z",tags:["数组","剑指Offer","Java","Python","Easy"],permalink:"/pages/84f558/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/04.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9804-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE.html",relativePath:"06.算法/01.剑指Offer/04.LeetCode-面试题04-二维数组中的查找.md",key:"v-3c4a2030",path:"/pages/84f558/",headers:[{level:2,title:"LeetCode-面试题04-二维数组中的查找",slug:"leetcode-面试题04-二维数组中的查找",normalizedTitle:"leetcode-面试题04-二维数组中的查找",charIndex:2},{level:3,title:"解题思路1",slug:"解题思路1",normalizedTitle:"解题思路1",charIndex:428},{level:3,title:"解题思路2",slug:"解题思路2",normalizedTitle:"解题思路2",charIndex:655},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:703},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:1478},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:2264}],headersStr:"LeetCode-面试题04-二维数组中的查找 解题思路1 解题思路2 Java代码 Python代码 Java代码2",content:'# LeetCode-面试题04-二维数组中的查找\n\n在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\n\n示例:\n\n现有矩阵 matrix 如下：\n[\n  [1,   4,  7, 11, 15],\n  [2,   5,  8, 12, 19],\n  [3,   6,  9, 16, 22],\n  [10, 13, 14, 17, 24],\n  [18, 21, 23, 26, 30]\n]\n\n给定 target = 5，返回 true。\n给定 target = 20，返回 false。\n\n限制：\n0 <= n <= 1000\n0 <= m <= 1000\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 解题思路1\n\n这个问题本身有一定的规律，从左到右数字是递增的，从上到下数字也是递增的。可以从第一行的最大数开始与目标数target比较，如果第一行的最大数比target大的话，这一列就可以排除不是要找的位置了，因为第一行也是一列的最小数，只有当target比第一行某一列大的时候，才需要往下面找，找到一个数之后，target的位置可能是向左或者向下的，但不可能向右了，因为右边已经被排除。整个过程一直重复下去就能找到目标数，没有就返回false\n\n\n# 解题思路2\n\n每行是从左往右递增有序的，所以只需要对每行进行二分查找，也能快速得到结果\n\n\n# Java代码\n\nclass Solution {\n    public boolean findNumberIn2DArray(int[][] matrix, int target) {\n        boolean falg = false;\n        if (matrix == null || matrix.length == 0) {\n            return falg;\n        }\n        int collen = matrix[0].length - 1;\n        int rowlen = 0;\n        while (rowlen < matrix.length && collen >= 0) {\n            if (target < matrix[rowlen][collen]) {\n                collen--;\n            } else if (target == matrix[rowlen][collen]) {\n                falg = true;\n                break;\n            } else if (target > matrix[rowlen][collen]) {\n                rowlen++;\n            }\n        }\n        return falg;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# Python代码\n\nclass Solution(object):\n    def findNumberIn2DArray(self, matrix, target):\n        """\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        """\n        falg = False\n        if (matrix==None or len(matrix) == 0):\n            return falg\n        collen = len(matrix[0]) - 1\n        rowlen = 0\n        while (rowlen < len(matrix) and collen >= 0):\n            if target < matrix[rowlen][collen]:\n                collen -= 1\n            elif target == matrix[rowlen][collen]:\n                falg = True\n                break\n            elif target > matrix[rowlen][collen]:\n                rowlen += 1\n        return falg\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# Java代码2\n\nclass Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        if(matrix==null||matrix.length==0||matrix[0].length==0){\n            return false;\n        }\n        for(int[] i : matrix){\n            int find = search(i,target);\n            if(find>=0){\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public int search(int[] rowMat,int target){\n        int left = 0;\n        int right = rowMat.length-1;\n        while(left<=right){\n            int mid = left+(right-left)/2;\n            if(rowMat[mid]<target){\n                left = mid+1;\n            } else if (rowMat[mid]>target){\n                right = mid-1;\n            } else {\n                return 1;\n            }\n        }\n        return -1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n',normalizedContent:'# leetcode-面试题04-二维数组中的查找\n\n在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\n\n示例:\n\n现有矩阵 matrix 如下：\n[\n  [1,   4,  7, 11, 15],\n  [2,   5,  8, 12, 19],\n  [3,   6,  9, 16, 22],\n  [10, 13, 14, 17, 24],\n  [18, 21, 23, 26, 30]\n]\n\n给定 target = 5，返回 true。\n给定 target = 20，返回 false。\n\n限制：\n0 <= n <= 1000\n0 <= m <= 1000\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 解题思路1\n\n这个问题本身有一定的规律，从左到右数字是递增的，从上到下数字也是递增的。可以从第一行的最大数开始与目标数target比较，如果第一行的最大数比target大的话，这一列就可以排除不是要找的位置了，因为第一行也是一列的最小数，只有当target比第一行某一列大的时候，才需要往下面找，找到一个数之后，target的位置可能是向左或者向下的，但不可能向右了，因为右边已经被排除。整个过程一直重复下去就能找到目标数，没有就返回false\n\n\n# 解题思路2\n\n每行是从左往右递增有序的，所以只需要对每行进行二分查找，也能快速得到结果\n\n\n# java代码\n\nclass solution {\n    public boolean findnumberin2darray(int[][] matrix, int target) {\n        boolean falg = false;\n        if (matrix == null || matrix.length == 0) {\n            return falg;\n        }\n        int collen = matrix[0].length - 1;\n        int rowlen = 0;\n        while (rowlen < matrix.length && collen >= 0) {\n            if (target < matrix[rowlen][collen]) {\n                collen--;\n            } else if (target == matrix[rowlen][collen]) {\n                falg = true;\n                break;\n            } else if (target > matrix[rowlen][collen]) {\n                rowlen++;\n            }\n        }\n        return falg;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# python代码\n\nclass solution(object):\n    def findnumberin2darray(self, matrix, target):\n        """\n        :type matrix: list[list[int]]\n        :type target: int\n        :rtype: bool\n        """\n        falg = false\n        if (matrix==none or len(matrix) == 0):\n            return falg\n        collen = len(matrix[0]) - 1\n        rowlen = 0\n        while (rowlen < len(matrix) and collen >= 0):\n            if target < matrix[rowlen][collen]:\n                collen -= 1\n            elif target == matrix[rowlen][collen]:\n                falg = true\n                break\n            elif target > matrix[rowlen][collen]:\n                rowlen += 1\n        return falg\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# java代码2\n\nclass solution {\n    public boolean searchmatrix(int[][] matrix, int target) {\n        if(matrix==null||matrix.length==0||matrix[0].length==0){\n            return false;\n        }\n        for(int[] i : matrix){\n            int find = search(i,target);\n            if(find>=0){\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public int search(int[] rowmat,int target){\n        int left = 0;\n        int right = rowmat.length-1;\n        while(left<=right){\n            int mid = left+(right-left)/2;\n            if(rowmat[mid]<target){\n                left = mid+1;\n            } else if (rowmat[mid]>target){\n                right = mid-1;\n            } else {\n                return 1;\n            }\n        }\n        return -1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题05-替换空格",frontmatter:{title:"LeetCode-面试题05-替换空格",date:"2020-04-03T16:12:56.000Z",tags:["字符串","剑指Offer","Java","Python","Easy"],permalink:"/pages/b0f96d/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/05.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9805-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC.html",relativePath:"06.算法/01.剑指Offer/05.LeetCode-面试题05-替换空格.md",key:"v-aeaf62e4",path:"/pages/b0f96d/",headers:[{level:2,title:"LeetCode-面试题05-替换空格",slug:"leetcode-面试题05-替换空格",normalizedTitle:"leetcode-面试题05-替换空格",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:122},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:224},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:618}],headersStr:"LeetCode-面试题05-替换空格 解题思路 Java代码 Python代码",content:'# LeetCode-面试题05-替换空格\n\n请实现一个函数，把字符串 s 中的每个空格替换成"%20"。\n\n示例:\n\n输入：s = "We are happy."\n输出："We%20are%20happy."\n\n\n1\n2\n\n1\n2\n\n\n\n# 解题思路\n\n方法1、遍历的时候直接用StringBuilder添加字符，遍历到空格的时候就添加%20，最后把char转化为String类型就可以了\n\n方法2、利用python特点，一行解决= =\n\n\n# Java代码\n\nclass Solution {\n    public String replaceSpace(String s) {\n        StringBuilder result = new StringBuilder();\n        for (char i : s.toCharArray()) {\n            if (i == \' \') {\n                result.append("%20");\n            } else\n                result.append(i);\n        }\n        return result.toString();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# Python代码\n\nclass Solution(object):\n    def replaceSpace(self, s):\n        """\n        :type s: str\n        :rtype: str\n        """\n        return \'\'.join((\'%20\' if c == \' \' else c for c in s))\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n',normalizedContent:'# leetcode-面试题05-替换空格\n\n请实现一个函数，把字符串 s 中的每个空格替换成"%20"。\n\n示例:\n\n输入：s = "we are happy."\n输出："we%20are%20happy."\n\n\n1\n2\n\n1\n2\n\n\n\n# 解题思路\n\n方法1、遍历的时候直接用stringbuilder添加字符，遍历到空格的时候就添加%20，最后把char转化为string类型就可以了\n\n方法2、利用python特点，一行解决= =\n\n\n# java代码\n\nclass solution {\n    public string replacespace(string s) {\n        stringbuilder result = new stringbuilder();\n        for (char i : s.tochararray()) {\n            if (i == \' \') {\n                result.append("%20");\n            } else\n                result.append(i);\n        }\n        return result.tostring();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# python代码\n\nclass solution(object):\n    def replacespace(self, s):\n        """\n        :type s: str\n        :rtype: str\n        """\n        return \'\'.join((\'%20\' if c == \' \' else c for c in s))\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题06-从尾到头打印链表",frontmatter:{title:"LeetCode-面试题06-从尾到头打印链表",date:"2020-04-03T17:54:23.000Z",description:"从尾到头打印链表",tags:["链表","剑指Offer","Java","Python","Easy"],keywords:"链表,Java,Python,Easy,剑指Offer",permalink:"/pages/642877/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/06.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9806-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8.html",relativePath:"06.算法/01.剑指Offer/06.LeetCode-面试题06-从尾到头打印链表.md",key:"v-5d535259",path:"/pages/642877/",headers:[{level:2,title:"LeetCode-面试题06-从尾到头打印链表",slug:"leetcode-面试题06-从尾到头打印链表",normalizedTitle:"leetcode-面试题06-从尾到头打印链表",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:115},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:230},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:964}],headersStr:"LeetCode-面试题06-从尾到头打印链表 解题思路 Java代码 Python代码",content:'# LeetCode-面试题06-从尾到头打印链表\n\n输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。\n\n\n\n示例:\n\n输入：head = [1,3,2]\n输出：[2,3,1]\n\n\n1\n2\n\n1\n2\n\n\n\n# 解题思路\n\n用ArryList或者Stack都可以，先进后出本身就是栈的特点，这里就直接用栈来做了。还有一种思路是递归，但是递归的问题就在于链表长了之后，层级过深会引起StackOverFlowerror，也就是栈溢出。\n\n\n# Java代码\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public int[] reversePrint(ListNode head) {\n        Deque<Integer> stack = new LinkedList<>();\n        ListNode node = head;\n        while (node != null) {\n            stack.push(node.val);\n            node = node.next;\n        }\n        int size = stack.size();\n        int[] result = new int[size];\n        for (int i = 0; i < size; i++) {\n            result[i] = stack.pop();\n        }\n        return result;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# Python代码\n\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def reversePrint(self, head):\n        """\n        :type head: ListNode\n        :rtype: List[int]\n        """\n        result = []\n        node = head\n        while (node):\n            result.append(node.val)\n            node = node.next\n        return result[::-1]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n',normalizedContent:'# leetcode-面试题06-从尾到头打印链表\n\n输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。\n\n\n\n示例:\n\n输入：head = [1,3,2]\n输出：[2,3,1]\n\n\n1\n2\n\n1\n2\n\n\n\n# 解题思路\n\n用arrylist或者stack都可以，先进后出本身就是栈的特点，这里就直接用栈来做了。还有一种思路是递归，但是递归的问题就在于链表长了之后，层级过深会引起stackoverflowerror，也就是栈溢出。\n\n\n# java代码\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode(int x) { val = x; }\n * }\n */\nclass solution {\n    public int[] reverseprint(listnode head) {\n        deque<integer> stack = new linkedlist<>();\n        listnode node = head;\n        while (node != null) {\n            stack.push(node.val);\n            node = node.next;\n        }\n        int size = stack.size();\n        int[] result = new int[size];\n        for (int i = 0; i < size; i++) {\n            result[i] = stack.pop();\n        }\n        return result;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# python代码\n\n# definition for singly-linked list.\n# class listnode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = none\n\nclass solution(object):\n    def reverseprint(self, head):\n        """\n        :type head: listnode\n        :rtype: list[int]\n        """\n        result = []\n        node = head\n        while (node):\n            result.append(node.val)\n            node = node.next\n        return result[::-1]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题09-用两个栈实现队列",frontmatter:{title:"LeetCode-面试题09-用两个栈实现队列",date:"2020-04-07T22:04:26.000Z",description:"用两个栈实现队列",tags:["队列","Java","Python","Easy","剑指Offer"],keywords:"队列,Java,Python,Easy,剑指Offer",permalink:"/pages/e5bc1f/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/07.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9809-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.html",relativePath:"06.算法/01.剑指Offer/07.LeetCode-面试题09-用两个栈实现队列.md",key:"v-4786c633",path:"/pages/e5bc1f/",headers:[{level:2,title:"LeetCode-面试题09-用两个栈实现队列",slug:"leetcode-面试题09-用两个栈实现队列",normalizedTitle:"leetcode-面试题09-用两个栈实现队列",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:485},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:668},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:1538}],headersStr:"LeetCode-面试题09-用两个栈实现队列 解题思路 Java代码 Python代码",content:'# LeetCode-面试题09-用两个栈实现队列\n\n用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )\n\n示例1\n\n输入：\n["CQueue","appendTail","deleteHead","deleteHead"]\n[[],[3],[],[]]\n输出：[null,null,3,-1]\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n示例2\n\n输入：\n["CQueue","deleteHead","appendTail","appendTail","deleteHead","deleteHead"]\n[[],[],[5],[2],[],[]]\n输出：[null,-1,null,null,5,2]\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n提示：\n\n * 1 <= values <= 10000\n * 最多会对 appendTail、deleteHead 进行 10000 次调用\n\n\n# 解题思路\n\n首先，栈的特点是先进后出，队列的特点是先进先出。对于一批输入的数字，如5，2。我们保存在栈内5在栈底，2在栈顶，直接不能输出5，可以利用另外一个栈stack2将stack1的数据复制出去，当stack1不为空时就弹出复制到stack2，为2，5，此时栈顶为5，当stack2不为空时，不断弹出栈顶即可模拟先进先出。当stack2为空是，输出-1\n\n\n# Java代码\n\nclass CQueue {\n\n    Deque<Integer> stack1;\n    Deque<Integer> stack2;\n\n    public CQueue() {\n        stack1 = new LinkedList<>();\n        stack2 = new LinkedList<>();\n    }\n\n    public void appendTail(int value) {\n        stack1.push(value);\n    }\n\n    public int deleteHead() {\n        while(stack1.size()>0){\n            stack2.addLast(stack1.removeLast());\n            return stack2.removeLast();\n        }\n        if(stack2.size()==0){\n            return -1;\n        }\n        return stack2.removeLast();\n    }\n}\n\n/**\n * Your CQueue object will be instantiated and called as such:\n * CQueue obj = new CQueue();\n * obj.appendTail(value);\n * int param_2 = obj.deleteHead();\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# Python代码\n\nclass CQueue(object):\n\n    def __init__(self):\n        self.stack1,self.stack2 = [],[]\n\n\n    def appendTail(self, value):\n        """\n        :type value: int\n        :rtype: None\n        """\n        self.stack1.append(value)\n\n\n    def deleteHead(self):\n        """\n        :rtype: int\n        """\n        if self.stack2: return self.stack2.pop()\n        if not self.stack1: return -1\n        while self.stack1:\n            self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n\n\n\n# Your CQueue object will be instantiated and called as such:\n# obj = CQueue()\n# obj.appendTail(value)\n# param_2 = obj.deleteHead()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n',normalizedContent:'# leetcode-面试题09-用两个栈实现队列\n\n用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendtail 和 deletehead，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deletehead 操作返回 -1 )\n\n示例1\n\n输入：\n["cqueue","appendtail","deletehead","deletehead"]\n[[],[3],[],[]]\n输出：[null,null,3,-1]\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n示例2\n\n输入：\n["cqueue","deletehead","appendtail","appendtail","deletehead","deletehead"]\n[[],[],[5],[2],[],[]]\n输出：[null,-1,null,null,5,2]\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n提示：\n\n * 1 <= values <= 10000\n * 最多会对 appendtail、deletehead 进行 10000 次调用\n\n\n# 解题思路\n\n首先，栈的特点是先进后出，队列的特点是先进先出。对于一批输入的数字，如5，2。我们保存在栈内5在栈底，2在栈顶，直接不能输出5，可以利用另外一个栈stack2将stack1的数据复制出去，当stack1不为空时就弹出复制到stack2，为2，5，此时栈顶为5，当stack2不为空时，不断弹出栈顶即可模拟先进先出。当stack2为空是，输出-1\n\n\n# java代码\n\nclass cqueue {\n\n    deque<integer> stack1;\n    deque<integer> stack2;\n\n    public cqueue() {\n        stack1 = new linkedlist<>();\n        stack2 = new linkedlist<>();\n    }\n\n    public void appendtail(int value) {\n        stack1.push(value);\n    }\n\n    public int deletehead() {\n        while(stack1.size()>0){\n            stack2.addlast(stack1.removelast());\n            return stack2.removelast();\n        }\n        if(stack2.size()==0){\n            return -1;\n        }\n        return stack2.removelast();\n    }\n}\n\n/**\n * your cqueue object will be instantiated and called as such:\n * cqueue obj = new cqueue();\n * obj.appendtail(value);\n * int param_2 = obj.deletehead();\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# python代码\n\nclass cqueue(object):\n\n    def __init__(self):\n        self.stack1,self.stack2 = [],[]\n\n\n    def appendtail(self, value):\n        """\n        :type value: int\n        :rtype: none\n        """\n        self.stack1.append(value)\n\n\n    def deletehead(self):\n        """\n        :rtype: int\n        """\n        if self.stack2: return self.stack2.pop()\n        if not self.stack1: return -1\n        while self.stack1:\n            self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n\n\n\n# your cqueue object will be instantiated and called as such:\n# obj = cqueue()\n# obj.appendtail(value)\n# param_2 = obj.deletehead()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题10-1-斐波那契数列",frontmatter:{title:"LeetCode-面试题10-1-斐波那契数列",date:"2020-04-08T21:51:39.000Z",description:"斐波那契数列",tags:["数据结构","Java","Python","Easy","剑指Offer"],keywords:"数据结构,Java,Python,Easy,剑指Offer",permalink:"/pages/6a6f3c/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/08.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9810-1-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97.html",relativePath:"06.算法/01.剑指Offer/08.LeetCode-面试题10-1-斐波那契数列.md",key:"v-1b073eaa",path:"/pages/6a6f3c/",headers:[{level:2,title:"LeetCode-面试题10-1-斐波那契数列",slug:"leetcode-面试题10-1-斐波那契数列",normalizedTitle:"leetcode-面试题10-1-斐波那契数列",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:343},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:511},{level:3,title:"Python代码1",slug:"python代码1",normalizedTitle:"python代码1",charIndex:1016},{level:3,title:"Python代码2",slug:"python代码2",normalizedTitle:"python代码2",charIndex:1308}],headersStr:"LeetCode-面试题10-1-斐波那契数列 解题思路 Java代码 Python代码1 Python代码2",content:'# LeetCode-面试题10-1-斐波那契数列\n\n写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：\n\nF(0) = 0,   F(1) = 1\nF(N) = F(N - 1) + F(N - 2), 其中 N > 1.\n\n\n1\n2\n\n1\n2\n\n\n斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。\n\n答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。\n\n一定记得取余!\n\n示例1\n\n输入：n = 2\n输出：1\n\n\n1\n2\n\n1\n2\n\n\n示例2\n\n输入：n = 5\n输出：5\n\n\n1\n2\n\n1\n2\n\n\n提示：\n\n * 0 <= n <= 100\n\n\n# 解题思路\n\n斐波那契数列是一个非常熟悉的问题了，基本思路有2种方法\n\n方法1、循环累加：按照f(0)+f(1)=f(2)的公式，循环累加到n即可求得\n\n方法2、递归：递归的解法看上去很简洁，但是实际运行的时候效率特别慢，还会遇到重复计算和超出系统栈的问题，不推荐使用。基本思想是按照公式f(n)=f(n-1)+f(n-2)递归\n\n\n# Java代码\n\nclass Solution {\n    public int fib(int n) {\n        int[] result = new int[]{0, 1};\n        if (n < 2) {\n            return result[n];\n        }\n        int sum = 0;\n        int f1 = 0;\n        int f2 = 1;\n        for (int i = 2; i <= n; i++) {\n            // 防止大数情况下超过int范围\n            sum = (f1 + f2) % 1000000007;\n            f1 = f2;\n            f2 = sum;\n        }\n        return sum;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# Python代码1\n\n递归超时\n\nclass Solution(object):\n    def fib(self, n):\n        """\n        :type n: int\n        :rtype: int\n        """\n        if n <= 0: return 0\n        if n == 1: return 1\n        return (self.fib(n - 1) + self.fib(n - 2)) % 1000000007\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# Python代码2\n\nclass Solution(object):\n    def fib(self, n):\n        """\n        :type n: int\n        :rtype: int\n        """\n        f0, f1 = 0, 1\n        for _ in range(n):\n            f0, f1 = f1, f0 + f1\n        return f0 % 1000000007\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n',normalizedContent:'# leetcode-面试题10-1-斐波那契数列\n\n写一个函数，输入 n ，求斐波那契（fibonacci）数列的第 n 项。斐波那契数列的定义如下：\n\nf(0) = 0,   f(1) = 1\nf(n) = f(n - 1) + f(n - 2), 其中 n > 1.\n\n\n1\n2\n\n1\n2\n\n\n斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。\n\n答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。\n\n一定记得取余!\n\n示例1\n\n输入：n = 2\n输出：1\n\n\n1\n2\n\n1\n2\n\n\n示例2\n\n输入：n = 5\n输出：5\n\n\n1\n2\n\n1\n2\n\n\n提示：\n\n * 0 <= n <= 100\n\n\n# 解题思路\n\n斐波那契数列是一个非常熟悉的问题了，基本思路有2种方法\n\n方法1、循环累加：按照f(0)+f(1)=f(2)的公式，循环累加到n即可求得\n\n方法2、递归：递归的解法看上去很简洁，但是实际运行的时候效率特别慢，还会遇到重复计算和超出系统栈的问题，不推荐使用。基本思想是按照公式f(n)=f(n-1)+f(n-2)递归\n\n\n# java代码\n\nclass solution {\n    public int fib(int n) {\n        int[] result = new int[]{0, 1};\n        if (n < 2) {\n            return result[n];\n        }\n        int sum = 0;\n        int f1 = 0;\n        int f2 = 1;\n        for (int i = 2; i <= n; i++) {\n            // 防止大数情况下超过int范围\n            sum = (f1 + f2) % 1000000007;\n            f1 = f2;\n            f2 = sum;\n        }\n        return sum;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# python代码1\n\n递归超时\n\nclass solution(object):\n    def fib(self, n):\n        """\n        :type n: int\n        :rtype: int\n        """\n        if n <= 0: return 0\n        if n == 1: return 1\n        return (self.fib(n - 1) + self.fib(n - 2)) % 1000000007\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# python代码2\n\nclass solution(object):\n    def fib(self, n):\n        """\n        :type n: int\n        :rtype: int\n        """\n        f0, f1 = 0, 1\n        for _ in range(n):\n            f0, f1 = f1, f0 + f1\n        return f0 % 1000000007\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题10-2-青蛙跳台阶",frontmatter:{title:"LeetCode-面试题10-2-青蛙跳台阶",date:"2020-04-08T22:34:29.000Z",description:"青蛙跳台阶",tags:["数据结构","Java","Python","Easy","剑指Offer"],keywords:"数据结构,Java,Python,Easy,剑指Offer",permalink:"/pages/78c895/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/09.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9810-2-%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6.html",relativePath:"06.算法/01.剑指Offer/09.LeetCode-面试题10-2-青蛙跳台阶.md",key:"v-cb57926c",path:"/pages/78c895/",headers:[{level:2,title:"LeetCode-面试题10-2-青蛙跳台阶",slug:"leetcode-面试题10-2-青蛙跳台阶",normalizedTitle:"leetcode-面试题10-2-青蛙跳台阶",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:230},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:439},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:948}],headersStr:"LeetCode-面试题10-2-青蛙跳台阶 解题思路 Java代码 Python代码",content:'# LeetCode-面试题10-2-青蛙跳台阶\n\n一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。\n\n答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。\n\n一定记得取余!\n\n示例1\n\n输入：n = 2\n输出：2\n\n\n1\n2\n\n1\n2\n\n\n示例2\n\n输入：n = 7\n输出：21\n\n\n1\n2\n\n1\n2\n\n\n提示：\n\n * 0 <= n <= 100\n\n\n# 解题思路\n\n青蛙可以跳1级台阶，也可以跳2级台阶。把跳n级台阶时的跳发看成n的函数，即为f(n)。当n>2时，第一次跳有2种不同的选择：一是第一次只跳1级，此时跳法数目等于后面剩下的n-1级台阶的跳法数目，即为f(n-1)；二是第一次跳2级，此时跳法数目等于后面剩下的n-2级台阶的跳发数目，即f(n-2)。因此n级台阶的不同跳法的总数为f(n)=f(n-1)+f(n-2)。不难看出这是一个斐波那契数列问题\n\n\n# Java代码\n\nclass Solution {\n    public int numWays(int n) {\n        int[] result = new int[]{1, 1};\n        if (n < 2) {\n            return result[n];\n        }\n        int sum = 0;\n        int f1 = 1;\n        int f2 = 1;\n        for (int i = 2; i <= n; i++) {\n            // 防止大数情况下超过int范围\n            sum = (f1 + f2) % 1000000007;\n            f1 = f2;\n            f2 = sum;\n        }\n        return sum;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# Python代码\n\nclass Solution(object):\n    def numWays(self, n):\n        """\n        :type n: int\n        :rtype: int\n        """\n        f0, f1 = 1, 1\n        for _ in range(n):\n            f0, f1 = f1, f0 + f1\n        return f0 % 1000000007\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n',normalizedContent:'# leetcode-面试题10-2-青蛙跳台阶\n\n一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。\n\n答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。\n\n一定记得取余!\n\n示例1\n\n输入：n = 2\n输出：2\n\n\n1\n2\n\n1\n2\n\n\n示例2\n\n输入：n = 7\n输出：21\n\n\n1\n2\n\n1\n2\n\n\n提示：\n\n * 0 <= n <= 100\n\n\n# 解题思路\n\n青蛙可以跳1级台阶，也可以跳2级台阶。把跳n级台阶时的跳发看成n的函数，即为f(n)。当n>2时，第一次跳有2种不同的选择：一是第一次只跳1级，此时跳法数目等于后面剩下的n-1级台阶的跳法数目，即为f(n-1)；二是第一次跳2级，此时跳法数目等于后面剩下的n-2级台阶的跳发数目，即f(n-2)。因此n级台阶的不同跳法的总数为f(n)=f(n-1)+f(n-2)。不难看出这是一个斐波那契数列问题\n\n\n# java代码\n\nclass solution {\n    public int numways(int n) {\n        int[] result = new int[]{1, 1};\n        if (n < 2) {\n            return result[n];\n        }\n        int sum = 0;\n        int f1 = 1;\n        int f2 = 1;\n        for (int i = 2; i <= n; i++) {\n            // 防止大数情况下超过int范围\n            sum = (f1 + f2) % 1000000007;\n            f1 = f2;\n            f2 = sum;\n        }\n        return sum;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# python代码\n\nclass solution(object):\n    def numways(self, n):\n        """\n        :type n: int\n        :rtype: int\n        """\n        f0, f1 = 1, 1\n        for _ in range(n):\n            f0, f1 = f1, f0 + f1\n        return f0 % 1000000007\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题11-旋转数组的最小数字",frontmatter:{title:"LeetCode-面试题11-旋转数组的最小数字",date:"2020-04-10T16:53:08.000Z",description:"旋转数组的最小数字",tags:["数组","Java","Python","Easy","剑指Offer"],keywords:"数组,Java,Python,Easy,剑指Offer",permalink:"/pages/ea52d6/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/10.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9811-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97.html",relativePath:"06.算法/01.剑指Offer/10.LeetCode-面试题11-旋转数组的最小数字.md",key:"v-2bcd48ed",path:"/pages/ea52d6/",headers:[{level:2,title:"LeetCode-面试题11-旋转数组的最小数字",slug:"leetcode-面试题11-旋转数组的最小数字",normalizedTitle:"leetcode-面试题11-旋转数组的最小数字",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:219},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:493},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:1843}],headersStr:"LeetCode-面试题11-旋转数组的最小数字 解题思路 Java代码 Python代码",content:'# LeetCode-面试题11-旋转数组的最小数字\n\n把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。\n\n示例1\n\n输入：[3,4,5,1,2]\n输出：1\n\n\n1\n2\n\n1\n2\n\n\n示例2\n\n输入：[2,2,2,0,1]\n输出：0\n\n\n1\n2\n\n1\n2\n\n\n\n# 解题思路\n\n方法1、类似于二分查找的方法：\n\n旋转之后的数组实际上可以划分为两个排序的子数组，最小的元素刚好是这两个子数组的分界线。知道这个之后就沿用二分查找的方法，逐渐缩小范围，结合数组的递增规律，当两个指针差值为1的时候，end位置就是最小数。\n\n其次是两个特例：\n\n * 当不需要把元素移动到后面的时候，数组为排序好的数组且是递增的，所以第一个位置就是最小的。\n * 当前中后3个位置都是相等的时候，这时用二分查找就行不通了，转化为顺序查找\n\n方法2、循环二分(摘自Leetcode大佬题解)：\n\n分析见原文，j = j-1厉害了！\n\n\n# Java代码\n\nclass Solution {\n    public int minArray(int[] numbers) {\n        if (numbers.length == 0) {\n            return -1;\n        }\n        int start = 0;\n        int end = numbers.length - 1;\n        int middle = start; // 考虑前面0个元素搬到后面，则数组为排序数组，第一个即最小\n        while (numbers[start] >= numbers[end]) {\n            if (end - start == 1) {\n                middle = end;\n                break;\n            }\n            middle = (start + end) / 2;\n            // 当前中后相等时，这时候只能顺序搜索\n            if (numbers[start] == numbers[end] && numbers[start] == numbers[middle]) {\n                return search(numbers, start, end);\n            }\n            if (numbers[middle] >= numbers[start]) {\n                start = middle;\n            } else if (numbers[middle] <= numbers[end]) {\n                end = middle;\n            }\n        }\n        return numbers[middle];\n    }\n    public int search(int[] numbers, int start, int end) {\n        int result = numbers[start];\n        for (int i = start + 1; i <= end; i++) {\n            if (result > numbers[i]) {\n                result = numbers[i];\n            }\n        }\n        return result;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# Python代码\n\nclass Solution(object):\n    def minArray(self, numbers):\n        """\n        :type numbers: List[int]\n        :rtype: int\n        """\n        i, j = 0, len(numbers) - 1\n        while i < j:\n            m = (i + j) // 2\n            if numbers[m] > numbers[j]: i = m + 1\n            elif numbers[m] < numbers[j]: j = m\n            else: j -= 1\n        return numbers[i]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n',normalizedContent:'# leetcode-面试题11-旋转数组的最小数字\n\n把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。\n\n示例1\n\n输入：[3,4,5,1,2]\n输出：1\n\n\n1\n2\n\n1\n2\n\n\n示例2\n\n输入：[2,2,2,0,1]\n输出：0\n\n\n1\n2\n\n1\n2\n\n\n\n# 解题思路\n\n方法1、类似于二分查找的方法：\n\n旋转之后的数组实际上可以划分为两个排序的子数组，最小的元素刚好是这两个子数组的分界线。知道这个之后就沿用二分查找的方法，逐渐缩小范围，结合数组的递增规律，当两个指针差值为1的时候，end位置就是最小数。\n\n其次是两个特例：\n\n * 当不需要把元素移动到后面的时候，数组为排序好的数组且是递增的，所以第一个位置就是最小的。\n * 当前中后3个位置都是相等的时候，这时用二分查找就行不通了，转化为顺序查找\n\n方法2、循环二分(摘自leetcode大佬题解)：\n\n分析见原文，j = j-1厉害了！\n\n\n# java代码\n\nclass solution {\n    public int minarray(int[] numbers) {\n        if (numbers.length == 0) {\n            return -1;\n        }\n        int start = 0;\n        int end = numbers.length - 1;\n        int middle = start; // 考虑前面0个元素搬到后面，则数组为排序数组，第一个即最小\n        while (numbers[start] >= numbers[end]) {\n            if (end - start == 1) {\n                middle = end;\n                break;\n            }\n            middle = (start + end) / 2;\n            // 当前中后相等时，这时候只能顺序搜索\n            if (numbers[start] == numbers[end] && numbers[start] == numbers[middle]) {\n                return search(numbers, start, end);\n            }\n            if (numbers[middle] >= numbers[start]) {\n                start = middle;\n            } else if (numbers[middle] <= numbers[end]) {\n                end = middle;\n            }\n        }\n        return numbers[middle];\n    }\n    public int search(int[] numbers, int start, int end) {\n        int result = numbers[start];\n        for (int i = start + 1; i <= end; i++) {\n            if (result > numbers[i]) {\n                result = numbers[i];\n            }\n        }\n        return result;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# python代码\n\nclass solution(object):\n    def minarray(self, numbers):\n        """\n        :type numbers: list[int]\n        :rtype: int\n        """\n        i, j = 0, len(numbers) - 1\n        while i < j:\n            m = (i + j) // 2\n            if numbers[m] > numbers[j]: i = m + 1\n            elif numbers[m] < numbers[j]: j = m\n            else: j -= 1\n        return numbers[i]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题13-机器人的运动范围",frontmatter:{title:"LeetCode-面试题13-机器人的运动范围",date:"2020-04-12T21:04:54.000Z",description:"机器人的运动范围",tags:["DFS","BFS","Java","Python","Medium","剑指Offer"],keywords:"搜索,Java,Python,Medium,剑指Offer",permalink:"/pages/ab9430/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/11.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9813-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4.html",relativePath:"06.算法/01.剑指Offer/11.LeetCode-面试题13-机器人的运动范围.md",key:"v-1109df90",path:"/pages/ab9430/",headers:[{level:2,title:"LeetCode-面试题13-机器人的运动范围",slug:"leetcode-面试题13-机器人的运动范围",normalizedTitle:"leetcode-面试题13-机器人的运动范围",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:369},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:744},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:1553}],headersStr:"LeetCode-面试题13-机器人的运动范围 解题思路 Java代码 Python代码",content:"# LeetCode-面试题13-机器人的运动范围\n\n地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？\n\n示例1\n\n输入：m = 2, n = 3, k = 1\n输出：3\n\n\n1\n2\n\n1\n2\n\n\n示例2\n\n输入：m = 3, n = 1, k = 0\n输出：1\n\n\n1\n2\n\n1\n2\n\n\n提示:\n\n * 1 <= n,m <= 100\n * 0 <= k <= 20\n\n\n# 解题思路\n\n除了边界以外，其他格子都可以上下左右移动，这道题可以简化为向右和向下移动。\n\n这是因为随着限制条件 k 的增大，(0, 0) 所在的蓝色方格区域内新加入的非障碍方格都可以由上方或左方的格子移动一步得到。\n\n * 在递归深度优先搜索的时候，需要进行数位和运算，约束不能去的格子。对于传入的数字，其对10求余得到个位数，之后除以10，类似右移一位挤掉本来的个位数，再对10求余即可得到十位数。循环下来就是单个数字的数位和。\n\n * 广度优先搜索也可以，这里采用一个基本的广度优先搜索策略，步骤如下把起始节点放入queue，之后从queue中取出队列头的格子，当格子符合数位和要求的时候就添加进set中，找出与取出格子相邻的上下左右的格子(这里只需要右边和下边的格子即可)，把它们放入到queue中，重复这个过程到queue为空为止。\n\n\n# Java代码\n\nclass Solution {\n    int count = 0;\n    public int movingCount(int m, int n, int k) {\n        boolean[][] visited = new boolean[m][n];\n        dfs(0,0,m,n,k,visited);\n        return count;\n    }\n\n    public void dfs(int i,int j,int m,int n,int k,boolean[][] visited){\n        if(i>=0&&i<m&&j>=0&&j<n&&sumNum(i)+sumNum(j)<=k&&visited[i][j]==false){\n            count++;\n            visited[i][j] = true;\n            dfs(i+1,j,m,n,k,visited);\n            dfs(i,j+1,m,n,k,visited);\n        }\n    }\n\n    public int sumNum(int num){\n        int sum = 0;\n        while(num>0){\n            sum+=num%10;\n            num/=10;\n        }\n        return sum;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# Python代码\n\nfrom queue import Queue\nclass Solution:\n    def movingCount(self, m: int, n: int, k: int) -> int:\n        q = Queue()\n        q.put((0,0))\n        s = set()\n        while not q.empty():\n            i , j = q.get()\n            if (i, j) not in s and 0<=i<m and 0<=j<n and self.sumNum(i)+self.sumNum(j)<=k:\n                s.add((i,j))\n                for x,y in [(i+1,j),(i,j+1)]:\n                    q.put((x,y))\n        return len(s)\n\n    def sumNum(self,n):\n        sum = 0\n        while n:\n            sum += n % 10\n            n //= 10\n        return sum\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n",normalizedContent:"# leetcode-面试题13-机器人的运动范围\n\n地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？\n\n示例1\n\n输入：m = 2, n = 3, k = 1\n输出：3\n\n\n1\n2\n\n1\n2\n\n\n示例2\n\n输入：m = 3, n = 1, k = 0\n输出：1\n\n\n1\n2\n\n1\n2\n\n\n提示:\n\n * 1 <= n,m <= 100\n * 0 <= k <= 20\n\n\n# 解题思路\n\n除了边界以外，其他格子都可以上下左右移动，这道题可以简化为向右和向下移动。\n\n这是因为随着限制条件 k 的增大，(0, 0) 所在的蓝色方格区域内新加入的非障碍方格都可以由上方或左方的格子移动一步得到。\n\n * 在递归深度优先搜索的时候，需要进行数位和运算，约束不能去的格子。对于传入的数字，其对10求余得到个位数，之后除以10，类似右移一位挤掉本来的个位数，再对10求余即可得到十位数。循环下来就是单个数字的数位和。\n\n * 广度优先搜索也可以，这里采用一个基本的广度优先搜索策略，步骤如下把起始节点放入queue，之后从queue中取出队列头的格子，当格子符合数位和要求的时候就添加进set中，找出与取出格子相邻的上下左右的格子(这里只需要右边和下边的格子即可)，把它们放入到queue中，重复这个过程到queue为空为止。\n\n\n# java代码\n\nclass solution {\n    int count = 0;\n    public int movingcount(int m, int n, int k) {\n        boolean[][] visited = new boolean[m][n];\n        dfs(0,0,m,n,k,visited);\n        return count;\n    }\n\n    public void dfs(int i,int j,int m,int n,int k,boolean[][] visited){\n        if(i>=0&&i<m&&j>=0&&j<n&&sumnum(i)+sumnum(j)<=k&&visited[i][j]==false){\n            count++;\n            visited[i][j] = true;\n            dfs(i+1,j,m,n,k,visited);\n            dfs(i,j+1,m,n,k,visited);\n        }\n    }\n\n    public int sumnum(int num){\n        int sum = 0;\n        while(num>0){\n            sum+=num%10;\n            num/=10;\n        }\n        return sum;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# python代码\n\nfrom queue import queue\nclass solution:\n    def movingcount(self, m: int, n: int, k: int) -> int:\n        q = queue()\n        q.put((0,0))\n        s = set()\n        while not q.empty():\n            i , j = q.get()\n            if (i, j) not in s and 0<=i<m and 0<=j<n and self.sumnum(i)+self.sumnum(j)<=k:\n                s.add((i,j))\n                for x,y in [(i+1,j),(i,j+1)]:\n                    q.put((x,y))\n        return len(s)\n\n    def sumnum(self,n):\n        sum = 0\n        while n:\n            sum += n % 10\n            n //= 10\n        return sum\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题14-1-剪绳子",frontmatter:{title:"LeetCode-面试题14-1-剪绳子",date:"2020-04-13T14:56:35.000Z",description:"剪绳子",tags:["DP","贪心算法","Java","Python","Medium","剑指Offer"],keywords:"动态规划,贪心算法,Java,Python,Medium,剑指Offer",permalink:"/pages/2d7b5b/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/12.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9814-1-%E5%89%AA%E7%BB%B3%E5%AD%90.html",relativePath:"06.算法/01.剑指Offer/12.LeetCode-面试题14-1-剪绳子.md",key:"v-61b66e0f",path:"/pages/2d7b5b/",headers:[{level:2,title:"LeetCode-面试题14-1-剪绳子",slug:"leetcode-面试题14-1-剪绳子",normalizedTitle:"leetcode-面试题14-1-剪绳子",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:333},{level:3,title:"Java代码1",slug:"java代码1",normalizedTitle:"java代码1",charIndex:817},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:709},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:1828}],headersStr:"LeetCode-面试题14-1-剪绳子 解题思路 Java代码1 Java代码2 Python代码",content:"# LeetCode-面试题14-1-剪绳子\n\n给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m] 。请问 k[0]k[1]...k[m] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。\n\n示例1\n\n输入: 2\n输出: 1\n解释: 2 = 1 + 1, 1 × 1 = 1\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2\n\n输入: 10\n输出: 36\n解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n提示:\n\n * 2 <= n <= 58\n\n\n# 解题思路\n\n方法1、动态规划\n\n整体目标为最大化f(n)=max(f(i) x f(n-i))，可以看成递归自顶向下解决，但是这样会有很多重复计算。一个更好的方法是自底向上，把小的子问题最优解，然后再往上计算，子问题要存储起来，避免重复的计算过程。对于f(0)~f(3)，最优解的值是n-1，对于n>=4的数，比如4，可以切分为1，2，3的数字组合，于是dp[1]，dp[2]，dp[3]分别等于1，2，3。这里的dp[3]不等于最优解2，因为切分4并不需要对数字3再次切分。\n\n另外一种解释是把线切的方法分为切成2段或者切成很多段，切成2段的乘积可以表示为第一段长度j，第二段长度i-j。切成多段的乘积可以表示为第一段长度为j，第二段长度为f(j-i)。到底是切2段大还是切多段大，用max函数比较一下。同时与现存的dp[i]的值比较，取最大的值。如Java代码2所示，也能够解决。\n\n方法2、贪心算法\n\n切的时候尽可能的使乘积最大，当n>=5时，尽可能多切长度为3的绳子；当剩下的长度为4时，切成2段长度为2的绳子，之后乘积就是切成3的次数*切成2的次数\n\n\n# Java代码1\n\nclass Solution {\n    public int cuttingRope(int n) {\n        // 此处计算f(0)~f(3)的最优解\n        if(n < 4)\n            return n-1;\n        int[] dp = new int[n+1];\n        // 当n>=4时，切分的长度有1，2，3的可能，dp[3]并不是代表f(3)的最优解\n        // 因为长度为1、2、3的线是4的子集，不需要再切分\n        dp[0] = 0;\n        dp[1] = 1;\n        dp[2] = 2;\n        dp[3] = 3;\n        for(int i=4;i<=n;i++){\n            for(int j=1;j<=i/2;j++){\n                dp[i] = Math.max((dp[j]*dp[i-j]),dp[i]);\n            }\n        }\n        return dp[n];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# Java代码2\n\nclass Solution {\n    public int cuttingRope(int n) {\n        int[] dp = new int[n + 1];\n        dp[1] = 1;\n        for (int i = 2; i <= n; i++) {\n            for (int j = 1; j < i; j++) {\n                dp[i] = Math.max(dp[i], Math.max(j * (i - j), j * dp[i - j]));\n            }\n        }\n        return dp[n];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# Python代码\n\nclass Solution:\n    def cuttingRope(self, n: int) -> int:\n        if(n<=3): return n-1\n        # 尽可能多的剪去长度为3的绳子\n        count3 = n//3\n        # 当绳子剩下的长度为4时，不再剪去长度为3的绳子，因为2x2>3x1，剪为3的次数减少1次\n        if(n-count3*3): count3-=1\n        # 重新计算差值，计算剪为2的次数\n        count2 = (n-count3*3)//2\n        return int(math.pow(3,count3)*math.pow(2,count2))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n",normalizedContent:"# leetcode-面试题14-1-剪绳子\n\n给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m] 。请问 k[0]k[1]...k[m] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。\n\n示例1\n\n输入: 2\n输出: 1\n解释: 2 = 1 + 1, 1 × 1 = 1\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2\n\n输入: 10\n输出: 36\n解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n提示:\n\n * 2 <= n <= 58\n\n\n# 解题思路\n\n方法1、动态规划\n\n整体目标为最大化f(n)=max(f(i) x f(n-i))，可以看成递归自顶向下解决，但是这样会有很多重复计算。一个更好的方法是自底向上，把小的子问题最优解，然后再往上计算，子问题要存储起来，避免重复的计算过程。对于f(0)~f(3)，最优解的值是n-1，对于n>=4的数，比如4，可以切分为1，2，3的数字组合，于是dp[1]，dp[2]，dp[3]分别等于1，2，3。这里的dp[3]不等于最优解2，因为切分4并不需要对数字3再次切分。\n\n另外一种解释是把线切的方法分为切成2段或者切成很多段，切成2段的乘积可以表示为第一段长度j，第二段长度i-j。切成多段的乘积可以表示为第一段长度为j，第二段长度为f(j-i)。到底是切2段大还是切多段大，用max函数比较一下。同时与现存的dp[i]的值比较，取最大的值。如java代码2所示，也能够解决。\n\n方法2、贪心算法\n\n切的时候尽可能的使乘积最大，当n>=5时，尽可能多切长度为3的绳子；当剩下的长度为4时，切成2段长度为2的绳子，之后乘积就是切成3的次数*切成2的次数\n\n\n# java代码1\n\nclass solution {\n    public int cuttingrope(int n) {\n        // 此处计算f(0)~f(3)的最优解\n        if(n < 4)\n            return n-1;\n        int[] dp = new int[n+1];\n        // 当n>=4时，切分的长度有1，2，3的可能，dp[3]并不是代表f(3)的最优解\n        // 因为长度为1、2、3的线是4的子集，不需要再切分\n        dp[0] = 0;\n        dp[1] = 1;\n        dp[2] = 2;\n        dp[3] = 3;\n        for(int i=4;i<=n;i++){\n            for(int j=1;j<=i/2;j++){\n                dp[i] = math.max((dp[j]*dp[i-j]),dp[i]);\n            }\n        }\n        return dp[n];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# java代码2\n\nclass solution {\n    public int cuttingrope(int n) {\n        int[] dp = new int[n + 1];\n        dp[1] = 1;\n        for (int i = 2; i <= n; i++) {\n            for (int j = 1; j < i; j++) {\n                dp[i] = math.max(dp[i], math.max(j * (i - j), j * dp[i - j]));\n            }\n        }\n        return dp[n];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# python代码\n\nclass solution:\n    def cuttingrope(self, n: int) -> int:\n        if(n<=3): return n-1\n        # 尽可能多的剪去长度为3的绳子\n        count3 = n//3\n        # 当绳子剩下的长度为4时，不再剪去长度为3的绳子，因为2x2>3x1，剪为3的次数减少1次\n        if(n-count3*3): count3-=1\n        # 重新计算差值，计算剪为2的次数\n        count2 = (n-count3*3)//2\n        return int(math.pow(3,count3)*math.pow(2,count2))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题14-2-剪绳子(大数)",frontmatter:{title:"LeetCode-面试题14-2-剪绳子(大数)",date:"2020-04-13T14:56:35.000Z",description:"剪绳子(大数)",tags:["DP","贪心算法","Java","Python","Medium","剑指Offer"],keywords:"动态规划,贪心算法,Java,Python,Medium,剑指Offer",permalink:"/pages/7c3197/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/13.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9814-2-%E5%89%AA%E7%BB%B3%E5%AD%90(%E5%A4%A7%E6%95%B0).html",relativePath:"06.算法/01.剑指Offer/13.LeetCode-面试题14-2-剪绳子(大数).md",key:"v-06664e26",path:"/pages/7c3197/",headers:[{level:2,title:"LeetCode-面试题14-2-剪绳子(大数)",slug:"leetcode-面试题14-2-剪绳子-大数",normalizedTitle:"leetcode-面试题14-2-剪绳子(大数)",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:392},{level:3,title:"Java代码1",slug:"java代码1",normalizedTitle:"java代码1",charIndex:477},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:841}],headersStr:"LeetCode-面试题14-2-剪绳子(大数) 解题思路 Java代码1 Python代码",content:"# LeetCode-面试题14-2-剪绳子(大数)\n\n给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m] 。请问 k[0]k[1]...k[m] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。\n\n答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。\n\n示例1\n\n输入: 2\n输出: 1\n解释: 2 = 1 + 1, 1 × 1 = 1\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2\n\n输入: 10\n输出: 36\n解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n提示:\n\n * 2 <= n <= 1000\n\n\n# 解题思路\n\n这个题和上个题主体一样，但是是求的大数环境下，求指数就超过int的区间了，需要求模。还是尽可能的多切长度为3的，最后把不足3的乘上就是结果，都要求余\n\n\n# Java代码1\n\nclass Solution {\n    public int cuttingRope(int n) {\n        if(n<=3)\n            return n-1;\n        long product = 1;\n        while(n>4){\n            product *=3;\n            product = product%1000000007;\n            n-=3;\n        }\n        return (int)(product*n%1000000007);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# Python代码\n\nclass Solution:\n    def cuttingRope(self, n: int) -> int:\n        if(n<=3): return n-1\n        dp = [0 for i in range(n+1)]\n        dp[0],dp[1],dp[2],dp[3]= 0,1,2,3\n        for i in range(4, n+1):\n            for j in range(1, i // 2+1):\n                dp[i] = max(dp[i],(dp[j]*dp[i-j]))\n        return dp[n] % 1000000007\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n",normalizedContent:"# leetcode-面试题14-2-剪绳子(大数)\n\n给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m] 。请问 k[0]k[1]...k[m] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。\n\n答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。\n\n示例1\n\n输入: 2\n输出: 1\n解释: 2 = 1 + 1, 1 × 1 = 1\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2\n\n输入: 10\n输出: 36\n解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n提示:\n\n * 2 <= n <= 1000\n\n\n# 解题思路\n\n这个题和上个题主体一样，但是是求的大数环境下，求指数就超过int的区间了，需要求模。还是尽可能的多切长度为3的，最后把不足3的乘上就是结果，都要求余\n\n\n# java代码1\n\nclass solution {\n    public int cuttingrope(int n) {\n        if(n<=3)\n            return n-1;\n        long product = 1;\n        while(n>4){\n            product *=3;\n            product = product%1000000007;\n            n-=3;\n        }\n        return (int)(product*n%1000000007);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# python代码\n\nclass solution:\n    def cuttingrope(self, n: int) -> int:\n        if(n<=3): return n-1\n        dp = [0 for i in range(n+1)]\n        dp[0],dp[1],dp[2],dp[3]= 0,1,2,3\n        for i in range(4, n+1):\n            for j in range(1, i // 2+1):\n                dp[i] = max(dp[i],(dp[j]*dp[i-j]))\n        return dp[n] % 1000000007\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题15-二进制中1的个数",frontmatter:{title:"LeetCode-面试题15-二进制中1的个数",date:"2020-04-14T10:59:53.000Z",description:"二进制中1的个数",tags:["位运算","Java","Python","Easy","剑指Offer"],keywords:"位运算,Java,Python,Easy,剑指Offer",permalink:"/pages/5abb63/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/14.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9815-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0.html",relativePath:"06.算法/01.剑指Offer/14.LeetCode-面试题15-二进制中1的个数.md",key:"v-b0913c7a",path:"/pages/5abb63/",headers:[{level:2,title:"LeetCode-面试题15-二进制中1的个数",slug:"leetcode-面试题15-二进制中1的个数",normalizedTitle:"leetcode-面试题15-二进制中1的个数",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:476},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:632},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:1008}],headersStr:"LeetCode-面试题15-二进制中1的个数 解题思路 Java代码 Python代码",content:"# LeetCode-面试题15-二进制中1的个数\n\n请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。\n\n示例1\n\n输入：00000000000000000000000000001011\n输出：3\n解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2\n\n输入：00000000000000000000000010000000\n输出：1\n解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例3\n\n输入：11111111111111111111111111111101\n输出：31\n解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n\n# 解题思路\n\n实际上把二进制不断向右移动和1求与运算就可以得到所有1了，但是这样不适用于负整数的情况。\n\n换一个思路把1左移一位，右边始终是加0，跟n求与运算得到所有的1，这种是有多少位数循环多少次。\n\n一种更好的方法是，把n减去1，再和原本的n做与运算，会把n最右边的1变为0，有多少1就会执行多少次。\n\n\n# Java代码\n\npublic class Solution {\n    // you need to treat n as an unsigned value\n    public int hammingWeight(int n) {\n        int count = 0;\n        int flag = 1;\n        while(flag!=0){\n            if((n&flag)!=0)\n                count++;\n            flag = flag<<1;\n        }\n        return count;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# Python代码\n\nclass Solution:\n    def hammingWeight(self, n: int) -> int:\n        count = 0\n        while n:\n            n = (n-1)&n\n            count+=1\n        return count\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n",normalizedContent:"# leetcode-面试题15-二进制中1的个数\n\n请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。\n\n示例1\n\n输入：00000000000000000000000000001011\n输出：3\n解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2\n\n输入：00000000000000000000000010000000\n输出：1\n解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例3\n\n输入：11111111111111111111111111111101\n输出：31\n解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n\n# 解题思路\n\n实际上把二进制不断向右移动和1求与运算就可以得到所有1了，但是这样不适用于负整数的情况。\n\n换一个思路把1左移一位，右边始终是加0，跟n求与运算得到所有的1，这种是有多少位数循环多少次。\n\n一种更好的方法是，把n减去1，再和原本的n做与运算，会把n最右边的1变为0，有多少1就会执行多少次。\n\n\n# java代码\n\npublic class solution {\n    // you need to treat n as an unsigned value\n    public int hammingweight(int n) {\n        int count = 0;\n        int flag = 1;\n        while(flag!=0){\n            if((n&flag)!=0)\n                count++;\n            flag = flag<<1;\n        }\n        return count;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# python代码\n\nclass solution:\n    def hammingweight(self, n: int) -> int:\n        count = 0\n        while n:\n            n = (n-1)&n\n            count+=1\n        return count\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题16-数值的整数次方",frontmatter:{title:"LeetCode-面试题16-数值的整数次方",date:"2020-04-14T17:15:23.000Z",description:"数值的整数次方",tags:["位运算","Java","Python","Medium","剑指Offer"],keywords:"位运算,Java,Python,Medium,剑指Offer",permalink:"/pages/4e2fa9/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/15.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9816-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9.html",relativePath:"06.算法/01.剑指Offer/15.LeetCode-面试题16-数值的整数次方.md",key:"v-068d4a28",path:"/pages/4e2fa9/",headers:[{level:2,title:"LeetCode-面试题16-数值的整数次方",slug:"leetcode-面试题16-数值的整数次方",normalizedTitle:"leetcode-面试题16-数值的整数次方",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:354},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:705},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:1215}],headersStr:"LeetCode-面试题16-数值的整数次方 解题思路 Java代码 Python代码",content:"# LeetCode-面试题16-数值的整数次方\n\n实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。\n\n示例1\n\n输入: 2.00000, 10\n输出: 1024.00000\n\n\n1\n2\n\n1\n2\n\n\n示例2\n\n输入: 2.10000, 3\n输出: 9.26100\n\n\n1\n2\n\n1\n2\n\n\n示例3\n\n输入: 2.00000, -2\n输出: 0.25000\n解释: 2-2 = 1/22 = 1/4 = 0.25\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n说明:\n\n * -100.0 < x < 100.0\n * n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。\n\n\n# 解题思路\n\n特殊值，x为0，n为0，没有意义返回1。n<0的时候要变换符号，但是这道题有个特殊的测试用例超出了int范围，拿一个long类型的作为中间变量存储\n\n传统的思路就是n多大就循环多少次，累乘一起就是结果，这种方法超时了。说明需要一个更加有效率的解法\n\n于是上了递归.....栈溢出了emmmm不知道是不是写错了，又换了一个写法。具体思路如下，对于一个次方数比如32，只需要求得16，8，4，2次方的数值即可获得32次方的数值，2次方的平方是4次方，4次方的平方是8次方，8次方的平方是16次方，16次方的平方是32次方。这是偶数的情况，奇数的情况会多乘一次x本身。\n\n奇数有一个特点就是%2==1，也可以算成与运算&1==1，做除法/2也可以等价于移位>>1，位运算本身要更快一些。\n\n\n# Java代码\n\nclass Solution {\n    public double myPow(double x, int n) {\n        double result = 1.0;\n        if (x == 0.0 && n == 0.0)\n            return 1.0;\n        long num = n;\n        if (num < 0) {\n            num = -num;\n            x = 1 / x;\n        }\n        while (num > 0) {\n            if ((num & 1) == 1) result *= x;\n            x *= x;\n            num >>= 1;\n        }\n        return result;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# Python代码\n\nclass Solution:\n    def myPow(self, x: float, n: int) -> float:\n        if x == 0: return 0\n        res = 1\n        if n < 0: x, n = 1 / x, -n\n        while n:\n            if n & 1: res *= x\n            x *= x\n            n >>= 1\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n",normalizedContent:"# leetcode-面试题16-数值的整数次方\n\n实现函数double power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。\n\n示例1\n\n输入: 2.00000, 10\n输出: 1024.00000\n\n\n1\n2\n\n1\n2\n\n\n示例2\n\n输入: 2.10000, 3\n输出: 9.26100\n\n\n1\n2\n\n1\n2\n\n\n示例3\n\n输入: 2.00000, -2\n输出: 0.25000\n解释: 2-2 = 1/22 = 1/4 = 0.25\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n说明:\n\n * -100.0 < x < 100.0\n * n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。\n\n\n# 解题思路\n\n特殊值，x为0，n为0，没有意义返回1。n<0的时候要变换符号，但是这道题有个特殊的测试用例超出了int范围，拿一个long类型的作为中间变量存储\n\n传统的思路就是n多大就循环多少次，累乘一起就是结果，这种方法超时了。说明需要一个更加有效率的解法\n\n于是上了递归.....栈溢出了emmmm不知道是不是写错了，又换了一个写法。具体思路如下，对于一个次方数比如32，只需要求得16，8，4，2次方的数值即可获得32次方的数值，2次方的平方是4次方，4次方的平方是8次方，8次方的平方是16次方，16次方的平方是32次方。这是偶数的情况，奇数的情况会多乘一次x本身。\n\n奇数有一个特点就是%2==1，也可以算成与运算&1==1，做除法/2也可以等价于移位>>1，位运算本身要更快一些。\n\n\n# java代码\n\nclass solution {\n    public double mypow(double x, int n) {\n        double result = 1.0;\n        if (x == 0.0 && n == 0.0)\n            return 1.0;\n        long num = n;\n        if (num < 0) {\n            num = -num;\n            x = 1 / x;\n        }\n        while (num > 0) {\n            if ((num & 1) == 1) result *= x;\n            x *= x;\n            num >>= 1;\n        }\n        return result;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# python代码\n\nclass solution:\n    def mypow(self, x: float, n: int) -> float:\n        if x == 0: return 0\n        res = 1\n        if n < 0: x, n = 1 / x, -n\n        while n:\n            if n & 1: res *= x\n            x *= x\n            n >>= 1\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题18-删除链表的节点",frontmatter:{title:"LeetCode-面试题18-删除链表的节点",date:"2020-04-15T18:07:21.000Z",description:"删除链表的节点",tags:["链表","Java","Python","Easy","剑指Offer"],keywords:"链表,Java,Python,Easy,剑指Offer",permalink:"/pages/a7cb1c/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/16.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9818-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9.html",relativePath:"06.算法/01.剑指Offer/16.LeetCode-面试题18-删除链表的节点.md",key:"v-3d447ed6",path:"/pages/a7cb1c/",headers:[{level:2,title:"LeetCode-面试题18-删除链表的节点",slug:"leetcode-面试题18-删除链表的节点",normalizedTitle:"leetcode-面试题18-删除链表的节点",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:387},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:524},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:1260}],headersStr:"LeetCode-面试题18-删除链表的节点 解题思路 Java代码 Python代码",content:"# LeetCode-面试题18-删除链表的节点\n\n给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。\n\n返回删除后的链表的头节点。\n\n示例1\n\n输入: head = [4,5,1,9], val = 5\n输出: [4,1,9]\n解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2\n\n输入: head = [4,5,1,9], val = 1\n输出: [4,5,9]\n解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n说明:\n\n * 题目保证链表中节点的值互不相同\n * 若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点\n\n\n# 解题思路\n\n没有O(1)的时间复杂度要求，顺序查找，头结点是查找值直接返回，如果不是则继续找，指针指向查找数的前一个位置，如果没有找完了都没有找到，循环依然是要跳出的，此时res.next==null，就不需要对链表进行修改，所以只有！=null的时候才有删除操作\n\n\n# Java代码\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode deleteNode(ListNode head, int val) {\n        if (head == null) {\n            return head;\n        }\n        if (head.val == val) {\n            return head.next;\n        }\n        ListNode res = head;\n        while(res.next!=null&&res.next.val!=val){\n            res = res.next;\n        }\n        if(res.next!=null){\n            res.next = res.next.next;\n        }\n        return head;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# Python代码\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def deleteNode(self, head: ListNode, val: int) -> ListNode:\n        if head.val == val: return head.next\n        res = head\n        while res.next and res.next.val!=val:\n            res = res.next\n        if res.next:\n            res.next = res.next.next\n        return head\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n",normalizedContent:"# leetcode-面试题18-删除链表的节点\n\n给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。\n\n返回删除后的链表的头节点。\n\n示例1\n\n输入: head = [4,5,1,9], val = 5\n输出: [4,1,9]\n解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2\n\n输入: head = [4,5,1,9], val = 1\n输出: [4,5,9]\n解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n说明:\n\n * 题目保证链表中节点的值互不相同\n * 若使用 c 或 c++ 语言，你不需要 free 或 delete 被删除的节点\n\n\n# 解题思路\n\n没有o(1)的时间复杂度要求，顺序查找，头结点是查找值直接返回，如果不是则继续找，指针指向查找数的前一个位置，如果没有找完了都没有找到，循环依然是要跳出的，此时res.next==null，就不需要对链表进行修改，所以只有！=null的时候才有删除操作\n\n\n# java代码\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode(int x) { val = x; }\n * }\n */\nclass solution {\n    public listnode deletenode(listnode head, int val) {\n        if (head == null) {\n            return head;\n        }\n        if (head.val == val) {\n            return head.next;\n        }\n        listnode res = head;\n        while(res.next!=null&&res.next.val!=val){\n            res = res.next;\n        }\n        if(res.next!=null){\n            res.next = res.next.next;\n        }\n        return head;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# python代码\n\n# definition for singly-linked list.\n# class listnode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = none\n\nclass solution:\n    def deletenode(self, head: listnode, val: int) -> listnode:\n        if head.val == val: return head.next\n        res = head\n        while res.next and res.next.val!=val:\n            res = res.next\n        if res.next:\n            res.next = res.next.next\n        return head\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题19-正则表达式匹配",frontmatter:{title:"LeetCode-面试题19-正则表达式匹配",date:"2020-04-16T14:56:55.000Z",description:"正则表达式匹配",tags:["DP","字符串","Python","Java","Hard","剑指Offer"],keywords:"DP,字符串,Java,Python,Hard,剑指Offer",permalink:"/pages/489cb9/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/17.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9819-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D.html",relativePath:"06.算法/01.剑指Offer/17.LeetCode-面试题19-正则表达式匹配.md",key:"v-7eaffbbc",path:"/pages/489cb9/",headers:[{level:2,title:"LeetCode-面试题19-正则表达式匹配",slug:"leetcode-面试题19-正则表达式匹配",normalizedTitle:"leetcode-面试题19-正则表达式匹配",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:732},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:1026},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:3518}],headersStr:"LeetCode-面试题19-正则表达式匹配 解题思路 Java代码 Python代码",content:"# LeetCode-面试题19-正则表达式匹配\n\n给你一个字符串s和一个字符规律p，请你来实现一个支持 '.'和'*'的正则表达式匹配。\n\n'.' 匹配任意单个字符\n\n'*' 匹配零个或多个前面的那一个元素\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n所谓匹配，是要涵盖整个字符串s的，而不是部分字符串。\n\n说明:\n\n * s可能为空，且只包含从a-z的小写字母。\n\n * p可能为空，且只包含从a-z的小写字母，以及字符.和*。\n\n示例1\n\n输入:\ns = \"aa\"\np = \"a\"\n输出: false\n解释: \"a\" 无法匹配 \"aa\" 整个字符串。\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n示例2\n\n输入:\ns = \"aa\"\np = \"a*\"\n输出: true\n解释:因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 \"aa\" 可被视为 'a' 重复了一次。\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n示例3\n\n输入:\ns = \"ab\"\np = \".*\"\n输出: true\n解释: \".*\" 表示可匹配零个或多个（'*'）任意字符（'.'）。\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n示例4\n\n输入:\ns = \"aab\"\np = \"c*a*b\"\n输出: true\n解释:因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 \"aab\"。\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n示例5\n\n输入:\ns = \"mississippi\"\np = \"mis*is*p*.\"\n输出: false\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n\n# 解题思路\n\n方法1、暴力递归(Python)：\n\n 1. 如果p为空，s也为空匹配，s不为空不匹配\n 2. s非空，p的首字母和s首字母或者.匹配，first=true\n 3. 判断如果p[1]不是*，则不需要考虑p[0]位置，直接进行下一位递归匹配\n 4. 如果p[1]==*，则有两种情况匹配\n 5. 匹配*号前的字符0次，说明前面这个字符不需要，我们要跳过ch*去匹配后面的，即isMatch(s,p[2:])\n 6. 匹配*号前的字符1次，说明前面这个字符至少出现了一次，s移动一位，继续使用匹配后面的\n\n方法2、动态规划(Java)：\n\n不会写....copy自评论区\n\n\n# Java代码\n\nclass Solution {\n    public boolean isMatch(String s, String p) {\n        int slen=s.length();\n        int plen=p.length();\n        if(slen==0&&plen==0)return true;\n        //if(slen==0||plen==0)return false;\n\n        boolean[][] dp=new boolean[slen+1][plen+1];\n        //dp[i][j]表示s的0到i-1和p的0到j-1是否匹配\n        dp[0][0]=true;\n        //初始化s=0\n        for(int j=1;j<=plen;j++){\n            //当s为空时，a*b*c*可以匹配\n            //当判断到下标j-1是*，j-2是b，b对应f，要看之前的能否匹配\n            //比如a*b*下标依次为ftft，b之前的位t，所以j-1也是true\n            //即dp[0][j]对应的下标j-1位true\n            if(j==1)dp[0][j]=false;\n            if(p.charAt(j-1)=='*'&&dp[0][j-2])dp[0][j]=true;\n        }\n\n        //for循环当s长度为1时能否匹配，一直到s长度为slen\n        for(int i=1;i<=slen;i++){\n            for(int j=1;j<=plen;j++){\n                //最简单的两种情况   字符相等或者p的字符是‘.'\n                if(s.charAt(i-1)==p.charAt(j-1)||p.charAt(j-1)=='.'){\n                    dp[i][j]=dp[i-1][j-1];\n                }\n                //p当前字符是*时，要判断*前边一个字符和s当前字符   \n                \n                else if(p.charAt(j-1)=='*'){\n                    if(j<2)dp[i][j]=false;\n                     //如果p的*前边字符和s当前字符相等或者p的字符是‘.'\n                     //三种可能\n                     //匹配0个，比如aa aaa*也就是没有*和*之前的字符也可以匹配上（在你（a*）没来之前我们(aa)已经能匹配上了）dp[i][j]=dp[i][j-2]\n                     //匹配1个，比如aab aab* 也就是*和*之前一个字符只匹配s串的当前一个字符就不看*号了  即 dp[i][j]=dp[i][j-1]\n                     //匹配多个，比如aabb aab*  b*匹配了bb两个b  那么看aab 和aab*是否能匹配上就行了，即dp[i][j]=dp[i-1][j]\n                     if(p.charAt(j-2)==s.charAt(i-1)||p.charAt(j-2)=='.'){\n                        dp[i][j]=dp[i-1][j]||dp[i][j-1]||dp[i][j-2];\n                    }\n                    //如果p的*前边字符和s当前字符不相等或者p的字符不是‘.'，那就把*和*前边一个字符都不要了呗\n                    //你会发现不管是这种情况还是上边的情况都会有dp[i][j]=dp[i][j-2];所以可以把下边剪枝，不用分开写了\n                    //这里分开写是为了好理解\n                    else if(p.charAt(j-2)!=s.charAt(i-1)&&p.charAt(j-2)!='.'){\n                        dp[i][j]=dp[i][j-2];\n                    }\n                }\n                //其他情况肯定不能匹配上了  直接false  比如 aba abb*c  \n                else{\n                    dp[i][j]=false;\n                }\n            }\n        }\n        return dp[slen][plen];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n\n# Python代码\n\nclass Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        if not p: return not s\n        first = bool(s) and p[0] in {s[0], '.'}\n        # 解释：如果发现有字符和 '*' 结合，\n        if len(p) >= 2 and p[1] == '*':\n            # 或者匹配该字符 0 次，然后跳过该字符和 '*'\n            return self.isMatch(s, p[2:]) or \\\n            # 或者当 pattern[0] 和 string[0] 匹配后，移动 string\n                   first and self.isMatch(s[1:], p)\n        else:\n            return first and self.isMatch(s[1:], p[1:])\n\n\nif __name__ == '__main__':\n    s = input().strip()\n    p = input().strip()\n    so = Solution()\n    output = so.isMatch(s, p)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n",normalizedContent:"# leetcode-面试题19-正则表达式匹配\n\n给你一个字符串s和一个字符规律p，请你来实现一个支持 '.'和'*'的正则表达式匹配。\n\n'.' 匹配任意单个字符\n\n'*' 匹配零个或多个前面的那一个元素\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n所谓匹配，是要涵盖整个字符串s的，而不是部分字符串。\n\n说明:\n\n * s可能为空，且只包含从a-z的小写字母。\n\n * p可能为空，且只包含从a-z的小写字母，以及字符.和*。\n\n示例1\n\n输入:\ns = \"aa\"\np = \"a\"\n输出: false\n解释: \"a\" 无法匹配 \"aa\" 整个字符串。\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n示例2\n\n输入:\ns = \"aa\"\np = \"a*\"\n输出: true\n解释:因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 \"aa\" 可被视为 'a' 重复了一次。\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n示例3\n\n输入:\ns = \"ab\"\np = \".*\"\n输出: true\n解释: \".*\" 表示可匹配零个或多个（'*'）任意字符（'.'）。\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n示例4\n\n输入:\ns = \"aab\"\np = \"c*a*b\"\n输出: true\n解释:因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 \"aab\"。\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n示例5\n\n输入:\ns = \"mississippi\"\np = \"mis*is*p*.\"\n输出: false\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n\n# 解题思路\n\n方法1、暴力递归(python)：\n\n 1. 如果p为空，s也为空匹配，s不为空不匹配\n 2. s非空，p的首字母和s首字母或者.匹配，first=true\n 3. 判断如果p[1]不是*，则不需要考虑p[0]位置，直接进行下一位递归匹配\n 4. 如果p[1]==*，则有两种情况匹配\n 5. 匹配*号前的字符0次，说明前面这个字符不需要，我们要跳过ch*去匹配后面的，即ismatch(s,p[2:])\n 6. 匹配*号前的字符1次，说明前面这个字符至少出现了一次，s移动一位，继续使用匹配后面的\n\n方法2、动态规划(java)：\n\n不会写....copy自评论区\n\n\n# java代码\n\nclass solution {\n    public boolean ismatch(string s, string p) {\n        int slen=s.length();\n        int plen=p.length();\n        if(slen==0&&plen==0)return true;\n        //if(slen==0||plen==0)return false;\n\n        boolean[][] dp=new boolean[slen+1][plen+1];\n        //dp[i][j]表示s的0到i-1和p的0到j-1是否匹配\n        dp[0][0]=true;\n        //初始化s=0\n        for(int j=1;j<=plen;j++){\n            //当s为空时，a*b*c*可以匹配\n            //当判断到下标j-1是*，j-2是b，b对应f，要看之前的能否匹配\n            //比如a*b*下标依次为ftft，b之前的位t，所以j-1也是true\n            //即dp[0][j]对应的下标j-1位true\n            if(j==1)dp[0][j]=false;\n            if(p.charat(j-1)=='*'&&dp[0][j-2])dp[0][j]=true;\n        }\n\n        //for循环当s长度为1时能否匹配，一直到s长度为slen\n        for(int i=1;i<=slen;i++){\n            for(int j=1;j<=plen;j++){\n                //最简单的两种情况   字符相等或者p的字符是‘.'\n                if(s.charat(i-1)==p.charat(j-1)||p.charat(j-1)=='.'){\n                    dp[i][j]=dp[i-1][j-1];\n                }\n                //p当前字符是*时，要判断*前边一个字符和s当前字符   \n                \n                else if(p.charat(j-1)=='*'){\n                    if(j<2)dp[i][j]=false;\n                     //如果p的*前边字符和s当前字符相等或者p的字符是‘.'\n                     //三种可能\n                     //匹配0个，比如aa aaa*也就是没有*和*之前的字符也可以匹配上（在你（a*）没来之前我们(aa)已经能匹配上了）dp[i][j]=dp[i][j-2]\n                     //匹配1个，比如aab aab* 也就是*和*之前一个字符只匹配s串的当前一个字符就不看*号了  即 dp[i][j]=dp[i][j-1]\n                     //匹配多个，比如aabb aab*  b*匹配了bb两个b  那么看aab 和aab*是否能匹配上就行了，即dp[i][j]=dp[i-1][j]\n                     if(p.charat(j-2)==s.charat(i-1)||p.charat(j-2)=='.'){\n                        dp[i][j]=dp[i-1][j]||dp[i][j-1]||dp[i][j-2];\n                    }\n                    //如果p的*前边字符和s当前字符不相等或者p的字符不是‘.'，那就把*和*前边一个字符都不要了呗\n                    //你会发现不管是这种情况还是上边的情况都会有dp[i][j]=dp[i][j-2];所以可以把下边剪枝，不用分开写了\n                    //这里分开写是为了好理解\n                    else if(p.charat(j-2)!=s.charat(i-1)&&p.charat(j-2)!='.'){\n                        dp[i][j]=dp[i][j-2];\n                    }\n                }\n                //其他情况肯定不能匹配上了  直接false  比如 aba abb*c  \n                else{\n                    dp[i][j]=false;\n                }\n            }\n        }\n        return dp[slen][plen];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n\n# python代码\n\nclass solution:\n    def ismatch(self, s: str, p: str) -> bool:\n        if not p: return not s\n        first = bool(s) and p[0] in {s[0], '.'}\n        # 解释：如果发现有字符和 '*' 结合，\n        if len(p) >= 2 and p[1] == '*':\n            # 或者匹配该字符 0 次，然后跳过该字符和 '*'\n            return self.ismatch(s, p[2:]) or \\\n            # 或者当 pattern[0] 和 string[0] 匹配后，移动 string\n                   first and self.ismatch(s[1:], p)\n        else:\n            return first and self.ismatch(s[1:], p[1:])\n\n\nif __name__ == '__main__':\n    s = input().strip()\n    p = input().strip()\n    so = solution()\n    output = so.ismatch(s, p)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题20-表示数值的字符串",frontmatter:{title:"LeetCode-面试题20-表示数值的字符串",date:"2020-04-17T12:21:56.000Z",description:"表示数值的字符串",tags:["字符串","Python","Java","Medium","剑指Offer"],keywords:"字符串,Java,Python,Medium,剑指Offer",permalink:"/pages/6845e4/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/18.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9820-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2.html",relativePath:"06.算法/01.剑指Offer/18.LeetCode-面试题20-表示数值的字符串.md",key:"v-a17ec6d2",path:"/pages/6845e4/",headers:[{level:2,title:"LeetCode-面试题20-表示数值的字符串",slug:"leetcode-面试题20-表示数值的字符串",normalizedTitle:"leetcode-面试题20-表示数值的字符串",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:161},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:411},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:1831}],headersStr:"LeetCode-面试题20-表示数值的字符串 解题思路 Java代码 Python代码",content:"# LeetCode-面试题20-表示数值的字符串\n\n请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串\"+100\"、\"5e2\"、\"-123\"、\"3.1416\"、\"0123\"及\"-1E-16\"都表示数值，但\"12e\"、\"1a3.14\"、\"1.2.3\"、\"+-5\"及\"12e+5.4\"都不是。\n\n\n# 解题思路\n\n一位一位进行判断，字符串遵循模式A[.[B]][e|EC]或者.[B][e|EC]\n\n其中A和C都是可能以+或者-开头的0~9的数位串\n\nB也是0~9的数位串，但是不能带有正负号\n\nC紧跟着'e'或者'E'为数值的指数部分\n\n判断一个字符串是否符合上述模式时，首先尽可能多地扫描0~9的数位(有可能在起始处有'+'或'-'，也就是前面模式中表示数值整数的A部分)，如果遇到小数点'.'，则开始扫描表示数值小数部分的B部分，如果遇到'e'或者'E'，则开始扫描表示数值指数的C部分\n\n\n# Java代码\n\nclass Solution {\n    public boolean isNumber(String s) {\n        if(s==null||s.length()==0)\n            return false;\n        boolean isNum = false;\n        boolean isDot = false;\n        boolean isE = false;\n        char[] str = s.trim().toCharArray();\n        for(int i = 0;i < str.length;i++){\n            if(str[i]>='0'&&str[i]<='9'){\n                isNum = true;\n            }\n            else if('.'==str[i]){\n                // .的前面不能有.或者E\n                if(isDot||isE)\n                    return false;\n                isDot = true;\n            }\n            else if(str[i]=='e'||str[i]=='E'){\n                // e或E的前面不能有e/E，只能是数字\n                if(isE||isNum==false)\n                    return false;\n                isE = true;\n                // 越过e之后必须要有数字，重置isNum，记录后面是不是有数字出现\n                // 如果e是最后一位，则这个数字不合法\n                isNum = false;\n            }\n            else if(str[i]=='+'||str[i]=='-'){\n                // 只有i=0或者e/E前面出现正负号的时候才合法，不然就是非法\n                if(i!=0&&str[i-1]!='e'&&str[i-1]!='E')\n                    return false;\n            }\n            else{ // 其他非法情况\n                return false;\n            }\n        }\n        return isNum;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# Python代码\n\nclass Solution:\n    def __init__(self):\n        self.p = 0\n\n    def isNumber(self, s: str) -> bool:\n        s = s.strip()\n        if not s: return False\n        numeric = self.scanInteger(s)\n        if self.p > len(s)-1:\n            return numeric\n        if self.p < len(s) and s[self.p] == '.':\n            self.p +=1\n            if self.p > len(s)-1:\n                return numeric\n            numeric = self.scanUnsignedIntergers(s) or numeric\n        if self.p < len(s) and s[self.p] in ['e','E']:\n            self.p +=1\n            if self.p > len(s)-1:\n                return False\n            numeric = numeric and self.scanInteger(s)\n        if self.p < len(s):\n            return False\n        return numeric\n    \n    def scanInteger(self,s):\n        if s[self.p] in ['+','-']:\n            self.p +=1\n        return self.scanUnsignedIntergers(s)\n    \n    def scanUnsignedIntergers(self,s):\n        pre = self.p\n        while(self.p < len(s) and s[self.p]>='0' and s[self.p]<='9'):\n            self.p +=1\n        return self.p>pre\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n",normalizedContent:"# leetcode-面试题20-表示数值的字符串\n\n请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串\"+100\"、\"5e2\"、\"-123\"、\"3.1416\"、\"0123\"及\"-1e-16\"都表示数值，但\"12e\"、\"1a3.14\"、\"1.2.3\"、\"+-5\"及\"12e+5.4\"都不是。\n\n\n# 解题思路\n\n一位一位进行判断，字符串遵循模式a[.[b]][e|ec]或者.[b][e|ec]\n\n其中a和c都是可能以+或者-开头的0~9的数位串\n\nb也是0~9的数位串，但是不能带有正负号\n\nc紧跟着'e'或者'e'为数值的指数部分\n\n判断一个字符串是否符合上述模式时，首先尽可能多地扫描0~9的数位(有可能在起始处有'+'或'-'，也就是前面模式中表示数值整数的a部分)，如果遇到小数点'.'，则开始扫描表示数值小数部分的b部分，如果遇到'e'或者'e'，则开始扫描表示数值指数的c部分\n\n\n# java代码\n\nclass solution {\n    public boolean isnumber(string s) {\n        if(s==null||s.length()==0)\n            return false;\n        boolean isnum = false;\n        boolean isdot = false;\n        boolean ise = false;\n        char[] str = s.trim().tochararray();\n        for(int i = 0;i < str.length;i++){\n            if(str[i]>='0'&&str[i]<='9'){\n                isnum = true;\n            }\n            else if('.'==str[i]){\n                // .的前面不能有.或者e\n                if(isdot||ise)\n                    return false;\n                isdot = true;\n            }\n            else if(str[i]=='e'||str[i]=='e'){\n                // e或e的前面不能有e/e，只能是数字\n                if(ise||isnum==false)\n                    return false;\n                ise = true;\n                // 越过e之后必须要有数字，重置isnum，记录后面是不是有数字出现\n                // 如果e是最后一位，则这个数字不合法\n                isnum = false;\n            }\n            else if(str[i]=='+'||str[i]=='-'){\n                // 只有i=0或者e/e前面出现正负号的时候才合法，不然就是非法\n                if(i!=0&&str[i-1]!='e'&&str[i-1]!='e')\n                    return false;\n            }\n            else{ // 其他非法情况\n                return false;\n            }\n        }\n        return isnum;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# python代码\n\nclass solution:\n    def __init__(self):\n        self.p = 0\n\n    def isnumber(self, s: str) -> bool:\n        s = s.strip()\n        if not s: return false\n        numeric = self.scaninteger(s)\n        if self.p > len(s)-1:\n            return numeric\n        if self.p < len(s) and s[self.p] == '.':\n            self.p +=1\n            if self.p > len(s)-1:\n                return numeric\n            numeric = self.scanunsignedintergers(s) or numeric\n        if self.p < len(s) and s[self.p] in ['e','e']:\n            self.p +=1\n            if self.p > len(s)-1:\n                return false\n            numeric = numeric and self.scaninteger(s)\n        if self.p < len(s):\n            return false\n        return numeric\n    \n    def scaninteger(self,s):\n        if s[self.p] in ['+','-']:\n            self.p +=1\n        return self.scanunsignedintergers(s)\n    \n    def scanunsignedintergers(self,s):\n        pre = self.p\n        while(self.p < len(s) and s[self.p]>='0' and s[self.p]<='9'):\n            self.p +=1\n        return self.p>pre\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题21-调整数组顺序使奇数位于偶数前面",frontmatter:{title:"LeetCode-面试题21-调整数组顺序使奇数位于偶数前面",date:"2020-04-17T17:58:38.000Z",description:"调整数组顺序使奇数位于偶数前面",tags:["数组","Python","Java","Easy","剑指Offer"],keywords:"数组,Java,Python,Easy,剑指Offer",permalink:"/pages/d28ff3/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/19.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9821-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2.html",relativePath:"06.算法/01.剑指Offer/19.LeetCode-面试题21-调整数组顺序使奇数位于偶数前面.md",key:"v-18b54ca0",path:"/pages/d28ff3/",headers:[{level:2,title:"LeetCode-面试题21-调整数组顺序使奇数位于偶数前面",slug:"leetcode-面试题21-调整数组顺序使奇数位于偶数前面",normalizedTitle:"leetcode-面试题21-调整数组顺序使奇数位于偶数前面",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:238},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:401},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:1216}],headersStr:"LeetCode-面试题21-调整数组顺序使奇数位于偶数前面 解题思路 Java代码 Python代码",content:"# LeetCode-面试题21-调整数组顺序使奇数位于偶数前面\n\n输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。\n\n示例：\n\n输入：nums = [1,2,3,4]\n输出：[1,3,2,4] \n注：[3,1,2,4] 也是正确的答案之一。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n提示：\n\n 1. 1 <= nums.length <= 50000\n 2. 1 <= nums[i] <= 10000\n\n\n# 解题思路\n\n设置2个指针，一个指向头，一个指向尾，当start>end的时候，进行循环判断，前面的偶数已经和后面的奇数互换\n\n所以前面的指针要不断寻找偶数，找到偶数位置记录下来。\n\n后面的指针要不断寻找奇数，找到奇数的位置。\n\n当前面是偶数后面是奇数时则满足交换条件，进行互换，这样遍历之后就将奇数全部放在了偶数之前\n\n\n# Java代码\n\nclass Solution {\n    public int[] exchange(int[] nums) {\n        if(nums==null||nums.length==0){\n            return nums;\n        }\n        int start = 0;\n        int end = nums.length-1;\n        while(start<end){\n            // 当前是奇数时，向后移动start，直到碰到偶数\n            while(start<end&&(nums[start]&0x1)!=0)\n                start++;\n            // 当前是偶数时，向前移动end，直到碰到奇数\n            while(start<end&&(nums[end]&0x1)==0)\n                end--;\n            // 当start和end是前偶后奇时，交换2个数位置\n            if(start<end){\n                int temp = nums[start];\n                nums[start] = nums[end];\n                nums[end] = temp;\n            }\n        }\n        return nums;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# Python代码\n\nclass Solution:\n    def exchange(self, nums: List[int]) -> List[int]:\n        if not nums or len(nums)==0:\n            return nums;\n        start ,end = 0, len(nums)-1\n        while start<end:\n            while start<end and (nums[start]&0x1)!=0:\n                start +=1\n            while start<end and (nums[end]&0x1)==0:\n                end -=1\n            if start<end:\n                temp = nums[start]\n                nums[start] = nums[end]\n                nums[end] = temp\n        return nums\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n",normalizedContent:"# leetcode-面试题21-调整数组顺序使奇数位于偶数前面\n\n输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。\n\n示例：\n\n输入：nums = [1,2,3,4]\n输出：[1,3,2,4] \n注：[3,1,2,4] 也是正确的答案之一。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n提示：\n\n 1. 1 <= nums.length <= 50000\n 2. 1 <= nums[i] <= 10000\n\n\n# 解题思路\n\n设置2个指针，一个指向头，一个指向尾，当start>end的时候，进行循环判断，前面的偶数已经和后面的奇数互换\n\n所以前面的指针要不断寻找偶数，找到偶数位置记录下来。\n\n后面的指针要不断寻找奇数，找到奇数的位置。\n\n当前面是偶数后面是奇数时则满足交换条件，进行互换，这样遍历之后就将奇数全部放在了偶数之前\n\n\n# java代码\n\nclass solution {\n    public int[] exchange(int[] nums) {\n        if(nums==null||nums.length==0){\n            return nums;\n        }\n        int start = 0;\n        int end = nums.length-1;\n        while(start<end){\n            // 当前是奇数时，向后移动start，直到碰到偶数\n            while(start<end&&(nums[start]&0x1)!=0)\n                start++;\n            // 当前是偶数时，向前移动end，直到碰到奇数\n            while(start<end&&(nums[end]&0x1)==0)\n                end--;\n            // 当start和end是前偶后奇时，交换2个数位置\n            if(start<end){\n                int temp = nums[start];\n                nums[start] = nums[end];\n                nums[end] = temp;\n            }\n        }\n        return nums;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# python代码\n\nclass solution:\n    def exchange(self, nums: list[int]) -> list[int]:\n        if not nums or len(nums)==0:\n            return nums;\n        start ,end = 0, len(nums)-1\n        while start<end:\n            while start<end and (nums[start]&0x1)!=0:\n                start +=1\n            while start<end and (nums[end]&0x1)==0:\n                end -=1\n            if start<end:\n                temp = nums[start]\n                nums[start] = nums[end]\n                nums[end] = temp\n        return nums\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题22-链表中倒数第k个节点",frontmatter:{title:"LeetCode-面试题22-链表中倒数第k个节点",date:"2020-04-18T22:59:57.000Z",description:"链表中倒数第k个节点",tags:["链表","Python","Java","Easy","剑指Offer"],keywords:"链表,Java,Python,Easy,剑指Offer",permalink:"/pages/663c3e/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/20.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9822-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9.html",relativePath:"06.算法/01.剑指Offer/20.LeetCode-面试题22-链表中倒数第k个节点.md",key:"v-477a301f",path:"/pages/663c3e/",headers:[{level:2,title:"LeetCode-面试题22-链表中倒数第k个节点",slug:"leetcode-面试题22-链表中倒数第k个节点",normalizedTitle:"leetcode-面试题22-链表中倒数第k个节点",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:217},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:401},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:1259}],headersStr:"LeetCode-面试题22-链表中倒数第k个节点 解题思路 Java代码 Python代码",content:"# LeetCode-面试题22-链表中倒数第k个节点\n\n输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。\n\n示例：\n\n给定一个链表: 1->2->3->4->5, 和 k = 2.\n\n返回链表 4->5.\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n\n# 解题思路\n\n设置2个指针，只遍历链表一次找到倒数第k个节点，\n\n假设有n个节点，那么倒数第k个节点就是从头结点开始的第n-k+1个节点。\n\n第一个指针从链表的头指针开始遍历向前走k-1步，第二个指针保持不动。从第k步开始，第二个指针也开始从链表的头指针开始遍历，由于两个指针的距离保持k-1，当第一个指针到达链表的尾节点时，第二个指针正好指向倒数第k个节点。\n\n\n# Java代码\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode getKthFromEnd(ListNode head, int k) {\n        if(head==null||k==0)\n            return head;\n        ListNode phead = head;\n        ListNode pbehind = null;\n        for(int i = 0;i<k-1;i++){\n            if(phead.next!=null)\n                phead = phead.next;\n            else{\n                return head;\n            }\n        }\n        pbehind = head;\n        while(phead.next!=null){\n            phead = phead.next;\n            pbehind = pbehind.next;\n        }\n        return pbehind;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# Python代码\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getKthFromEnd(self, head: ListNode, k: int) -> ListNode:\n        if not head or k==0:\n            return head\n        phead , pafter = head,head\n        for _ in range(k-1):\n            if phead.next:\n                phead = phead.next\n            else:\n                return head\n        while phead.next:\n            phead = phead.next\n            pafter = pafter.next\n        return pafter\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n",normalizedContent:"# leetcode-面试题22-链表中倒数第k个节点\n\n输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。\n\n示例：\n\n给定一个链表: 1->2->3->4->5, 和 k = 2.\n\n返回链表 4->5.\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n\n# 解题思路\n\n设置2个指针，只遍历链表一次找到倒数第k个节点，\n\n假设有n个节点，那么倒数第k个节点就是从头结点开始的第n-k+1个节点。\n\n第一个指针从链表的头指针开始遍历向前走k-1步，第二个指针保持不动。从第k步开始，第二个指针也开始从链表的头指针开始遍历，由于两个指针的距离保持k-1，当第一个指针到达链表的尾节点时，第二个指针正好指向倒数第k个节点。\n\n\n# java代码\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode(int x) { val = x; }\n * }\n */\nclass solution {\n    public listnode getkthfromend(listnode head, int k) {\n        if(head==null||k==0)\n            return head;\n        listnode phead = head;\n        listnode pbehind = null;\n        for(int i = 0;i<k-1;i++){\n            if(phead.next!=null)\n                phead = phead.next;\n            else{\n                return head;\n            }\n        }\n        pbehind = head;\n        while(phead.next!=null){\n            phead = phead.next;\n            pbehind = pbehind.next;\n        }\n        return pbehind;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# python代码\n\n# definition for singly-linked list.\n# class listnode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = none\n\nclass solution:\n    def getkthfromend(self, head: listnode, k: int) -> listnode:\n        if not head or k==0:\n            return head\n        phead , pafter = head,head\n        for _ in range(k-1):\n            if phead.next:\n                phead = phead.next\n            else:\n                return head\n        while phead.next:\n            phead = phead.next\n            pafter = pafter.next\n        return pafter\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题27-二叉树的镜像",frontmatter:{title:"LeetCode-面试题27-二叉树的镜像",date:"2020-04-20T15:43:20.000Z",description:"二叉树的镜像",tags:["树","Python","Java","Easy","剑指Offer"],keywords:"树,Java,Python,Easy,剑指Offer",permalink:"/pages/107b94/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/24.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9827-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F.html",relativePath:"06.算法/01.剑指Offer/24.LeetCode-面试题27-二叉树的镜像.md",key:"v-0ddb40ea",path:"/pages/107b94/",headers:[{level:2,title:"LeetCode-面试题27-二叉树的镜像",slug:"leetcode-面试题27-二叉树的镜像",normalizedTitle:"leetcode-面试题27-二叉树的镜像",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:306},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:584},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:1342}],headersStr:"LeetCode-面试题27-二叉树的镜像 解题思路 Java代码 Python代码",content:"# LeetCode-面试题27-二叉树的镜像\n\n请完成一个函数，输入一个二叉树，该函数输出它的镜像。\n\n例如输入：\n\n     4\n   /   \\\n  2     7\n / \\   / \\\n1   3 6   9\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n镜像输出：\n\n     4\n   /   \\\n  7     2\n / \\   / \\\n9   6 3   1\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n示例1：\n\n输入：root = [4,2,7,1,3,6,9]\n输出：[4,7,2,9,6,3,1]\n\n\n1\n2\n\n1\n2\n\n\n限制：\n\n0 <= 节点个数 <= 1000\n\n\n# 解题思路\n\n方法1、递归：\n\n一个二叉树的镜像就是把原本的子节点交换，一层一层来看，先要交换root节点的左右节点，然后分别交换左右节点的子节点，利用递归解决，终止条件是当遍历到左右子树为空或者头结点为空时跳出。\n\n方法2、栈：\n\n类似于DFS的解法，利用一个辅助栈当root为空||root的左右节点为空时返回null\n\n初始化一个栈，存放头节点root，\n\n然后进行循环：当stack为空的时候跳出，\n\n之后的原理是，弹出一个节点node，找到这个节点的左右邻居节点(邻居不为空时)，并压入栈中，交换2个左右节点的值\n\n最后返回根节点root\n\n\n# Java代码\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode mirrorTree(TreeNode root) {\n        if(root==null)\n            return root;\n        if(root.left==null&&root.right==null)\n            return root;\n        TreeNode temp = root.left;\n        root.left = root.right;\n        root.right = temp;\n        if(root.left!=null)\n            mirrorTree(root.left);\n        if(root.right!=null)\n            mirrorTree(root.right);\n        return root;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# Python代码\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def mirrorTree(self, root: TreeNode) -> TreeNode:\n        if not root: return root\n        if not root.left and not root.right: return root\n        stack = [root]\n        while stack:\n            node = stack.pop()\n            if node.left: stack.append(node.left)\n            if node.right: stack.append(node.right)\n            node.left,node.right = node.right,node.left\n        return root\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n",normalizedContent:"# leetcode-面试题27-二叉树的镜像\n\n请完成一个函数，输入一个二叉树，该函数输出它的镜像。\n\n例如输入：\n\n     4\n   /   \\\n  2     7\n / \\   / \\\n1   3 6   9\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n镜像输出：\n\n     4\n   /   \\\n  7     2\n / \\   / \\\n9   6 3   1\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n示例1：\n\n输入：root = [4,2,7,1,3,6,9]\n输出：[4,7,2,9,6,3,1]\n\n\n1\n2\n\n1\n2\n\n\n限制：\n\n0 <= 节点个数 <= 1000\n\n\n# 解题思路\n\n方法1、递归：\n\n一个二叉树的镜像就是把原本的子节点交换，一层一层来看，先要交换root节点的左右节点，然后分别交换左右节点的子节点，利用递归解决，终止条件是当遍历到左右子树为空或者头结点为空时跳出。\n\n方法2、栈：\n\n类似于dfs的解法，利用一个辅助栈当root为空||root的左右节点为空时返回null\n\n初始化一个栈，存放头节点root，\n\n然后进行循环：当stack为空的时候跳出，\n\n之后的原理是，弹出一个节点node，找到这个节点的左右邻居节点(邻居不为空时)，并压入栈中，交换2个左右节点的值\n\n最后返回根节点root\n\n\n# java代码\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public treenode mirrortree(treenode root) {\n        if(root==null)\n            return root;\n        if(root.left==null&&root.right==null)\n            return root;\n        treenode temp = root.left;\n        root.left = root.right;\n        root.right = temp;\n        if(root.left!=null)\n            mirrortree(root.left);\n        if(root.right!=null)\n            mirrortree(root.right);\n        return root;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# python代码\n\n# definition for a binary tree node.\n# class treenode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = none\n#         self.right = none\n\nclass solution:\n    def mirrortree(self, root: treenode) -> treenode:\n        if not root: return root\n        if not root.left and not root.right: return root\n        stack = [root]\n        while stack:\n            node = stack.pop()\n            if node.left: stack.append(node.left)\n            if node.right: stack.append(node.right)\n            node.left,node.right = node.right,node.left\n        return root\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题29-顺时针打印矩阵",frontmatter:{title:"LeetCode-面试题29-顺时针打印矩阵",date:"2020-04-21T12:00:13.000Z",description:"顺时针打印矩阵",tags:["矩阵","Python","Java","Easy","剑指Offer"],keywords:"矩阵,Java,Python,Easy,剑指Offer",permalink:"/pages/0b663a/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/25.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9829-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5.html",relativePath:"06.算法/01.剑指Offer/25.LeetCode-面试题29-顺时针打印矩阵.md",key:"v-2c7e0c4b",path:"/pages/0b663a/",headers:[{level:2,title:"LeetCode-面试题29-顺时针打印矩阵",slug:"leetcode-面试题29-顺时针打印矩阵",normalizedTitle:"leetcode-面试题29-顺时针打印矩阵",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:316},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:1001},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:2601}],headersStr:"LeetCode-面试题29-顺时针打印矩阵 解题思路 Java代码 Python代码",content:"# LeetCode-面试题29-顺时针打印矩阵\n\n输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。本题和螺旋矩阵相同\n\n示例1：\n\n输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]\n输出：[1,2,3,6,9,8,7,4,5]\n\n\n1\n2\n\n1\n2\n\n\n示例2：\n\n输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n输出：[1,2,3,4,8,12,11,10,9,5,6,7]\n\n\n1\n2\n\n1\n2\n\n\n限制：\n\n * 0 <= matrix.length <= 100\n * 0 <= matrix[i].length <= 100\n\n\n# 解题思路\n\n**方法1、**圈层\n\n 1. 记录左右和上下两个边界的点，按照上下左右算一圈，下一圈开始的时候初始位置+1，直到数组长度达到元素个数为止。Tips：注意几个初始点不参与遍历的变化。\n 2. 首先遍历第一行，记录最左的列位置，初始化left为0，一直遍历到right为矩阵列数为止，遍历完成后此时行数应该+1，即top+1。\n 3. 然后开始最右边一列的遍历，从top+1行开始，遍历到底部位置，之后应该从列数-1的位置开始下一次遍历，即right-1。然后进行底部一行的遍历，从right-1位置遍历到left位置，遍历完成之后应该从底部行向上移动开始下一次遍历，即bottom-1。\n 4. 最后进行最左边一列的遍历，从bottom-1位置直到top行，这样就完成了第一圈的遍历，然后使初始left+1，到达下一圈，此时其他数个点已经缩至下一圈范围。完成之后即可得到螺旋矩阵元素。\n\n**方法2、**模拟\n\n绘制螺旋轨迹路径，我们发现当路径超出界限或者进入之前访问过的单元格时，会顺时针旋转方向。\n\n假设数组有R 行 C 列，seen[r,c]表示第 r 行第 c 列的单元格之前已经被访问过了。当前所在位置为(r, c)，前进方向是 di。我们希望访问所有R x C 个单元格。\n\n当我们遍历整个矩阵，下一步候选移动位置是(cr, cc)。如果这个候选位置在矩阵范围内并且没有被访问过，那么它将会变成下一步移动的位置；否则，我们将前进方向顺时针旋转之后再计算下一步的移动位置。\n\ndx，dy分别是向右下左上移动时，行和列的变化情况，联合起来看\n\n\n# Java代码\n\nclass Solution {\n    public int[] spiralOrder(int[][] matrix) {\n        if(matrix.length<=0)\n            return new int[0];\n        int rowlen = matrix.length;\n        int collen = matrix[0].length;\n        int[] result = new int[rowlen*collen];\n        int left = 0;\n        int right = collen-1;\n        int top = 0;\n        int bottom = rowlen-1;\n        int total = 0;\n        int x = 0;\n        while(total!=rowlen*collen){\n            for(int i = left;i<=right;i++){\n                result[x] = matrix[top][i];\n                total++;\n                x++;\n            }\n            if(total==rowlen*collen) break;\n            top++;\n            for(int i = top;i<=bottom;i++){\n                result[x] = matrix[i][right];\n                total++;\n                x++;\n            }\n            if(total==rowlen*collen) break;\n            right--;\n            for(int i = right;i>=left;i--){\n                result[x] = matrix[bottom][i];\n                total++;\n                x++;\n            }\n            if(total==rowlen*collen) break;\n            bottom--;\n            for(int i = bottom;i>=top;i--){\n                result[x] = matrix[i][left];\n                total++;\n                x++;\n            }\n            if(total==rowlen*collen) break;\n            left++;\n        }\n        return result;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# Python代码\n\nclass Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        if not matrix:return []\n        x=y=0                                     # 矩阵元素位置初始化\n        res = []                                  # 初始化，存储遍历后的矩阵元素\n        dx = [ 0, 1, 0,-1]                        # 方向：右，下，左，上，x和y连起来看\n        dy = [ 1, 0,-1, 0]                        # 注：与通常平面坐标系 记号 不同\n        di = 0                                    # 初始化方向变量\n        visited = set()                           # 初始化集合，存储已走过的坐标\n        m,n = len(matrix),len(matrix[0])          # 矩阵的行列 \n        for i in range(m*n):                                # \n            res.append(matrix[x][y])                        # 存储遍历矩阵过的元素\n            visited.add((x,y))                              # 存储遍历过的坐标\n            tx,ty = x+dx[di],y+dy[di]                       # 先记录下一步坐标，用于判断下一步怎么走\n            if 0<=tx<m and 0<=ty<n and (tx,ty) not in visited: # 判断坐标是否需变向，且没有遍历过\n                x,y = tx,ty                                       \n            else:                                                \n                di = (di+1)%4                               # 改变方向，右下左上为一圈，防止方向坐标越界\n                x,y = x + dx[di],y+dy[di]                   # 下一步坐标\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n",normalizedContent:"# leetcode-面试题29-顺时针打印矩阵\n\n输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。本题和螺旋矩阵相同\n\n示例1：\n\n输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]\n输出：[1,2,3,6,9,8,7,4,5]\n\n\n1\n2\n\n1\n2\n\n\n示例2：\n\n输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n输出：[1,2,3,4,8,12,11,10,9,5,6,7]\n\n\n1\n2\n\n1\n2\n\n\n限制：\n\n * 0 <= matrix.length <= 100\n * 0 <= matrix[i].length <= 100\n\n\n# 解题思路\n\n**方法1、**圈层\n\n 1. 记录左右和上下两个边界的点，按照上下左右算一圈，下一圈开始的时候初始位置+1，直到数组长度达到元素个数为止。tips：注意几个初始点不参与遍历的变化。\n 2. 首先遍历第一行，记录最左的列位置，初始化left为0，一直遍历到right为矩阵列数为止，遍历完成后此时行数应该+1，即top+1。\n 3. 然后开始最右边一列的遍历，从top+1行开始，遍历到底部位置，之后应该从列数-1的位置开始下一次遍历，即right-1。然后进行底部一行的遍历，从right-1位置遍历到left位置，遍历完成之后应该从底部行向上移动开始下一次遍历，即bottom-1。\n 4. 最后进行最左边一列的遍历，从bottom-1位置直到top行，这样就完成了第一圈的遍历，然后使初始left+1，到达下一圈，此时其他数个点已经缩至下一圈范围。完成之后即可得到螺旋矩阵元素。\n\n**方法2、**模拟\n\n绘制螺旋轨迹路径，我们发现当路径超出界限或者进入之前访问过的单元格时，会顺时针旋转方向。\n\n假设数组有r 行 c 列，seen[r,c]表示第 r 行第 c 列的单元格之前已经被访问过了。当前所在位置为(r, c)，前进方向是 di。我们希望访问所有r x c 个单元格。\n\n当我们遍历整个矩阵，下一步候选移动位置是(cr, cc)。如果这个候选位置在矩阵范围内并且没有被访问过，那么它将会变成下一步移动的位置；否则，我们将前进方向顺时针旋转之后再计算下一步的移动位置。\n\ndx，dy分别是向右下左上移动时，行和列的变化情况，联合起来看\n\n\n# java代码\n\nclass solution {\n    public int[] spiralorder(int[][] matrix) {\n        if(matrix.length<=0)\n            return new int[0];\n        int rowlen = matrix.length;\n        int collen = matrix[0].length;\n        int[] result = new int[rowlen*collen];\n        int left = 0;\n        int right = collen-1;\n        int top = 0;\n        int bottom = rowlen-1;\n        int total = 0;\n        int x = 0;\n        while(total!=rowlen*collen){\n            for(int i = left;i<=right;i++){\n                result[x] = matrix[top][i];\n                total++;\n                x++;\n            }\n            if(total==rowlen*collen) break;\n            top++;\n            for(int i = top;i<=bottom;i++){\n                result[x] = matrix[i][right];\n                total++;\n                x++;\n            }\n            if(total==rowlen*collen) break;\n            right--;\n            for(int i = right;i>=left;i--){\n                result[x] = matrix[bottom][i];\n                total++;\n                x++;\n            }\n            if(total==rowlen*collen) break;\n            bottom--;\n            for(int i = bottom;i>=top;i--){\n                result[x] = matrix[i][left];\n                total++;\n                x++;\n            }\n            if(total==rowlen*collen) break;\n            left++;\n        }\n        return result;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# python代码\n\nclass solution:\n    def spiralorder(self, matrix: list[list[int]]) -> list[int]:\n        if not matrix:return []\n        x=y=0                                     # 矩阵元素位置初始化\n        res = []                                  # 初始化，存储遍历后的矩阵元素\n        dx = [ 0, 1, 0,-1]                        # 方向：右，下，左，上，x和y连起来看\n        dy = [ 1, 0,-1, 0]                        # 注：与通常平面坐标系 记号 不同\n        di = 0                                    # 初始化方向变量\n        visited = set()                           # 初始化集合，存储已走过的坐标\n        m,n = len(matrix),len(matrix[0])          # 矩阵的行列 \n        for i in range(m*n):                                # \n            res.append(matrix[x][y])                        # 存储遍历矩阵过的元素\n            visited.add((x,y))                              # 存储遍历过的坐标\n            tx,ty = x+dx[di],y+dy[di]                       # 先记录下一步坐标，用于判断下一步怎么走\n            if 0<=tx<m and 0<=ty<n and (tx,ty) not in visited: # 判断坐标是否需变向，且没有遍历过\n                x,y = tx,ty                                       \n            else:                                                \n                di = (di+1)%4                               # 改变方向，右下左上为一圈，防止方向坐标越界\n                x,y = x + dx[di],y+dy[di]                   # 下一步坐标\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题31-栈的压入弹出序列",frontmatter:{title:"LeetCode-面试题31-栈的压入弹出序列",date:"2020-04-21T15:50:42.000Z",description:"栈的压入弹出序列",tags:["栈","Python","Java","Medium","剑指Offer"],keywords:"栈,Java,Python,Medium,剑指Offer",permalink:"/pages/baac38/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/26.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9831-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97.html",relativePath:"06.算法/01.剑指Offer/26.LeetCode-面试题31-栈的压入弹出序列.md",key:"v-404f6236",path:"/pages/baac38/",headers:[{level:2,title:"LeetCode-面试题31-栈的压入弹出序列",slug:"leetcode-面试题31-栈的压入弹出序列",normalizedTitle:"leetcode-面试题31-栈的压入弹出序列",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:593},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:782},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:1401}],headersStr:"LeetCode-面试题31-栈的压入弹出序列 解题思路 Java代码 Python代码",content:"# LeetCode-面试题31-栈的压入弹出序列\n\n输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。\n\n示例1：\n\n输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]\n输出：true\n解释：我们可以按以下顺序执行：\npush(1), push(2), push(3), push(4), pop() -> 4,\npush(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n示例2：\n\n输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]\n输出：false\n解释：1 不能在 2 之前弹出。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n限制：\n\n 1. 0 <= pushed.length == popped.length <= 1000\n 2. 0 <= pushed[i], popped[i] < 1000\n 3. pushed 是 popped 的排列。\n\n\n# 解题思路\n\n特殊测试用例：入栈序列为空、出栈序列为空、出入栈值不相等时，返回false\n\n辅助栈：利用一个栈来进行辅助，将入栈元素push入辅助栈，判断辅助栈内的值是否和出栈顺序相同，如果不相同就继续push入栈元素，如果相同则将辅助栈元素弹出，出栈下标加1。当入栈和出栈序列相同时，辅助栈应该为空。当找完了入栈，辅助栈不为空的情况，说明该出栈不是入栈的一个弹出序列。\n\n\n# Java代码\n\nclass Solution {\n    public boolean validateStackSequences(int[] pushed, int[] popped) {\n        if(pushed==null||popped==null||pushed.length!=popped.length)\n            return false;\n        Stack<Integer> stack = new Stack<>();\n        int index = 0;\n        for(Integer i : pushed){\n            stack.push(i);\n            while(!stack.isEmpty()&&index<popped.length&&stack.peek().equals(popped[index])){\n                stack.pop();\n                index++;\n            }\n        }\n        return stack.isEmpty();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# Python代码\n\nclass Solution:\n    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:\n        stack = []\n        j = 0\n        for x in pushed:\n            stack.append(x)\n            while stack and j < len(popped) and stack[-1] == popped[j]:\n                stack.pop()\n                j += 1\n        return not stack\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n",normalizedContent:"# leetcode-面试题31-栈的压入弹出序列\n\n输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。\n\n示例1：\n\n输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]\n输出：true\n解释：我们可以按以下顺序执行：\npush(1), push(2), push(3), push(4), pop() -> 4,\npush(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n示例2：\n\n输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]\n输出：false\n解释：1 不能在 2 之前弹出。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n限制：\n\n 1. 0 <= pushed.length == popped.length <= 1000\n 2. 0 <= pushed[i], popped[i] < 1000\n 3. pushed 是 popped 的排列。\n\n\n# 解题思路\n\n特殊测试用例：入栈序列为空、出栈序列为空、出入栈值不相等时，返回false\n\n辅助栈：利用一个栈来进行辅助，将入栈元素push入辅助栈，判断辅助栈内的值是否和出栈顺序相同，如果不相同就继续push入栈元素，如果相同则将辅助栈元素弹出，出栈下标加1。当入栈和出栈序列相同时，辅助栈应该为空。当找完了入栈，辅助栈不为空的情况，说明该出栈不是入栈的一个弹出序列。\n\n\n# java代码\n\nclass solution {\n    public boolean validatestacksequences(int[] pushed, int[] popped) {\n        if(pushed==null||popped==null||pushed.length!=popped.length)\n            return false;\n        stack<integer> stack = new stack<>();\n        int index = 0;\n        for(integer i : pushed){\n            stack.push(i);\n            while(!stack.isempty()&&index<popped.length&&stack.peek().equals(popped[index])){\n                stack.pop();\n                index++;\n            }\n        }\n        return stack.isempty();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# python代码\n\nclass solution:\n    def validatestacksequences(self, pushed: list[int], popped: list[int]) -> bool:\n        stack = []\n        j = 0\n        for x in pushed:\n            stack.append(x)\n            while stack and j < len(popped) and stack[-1] == popped[j]:\n                stack.pop()\n                j += 1\n        return not stack\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题32-1-从上到下打印二叉树",frontmatter:{title:"LeetCode-面试题32-1-从上到下打印二叉树",date:"2020-04-22T10:47:48.000Z",description:"从上到下打印二叉树",tags:["BFS","树","Python","Java","Medium","剑指Offer"],keywords:"BFS,树,Java,Python,Medium,剑指Offer",permalink:"/pages/f4c63f/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/27.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9832-1-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html",relativePath:"06.算法/01.剑指Offer/27.LeetCode-面试题32-1-从上到下打印二叉树.md",key:"v-04dccd77",path:"/pages/f4c63f/",headers:[{level:2,title:"LeetCode-面试题32-1-从上到下打印二叉树",slug:"leetcode-面试题32-1-从上到下打印二叉树",normalizedTitle:"leetcode-面试题32-1-从上到下打印二叉树",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:173},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:320},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:1221}],headersStr:"LeetCode-面试题32-1-从上到下打印二叉树 解题思路 Java代码 Python代码",content:"# LeetCode-面试题32-1-从上到下打印二叉树\n\n从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。\n\n例如: 给定二叉树: [3,9,20,null,null,15,7],\n\n3 /\n9 20 /\n15 7 返回：\n\n[3,9,20,15,7]\n\n\n1\n\n1\n\n\n提示：\n\n 1. 节点总数 <= 1000\n\n\n# 解题思路\n\nBFS就完事儿了.....\n\n用一个队列Queue保存节点，标准BFS遍历模版如下：\n\n * 将root节点放入queue\n\n * 重复以下2个步骤，直到queue为空为止：\n   \n   取出queue中的头结点\n   \n   找出头结点左右子节点，依次放入queue中\n\n\n# Java代码\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public int[] levelOrder(TreeNode root) {\n        if(root==null) return new int[0];\n        Queue<TreeNode> queue = new LinkedList<>();\n        ArrayList<Integer> alist = new ArrayList<>();\n        queue.add(root);\n        while(!queue.isEmpty()){\n            TreeNode temp = queue.poll();\n            alist.add(temp.val);\n            if(temp.left!=null)\n                queue.add(temp.left);\n            if(temp.right!=null)\n                queue.add(temp.right);\n        }\n        return alist.stream().mapToInt(Integer::intValue).toArray();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# Python代码\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def levelOrder(self, root: TreeNode) -> List[int]:\n        if not root: return []\n        quque = [root]\n        ans = []\n        while quque:\n            node = quque.pop(0)\n            ans.append(node.val)\n            if node.left: quque.append(node.left)\n            if node.right: quque.append(node.right)\n        return ans\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n",normalizedContent:"# leetcode-面试题32-1-从上到下打印二叉树\n\n从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。\n\n例如: 给定二叉树: [3,9,20,null,null,15,7],\n\n3 /\n9 20 /\n15 7 返回：\n\n[3,9,20,15,7]\n\n\n1\n\n1\n\n\n提示：\n\n 1. 节点总数 <= 1000\n\n\n# 解题思路\n\nbfs就完事儿了.....\n\n用一个队列queue保存节点，标准bfs遍历模版如下：\n\n * 将root节点放入queue\n\n * 重复以下2个步骤，直到queue为空为止：\n   \n   取出queue中的头结点\n   \n   找出头结点左右子节点，依次放入queue中\n\n\n# java代码\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public int[] levelorder(treenode root) {\n        if(root==null) return new int[0];\n        queue<treenode> queue = new linkedlist<>();\n        arraylist<integer> alist = new arraylist<>();\n        queue.add(root);\n        while(!queue.isempty()){\n            treenode temp = queue.poll();\n            alist.add(temp.val);\n            if(temp.left!=null)\n                queue.add(temp.left);\n            if(temp.right!=null)\n                queue.add(temp.right);\n        }\n        return alist.stream().maptoint(integer::intvalue).toarray();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# python代码\n\n# definition for a binary tree node.\n# class treenode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = none\n#         self.right = none\n\nclass solution:\n    def levelorder(self, root: treenode) -> list[int]:\n        if not root: return []\n        quque = [root]\n        ans = []\n        while quque:\n            node = quque.pop(0)\n            ans.append(node.val)\n            if node.left: quque.append(node.left)\n            if node.right: quque.append(node.right)\n        return ans\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题32-2-从上到下打印二叉树",frontmatter:{title:"LeetCode-面试题32-2-从上到下打印二叉树",date:"2020-04-22T15:15:30.000Z",description:"从上到下打印二叉树",tags:["BFS","树","Python","Java","Easy","剑指Offer"],keywords:"BFS,树,Java,Python,Easy,剑指Offer",permalink:"/pages/7e90de/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/28.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9832-2-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%20.html",relativePath:"06.算法/01.剑指Offer/28.LeetCode-面试题32-2-从上到下打印二叉树 .md",key:"v-5346a03e",path:"/pages/7e90de/",headers:[{level:2,title:"LeetCode-面试题32-2-从上到下打印二叉树",slug:"leetcode-面试题32-2-从上到下打印二叉树",normalizedTitle:"leetcode-面试题32-2-从上到下打印二叉树",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:217},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:858},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:2198}],headersStr:"LeetCode-面试题32-2-从上到下打印二叉树 解题思路 Java代码 Python代码",content:"# LeetCode-面试题32-2-从上到下打印二叉树\n\n从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。\n\n例如: 给定二叉树: [3,9,20,null,null,15,7],\n\n3 /\n9 20 /\n15 7\n\n返回其层次遍历结果：\n\n[\n  [3],\n  [9,20],\n  [15,7]\n]\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n提示：\n\n 1. 节点总数 <= 1000\n\n\n# 解题思路\n\n方法1：递推\n\n依然是BFS，只是要多2个List去保存结果，还需要2个变量一个记录下一层的节点数目，另一个记录当前层没有打印的节点数目\n\n用一个队列Queue保存节点，标准BFS遍历模版如下：\n\n * 将root节点放入queue，当前待打印节点数-1\n\n * 重复以下2个步骤，直到queue为空为止：\n   \n   取出queue中的头结点，添加进rowList中\n   \n   找出头结点左右子节点，依次放入queue中，下一行节点数目+1\n   \n   当前行待打印节点数==0时，说明这行节点都添加进了rowList中，将rowList添加进result，进入下一行，当前行=下一行节点数，下一行节点数清空，rowList清空，这里不能用list.clear()方法，这个方法会把对应的引用数据清掉，直接new ArrayList()即可\n\n方法2：递归\n\n初始化一个k作为树层数标记，对于大的list而言，每一层都是一个小list，当这个小list没有时，新建这个小list添加进头结点（大list的长度<=k）\n\n如果存在这一层的小list，就在这个小list中继续添加这一层的数据即res[depth].append(node.val)\n\n之后进行头结点左子树和右子树的递归，每一次递归层数+1即\n\n * traversal(node.left, depth + 1)\n * traversal(node.right, depth + 1)·\n\n\n# Java代码\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        if(root==null) return new ArrayList();\n        List<List<Integer>> result = new ArrayList<>();\n        List<Integer> row = new ArrayList<>();\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.add(root);\n        int rownode = 1;\n        int nextrow = 0;\n        while(!queue.isEmpty()){\n            TreeNode temp = queue.poll();\n            row.add(temp.val);\n            if(temp.left!=null){\n                queue.add(temp.left);\n                nextrow++;\n            }\n            if(temp.right!=null){\n                queue.add(temp.right);\n                nextrow++;\n            }\n            rownode--;\n            if(rownode==0){\n                result.add(row);\n                rownode = nextrow;\n                nextrow = 0;\n                row = new ArrayList();\n            }\n        }\n        return result;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# Python代码\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def levelOrder(self, root: TreeNode) -> List[List[int]]:\n        res = []\n        def traversal(node, depth):\n            if not node:\n                return\n            if len(res) <= depth:  # 如果结果集没有对应层数的列表，则先创建并将当前节点值压入\n                temp = []\n                temp.append(node.val)\n                res.append(temp)\n            else:  # 如果有，直接压入对应层数所对应的列表\n                res[depth].append(node.val)\n            traversal(node.left, depth + 1)\n            traversal(node.right, depth + 1)\n        traversal(root, 0)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n",normalizedContent:"# leetcode-面试题32-2-从上到下打印二叉树\n\n从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。\n\n例如: 给定二叉树: [3,9,20,null,null,15,7],\n\n3 /\n9 20 /\n15 7\n\n返回其层次遍历结果：\n\n[\n  [3],\n  [9,20],\n  [15,7]\n]\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n提示：\n\n 1. 节点总数 <= 1000\n\n\n# 解题思路\n\n方法1：递推\n\n依然是bfs，只是要多2个list去保存结果，还需要2个变量一个记录下一层的节点数目，另一个记录当前层没有打印的节点数目\n\n用一个队列queue保存节点，标准bfs遍历模版如下：\n\n * 将root节点放入queue，当前待打印节点数-1\n\n * 重复以下2个步骤，直到queue为空为止：\n   \n   取出queue中的头结点，添加进rowlist中\n   \n   找出头结点左右子节点，依次放入queue中，下一行节点数目+1\n   \n   当前行待打印节点数==0时，说明这行节点都添加进了rowlist中，将rowlist添加进result，进入下一行，当前行=下一行节点数，下一行节点数清空，rowlist清空，这里不能用list.clear()方法，这个方法会把对应的引用数据清掉，直接new arraylist()即可\n\n方法2：递归\n\n初始化一个k作为树层数标记，对于大的list而言，每一层都是一个小list，当这个小list没有时，新建这个小list添加进头结点（大list的长度<=k）\n\n如果存在这一层的小list，就在这个小list中继续添加这一层的数据即res[depth].append(node.val)\n\n之后进行头结点左子树和右子树的递归，每一次递归层数+1即\n\n * traversal(node.left, depth + 1)\n * traversal(node.right, depth + 1)·\n\n\n# java代码\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public list<list<integer>> levelorder(treenode root) {\n        if(root==null) return new arraylist();\n        list<list<integer>> result = new arraylist<>();\n        list<integer> row = new arraylist<>();\n        queue<treenode> queue = new linkedlist<>();\n        queue.add(root);\n        int rownode = 1;\n        int nextrow = 0;\n        while(!queue.isempty()){\n            treenode temp = queue.poll();\n            row.add(temp.val);\n            if(temp.left!=null){\n                queue.add(temp.left);\n                nextrow++;\n            }\n            if(temp.right!=null){\n                queue.add(temp.right);\n                nextrow++;\n            }\n            rownode--;\n            if(rownode==0){\n                result.add(row);\n                rownode = nextrow;\n                nextrow = 0;\n                row = new arraylist();\n            }\n        }\n        return result;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# python代码\n\n# definition for a binary tree node.\n# class treenode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = none\n#         self.right = none\n\nclass solution:\n    def levelorder(self, root: treenode) -> list[list[int]]:\n        res = []\n        def traversal(node, depth):\n            if not node:\n                return\n            if len(res) <= depth:  # 如果结果集没有对应层数的列表，则先创建并将当前节点值压入\n                temp = []\n                temp.append(node.val)\n                res.append(temp)\n            else:  # 如果有，直接压入对应层数所对应的列表\n                res[depth].append(node.val)\n            traversal(node.left, depth + 1)\n            traversal(node.right, depth + 1)\n        traversal(root, 0)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题32-3-从上到下打印二叉树",frontmatter:{title:"LeetCode-面试题32-3-从上到下打印二叉树",date:"2020-04-22T16:08:35.000Z",description:"从上到下打印二叉树",tags:["BFS","树","Java","Medium","剑指Offer"],keywords:"BFS,树,Java,Medium,剑指Offer",permalink:"/pages/a2ebc7/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/29.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9832-3-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html",relativePath:"06.算法/01.剑指Offer/29.LeetCode-面试题32-3-从上到下打印二叉树.md",key:"v-d728c212",path:"/pages/a2ebc7/",headers:[{level:2,title:"LeetCode-面试题32-3-从上到下打印二叉树",slug:"leetcode-面试题32-3-从上到下打印二叉树",normalizedTitle:"leetcode-面试题32-3-从上到下打印二叉树",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:254},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:638}],headersStr:"LeetCode-面试题32-3-从上到下打印二叉树 解题思路 Java代码",content:"# LeetCode-面试题32-3-从上到下打印二叉树\n\n请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。\n\n例如: 给定二叉树: [3,9,20,null,null,15,7],\n\n3 /\n9 20 /\n15 7\n\n返回其层次遍历结果：\n\n[\n  [3],\n  [20,9],\n  [15,7]\n]\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n提示：\n\n 1. 节点总数 <= 1000\n\n\n# 解题思路\n\n递推：奇数行从左到右打印，偶数行从右到左打印\n\n用一个队列Queue保存节点，并利用一个双端队列保存行数据，如下：\n\n * 将root节点放入queue\n\n * 重复以下2个步骤，直到queue为空为止：\n   \n   新建一个双端队列，存储行数据\n   \n   当queue.size()>0时开始循环：\n   \n   取出queue中的头结点，添加进rowList中\n   \n   判断当前行是奇数行还是偶数行，由于数组是从0开始存储的，所以原本的奇数变成了偶数，偶数变成了奇\n   \n   数，对于0行和2行，应该从左到右输出，所以向尾部插入新数据即可；对于1行，应该从右到左输出，所以\n   \n   向头部插入新数据即可倒序\n   \n   找出头结点左右子节点，依次放入queue中\n   \n   添加rowList进入result数组中\n\n\n# Java代码\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        if (root == null) return new ArrayList();\n        List<List<Integer>> result = new ArrayList<>();\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.add(root);\n        while (!queue.isEmpty()) {\n            LinkedList<Integer> rowlist = new LinkedList<>();\n            for (int i = queue.size(); i > 0; i--) {\n                TreeNode temp = queue.poll();\t//取出队列头部\n                if ((result.size()& 0x1) == 0) {// 当前是偶数行(0行2行)，行从0开始\n                    rowlist.addLast(temp.val); //添加数据到list尾部，即从左至右顺序\n                } else // 当前是奇数行(1行)\n                    rowlist.addFirst(temp.val);//添加数据到list头部，即从右至左顺序\n                if (temp.left != null) queue.add(temp.left);\n                if (temp.right != null) queue.add(temp.right);\n            }\n            result.add(rowlist);\n        }\n        return result;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n",normalizedContent:"# leetcode-面试题32-3-从上到下打印二叉树\n\n请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。\n\n例如: 给定二叉树: [3,9,20,null,null,15,7],\n\n3 /\n9 20 /\n15 7\n\n返回其层次遍历结果：\n\n[\n  [3],\n  [20,9],\n  [15,7]\n]\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n提示：\n\n 1. 节点总数 <= 1000\n\n\n# 解题思路\n\n递推：奇数行从左到右打印，偶数行从右到左打印\n\n用一个队列queue保存节点，并利用一个双端队列保存行数据，如下：\n\n * 将root节点放入queue\n\n * 重复以下2个步骤，直到queue为空为止：\n   \n   新建一个双端队列，存储行数据\n   \n   当queue.size()>0时开始循环：\n   \n   取出queue中的头结点，添加进rowlist中\n   \n   判断当前行是奇数行还是偶数行，由于数组是从0开始存储的，所以原本的奇数变成了偶数，偶数变成了奇\n   \n   数，对于0行和2行，应该从左到右输出，所以向尾部插入新数据即可；对于1行，应该从右到左输出，所以\n   \n   向头部插入新数据即可倒序\n   \n   找出头结点左右子节点，依次放入queue中\n   \n   添加rowlist进入result数组中\n\n\n# java代码\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public list<list<integer>> levelorder(treenode root) {\n        if (root == null) return new arraylist();\n        list<list<integer>> result = new arraylist<>();\n        queue<treenode> queue = new linkedlist<>();\n        queue.add(root);\n        while (!queue.isempty()) {\n            linkedlist<integer> rowlist = new linkedlist<>();\n            for (int i = queue.size(); i > 0; i--) {\n                treenode temp = queue.poll();\t//取出队列头部\n                if ((result.size()& 0x1) == 0) {// 当前是偶数行(0行2行)，行从0开始\n                    rowlist.addlast(temp.val); //添加数据到list尾部，即从左至右顺序\n                } else // 当前是奇数行(1行)\n                    rowlist.addfirst(temp.val);//添加数据到list头部，即从右至左顺序\n                if (temp.left != null) queue.add(temp.left);\n                if (temp.right != null) queue.add(temp.right);\n            }\n            result.add(rowlist);\n        }\n        return result;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题35-复杂链表的复制",frontmatter:{title:"LeetCode-面试题35-复杂链表的复制",date:"2020-04-23T21:13:47.000Z",description:"复杂链表的复制",tags:["链表","Java","Python","Medium","剑指Offer"],keywords:"链表,Java,Python,Medium,剑指Offer",permalink:"/pages/9050fc/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/30.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9835-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6.html",relativePath:"06.算法/01.剑指Offer/30.LeetCode-面试题35-复杂链表的复制.md",key:"v-4a0528ed",path:"/pages/9050fc/",headers:[{level:2,title:"LeetCode-面试题35-复杂链表的复制",slug:"leetcode-面试题35-复杂链表的复制",normalizedTitle:"leetcode-面试题35-复杂链表的复制",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:533},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:1177},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:2103}],headersStr:"LeetCode-面试题35-复杂链表的复制 解题思路 Java代码 Python代码",content:"# LeetCode-面试题35-复杂链表的复制\n\n请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。\n\n示例1：\n\n输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\n输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]\n\n\n1\n2\n\n1\n2\n\n\n示例2\n\n输入：head = [[1,1],[2,1]]\n输出：[[1,1],[2,1]]\n\n\n1\n2\n\n1\n2\n\n\n示例3\n\n输入：head = [[3,null],[3,0],[3,null]]\n输出：[[3,null],[3,0],[3,null]]\n\n\n1\n2\n\n1\n2\n\n\n示例4\n\n输入：head = []\n输出：[]\n解释：给定的链表为空（空指针），因此返回 null。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n提示：\n\n * -10000 <= Node.val <= 10000\n * Node.random 为空（null）或指向链表中的节点。\n * 节点数目不超过 1000 。\n\n\n# 解题思路\n\n方法1、哈希表：\n\n需要2次循环，第一次循环建立原始链表Node和复制链表Node的映射关系，具体映射Node——>new(Node.val)，node.val只是为了初始化最开始的数值，新节点的next和random并没有设置\n\n第二次循环建立复制链表关系，复制节点的next就是原本节点next对应的节点，random同理\n\n方法2、分治(剑指解法)：\n\n把复制链表的问题分解为3个子问题，每个问题独立解决\n\n * 步骤1：连接原始链表和复制链表\n   \n   复制链表的next应该是原始链表的next(即pClone.next = pNode.next)，random暂时不设置，原始链表的next此时应该是复制链表的新建的Node(即pNode.next = pClone)，指针应该后移，此时复制链表的next对应着原始链表的next，所以pNode = pClone.next\n\n * 步骤2：设置复制链表random指针的指向\n   \n   首先需要找到原始链表Node的random指向，即node.random，由于两个链表已经合并了的关系，此时复制链表的Node的random指针，应该指向node.random.next，因为现在N->N'，N代表原始链表节点，N'代表复制链表节点\n\n * 步骤3：拆分整个链表为原始链表和复制链表\n   \n   把奇数位置的节点用next连接起来就是原始链表，把偶数位置的节点用next连接起来就是复制链表\n\n\n# Java代码\n\n/*\n// Definition for a Node.\nclass Node {\n    int val;\n    Node next;\n    Node random;\n\n    public Node(int val) {\n        this.val = val;\n        this.next = null;\n        this.random = null;\n    }\n}\n*/\nclass Solution {\n    public Node copyRandomList(Node head) {\n        Map<Node,Node> map = new HashMap<>();\n        if(head==null) return head;\n        Node first = head;\n        while(first!=null){\n            map.put(first,new Node(first.val));\n            first = first.next;\n        }\n        first = head;\n        while(first!=null){\n            map.get(first).next = map.get(first.next);\n            map.get(first).random = map.get(first.random);\n            first = first.next;\n        }\n        return map.get(head);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# Python代码\n\n\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\nclass Solution:\n    def copyRandomList(self, head: 'Node') -> 'Node':\n        self.CloneNodes(head)\n        self.ConnectRandom(head)\n        return self.ReconnectNodes(head)\n    \n    # 复制复杂链表\n    def CloneNodes(self,head):\n        pNode = head\n        while pNode:\n            pClone = Node(pNode.val)\n            pClone.next = pNode.next\n            pClone.random = None\n            pNode.next = pClone\n            pNode = pClone.next\n    \n    # 复制链表random部分\n    def ConnectRandom(self,head):\n        pNode = head\n        while pNode:\n            pClone = pNode.next\n            if pNode.random:\n                pClone.random = pNode.random.next\n            pNode = pClone.next\n    \n    # 将复杂链表拆分成两个链表\n    def ReconnectNodes(self,head):\n        pNode = head\n        pCloneHead = None\n        pCloneNode = None\n        if pNode:\n            pCloneNode = pNode.next\n            pCloneHead = pCloneNode\n            pNode.next = pCloneNode.next\n            pNode = pNode.next\n        while pNode:\n            pCloneNode.next = pNode.next\n            pCloneNode = pCloneNode.next\n            pNode.next = pCloneNode.next\n            pNode = pNode.next\n        return pCloneHead\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n",normalizedContent:"# leetcode-面试题35-复杂链表的复制\n\n请实现 copyrandomlist 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。\n\n示例1：\n\n输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\n输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]\n\n\n1\n2\n\n1\n2\n\n\n示例2\n\n输入：head = [[1,1],[2,1]]\n输出：[[1,1],[2,1]]\n\n\n1\n2\n\n1\n2\n\n\n示例3\n\n输入：head = [[3,null],[3,0],[3,null]]\n输出：[[3,null],[3,0],[3,null]]\n\n\n1\n2\n\n1\n2\n\n\n示例4\n\n输入：head = []\n输出：[]\n解释：给定的链表为空（空指针），因此返回 null。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n提示：\n\n * -10000 <= node.val <= 10000\n * node.random 为空（null）或指向链表中的节点。\n * 节点数目不超过 1000 。\n\n\n# 解题思路\n\n方法1、哈希表：\n\n需要2次循环，第一次循环建立原始链表node和复制链表node的映射关系，具体映射node——>new(node.val)，node.val只是为了初始化最开始的数值，新节点的next和random并没有设置\n\n第二次循环建立复制链表关系，复制节点的next就是原本节点next对应的节点，random同理\n\n方法2、分治(剑指解法)：\n\n把复制链表的问题分解为3个子问题，每个问题独立解决\n\n * 步骤1：连接原始链表和复制链表\n   \n   复制链表的next应该是原始链表的next(即pclone.next = pnode.next)，random暂时不设置，原始链表的next此时应该是复制链表的新建的node(即pnode.next = pclone)，指针应该后移，此时复制链表的next对应着原始链表的next，所以pnode = pclone.next\n\n * 步骤2：设置复制链表random指针的指向\n   \n   首先需要找到原始链表node的random指向，即node.random，由于两个链表已经合并了的关系，此时复制链表的node的random指针，应该指向node.random.next，因为现在n->n'，n代表原始链表节点，n'代表复制链表节点\n\n * 步骤3：拆分整个链表为原始链表和复制链表\n   \n   把奇数位置的节点用next连接起来就是原始链表，把偶数位置的节点用next连接起来就是复制链表\n\n\n# java代码\n\n/*\n// definition for a node.\nclass node {\n    int val;\n    node next;\n    node random;\n\n    public node(int val) {\n        this.val = val;\n        this.next = null;\n        this.random = null;\n    }\n}\n*/\nclass solution {\n    public node copyrandomlist(node head) {\n        map<node,node> map = new hashmap<>();\n        if(head==null) return head;\n        node first = head;\n        while(first!=null){\n            map.put(first,new node(first.val));\n            first = first.next;\n        }\n        first = head;\n        while(first!=null){\n            map.get(first).next = map.get(first.next);\n            map.get(first).random = map.get(first.random);\n            first = first.next;\n        }\n        return map.get(head);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# python代码\n\n\"\"\"\n# definition for a node.\nclass node:\n    def __init__(self, x: int, next: 'node' = none, random: 'node' = none):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\nclass solution:\n    def copyrandomlist(self, head: 'node') -> 'node':\n        self.clonenodes(head)\n        self.connectrandom(head)\n        return self.reconnectnodes(head)\n    \n    # 复制复杂链表\n    def clonenodes(self,head):\n        pnode = head\n        while pnode:\n            pclone = node(pnode.val)\n            pclone.next = pnode.next\n            pclone.random = none\n            pnode.next = pclone\n            pnode = pclone.next\n    \n    # 复制链表random部分\n    def connectrandom(self,head):\n        pnode = head\n        while pnode:\n            pclone = pnode.next\n            if pnode.random:\n                pclone.random = pnode.random.next\n            pnode = pclone.next\n    \n    # 将复杂链表拆分成两个链表\n    def reconnectnodes(self,head):\n        pnode = head\n        pclonehead = none\n        pclonenode = none\n        if pnode:\n            pclonenode = pnode.next\n            pclonehead = pclonenode\n            pnode.next = pclonenode.next\n            pnode = pnode.next\n        while pnode:\n            pclonenode.next = pnode.next\n            pclonenode = pclonenode.next\n            pnode.next = pclonenode.next\n            pnode = pnode.next\n        return pclonehead\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题36-二叉搜索树与双向链表",frontmatter:{title:"LeetCode-面试题36-二叉搜索树与双向链表",date:"2020-04-24T21:29:26.000Z",description:"二叉搜索树与双向链表",tags:["树","DFS","Java","Medium","剑指Offer"],keywords:"树,DFS,Java,Medium,剑指Offer",permalink:"/pages/e44b62/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/31.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9836-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.html",relativePath:"06.算法/01.剑指Offer/31.LeetCode-面试题36-二叉搜索树与双向链表.md",key:"v-de3dd5ac",path:"/pages/e44b62/",headers:[{level:2,title:"LeetCode-面试题36-二叉搜索树与双向链表",slug:"leetcode-面试题36-二叉搜索树与双向链表",normalizedTitle:"leetcode-面试题36-二叉搜索树与双向链表",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:330},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:755}],headersStr:"LeetCode-面试题36-二叉搜索树与双向链表 解题思路 Java代码",content:"# LeetCode-面试题36-二叉搜索树与双向链表\n\n输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。\n\n为了让您更好地理解问题，以下面的二叉搜索树为例：\n\n\n\n我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。\n\n下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。\n\n\n\n特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。\n\n\n# 解题思路\n\nDFS+修改指针：\n\n不难发现双向链表的序列是中序遍历的结果，只是在遍历的同时需要调整指针的指向\n\n特例处理：root==null，则返回\n\n初始化：记录前面一个节点的指针pre\n\n递归中序遍历：\n\n终止条件是当节点cur为空的时候，代表越过叶子节点，直接return\n\n之后开启左子树递归DFS(cur.left)\n\n构建链表：\n\n * 当前面一个节点pre为空时，代表正在访问链表头结点，head = cur\n * 当前面一个节点pre不为空时，修改双向节点引用，pre.right = cur，cur.left = pre\n * 保存cur：更新pre = cur，节点cur是pre的后继节点\n * 递归右子树，DFS(cur.right)\n\n完成递归之后，需要连接头尾节点，此时head指向头结点，pre指向尾节点\n\n修改head.left = pre ，pre.right = head\n\n之后返回头结点head即可\n\n\n# Java代码\n\n/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public Node left;\n    public Node right;\n\n    public Node() {}\n\n    public Node(int _val) {\n        val = _val;\n    }\n\n    public Node(int _val,Node _left,Node _right) {\n        val = _val;\n        left = _left;\n        right = _right;\n    }\n};\n*/\nclass Solution {\n    Node pre = null;\n    Node head = null;\n    public Node treeToDoublyList(Node root) {\n        if(root==null) return root;\n        DFS(root);\n        head.left = pre;\n        pre.right = head;\n        return head;\n    }\n\n    public void DFS(Node cur){\n        if(cur==null) return;\n        DFS(cur.left);\n        if(pre!=null)\n            pre.right = cur;\n        else\n            head = cur;\n        cur.left = pre;\n        pre = cur;\n        DFS(cur.right);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n",normalizedContent:"# leetcode-面试题36-二叉搜索树与双向链表\n\n输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。\n\n为了让您更好地理解问题，以下面的二叉搜索树为例：\n\n\n\n我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。\n\n下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。\n\n\n\n特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。\n\n\n# 解题思路\n\ndfs+修改指针：\n\n不难发现双向链表的序列是中序遍历的结果，只是在遍历的同时需要调整指针的指向\n\n特例处理：root==null，则返回\n\n初始化：记录前面一个节点的指针pre\n\n递归中序遍历：\n\n终止条件是当节点cur为空的时候，代表越过叶子节点，直接return\n\n之后开启左子树递归dfs(cur.left)\n\n构建链表：\n\n * 当前面一个节点pre为空时，代表正在访问链表头结点，head = cur\n * 当前面一个节点pre不为空时，修改双向节点引用，pre.right = cur，cur.left = pre\n * 保存cur：更新pre = cur，节点cur是pre的后继节点\n * 递归右子树，dfs(cur.right)\n\n完成递归之后，需要连接头尾节点，此时head指向头结点，pre指向尾节点\n\n修改head.left = pre ，pre.right = head\n\n之后返回头结点head即可\n\n\n# java代码\n\n/*\n// definition for a node.\nclass node {\n    public int val;\n    public node left;\n    public node right;\n\n    public node() {}\n\n    public node(int _val) {\n        val = _val;\n    }\n\n    public node(int _val,node _left,node _right) {\n        val = _val;\n        left = _left;\n        right = _right;\n    }\n};\n*/\nclass solution {\n    node pre = null;\n    node head = null;\n    public node treetodoublylist(node root) {\n        if(root==null) return root;\n        dfs(root);\n        head.left = pre;\n        pre.right = head;\n        return head;\n    }\n\n    public void dfs(node cur){\n        if(cur==null) return;\n        dfs(cur.left);\n        if(pre!=null)\n            pre.right = cur;\n        else\n            head = cur;\n        cur.left = pre;\n        pre = cur;\n        dfs(cur.right);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题37-序列化二叉树",frontmatter:{title:"LeetCode-面试题37-序列化二叉树",date:"2020-04-26T17:30:44.000Z",description:"序列化二叉树",tags:["树","Python","Java","Hard","剑指Offer"],keywords:"树,Python,Java,Hard,剑指Offer",permalink:"/pages/1643b9/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/32.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9837-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91.html",relativePath:"06.算法/01.剑指Offer/32.LeetCode-面试题37-序列化二叉树.md",key:"v-37ddeda4",path:"/pages/1643b9/",headers:[{level:2,title:"LeetCode-面试题37-序列化二叉树",slug:"leetcode-面试题37-序列化二叉树",normalizedTitle:"leetcode-面试题37-序列化二叉树",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:182},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:927},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:3147}],headersStr:"LeetCode-面试题37-序列化二叉树 解题思路 Java代码 Python代码",content:'# LeetCode-面试题37-序列化二叉树\n\n请实现两个函数，分别用来序列化和反序列化二叉树。\n\n示例：\n\n你可以将以下二叉树：\n\n    1\n   / \\\n  2   3\n     / \\\n    4   5\n\n序列化为 "[1,2,3,null,null,4,5]"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 解题思路\n\nBFS+位置指针(队列、递归2种解法)：\n\n队列：\n\n * 序列化的过程是一个典型的BFS层序遍历，由于返回的要求是String类型，所以在遍历的同时加上字符串拼接即可\n * 反序列化的过程，利用一个队列按层构建二叉树，并使用index指针记录节点temp的左子节点和右子节点。每构建一个节点，index就向右移动1位，只有当节点不为空时，左右节点的构建才有效。为空时index++会跳过值为null的节点\n\n递归：\n\n注意：递归序列化出来的序列和队列方式结果不同，递归返回的列表数据更像DFS遍历的结果，虽然两者序列化和反序列化的方式不同，但不影响构建结果。即怎么序列化，就怎么反序列化\n\n初始化：res列表，index指针\n\n序列化递归：\n\n * 判断头节点是否为空，为空则直接返回空列表\n\n * 否则开始序列化递归，序列化递归过程如下：\n   \n   **终止条件：**当遍历到左/右子节点为空时，res添加null字符，返回\n   \n   **递推：**res添加root节点值，开启左子树遍历self.serhelper(root.left)，之后开启右子树遍历self.serhelper(root.right)\n\n反序列化递归：\n\n * 判断头节点是否为空，为空则直接返回空列表\n\n * 否则开始反序列化递归，过程如下：\n   \n   **终止条件：**index位置为null，说明此位置是空节点，index后移一位，返回None\n   \n   **递推：**新建Node，index指针后移指向左节点，开启左右子树递归node.left = self.deshelper(data)和node.right = self.deshelper(data)\n\n\n# Java代码\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Codec {\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        if(root==null) return "[]";\n        StringBuilder res = new StringBuilder("[");\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.add(root);\n        while(!queue.isEmpty()){\n            TreeNode temp = queue.poll();\n            if(temp!=null){\n                res.append(temp.val+",");\n                queue.add(temp.left);\n                queue.add(temp.right);\n            }\n            else\n                res.append("null,");\n        }\n        res.deleteCharAt(res.length()-1);\n        res.append("]");\n        return res.toString();\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        if(data.equals("[]")) return null;\n        String[] origin = data.substring(1,data.length()-1).split(",");\n        TreeNode root = new TreeNode(Integer.parseInt(origin[0]));\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.add(root);\n        int index = 1;\n        while(!queue.isEmpty()){\n            TreeNode temp = queue.poll();\n            if(!origin[index].equals("null")){\n                temp.left = new TreeNode(Integer.parseInt(origin[index]));\n                queue.add(temp.left);\n            }\n            index++;\n            if(!origin[index].equals("null")){\n                temp.right = new TreeNode(Integer.parseInt(origin[index]));\n                queue.add(temp.right);\n            }\n            index++;\n        }\n        return root;\n    }\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec codec = new Codec();\n// codec.deserialize(codec.serialize(root));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n\n\n\n# Python代码\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Codec:\n    def __init__(self):\n        self.res = []\n        self.index = 0\n\n    def serialize(self, root):\n        """Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        """\n        if not root: return []\n        self.serhelper(root)\n        return self.res\n        \n    def serhelper(self,root):\n        if not root:\n            self.res.append("null")\n            return\n        self.res.append(root.val)\n        self.serhelper(root.left)\n        self.serhelper(root.right)\n\n    def deserialize(self, data):\n        """Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        """\n        if not data: return []\n        return self.deshelper(data)\n    \n    def deshelper(self,data):\n        if data[self.index] == "null":\n            self.index+=1\n            return None\n        node = TreeNode(data[self.index])\n        self.index+=1\n        node.left = self.deshelper(data)\n        node.right = self.deshelper(data)\n        return node\n        \n\n# Your Codec object will be instantiated and called as such:\n# codec = Codec()\n# codec.deserialize(codec.serialize(root))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n',normalizedContent:'# leetcode-面试题37-序列化二叉树\n\n请实现两个函数，分别用来序列化和反序列化二叉树。\n\n示例：\n\n你可以将以下二叉树：\n\n    1\n   / \\\n  2   3\n     / \\\n    4   5\n\n序列化为 "[1,2,3,null,null,4,5]"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 解题思路\n\nbfs+位置指针(队列、递归2种解法)：\n\n队列：\n\n * 序列化的过程是一个典型的bfs层序遍历，由于返回的要求是string类型，所以在遍历的同时加上字符串拼接即可\n * 反序列化的过程，利用一个队列按层构建二叉树，并使用index指针记录节点temp的左子节点和右子节点。每构建一个节点，index就向右移动1位，只有当节点不为空时，左右节点的构建才有效。为空时index++会跳过值为null的节点\n\n递归：\n\n注意：递归序列化出来的序列和队列方式结果不同，递归返回的列表数据更像dfs遍历的结果，虽然两者序列化和反序列化的方式不同，但不影响构建结果。即怎么序列化，就怎么反序列化\n\n初始化：res列表，index指针\n\n序列化递归：\n\n * 判断头节点是否为空，为空则直接返回空列表\n\n * 否则开始序列化递归，序列化递归过程如下：\n   \n   **终止条件：**当遍历到左/右子节点为空时，res添加null字符，返回\n   \n   **递推：**res添加root节点值，开启左子树遍历self.serhelper(root.left)，之后开启右子树遍历self.serhelper(root.right)\n\n反序列化递归：\n\n * 判断头节点是否为空，为空则直接返回空列表\n\n * 否则开始反序列化递归，过程如下：\n   \n   **终止条件：**index位置为null，说明此位置是空节点，index后移一位，返回none\n   \n   **递推：**新建node，index指针后移指向左节点，开启左右子树递归node.left = self.deshelper(data)和node.right = self.deshelper(data)\n\n\n# java代码\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\npublic class codec {\n    // encodes a tree to a single string.\n    public string serialize(treenode root) {\n        if(root==null) return "[]";\n        stringbuilder res = new stringbuilder("[");\n        queue<treenode> queue = new linkedlist<>();\n        queue.add(root);\n        while(!queue.isempty()){\n            treenode temp = queue.poll();\n            if(temp!=null){\n                res.append(temp.val+",");\n                queue.add(temp.left);\n                queue.add(temp.right);\n            }\n            else\n                res.append("null,");\n        }\n        res.deletecharat(res.length()-1);\n        res.append("]");\n        return res.tostring();\n    }\n\n    // decodes your encoded data to tree.\n    public treenode deserialize(string data) {\n        if(data.equals("[]")) return null;\n        string[] origin = data.substring(1,data.length()-1).split(",");\n        treenode root = new treenode(integer.parseint(origin[0]));\n        queue<treenode> queue = new linkedlist<>();\n        queue.add(root);\n        int index = 1;\n        while(!queue.isempty()){\n            treenode temp = queue.poll();\n            if(!origin[index].equals("null")){\n                temp.left = new treenode(integer.parseint(origin[index]));\n                queue.add(temp.left);\n            }\n            index++;\n            if(!origin[index].equals("null")){\n                temp.right = new treenode(integer.parseint(origin[index]));\n                queue.add(temp.right);\n            }\n            index++;\n        }\n        return root;\n    }\n}\n\n// your codec object will be instantiated and called as such:\n// codec codec = new codec();\n// codec.deserialize(codec.serialize(root));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n\n\n\n# python代码\n\n# definition for a binary tree node.\n# class treenode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = none\n#         self.right = none\n\nclass codec:\n    def __init__(self):\n        self.res = []\n        self.index = 0\n\n    def serialize(self, root):\n        """encodes a tree to a single string.\n        \n        :type root: treenode\n        :rtype: str\n        """\n        if not root: return []\n        self.serhelper(root)\n        return self.res\n        \n    def serhelper(self,root):\n        if not root:\n            self.res.append("null")\n            return\n        self.res.append(root.val)\n        self.serhelper(root.left)\n        self.serhelper(root.right)\n\n    def deserialize(self, data):\n        """decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: treenode\n        """\n        if not data: return []\n        return self.deshelper(data)\n    \n    def deshelper(self,data):\n        if data[self.index] == "null":\n            self.index+=1\n            return none\n        node = treenode(data[self.index])\n        self.index+=1\n        node.left = self.deshelper(data)\n        node.right = self.deshelper(data)\n        return node\n        \n\n# your codec object will be instantiated and called as such:\n# codec = codec()\n# codec.deserialize(codec.serialize(root))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题38-字符串的排列",frontmatter:{title:"LeetCode-面试题38-字符串的排列",date:"2020-04-27T18:01:14.000Z",description:"字符串的排列",tags:["字符串","全排列","DFS","回溯","Python","Java","Medium","剑指Offer"],keywords:"字符串,全排列,DFS,回溯,Python,Java,Medium,剑指Offer",permalink:"/pages/01dd29/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/33.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9838-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97.html",relativePath:"06.算法/01.剑指Offer/33.LeetCode-面试题38-字符串的排列.md",key:"v-3ea3c6ca",path:"/pages/01dd29/",headers:[{level:2,title:"LeetCode-面试题38-字符串的排列",slug:"leetcode-面试题38-字符串的排列",normalizedTitle:"leetcode-面试题38-字符串的排列",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:179},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:450},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:1590},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:2696}],headersStr:"LeetCode-面试题38-字符串的排列 解题思路 Java代码 Python代码 Java代码2",content:'# LeetCode-面试题38-字符串的排列\n\n输入一个字符串，打印出该字符串中字符的所有排列。\n\n你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。\n\n示例：\n\n输入：s = "abc"\n输出：["abc","acb","bac","bca","cab","cba"]\n\n\n1\n2\n\n1\n2\n\n\n限制：\n\n1 <= s 的长度 <= 8\n\n\n# 解题思路\n\n方法1：DFS全排列+剪枝\n\n基本原理通过字符交换的方式，先固定第1位，再固定第2位，一直到固定第n位。\n\n比如固定a，找剩下bc的可能排列，再固定b，找剩下c的可能排列。\n\n之后固定b，找ac的可能排列....直到所有的组合都被找到\n\n特例处理：当初始的字符串有重复的字符时，如aab，需要保证字符只在此为固定一次，即遇到重复的字符时不进行交换直接跳过，即剪枝\n\n方法2：DFS+回溯\n\n全排列问题详解见该文\n\n路径从空开始构建，当DFS深度达到了字符串长度时则添加进去，之后开始回溯，将访问过的状态复原，path弹出\n\n\n# Java代码\n\nclass Solution {\n    List<String> res = new LinkedList<>();\n    public String[] permutation(String s) {\n        if(s==null||s.length()==0) return new String[0];\n        char[] c = s.toCharArray(); \n        StringHelper(c,0);\n        return res.toArray(new String[res.size()]);\n    }\n\n    public void StringHelper(char[] c,int start){\n        if(start==c.length-1){\n            res.add(String.valueOf(c)); // 添加排列\n            return;\n        }\n        HashSet<Character> set = new HashSet<>();\n        for(int i=start;i<c.length;i++){\n            if(set.contains(c[i])) continue; // 剪枝重复的\n            set.add(c[i]);\n            // 交换，将c[i]固定在start位置，比如abc，此时固定a\n            char temp = c[i];\n            c[i] = c[start];\n            c[start] = temp;\n            // 递归start+1位置，比如abc，此时进入bc的固定再交换，递归\n            StringHelper(c,start+1);\n            // 恢复交换\n            temp = c[i];\n            c[i] = c[start];\n            c[start] = temp;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# Python代码\n\nclass Solution:\n    def permutation(self, s: str) -> List[str]:\n        def dfs(s, size, depth, visited, path, res):\n            if depth == size: # 路径达到长度了，进行添加\n                res.append("".join(path[:]))\n                return\n\n            for i in range(size):\n                if not visited[i]:\n                    # 如果当前节点和前一个节点相同，且他的前一个节点已经被遍历，则跳过\n                    if i>0 and s[i]==s[i-1] and not visited[i-1]:continue\n                    visited[i] = True # 访问过了\n                    path.append(s[i]) # 添加进路径\n                    dfs(s, size, depth + 1, visited, path, res) # 开启DFS\n                    visited[i] = False # 回溯，状态还原\n                    path.pop() # 路径还原\n                \n        s = list(sorted(s)) # 考虑重复问题，先进行排序\n        size = len(s)\n        if size == 0:\n            return []\n        res = []\n        path = []\n        visited = [False for _ in range(size)]\n        dfs(s, size, 0, visited, path, res)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# Java代码2\n\nclass Solution {\n    public String[] permutation(String s) {\n        int len = s.length();\n        Set<String> result = new HashSet<>();\n        boolean[] visited = new boolean[len];\n        char[] charStr = s.toCharArray();\n        dfs("",charStr,result,len,visited);\n        return result.toArray(new String[0]);\n    }\n\n    public void dfs(String s,char[] charStr,Set<String> result,int len,boolean[] visited){\n        if(s.length()==len){\n            result.add(s);\n            return;\n        }\n        for(int i =0;i<len;i++){\n            if(visited[i]){\n                continue;\n            }\n            if(i>0&&charStr[i]==charStr[i-1]&&!visited[i-1]){\n                continue;\n            }\n            visited[i] = true;\n            dfs(s+String.valueOf(charStr[i]),charStr,result,len,visited);\n            visited[i] = false;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n',normalizedContent:'# leetcode-面试题38-字符串的排列\n\n输入一个字符串，打印出该字符串中字符的所有排列。\n\n你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。\n\n示例：\n\n输入：s = "abc"\n输出：["abc","acb","bac","bca","cab","cba"]\n\n\n1\n2\n\n1\n2\n\n\n限制：\n\n1 <= s 的长度 <= 8\n\n\n# 解题思路\n\n方法1：dfs全排列+剪枝\n\n基本原理通过字符交换的方式，先固定第1位，再固定第2位，一直到固定第n位。\n\n比如固定a，找剩下bc的可能排列，再固定b，找剩下c的可能排列。\n\n之后固定b，找ac的可能排列....直到所有的组合都被找到\n\n特例处理：当初始的字符串有重复的字符时，如aab，需要保证字符只在此为固定一次，即遇到重复的字符时不进行交换直接跳过，即剪枝\n\n方法2：dfs+回溯\n\n全排列问题详解见该文\n\n路径从空开始构建，当dfs深度达到了字符串长度时则添加进去，之后开始回溯，将访问过的状态复原，path弹出\n\n\n# java代码\n\nclass solution {\n    list<string> res = new linkedlist<>();\n    public string[] permutation(string s) {\n        if(s==null||s.length()==0) return new string[0];\n        char[] c = s.tochararray(); \n        stringhelper(c,0);\n        return res.toarray(new string[res.size()]);\n    }\n\n    public void stringhelper(char[] c,int start){\n        if(start==c.length-1){\n            res.add(string.valueof(c)); // 添加排列\n            return;\n        }\n        hashset<character> set = new hashset<>();\n        for(int i=start;i<c.length;i++){\n            if(set.contains(c[i])) continue; // 剪枝重复的\n            set.add(c[i]);\n            // 交换，将c[i]固定在start位置，比如abc，此时固定a\n            char temp = c[i];\n            c[i] = c[start];\n            c[start] = temp;\n            // 递归start+1位置，比如abc，此时进入bc的固定再交换，递归\n            stringhelper(c,start+1);\n            // 恢复交换\n            temp = c[i];\n            c[i] = c[start];\n            c[start] = temp;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# python代码\n\nclass solution:\n    def permutation(self, s: str) -> list[str]:\n        def dfs(s, size, depth, visited, path, res):\n            if depth == size: # 路径达到长度了，进行添加\n                res.append("".join(path[:]))\n                return\n\n            for i in range(size):\n                if not visited[i]:\n                    # 如果当前节点和前一个节点相同，且他的前一个节点已经被遍历，则跳过\n                    if i>0 and s[i]==s[i-1] and not visited[i-1]:continue\n                    visited[i] = true # 访问过了\n                    path.append(s[i]) # 添加进路径\n                    dfs(s, size, depth + 1, visited, path, res) # 开启dfs\n                    visited[i] = false # 回溯，状态还原\n                    path.pop() # 路径还原\n                \n        s = list(sorted(s)) # 考虑重复问题，先进行排序\n        size = len(s)\n        if size == 0:\n            return []\n        res = []\n        path = []\n        visited = [false for _ in range(size)]\n        dfs(s, size, 0, visited, path, res)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# java代码2\n\nclass solution {\n    public string[] permutation(string s) {\n        int len = s.length();\n        set<string> result = new hashset<>();\n        boolean[] visited = new boolean[len];\n        char[] charstr = s.tochararray();\n        dfs("",charstr,result,len,visited);\n        return result.toarray(new string[0]);\n    }\n\n    public void dfs(string s,char[] charstr,set<string> result,int len,boolean[] visited){\n        if(s.length()==len){\n            result.add(s);\n            return;\n        }\n        for(int i =0;i<len;i++){\n            if(visited[i]){\n                continue;\n            }\n            if(i>0&&charstr[i]==charstr[i-1]&&!visited[i-1]){\n                continue;\n            }\n            visited[i] = true;\n            dfs(s+string.valueof(charstr[i]),charstr,result,len,visited);\n            visited[i] = false;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题39-数组中出现次数超过一半的数字",frontmatter:{title:"LeetCode-面试题39-数组中出现次数超过一半的数字",date:"2020-04-29T20:14:13.000Z",description:"数组中出现次数超过一半的数字",tags:["数组","Python","Java","Easy","剑指Offer"],keywords:"数组,Python,Java,Easy,剑指Offer",permalink:"/pages/c61856/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/34.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9839-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97.html",relativePath:"06.算法/01.剑指Offer/34.LeetCode-面试题39-数组中出现次数超过一半的数字.md",key:"v-6f1c1816",path:"/pages/c61856/",headers:[{level:2,title:"LeetCode-面试题39-数组中出现次数超过一半的数字",slug:"leetcode-面试题39-数组中出现次数超过一半的数字",normalizedTitle:"leetcode-面试题39-数组中出现次数超过一半的数字",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:180},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:316},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:890}],headersStr:"LeetCode-面试题39-数组中出现次数超过一半的数字 解题思路 Java代码 Python代码",content:"# LeetCode-面试题39-数组中出现次数超过一半的数字\n\n数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。\n\n你可以假设数组是非空的，并且给定的数组总是存在多数元素。\n\n示例：\n\n输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]\n输出: 2\n\n\n1\n2\n\n1\n2\n\n\n限制：\n\n1 <= 数组长度 <= 50000\n\n\n# 解题思路\n\n方法1、投票法：\n\n把众数的票数记为+1，非众数票数记为-1，如果众数出现的次数超过数组长度的一般，则一定会有所有的数字的票数和>0\n\n方法2、哈希Map\n\n空间换时间，没有出现在map中的数添加进去，出现过了则次数+1，之后获取次数最大的key即可\n\n\n# Java代码\n\nclass Solution {\n    public int majorityElement(int[] nums) {\n        if(nums==null||nums.length==0)\n            return 0;\n        int result = nums[0];\n        int times = 1;\n        for(int i=1;i<nums.length;i++){\n            if(times==0){\n                result = nums[i];\n                times = 1;\n            }\n            else if(nums[i]==result)\n                times++;\n            else\n                times--;\n        }\n        return result;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# Python代码\n\nclass Solution:\n    def majorityElement(self, nums: List[int]) -> int:\n        if not nums: return 0\n        numsMap = {}\n        for i in nums:\n            if i not in numsMap:\n                numsMap[i]=1\n            else:\n                numsMap[i]+=1\n        return max(numsMap,key=numsMap.get)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n",normalizedContent:"# leetcode-面试题39-数组中出现次数超过一半的数字\n\n数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。\n\n你可以假设数组是非空的，并且给定的数组总是存在多数元素。\n\n示例：\n\n输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]\n输出: 2\n\n\n1\n2\n\n1\n2\n\n\n限制：\n\n1 <= 数组长度 <= 50000\n\n\n# 解题思路\n\n方法1、投票法：\n\n把众数的票数记为+1，非众数票数记为-1，如果众数出现的次数超过数组长度的一般，则一定会有所有的数字的票数和>0\n\n方法2、哈希map\n\n空间换时间，没有出现在map中的数添加进去，出现过了则次数+1，之后获取次数最大的key即可\n\n\n# java代码\n\nclass solution {\n    public int majorityelement(int[] nums) {\n        if(nums==null||nums.length==0)\n            return 0;\n        int result = nums[0];\n        int times = 1;\n        for(int i=1;i<nums.length;i++){\n            if(times==0){\n                result = nums[i];\n                times = 1;\n            }\n            else if(nums[i]==result)\n                times++;\n            else\n                times--;\n        }\n        return result;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# python代码\n\nclass solution:\n    def majorityelement(self, nums: list[int]) -> int:\n        if not nums: return 0\n        numsmap = {}\n        for i in nums:\n            if i not in numsmap:\n                numsmap[i]=1\n            else:\n                numsmap[i]+=1\n        return max(numsmap,key=numsmap.get)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题40-最小的k个数",frontmatter:{title:"LeetCode-面试题40-最小的k个数",date:"2020-05-04T17:38:24.000Z",description:"最小的k个数",tags:["数组","Python","Java","Medium","剑指Offer"],keywords:"数组,Python,Java,Medium,剑指Offer",permalink:"/pages/504abd/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/35.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9840-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0.html",relativePath:"06.算法/01.剑指Offer/35.LeetCode-面试题40-最小的k个数.md",key:"v-0544891e",path:"/pages/504abd/",headers:[{level:2,title:"LeetCode-面试题40-最小的k个数",slug:"leetcode-面试题40-最小的k个数",normalizedTitle:"leetcode-面试题40-最小的k个数",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:274},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:550},{level:3,title:"Java代码",slug:"java代码-2",normalizedTitle:"java代码",charIndex:550}],headersStr:"LeetCode-面试题40-最小的k个数 解题思路 Java代码 Java代码",content:"# LeetCode-面试题40-最小的k个数\n\n输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。\n\n示例1：\n\n输入：arr = [3,2,1], k = 2\n输出：[1,2] 或者 [2,1]\n\n\n1\n2\n\n1\n2\n\n\n示例2：\n\n输入：arr = [0,1,2,1], k = 1\n输出：[0]\n\n\n1\n2\n\n1\n2\n\n\n限制：\n\n * 0 <= k <= arr.length <= 10000\n * 0 <= arr[i] <= 10000\n\n\n# 解题思路\n\n方法1、快排+选择：\n\n基于之前快速排序的代码实现，现在加了几个条件，如下：\n\n每快排切分1次，找到切分点，比较切分点和k的关系\n\n * 如果相等则意味着，切分点左边的数字已经是最小数组集合，直接返回\n * 如果k小于m说明需要在左子数组进行搜索\n * 如果k大于m说明需要在右子数组进行搜索\n\n方法2、最大堆：\n\n使用Java的优先级队列PriorityQueue，实现最大堆\n\n当队列不足k个的时候，传入一个元素\n\n当队列大于k个的时候，判断下一个元素是否小于堆顶，如果小于就把堆顶弹出，把下一个元素传入\n\n之后返回对应的数组\n\n\n# Java代码\n\nclass Solution {\n    public int[] getLeastNumbers(int[] arr, int k) {\n        if(k==0)\n            return new int[0];\n        else if(arr.length<=k)\n            return arr;\n        quickSort(arr,0,arr.length-1,k);\n        int[] res = new int[k];\n        for(int i = 0;i < k; i++){\n            res[i] = arr[i];\n        }\n        return res;\n    }\n\n    public void quickSort(int[] list, int left, int right,int k) {\n        // 每快排切分1次，找到切分点，比较切分点和k的关系\n        int m = partition(list,left,right);\n        // 如果相等则意味着，切分点左边的数字已经是最小数组集合，直接返回\n        if(k==m){\n            return;\n        }\n        // 如果k小于m说明需要在左子数组进行搜索\n        else if(k<m){\n            quickSort(list,left,m-1,k);\n        }\n        // 如果k大于m说明需要在右子数组进行搜索\n        else{\n            quickSort(list,m+1,right,k);\n        }\n    }\n\n    public int partition(int[] list, int left, int right) {\n        // 用数组的第一个元素作为基准数\n        int first = list[left];\n        while (left < right) {\n            while (left < right && list[right] >= first) {\n                right--;\n            }\n            swap(list, left, right);\n            while (left < right && list[left] <= first) {\n                left++;\n            }\n            swap(list, left, right);\n        }\n        // 返回分割点所在的位置\n        return left;\n    }\n\n    public void swap(int[] list, int left, int right) {\n        int temp;\n        if (list != null && list.length > 0) {\n            temp = list[left];\n            list[left] = list[right];\n            list[right] = temp;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n\n# Java代码\n\nclass Solution {\n    public int[] getLeastNumbers(int[] arr, int k) {\n        if(k==0||arr.length==0)\n            return new int[0];\n        // 使用一个最大堆\n        // 默认最小堆，需要转化，默认是升序的，转化之后是降序的\n        Queue<Integer> stack = new PriorityQueue<>((v1,v2)->v2-v1);\n        for(int num:arr){\n            if(stack.size()<k){\n                stack.offer(num);\n            }\n            // peek队首元素\n            else if(num<stack.peek()){\n                // 因为是降序，所以poll队首是最大元素\n                stack.poll();\n                stack.offer(num);\n            }\n        }\n        int[] res = new int[stack.size()];\n        int i = 0;\n        for(int num:stack){\n            res[i++] = num;\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n",normalizedContent:"# leetcode-面试题40-最小的k个数\n\n输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。\n\n示例1：\n\n输入：arr = [3,2,1], k = 2\n输出：[1,2] 或者 [2,1]\n\n\n1\n2\n\n1\n2\n\n\n示例2：\n\n输入：arr = [0,1,2,1], k = 1\n输出：[0]\n\n\n1\n2\n\n1\n2\n\n\n限制：\n\n * 0 <= k <= arr.length <= 10000\n * 0 <= arr[i] <= 10000\n\n\n# 解题思路\n\n方法1、快排+选择：\n\n基于之前快速排序的代码实现，现在加了几个条件，如下：\n\n每快排切分1次，找到切分点，比较切分点和k的关系\n\n * 如果相等则意味着，切分点左边的数字已经是最小数组集合，直接返回\n * 如果k小于m说明需要在左子数组进行搜索\n * 如果k大于m说明需要在右子数组进行搜索\n\n方法2、最大堆：\n\n使用java的优先级队列priorityqueue，实现最大堆\n\n当队列不足k个的时候，传入一个元素\n\n当队列大于k个的时候，判断下一个元素是否小于堆顶，如果小于就把堆顶弹出，把下一个元素传入\n\n之后返回对应的数组\n\n\n# java代码\n\nclass solution {\n    public int[] getleastnumbers(int[] arr, int k) {\n        if(k==0)\n            return new int[0];\n        else if(arr.length<=k)\n            return arr;\n        quicksort(arr,0,arr.length-1,k);\n        int[] res = new int[k];\n        for(int i = 0;i < k; i++){\n            res[i] = arr[i];\n        }\n        return res;\n    }\n\n    public void quicksort(int[] list, int left, int right,int k) {\n        // 每快排切分1次，找到切分点，比较切分点和k的关系\n        int m = partition(list,left,right);\n        // 如果相等则意味着，切分点左边的数字已经是最小数组集合，直接返回\n        if(k==m){\n            return;\n        }\n        // 如果k小于m说明需要在左子数组进行搜索\n        else if(k<m){\n            quicksort(list,left,m-1,k);\n        }\n        // 如果k大于m说明需要在右子数组进行搜索\n        else{\n            quicksort(list,m+1,right,k);\n        }\n    }\n\n    public int partition(int[] list, int left, int right) {\n        // 用数组的第一个元素作为基准数\n        int first = list[left];\n        while (left < right) {\n            while (left < right && list[right] >= first) {\n                right--;\n            }\n            swap(list, left, right);\n            while (left < right && list[left] <= first) {\n                left++;\n            }\n            swap(list, left, right);\n        }\n        // 返回分割点所在的位置\n        return left;\n    }\n\n    public void swap(int[] list, int left, int right) {\n        int temp;\n        if (list != null && list.length > 0) {\n            temp = list[left];\n            list[left] = list[right];\n            list[right] = temp;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n\n# java代码\n\nclass solution {\n    public int[] getleastnumbers(int[] arr, int k) {\n        if(k==0||arr.length==0)\n            return new int[0];\n        // 使用一个最大堆\n        // 默认最小堆，需要转化，默认是升序的，转化之后是降序的\n        queue<integer> stack = new priorityqueue<>((v1,v2)->v2-v1);\n        for(int num:arr){\n            if(stack.size()<k){\n                stack.offer(num);\n            }\n            // peek队首元素\n            else if(num<stack.peek()){\n                // 因为是降序，所以poll队首是最大元素\n                stack.poll();\n                stack.offer(num);\n            }\n        }\n        int[] res = new int[stack.size()];\n        int i = 0;\n        for(int num:stack){\n            res[i++] = num;\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题41-数据流中的中位数",frontmatter:{title:"LeetCode-面试题41-数据流中的中位数",date:"2020-05-04T18:37:01.000Z",description:"数据流中的中位数",tags:["数组","Java","Hard","剑指Offer"],keywords:"数组,Java,Hard,剑指Offer",permalink:"/pages/888f97/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/36.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9841-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0.html",relativePath:"06.算法/01.剑指Offer/36.LeetCode-面试题41-数据流中的中位数.md",key:"v-dd5b10b0",path:"/pages/888f97/",headers:[{level:2,title:"LeetCode-面试题41-数据流中的中位数",slug:"leetcode-面试题41-数据流中的中位数",normalizedTitle:"leetcode-面试题41-数据流中的中位数",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:640},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:861}],headersStr:"LeetCode-面试题41-数据流中的中位数 解题思路 Java代码",content:'# LeetCode-面试题41-数据流中的中位数\n\n如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。\n\n例如，\n\n[2,3,4] 的中位数是 3\n\n[2,3] 的中位数是 (2 + 3) / 2 = 2.5\n\n设计一个支持以下两种操作的数据结构：\n\n * void addNum(int num) - 从数据流中添加一个整数到数据结构中。\n\n * double findMedian() - 返回目前所有元素的中位数。\n\n示例1：\n\n输入：\n["MedianFinder","addNum","addNum","findMedian","addNum","findMedian"]\n[[],[1],[2],[],[3],[]]\n输出：[null,null,null,1.50000,null,2.00000]\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n示例2：\n\n输入：\n["MedianFinder","addNum","findMedian","addNum","findMedian"]\n[[],[2],[],[3],[]]\n输出：[null,null,2.00000,null,2.50000]\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n限制：\n\n * 最多会对 addNum、findMedia进行 50000 次调用。\n\n\n# 解题思路\n\n最大堆+最小堆：\n\n可以看作最大堆是普通班，最小堆是实验班。数量上时刻保持小顶-大顶<=1（两堆相等或者小顶比大顶多一个）。\n\n新学生先入普通班（最大堆），此时可能会失去平衡了，于是取最大堆的第一个（班里最好的学生）加入实验班（最小堆），判断若数量过多（不是等于或多一个），取第一个（实验班里最差的学生）到普通班（最大堆）里。 取中位数的时候，若两堆数量相等，则各取堆顶取平均，若小顶比大顶多一，则多的那一个就是中位数。\n\n\n# Java代码\n\nclass MedianFinder {\n    Queue<Integer> left;\n    Queue<Integer> right;\n    /** initialize your data structure here. */\n    public MedianFinder() {\n        left = new PriorityQueue<>((n1,n2)->n2-n1); // 最大堆\n        right = new PriorityQueue<>(); // 最小堆\n    }\n    \n    public void addNum(int num) {\n        // 先插入最大堆\n        left.offer(num);\n        // 之后把最大堆的最大的数字，拿出来给最小堆\n        right.offer(left.poll());\n        // 数组数目是奇数时，且小堆比大堆多时，需要平衡\n        // 小堆的堆顶拿出来给最大堆\n        if(right.size()>left.size())\n            left.offer(right.poll());\n        \n    }\n    \n    public double findMedian() {\n        // 如果最大堆大于最小堆个数，即数组是奇数，返回最大堆堆顶\n        // 如果是偶数，则是（最大堆堆顶+最小堆堆顶 ）/ 2\n        if(left.size()>right.size()) return left.peek();\n        else return (left.peek()+right.peek())/2.0;\n    }\n}\n\n/**\n * Your MedianFinder object will be instantiated and called as such:\n * MedianFinder obj = new MedianFinder();\n * obj.addNum(num);\n * double param_2 = obj.findMedian();\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n',normalizedContent:'# leetcode-面试题41-数据流中的中位数\n\n如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。\n\n例如，\n\n[2,3,4] 的中位数是 3\n\n[2,3] 的中位数是 (2 + 3) / 2 = 2.5\n\n设计一个支持以下两种操作的数据结构：\n\n * void addnum(int num) - 从数据流中添加一个整数到数据结构中。\n\n * double findmedian() - 返回目前所有元素的中位数。\n\n示例1：\n\n输入：\n["medianfinder","addnum","addnum","findmedian","addnum","findmedian"]\n[[],[1],[2],[],[3],[]]\n输出：[null,null,null,1.50000,null,2.00000]\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n示例2：\n\n输入：\n["medianfinder","addnum","findmedian","addnum","findmedian"]\n[[],[2],[],[3],[]]\n输出：[null,null,2.00000,null,2.50000]\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n限制：\n\n * 最多会对 addnum、findmedia进行 50000 次调用。\n\n\n# 解题思路\n\n最大堆+最小堆：\n\n可以看作最大堆是普通班，最小堆是实验班。数量上时刻保持小顶-大顶<=1（两堆相等或者小顶比大顶多一个）。\n\n新学生先入普通班（最大堆），此时可能会失去平衡了，于是取最大堆的第一个（班里最好的学生）加入实验班（最小堆），判断若数量过多（不是等于或多一个），取第一个（实验班里最差的学生）到普通班（最大堆）里。 取中位数的时候，若两堆数量相等，则各取堆顶取平均，若小顶比大顶多一，则多的那一个就是中位数。\n\n\n# java代码\n\nclass medianfinder {\n    queue<integer> left;\n    queue<integer> right;\n    /** initialize your data structure here. */\n    public medianfinder() {\n        left = new priorityqueue<>((n1,n2)->n2-n1); // 最大堆\n        right = new priorityqueue<>(); // 最小堆\n    }\n    \n    public void addnum(int num) {\n        // 先插入最大堆\n        left.offer(num);\n        // 之后把最大堆的最大的数字，拿出来给最小堆\n        right.offer(left.poll());\n        // 数组数目是奇数时，且小堆比大堆多时，需要平衡\n        // 小堆的堆顶拿出来给最大堆\n        if(right.size()>left.size())\n            left.offer(right.poll());\n        \n    }\n    \n    public double findmedian() {\n        // 如果最大堆大于最小堆个数，即数组是奇数，返回最大堆堆顶\n        // 如果是偶数，则是（最大堆堆顶+最小堆堆顶 ）/ 2\n        if(left.size()>right.size()) return left.peek();\n        else return (left.peek()+right.peek())/2.0;\n    }\n}\n\n/**\n * your medianfinder object will be instantiated and called as such:\n * medianfinder obj = new medianfinder();\n * obj.addnum(num);\n * double param_2 = obj.findmedian();\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题42-连续子数组的最大和",frontmatter:{title:"LeetCode-面试题42-连续子数组的最大和",date:"2020-05-05T18:08:46.000Z",description:"连续子数组的最大和",tags:["数组","Java","Python","DP","Easy","剑指Offer"],keywords:"数组,Java,Python,Easy,剑指Offer",permalink:"/pages/95eb09/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/37.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9842-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.html",relativePath:"06.算法/01.剑指Offer/37.LeetCode-面试题42-连续子数组的最大和.md",key:"v-e2fb1c2a",path:"/pages/95eb09/",headers:[{level:2,title:"LeetCode-面试题42-连续子数组的最大和",slug:"leetcode-面试题42-连续子数组的最大和",normalizedTitle:"leetcode-面试题42-连续子数组的最大和",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:255},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:681},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:1242}],headersStr:"LeetCode-面试题42-连续子数组的最大和 解题思路 Java代码 Python代码",content:"# LeetCode-面试题42-连续子数组的最大和\n\n输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。\n\n要求时间复杂度为O(n)。\n\n示例1：\n\n输入: nums = [-2,1,-3,4,-1,2,1,-5,4]\n输出: 6\n解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n限制：\n\n * 1 <= arr.length <= 10^5\n * -100 <= arr[i] <= 100\n\n\n# 解题思路\n\n方法1、找规律：\n\n * 当累和小于等于0时，则curSum从当前数开始，如果不小于0就开始累加\n * 如果当前和大于最大的和，就把curSum的值给maxSum\n\n方法2、动态规划：\n\n * dp[i] = dp[i-1] + nums[i] # if i != 0 and dp[i-1] > 0\n * dp[i] = nums[i] # if i == 0 or dp[i-1] < 0\n\n公式的意义在于，当第i-1个数字结尾的子数组中 所有数字的和小于0时，如果把这个负数与第i个数累加，则得到的结果比第i个数字本身还要小，所以这个情况下第i个数字结尾的子数组就是第i个数字本身。\n\n如果i-1个数字结尾的子数组中所有数字的和大于0，则与第i个数字累加就得到以第i个数字结尾的子数组中所有数字的和\n\n在这里因为dp[i]只与dp[i-1]和nums[i]有关系，因此可以将原数组nums用做dp列表，即直接在nums上修改\n\n\n# Java代码\n\nclass Solution {\n    public int maxSubArray(int[] nums) {\n        if(nums.length==0||nums==null)\n            return 0;\n        int maxSum = Integer.MIN_VALUE;\n        int curSum = 0;\n        for(int i = 0;i< nums.length;i++){\n            if(curSum<=0)\n                curSum = nums[i];\n            else\n                curSum+=nums[i];\n            if(curSum>maxSum){\n                maxSum = curSum;\n            }\n        }\n        return maxSum;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# Python代码\n\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        if not nums or len(nums)==0: return 0\n        maxSum = nums[0]\n        for i in range(1,len(nums)):\n            if nums[i-1]>0:\n                nums[i]+=nums[i-1]\n            maxSum = max(maxSum,nums[i])\n        return maxSum\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n",normalizedContent:"# leetcode-面试题42-连续子数组的最大和\n\n输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。\n\n要求时间复杂度为o(n)。\n\n示例1：\n\n输入: nums = [-2,1,-3,4,-1,2,1,-5,4]\n输出: 6\n解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n限制：\n\n * 1 <= arr.length <= 10^5\n * -100 <= arr[i] <= 100\n\n\n# 解题思路\n\n方法1、找规律：\n\n * 当累和小于等于0时，则cursum从当前数开始，如果不小于0就开始累加\n * 如果当前和大于最大的和，就把cursum的值给maxsum\n\n方法2、动态规划：\n\n * dp[i] = dp[i-1] + nums[i] # if i != 0 and dp[i-1] > 0\n * dp[i] = nums[i] # if i == 0 or dp[i-1] < 0\n\n公式的意义在于，当第i-1个数字结尾的子数组中 所有数字的和小于0时，如果把这个负数与第i个数累加，则得到的结果比第i个数字本身还要小，所以这个情况下第i个数字结尾的子数组就是第i个数字本身。\n\n如果i-1个数字结尾的子数组中所有数字的和大于0，则与第i个数字累加就得到以第i个数字结尾的子数组中所有数字的和\n\n在这里因为dp[i]只与dp[i-1]和nums[i]有关系，因此可以将原数组nums用做dp列表，即直接在nums上修改\n\n\n# java代码\n\nclass solution {\n    public int maxsubarray(int[] nums) {\n        if(nums.length==0||nums==null)\n            return 0;\n        int maxsum = integer.min_value;\n        int cursum = 0;\n        for(int i = 0;i< nums.length;i++){\n            if(cursum<=0)\n                cursum = nums[i];\n            else\n                cursum+=nums[i];\n            if(cursum>maxsum){\n                maxsum = cursum;\n            }\n        }\n        return maxsum;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# python代码\n\nclass solution:\n    def maxsubarray(self, nums: list[int]) -> int:\n        if not nums or len(nums)==0: return 0\n        maxsum = nums[0]\n        for i in range(1,len(nums)):\n            if nums[i-1]>0:\n                nums[i]+=nums[i-1]\n            maxsum = max(maxsum,nums[i])\n        return maxsum\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题43-1到n整数中1出现的次数",frontmatter:{title:"LeetCode-面试题43-1到n整数中1出现的次数",date:"2020-05-05T21:26:10.000Z",description:"1到n整数中1出现的次数",tags:["大数问题","Java","Python","Hard","剑指Offer"],keywords:"数组,Java,Python,Hard,剑指Offer",permalink:"/pages/e9ceb8/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/38.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9843-1%E5%88%B0n%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0.html",relativePath:"06.算法/01.剑指Offer/38.LeetCode-面试题43-1到n整数中1出现的次数.md",key:"v-1fb6cd47",path:"/pages/e9ceb8/",headers:[{level:2,title:"LeetCode-面试题43-1到n整数中1出现的次数",slug:"leetcode-面试题43-1到n整数中1出现的次数",normalizedTitle:"leetcode-面试题43-1到n整数中1出现的次数",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:207},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:984}],headersStr:"LeetCode-面试题43-1到n整数中1出现的次数 解题思路 Java代码",content:"# LeetCode-面试题43-1到n整数中1出现的次数\n\n输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。\n\n例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。\n\n示例1：\n\n输入：n = 12\n输出：5\n\n\n1\n2\n\n1\n2\n\n\n示例2：\n\n输入：n = 13\n输出：6\n\n\n1\n2\n\n1\n2\n\n\n限制：\n\n * 1 <= n < 2^31\n\n\n# 解题思路\n\n暴力破解不行，就像在做数学题TAT\n\n递归：转自力扣评论区\n\nf(n)函数的意思是1～n这n个整数的十进制表示中1出现的次数，将n拆分为两部分，最高一位的数字high和其他位的数字last，分别判断情况后将结果相加，看例子更加简单。\n\n例子如n=1234，high=1, pow=1000, last=234\n\n可以将数字范围分成两部分1999和10001234\n\n * 1~999这个范围1的个数是f(pow-1)\n\n * 1000~1234这个范围1的个数需要分为两部分：\n   \n   * 千分位是1的个数：千分位为1的个数刚好就是234+1(last+1)，注意，这儿只看千分位，不看其他位\n   * 其他位是1的个数：即是234中出现1的个数，为f(last)\n\n所以全部加起来是f(pow-1) + last + 1 + f(last);\n\n——————————————————————————————————————————————————————————————\n\n例子如3234，high=3, pow=1000, last=234\n\n可以将数字范围分成两部分1999，10001999，20002999和30003234\n\n * 1~999这个范围1的个数是f(pow-1)\n\n * 1000~1999这个范围1的个数需要分为两部分：\n   \n   * 千分位是1的个数：千分位为1的个数刚好就是pow，注意，这儿只看千分位，不看其他位\n   * 其他位是1的个数：即是999中出现1的个数，为f(pow-1)\n\n * 2000~2999这个范围1的个数是f(pow-1)\n\n * 3000~3234这个范围1的个数是f(last)\n\n所以全部加起来是pow + high*f(pow-1) + f(last);\n\n\n# Java代码\n\nclass Solution {\n    public int countDigitOne(int n) {\n        return f(n);\n    }\n    public int f(int n){\n        if(n<=0)\n            return 0;\n        String s = String.valueOf(n);\n        int high = s.charAt(0)-'0';\n        int pow = (int)Math.pow(10,s.length()-1);\n        int last = n-high*pow;\n        if(high==1){\n            return f(pow-1)+last+1+f(last);\n        }else{\n            return pow+high*f(pow-1)+f(last);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n",normalizedContent:"# leetcode-面试题43-1到n整数中1出现的次数\n\n输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。\n\n例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。\n\n示例1：\n\n输入：n = 12\n输出：5\n\n\n1\n2\n\n1\n2\n\n\n示例2：\n\n输入：n = 13\n输出：6\n\n\n1\n2\n\n1\n2\n\n\n限制：\n\n * 1 <= n < 2^31\n\n\n# 解题思路\n\n暴力破解不行，就像在做数学题tat\n\n递归：转自力扣评论区\n\nf(n)函数的意思是1～n这n个整数的十进制表示中1出现的次数，将n拆分为两部分，最高一位的数字high和其他位的数字last，分别判断情况后将结果相加，看例子更加简单。\n\n例子如n=1234，high=1, pow=1000, last=234\n\n可以将数字范围分成两部分1999和10001234\n\n * 1~999这个范围1的个数是f(pow-1)\n\n * 1000~1234这个范围1的个数需要分为两部分：\n   \n   * 千分位是1的个数：千分位为1的个数刚好就是234+1(last+1)，注意，这儿只看千分位，不看其他位\n   * 其他位是1的个数：即是234中出现1的个数，为f(last)\n\n所以全部加起来是f(pow-1) + last + 1 + f(last);\n\n——————————————————————————————————————————————————————————————\n\n例子如3234，high=3, pow=1000, last=234\n\n可以将数字范围分成两部分1999，10001999，20002999和30003234\n\n * 1~999这个范围1的个数是f(pow-1)\n\n * 1000~1999这个范围1的个数需要分为两部分：\n   \n   * 千分位是1的个数：千分位为1的个数刚好就是pow，注意，这儿只看千分位，不看其他位\n   * 其他位是1的个数：即是999中出现1的个数，为f(pow-1)\n\n * 2000~2999这个范围1的个数是f(pow-1)\n\n * 3000~3234这个范围1的个数是f(last)\n\n所以全部加起来是pow + high*f(pow-1) + f(last);\n\n\n# java代码\n\nclass solution {\n    public int countdigitone(int n) {\n        return f(n);\n    }\n    public int f(int n){\n        if(n<=0)\n            return 0;\n        string s = string.valueof(n);\n        int high = s.charat(0)-'0';\n        int pow = (int)math.pow(10,s.length()-1);\n        int last = n-high*pow;\n        if(high==1){\n            return f(pow-1)+last+1+f(last);\n        }else{\n            return pow+high*f(pow-1)+f(last);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题44-数字序列中某一位的数字",frontmatter:{title:"LeetCode-面试题44-数字序列中某一位的数字",date:"2020-05-06T15:15:55.000Z",description:"数字序列中某一位的数字",tags:["大数问题","数组","Java","Python","Medium","剑指Offer"],keywords:"大数问题,数组,Java,Python,Medium,剑指Offer",permalink:"/pages/11765a/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/39.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9844-%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97.html",relativePath:"06.算法/01.剑指Offer/39.LeetCode-面试题44-数字序列中某一位的数字.md",key:"v-2124d7fc",path:"/pages/11765a/",headers:[{level:2,title:"LeetCode-面试题44-数字序列中某一位的数字",slug:"leetcode-面试题44-数字序列中某一位的数字",normalizedTitle:"leetcode-面试题44-数字序列中某一位的数字",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:227},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:1023},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:2466}],headersStr:"LeetCode-面试题44-数字序列中某一位的数字 解题思路 Java代码 Python代码",content:"# LeetCode-面试题44-数字序列中某一位的数字\n\n数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。\n\n请写一个函数，求任意第n位对应的数字。\n\n示例1：\n\n输入：n = 3\n输出：3\n\n\n1\n2\n\n1\n2\n\n\n示例2：\n\n输入：n = 11\n输出：0\n\n\n1\n2\n\n1\n2\n\n\n限制：\n\n * 1 <= n < 2^31\n\n\n# 解题思路\n\n找规律：\n\n首先int类型只能表示2^31-1个数，所以存储的时候需要用long表示\n\n数字范围            位数         数字数量           数位数量\n数字范围1-9         位数=1       数字数量=9         数位数量=9\n数字范围10-99       位数=2       数字数量=90        数位数量 =180\n数字范围100-999     位数=3       数字数量=900       数位数量=2700\n数字范围start-end   位数=digit   数字数量=9xstart   数位数量=9xstartxdigit\n\n可以从上规律分析出，可以通过划分数字的范围，去确定输入n位在几位数的区间，之后再几位数的区间中找到这一位数字。\n\n * 剑指offer的解法：\n   \n   比如数字序列的1001位，由上表可知1001位的数字范围是100-999，因为1001<2700，1001-180-9=881位，即数字范围100~999中的881位数字，由于这个范围数字是3位数，881/3=270，余1。即在100的基础上走过270个数字之后，再移动1位即是1001位数。可以从数字n开始出发，每排除一种位数的范围，就把n减去这个范围的位数，然后确定n应该在的范围\n\n * 递推的解法：\n   \n   观察上面的表格可以看出\n   \n   位数递推公式digit = digit+1\n   \n   起始数字公式 start=startx10\n   \n   数位数量公式count=9xstartxdigit\n   \n   求解分为3步：\n   \n   * 确定n所在数字的位数，记为digit\n   * 确定n所在的数字，记为num\n   * 确定n是num中的哪一数位，返回结果\n\n\n# Java代码\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int out = findNthDigit(n);\n        System.out.println(out);\n    }\n\n    public static int findNthDigit(int n) {\n        if (n < 10) return n;\n        int digits = 1; // 代表是几位数\n        // 找到n位于几位数的范围中\n        while (true) {\n            long nums = 0;\n            if (digits == 1) nums = 10;\n            else nums = 9 * (long) Math.pow(10, digits - 1);\n            if (n < nums * digits)\n                return digitsN(n, digits);\n            n -= digits * nums;\n            digits++;\n        }\n    }\n\n    // 在几位数中找出那一位数字\n    // 比如811=270x3+1是从100开始的270个数字的中间1位\n    public static int digitsN(int n, int digits) {\n        long nums = begin(digits) + n / digits;\n        // 求得那个数字中的第几位，如370，7是这个数字的第2位\n        int indexFromRight = digits - n % digits;\n        for (int i = 1; i < indexFromRight; i++) {\n            nums /= 10;\n        }\n        return (int) nums % 10;\n    }\n    // 找到所属位数的初始值，如3位数的初始值是100\n    public static long begin(int digits) {\n        if (digits == 1)\n            return 0;\n        return (long) Math.pow(10, digits - 1);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n# Python代码\n\nclass Solution:\n    def findNthDigit(self, n: int) -> int:\n        digit,start,count = 1,1,9\n        while n>count:\n            n-=count\n            start*=10\n            digit+=1\n            count = 9*start*digit\n        num = start + (n-1)//digit # 确定所求数位所在的数字\n        res = str(num)[(n-1)%digit]# 确定所求数位在num的哪一数位，余数即使对应位置\n        return int(res)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n",normalizedContent:"# leetcode-面试题44-数字序列中某一位的数字\n\n数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。\n\n请写一个函数，求任意第n位对应的数字。\n\n示例1：\n\n输入：n = 3\n输出：3\n\n\n1\n2\n\n1\n2\n\n\n示例2：\n\n输入：n = 11\n输出：0\n\n\n1\n2\n\n1\n2\n\n\n限制：\n\n * 1 <= n < 2^31\n\n\n# 解题思路\n\n找规律：\n\n首先int类型只能表示2^31-1个数，所以存储的时候需要用long表示\n\n数字范围            位数         数字数量           数位数量\n数字范围1-9         位数=1       数字数量=9         数位数量=9\n数字范围10-99       位数=2       数字数量=90        数位数量 =180\n数字范围100-999     位数=3       数字数量=900       数位数量=2700\n数字范围start-end   位数=digit   数字数量=9xstart   数位数量=9xstartxdigit\n\n可以从上规律分析出，可以通过划分数字的范围，去确定输入n位在几位数的区间，之后再几位数的区间中找到这一位数字。\n\n * 剑指offer的解法：\n   \n   比如数字序列的1001位，由上表可知1001位的数字范围是100-999，因为1001<2700，1001-180-9=881位，即数字范围100~999中的881位数字，由于这个范围数字是3位数，881/3=270，余1。即在100的基础上走过270个数字之后，再移动1位即是1001位数。可以从数字n开始出发，每排除一种位数的范围，就把n减去这个范围的位数，然后确定n应该在的范围\n\n * 递推的解法：\n   \n   观察上面的表格可以看出\n   \n   位数递推公式digit = digit+1\n   \n   起始数字公式 start=startx10\n   \n   数位数量公式count=9xstartxdigit\n   \n   求解分为3步：\n   \n   * 确定n所在数字的位数，记为digit\n   * 确定n所在的数字，记为num\n   * 确定n是num中的哪一数位，返回结果\n\n\n# java代码\n\npublic class solution {\n    public static void main(string[] args) {\n        scanner sc = new scanner(system.in);\n        int n = sc.nextint();\n        int out = findnthdigit(n);\n        system.out.println(out);\n    }\n\n    public static int findnthdigit(int n) {\n        if (n < 10) return n;\n        int digits = 1; // 代表是几位数\n        // 找到n位于几位数的范围中\n        while (true) {\n            long nums = 0;\n            if (digits == 1) nums = 10;\n            else nums = 9 * (long) math.pow(10, digits - 1);\n            if (n < nums * digits)\n                return digitsn(n, digits);\n            n -= digits * nums;\n            digits++;\n        }\n    }\n\n    // 在几位数中找出那一位数字\n    // 比如811=270x3+1是从100开始的270个数字的中间1位\n    public static int digitsn(int n, int digits) {\n        long nums = begin(digits) + n / digits;\n        // 求得那个数字中的第几位，如370，7是这个数字的第2位\n        int indexfromright = digits - n % digits;\n        for (int i = 1; i < indexfromright; i++) {\n            nums /= 10;\n        }\n        return (int) nums % 10;\n    }\n    // 找到所属位数的初始值，如3位数的初始值是100\n    public static long begin(int digits) {\n        if (digits == 1)\n            return 0;\n        return (long) math.pow(10, digits - 1);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n# python代码\n\nclass solution:\n    def findnthdigit(self, n: int) -> int:\n        digit,start,count = 1,1,9\n        while n>count:\n            n-=count\n            start*=10\n            digit+=1\n            count = 9*start*digit\n        num = start + (n-1)//digit # 确定所求数位所在的数字\n        res = str(num)[(n-1)%digit]# 确定所求数位在num的哪一数位，余数即使对应位置\n        return int(res)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题45-把数组排成最小的数",frontmatter:{title:"LeetCode-面试题45-把数组排成最小的数",date:"2020-05-06T18:51:48.000Z",description:"把数组排成最小的数",tags:["大数问题","数组","Java","Python","Medium","剑指Offer"],keywords:"大数问题,数组,Java,Python,Medium,剑指Offer",permalink:"/pages/0856b2/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/40.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9845-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0.html",relativePath:"06.算法/01.剑指Offer/40.LeetCode-面试题45-把数组排成最小的数.md",key:"v-6c380f3c",path:"/pages/0856b2/",headers:[{level:2,title:"LeetCode-面试题45-把数组排成最小的数",slug:"leetcode-面试题45-把数组排成最小的数",normalizedTitle:"leetcode-面试题45-把数组排成最小的数",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:272},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:429},{level:3,title:"Python代码1",slug:"python代码1",normalizedTitle:"python代码1",charIndex:1173},{level:3,title:"Python代码2",slug:"python代码2",normalizedTitle:"python代码2",charIndex:1492}],headersStr:"LeetCode-面试题45-把数组排成最小的数 解题思路 Java代码 Python代码1 Python代码2",content:'# LeetCode-面试题45-把数组排成最小的数\n\n输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。\n\n示例1：\n\n输入: [10,2]\n输出: "102"\n\n\n1\n2\n\n1\n2\n\n\n示例2：\n\n输入: [3,30,34,5,9]\n输出: "3033459"\n\n\n1\n2\n\n1\n2\n\n\n限制：\n\n * 0 < nums.length <= 100\n\n说明：\n\n * 输出结果可能非常大，所以你需要返回一个字符串而不是整数\n * 拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0\n\n\n# 解题思路\n\n排序：\n\n对于两个数字m和n，可以拼接成mn和nm，如果mn<nm，那么就应该打印出mn，也就是m应该排在n之前，此时定义m"小于"n；反之，如果nm<mn，应该打印nm，此时定义n"小于"m；如果mn=nm，则n"等于"m，由于组合的数字很大，所以这也是一个大数问题，用字符串来进行拼接得到结果\n\n在Java代码中可以重写Arrays中的compareTo接口，使x+y和y+x进行大小比较，sort方法默认升序，所以比较出来的数组自然是最小的\n\nPython代码....原来还可以根据key自定义规则，方法来自https://leetcode-cn.com/u/bigkjp97/因为默认升序，所以只需要改变大于或者小于的规则即可，其他规则富比较方法中不变不影响\n\n\n# Java代码\n\nclass Solution {\n    public String minNumber(int[] nums) {\n        if(nums==null||nums.length==0)\n            return "";\n        String[] str = new String[nums.length];\n        for(int i =0;i<nums.length;i++){\n            str[i] = String.valueOf(nums[i]);\n        }\n        Arrays.sort(str, (x, y) -> (x + y).compareTo(y + x));\n        StringBuilder res = new StringBuilder();\n        for(String s:str)\n            res.append(s);\n        return res.toString();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# Python代码1\n\nclass SmallerNumKey(str): # 定义一个类\n    # 富比较方法\n    def __lt__(x, y):\n        return x + y < y + x\n\nclass Solution:\n    def minNumber(self, nums: List[int]) -> str:\n        smallest_num = \'\'.join(sorted(map(str, nums),key=SmallerNumKey))\n        return smallest_num\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# Python代码2\n\nclass Solution:\n    def minNumber(self, nums: List[int]) -> str:\n        def sort_rule(x, y):\n            a, b = x + y, y + x\n            if a > b: return 1\n            elif a < b: return -1\n            else: return 0\n        strs.sort(map(str,nums),key = functools.cmp_to_key(sort_rule))\n        return \'\'.join(strs)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n',normalizedContent:'# leetcode-面试题45-把数组排成最小的数\n\n输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。\n\n示例1：\n\n输入: [10,2]\n输出: "102"\n\n\n1\n2\n\n1\n2\n\n\n示例2：\n\n输入: [3,30,34,5,9]\n输出: "3033459"\n\n\n1\n2\n\n1\n2\n\n\n限制：\n\n * 0 < nums.length <= 100\n\n说明：\n\n * 输出结果可能非常大，所以你需要返回一个字符串而不是整数\n * 拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0\n\n\n# 解题思路\n\n排序：\n\n对于两个数字m和n，可以拼接成mn和nm，如果mn<nm，那么就应该打印出mn，也就是m应该排在n之前，此时定义m"小于"n；反之，如果nm<mn，应该打印nm，此时定义n"小于"m；如果mn=nm，则n"等于"m，由于组合的数字很大，所以这也是一个大数问题，用字符串来进行拼接得到结果\n\n在java代码中可以重写arrays中的compareto接口，使x+y和y+x进行大小比较，sort方法默认升序，所以比较出来的数组自然是最小的\n\npython代码....原来还可以根据key自定义规则，方法来自https://leetcode-cn.com/u/bigkjp97/因为默认升序，所以只需要改变大于或者小于的规则即可，其他规则富比较方法中不变不影响\n\n\n# java代码\n\nclass solution {\n    public string minnumber(int[] nums) {\n        if(nums==null||nums.length==0)\n            return "";\n        string[] str = new string[nums.length];\n        for(int i =0;i<nums.length;i++){\n            str[i] = string.valueof(nums[i]);\n        }\n        arrays.sort(str, (x, y) -> (x + y).compareto(y + x));\n        stringbuilder res = new stringbuilder();\n        for(string s:str)\n            res.append(s);\n        return res.tostring();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# python代码1\n\nclass smallernumkey(str): # 定义一个类\n    # 富比较方法\n    def __lt__(x, y):\n        return x + y < y + x\n\nclass solution:\n    def minnumber(self, nums: list[int]) -> str:\n        smallest_num = \'\'.join(sorted(map(str, nums),key=smallernumkey))\n        return smallest_num\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# python代码2\n\nclass solution:\n    def minnumber(self, nums: list[int]) -> str:\n        def sort_rule(x, y):\n            a, b = x + y, y + x\n            if a > b: return 1\n            elif a < b: return -1\n            else: return 0\n        strs.sort(map(str,nums),key = functools.cmp_to_key(sort_rule))\n        return \'\'.join(strs)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题47-礼物的最大价值",frontmatter:{title:"LeetCode-面试题47-礼物的最大价值",date:"2020-05-07T21:12:39.000Z",description:"礼物的最大价值",tags:["DP","数组","Java","Python","Medium","剑指Offer"],keywords:"DP,数组,Java,Python,Medium,剑指Offer",permalink:"/pages/85c8fd/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/41.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9847-%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC.html",relativePath:"06.算法/01.剑指Offer/41.LeetCode-面试题47-礼物的最大价值.md",key:"v-6b05a19d",path:"/pages/85c8fd/",headers:[{level:2,title:"LeetCode-面试题47-礼物的最大价值",slug:"leetcode-面试题47-礼物的最大价值",normalizedTitle:"leetcode-面试题47-礼物的最大价值",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:273},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:581},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:1272}],headersStr:"LeetCode-面试题47-礼物的最大价值 解题思路 Java代码 Python代码",content:"# LeetCode-面试题47-礼物的最大价值\n\n在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？\n\n示例1：\n\n输入: \n[\n  [1,3,1],\n  [1,5,1],\n  [4,2,1]\n]\n输出: 12\n解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 解题思路\n\n动态规划：\n\n由于只能向右和向下移动，所以对于第一行和第一列而言，可能的最大值就是直接向右和向下移动\n\n设置二维dp矩阵\n\n * 第一列表示为i不等于0时，dp[i][0]仅与dp[i-1][0]有关，于是可以在原矩阵直接进行修改\n\n * 第一行表示为j不等于0时，dp[0][j]仅与dp[0][j-1]有关\n   \n   对于一行和一列可以先计算出来，避免循环中重复的判断\n\n * 当i和j都不等于0时，dp[i][j]应该等于其左边格子的累和以及上边格子累和的最大值+当前格子的值\n   \n   即dp[i][j]=Max(dp[i-1][j],dp[i][j-1])+gift(i,j)\n\n\n# Java代码\n\nclass Solution {\n    public int maxValue(int[][] grid) {\n        if (grid == null||grid.length == 0||grid[0].length == 0) {\n            return 0;\n        }\n        int m = grid.length;\n        int n = grid[0].length;\n        for(int i=1;i<m;i++){\n            grid[i][0]+=grid[i-1][0];\n        }\n        for(int j=1;j<n;j++){\n            grid[0][j]+=grid[0][j-1];\n        }\n        for(int i=1;i<m;i++){\n            for(int j=1;j<n;j++){\n                grid[i][j] += Math.max(grid[i-1][j],grid[i][j-1]);\n            }\n        }\n        return grid[m-1][n-1];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# Python代码\n\nclass Solution:\n    def maxValue(self, grid: List[List[int]]) -> int:\n        if not grid or len(grid)==0 or len(grid[0])==0:\n            return 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if i==0 and j==0: continue\n                if i!=0 and j==0: grid[i][j]+=grid[i-1][j]\n                if i==0 and j!=0: grid[i][j]+=grid[i][j-1]\n                if i!=0 and j!=0: grid[i][j]+=max(grid[i-1][j],grid[i][j-1])\n        return grid[len(grid)-1][len(grid[0])-1]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n",normalizedContent:"# leetcode-面试题47-礼物的最大价值\n\n在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？\n\n示例1：\n\n输入: \n[\n  [1,3,1],\n  [1,5,1],\n  [4,2,1]\n]\n输出: 12\n解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 解题思路\n\n动态规划：\n\n由于只能向右和向下移动，所以对于第一行和第一列而言，可能的最大值就是直接向右和向下移动\n\n设置二维dp矩阵\n\n * 第一列表示为i不等于0时，dp[i][0]仅与dp[i-1][0]有关，于是可以在原矩阵直接进行修改\n\n * 第一行表示为j不等于0时，dp[0][j]仅与dp[0][j-1]有关\n   \n   对于一行和一列可以先计算出来，避免循环中重复的判断\n\n * 当i和j都不等于0时，dp[i][j]应该等于其左边格子的累和以及上边格子累和的最大值+当前格子的值\n   \n   即dp[i][j]=max(dp[i-1][j],dp[i][j-1])+gift(i,j)\n\n\n# java代码\n\nclass solution {\n    public int maxvalue(int[][] grid) {\n        if (grid == null||grid.length == 0||grid[0].length == 0) {\n            return 0;\n        }\n        int m = grid.length;\n        int n = grid[0].length;\n        for(int i=1;i<m;i++){\n            grid[i][0]+=grid[i-1][0];\n        }\n        for(int j=1;j<n;j++){\n            grid[0][j]+=grid[0][j-1];\n        }\n        for(int i=1;i<m;i++){\n            for(int j=1;j<n;j++){\n                grid[i][j] += math.max(grid[i-1][j],grid[i][j-1]);\n            }\n        }\n        return grid[m-1][n-1];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# python代码\n\nclass solution:\n    def maxvalue(self, grid: list[list[int]]) -> int:\n        if not grid or len(grid)==0 or len(grid[0])==0:\n            return 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if i==0 and j==0: continue\n                if i!=0 and j==0: grid[i][j]+=grid[i-1][j]\n                if i==0 and j!=0: grid[i][j]+=grid[i][j-1]\n                if i!=0 and j!=0: grid[i][j]+=max(grid[i-1][j],grid[i][j-1])\n        return grid[len(grid)-1][len(grid[0])-1]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题48-最长不含重复字符的子字符串",frontmatter:{title:"LeetCode-面试题48-最长不含重复字符的子字符串",date:"2020-05-08T10:25:53.000Z",description:"最长不含重复字符的子字符串",tags:["DP","双指针","字符串","Java","Python","Medium","剑指Offer"],keywords:"DP,双指针,字符串,Java,Python,Medium,剑指Offer",permalink:"/pages/7fd908/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/42.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9848-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html",relativePath:"06.算法/01.剑指Offer/42.LeetCode-面试题48-最长不含重复字符的子字符串.md",key:"v-5d0d0f9e",path:"/pages/7fd908/",headers:[{level:2,title:"LeetCode-面试题48-最长不含重复字符的子字符串",slug:"leetcode-面试题48-最长不含重复字符的子字符串",normalizedTitle:"leetcode-面试题48-最长不含重复字符的子字符串",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:352},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:938},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:1552}],headersStr:"LeetCode-面试题48-最长不含重复字符的子字符串 解题思路 Java代码 Python代码",content:'# LeetCode-面试题48-最长不含重复字符的子字符串\n\n请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。\n\n示例1：\n\n输入: "abcabcbb"\n输出: 3 \n解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2：\n\n输入: "bbbbb"\n输出: 1\n解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例3：\n\n输入: "pwwkew"\n输出: 3\n解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n\n# 解题思路\n\n方法1、DP+哈希表：\n\n设置右边界为j，左边界为i\n\n * 当字串左边没有相同的字符时，dp[j] = dp[j-1]+1\n * 当dp[j-1]<j-i，说明字符在dp[j-1]区间之外，如acbr，对于acb而言下一个字符r不是重复的字符，其在dp[j-1]之外，所以dp[j] = dp[j-1]+1\n * 当dp[j-1]>=j-i，说明字符在dp[j-1]区间之中，含有重复字符，则dp[j]的左边界由第一次出现的重复字符的位置觉得，dp[j]=j-i\n\n第一二种情况可以合并为一个，由于返回值取dp列表最大值，可以借助dp变量，存储dp[j]，每轮更新res\n\n节省原本需要dp列表的空间\n\n方法2、双指针+哈希表：\n\n按照顺序遍历字符串，同时计算子串的长度，当到达相同的字符时候，自然希望子串的起始位置变成重复的位置。\n\n而下一次子串的长度则=计算下一次碰到重复字符的位置end到上一次碰到重复字符位置start的差\n\n那么如何去知道前面是否有重复的字符？\n\n如果不使用hash表，就需要从最开始遍历到末尾end进行判断，这样时间复杂度太高。\n\n所以这里采用hash表的方式存储每一个字符最后出现的位置，以便于快速找到上一次start的位置，由于遍历从0开始，所以将start初始化为-1，表示第一个位置长度为1，最后取最大的字串长度\n\n\n# Java代码\n\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character,Integer> dict = new HashMap<>();\n        int res = 0,dp = 0;\n        for(int j=0;j<s.length();j++){\n            int i = dict.containsKey(s.charAt(j))?dict.get(s.charAt(j)):-1; // 获取索引\n            dict.put(s.charAt(j),j); // 更新hash\n            // dp[j-1] < j-i时，dp[j-1]+1\n            // dp[j-1] > j-i时，j-i\n            dp = dp<j-i?dp+1:j-i;\n            res = Math.max(res,dp); // max(dp[j-1],dp[j])\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# Python代码\n\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        start,res= -1,0\n        positionMap = {}\n        for end in range(len(s)):\n            if s[end] in positionMap:\n                start = max(positionMap[s[end]],start)\n            positionMap[s[end]] = end\n            res = max(res,end-start)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n',normalizedContent:'# leetcode-面试题48-最长不含重复字符的子字符串\n\n请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。\n\n示例1：\n\n输入: "abcabcbb"\n输出: 3 \n解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2：\n\n输入: "bbbbb"\n输出: 1\n解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例3：\n\n输入: "pwwkew"\n输出: 3\n解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n\n# 解题思路\n\n方法1、dp+哈希表：\n\n设置右边界为j，左边界为i\n\n * 当字串左边没有相同的字符时，dp[j] = dp[j-1]+1\n * 当dp[j-1]<j-i，说明字符在dp[j-1]区间之外，如acbr，对于acb而言下一个字符r不是重复的字符，其在dp[j-1]之外，所以dp[j] = dp[j-1]+1\n * 当dp[j-1]>=j-i，说明字符在dp[j-1]区间之中，含有重复字符，则dp[j]的左边界由第一次出现的重复字符的位置觉得，dp[j]=j-i\n\n第一二种情况可以合并为一个，由于返回值取dp列表最大值，可以借助dp变量，存储dp[j]，每轮更新res\n\n节省原本需要dp列表的空间\n\n方法2、双指针+哈希表：\n\n按照顺序遍历字符串，同时计算子串的长度，当到达相同的字符时候，自然希望子串的起始位置变成重复的位置。\n\n而下一次子串的长度则=计算下一次碰到重复字符的位置end到上一次碰到重复字符位置start的差\n\n那么如何去知道前面是否有重复的字符？\n\n如果不使用hash表，就需要从最开始遍历到末尾end进行判断，这样时间复杂度太高。\n\n所以这里采用hash表的方式存储每一个字符最后出现的位置，以便于快速找到上一次start的位置，由于遍历从0开始，所以将start初始化为-1，表示第一个位置长度为1，最后取最大的字串长度\n\n\n# java代码\n\nclass solution {\n    public int lengthoflongestsubstring(string s) {\n        map<character,integer> dict = new hashmap<>();\n        int res = 0,dp = 0;\n        for(int j=0;j<s.length();j++){\n            int i = dict.containskey(s.charat(j))?dict.get(s.charat(j)):-1; // 获取索引\n            dict.put(s.charat(j),j); // 更新hash\n            // dp[j-1] < j-i时，dp[j-1]+1\n            // dp[j-1] > j-i时，j-i\n            dp = dp<j-i?dp+1:j-i;\n            res = math.max(res,dp); // max(dp[j-1],dp[j])\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# python代码\n\nclass solution:\n    def lengthoflongestsubstring(self, s: str) -> int:\n        start,res= -1,0\n        positionmap = {}\n        for end in range(len(s)):\n            if s[end] in positionmap:\n                start = max(positionmap[s[end]],start)\n            positionmap[s[end]] = end\n            res = max(res,end-start)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题49-丑数",frontmatter:{title:"LeetCode-面试题49-丑数",date:"2020-05-08T17:10:42.000Z",description:"丑数",tags:["DP","Java","Medium","剑指Offer"],keywords:"DP,Java,Medium,剑指Offer",permalink:"/pages/0b0978/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/43.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9849-%E4%B8%91%E6%95%B0.html",relativePath:"06.算法/01.剑指Offer/43.LeetCode-面试题49-丑数.md",key:"v-55f7df2a",path:"/pages/0b0978/",headers:[{level:2,title:"LeetCode-面试题49-丑数",slug:"leetcode-面试题49-丑数",normalizedTitle:"leetcode-面试题49-丑数",charIndex:2},{level:3,title:"解题思路1",slug:"解题思路1",normalizedTitle:"解题思路1",charIndex:200},{level:3,title:"解题思路2",slug:"解题思路2",normalizedTitle:"解题思路2",charIndex:1769},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:1986},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:2540}],headersStr:"LeetCode-面试题49-丑数 解题思路1 解题思路2 Java代码 Java代码2",content:"# LeetCode-面试题49-丑数\n\n我们把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。\n\n示例1：\n\n输入: n = 10\n输出: 12\n解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n说明：\n\n 1. 1 是丑数。\n 2. n 不超过1690。\n\n\n# 解题思路1\n\n这个题暴力破解的解法很耗时，就是循环判断一个数是否能被2，3，5整除，如果都能，则最后的因子是1，就说明这是丑数，外层还需要一个n的循环，非常耗时。更好的解法如下\n\n三指针：\n\n问题分析：一个丑数只有2，3，5这3个因子，1也是丑数，那么基本的3个丑数就可以由1*2、1*3、1*5得到，而其他的丑数也可以由2、3、5的乘积得到，这样问题就转化为了一个类似DP的问题，最小的问题是2、3、5，大一点的问题是乘以2、3、5得到的丑数。\n\n由于需要从小到大的顺序排列n个丑数，所以怎么去保持丑数的顺序很重要\n\n在每次计算出基于2、3、5的3个丑数时，始终把最小的丑数添加进dp[i]中\n\n之后谁的结果最小，就移动那个指针\n\n如果第i个丑数==2xp2，也就是说前面0-p2个丑数*2不可能产生比第i个丑数更大的丑数了，所以p2++\n\np3，p5同理\n\n一个更好理解的例子源于https://leetcode-cn.com/u/sunrise-9/\n\n丑数的排列肯定是1,2,3,4,5,6,8,10.... 然后有一个特点是，任意一个丑数都是由小于它的某一个丑数*2，*3或者*5得到的，那么如何得到所有丑数呢？ 现在假设有3个数组，分别是： A：{1*2，2*2，3*2，4*2，5*2，6*2，8*2，10*2......}\n\nB：{1*3，2*3，3*3，4*3，5*3，6*3，8*3，10*3......}\n\nC：{1*5，2*5，3*5，4*5，5*5，6*5，8*5，10*5......}\n\n那么所有丑数的排列，必定就是上面ABC3个数组的合并结果然后去重得到的，那么这不就转换成了三个有序数组的无重复元素合并的问题了吗？而这三个数组就刚好是{1,2,3,4,5,6,8,10....}乘以2,3,5得到的。\n\n合并有序数组的一个比较好的方法，就是每个数组都对应一个指针，然后比较这些指针所指的数中哪个最小，就将这个数放到结果数组中，然后该指针向后挪一位。\n\n回到本题，要求丑数ugly数组中的第n项，而目前只知道ugly[0]=1，所以此时三个有序链表分别就只有一个元素：\n\nA ： {1*2......}\n\nB ： {1*3......}\n\nC ：{1*5......}\n\n假设三个数组的指针分别是i,j,k，此时均是指向第一个元素，然后比较A[i]，B[j]和C[k]，得到的最小的数A[i]，就是ugly[1]，此时ugly就变成{1,2}了，对应的ABC数组就分别变成了：\n\nA ： {1*2，2*2......}\n\nB ： {1*3, 2*3......}\n\nC ：{1*5,2*5......}\n\n此时根据合并有序数组的原理，A数组指针i就指向了下一个元素，即'2*2'，而j和k依然分别指向B[0]和C[0]，然后进行下一轮合并，就是A[1]和B[0]和C[0]比较，最小值作为ugly[2].....如此循环n次，就可以得到ugly[n]了。\n\n此外，注意到ABC三个数组实际上就是ugly[]*2，ugly[]*3和ugly[]*5的结果，所以每次只需要比较A[i]=ugly[i]*2，B[j]=ugly[j]*3和C[k]=ugly[k]*5的大小即可。然后谁最小，就把对应的指针往后移动一个，为了去重，如果多个元素都是最小，那么这多个指针都要往后移动一个。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 解题思路2\n\nHashSet+小顶堆\n\n丑数是以2、3、5为因子\n\n初始时堆为空。首先将最小的丑数 1 加入堆。\n\n每次取出堆顶元素 x，则 x 是堆中最小的丑数，由于 2x, 3x, 5x 也是丑数，因此将 2x, 3x, 5x 加入堆。\n\n上述做法会导致堆中出现重复元素的情况。为了避免重复元素，可以使用哈希集合去重，避免相同元素多次加入堆。\n\n在排除重复元素的情况下，第 n 次从最小堆中取出的元素即为第 n 个丑数。\n\n\n# Java代码\n\nclass Solution {\n    public int nthUglyNumber(int n) {\n        int p2=0,p3=0,p5=0; // 想象初始化3个有序链表的第一个元素，分别为2、3、5为基数乘的数组\n        int[] dp = new int[n];\n        dp[0] = 1;\n        for(int i=1;i<n;i++){\n            // 返回的下一个丑数应该是*2,*3,*5之后的最小丑数\n            dp[i] = Math.min(dp[p2]*2,Math.min(dp[p3]*3,dp[p5]*5));\n            if(dp[i]==dp[p2]*2) p2++;\n            if(dp[i]==dp[p3]*3) p3++;\n            if(dp[i]==dp[p5]*5) p5++;\n        }\n        return dp[n-1];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# Java代码2\n\nclass Solution {\n    public int nthUglyNumber(int n) {\n        int[] baseNum = new int[]{2, 3, 5};\n        HashSet<Long> set = new HashSet<>();\n        Queue<Long> queue = new PriorityQueue<>();\n        set.add(1L);\n        queue.offer(1L);\n        int ugly = 0;\n        for (int i = 0; i < n; i++) {\n            long cur = queue.poll();\n            ugly = (int) cur;\n            for (Integer j : baseNum) {\n                long next = cur * j;\n                if (set.add(next)) {\n                    queue.offer(next);\n                }\n            }\n        }\n        return ugly;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n",normalizedContent:"# leetcode-面试题49-丑数\n\n我们把只包含因子 2、3 和 5 的数称作丑数（ugly number）。求按从小到大的顺序的第 n 个丑数。\n\n示例1：\n\n输入: n = 10\n输出: 12\n解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n说明：\n\n 1. 1 是丑数。\n 2. n 不超过1690。\n\n\n# 解题思路1\n\n这个题暴力破解的解法很耗时，就是循环判断一个数是否能被2，3，5整除，如果都能，则最后的因子是1，就说明这是丑数，外层还需要一个n的循环，非常耗时。更好的解法如下\n\n三指针：\n\n问题分析：一个丑数只有2，3，5这3个因子，1也是丑数，那么基本的3个丑数就可以由1*2、1*3、1*5得到，而其他的丑数也可以由2、3、5的乘积得到，这样问题就转化为了一个类似dp的问题，最小的问题是2、3、5，大一点的问题是乘以2、3、5得到的丑数。\n\n由于需要从小到大的顺序排列n个丑数，所以怎么去保持丑数的顺序很重要\n\n在每次计算出基于2、3、5的3个丑数时，始终把最小的丑数添加进dp[i]中\n\n之后谁的结果最小，就移动那个指针\n\n如果第i个丑数==2xp2，也就是说前面0-p2个丑数*2不可能产生比第i个丑数更大的丑数了，所以p2++\n\np3，p5同理\n\n一个更好理解的例子源于https://leetcode-cn.com/u/sunrise-9/\n\n丑数的排列肯定是1,2,3,4,5,6,8,10.... 然后有一个特点是，任意一个丑数都是由小于它的某一个丑数*2，*3或者*5得到的，那么如何得到所有丑数呢？ 现在假设有3个数组，分别是： a：{1*2，2*2，3*2，4*2，5*2，6*2，8*2，10*2......}\n\nb：{1*3，2*3，3*3，4*3，5*3，6*3，8*3，10*3......}\n\nc：{1*5，2*5，3*5，4*5，5*5，6*5，8*5，10*5......}\n\n那么所有丑数的排列，必定就是上面abc3个数组的合并结果然后去重得到的，那么这不就转换成了三个有序数组的无重复元素合并的问题了吗？而这三个数组就刚好是{1,2,3,4,5,6,8,10....}乘以2,3,5得到的。\n\n合并有序数组的一个比较好的方法，就是每个数组都对应一个指针，然后比较这些指针所指的数中哪个最小，就将这个数放到结果数组中，然后该指针向后挪一位。\n\n回到本题，要求丑数ugly数组中的第n项，而目前只知道ugly[0]=1，所以此时三个有序链表分别就只有一个元素：\n\na ： {1*2......}\n\nb ： {1*3......}\n\nc ：{1*5......}\n\n假设三个数组的指针分别是i,j,k，此时均是指向第一个元素，然后比较a[i]，b[j]和c[k]，得到的最小的数a[i]，就是ugly[1]，此时ugly就变成{1,2}了，对应的abc数组就分别变成了：\n\na ： {1*2，2*2......}\n\nb ： {1*3, 2*3......}\n\nc ：{1*5,2*5......}\n\n此时根据合并有序数组的原理，a数组指针i就指向了下一个元素，即'2*2'，而j和k依然分别指向b[0]和c[0]，然后进行下一轮合并，就是a[1]和b[0]和c[0]比较，最小值作为ugly[2].....如此循环n次，就可以得到ugly[n]了。\n\n此外，注意到abc三个数组实际上就是ugly[]*2，ugly[]*3和ugly[]*5的结果，所以每次只需要比较a[i]=ugly[i]*2，b[j]=ugly[j]*3和c[k]=ugly[k]*5的大小即可。然后谁最小，就把对应的指针往后移动一个，为了去重，如果多个元素都是最小，那么这多个指针都要往后移动一个。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 解题思路2\n\nhashset+小顶堆\n\n丑数是以2、3、5为因子\n\n初始时堆为空。首先将最小的丑数 1 加入堆。\n\n每次取出堆顶元素 x，则 x 是堆中最小的丑数，由于 2x, 3x, 5x 也是丑数，因此将 2x, 3x, 5x 加入堆。\n\n上述做法会导致堆中出现重复元素的情况。为了避免重复元素，可以使用哈希集合去重，避免相同元素多次加入堆。\n\n在排除重复元素的情况下，第 n 次从最小堆中取出的元素即为第 n 个丑数。\n\n\n# java代码\n\nclass solution {\n    public int nthuglynumber(int n) {\n        int p2=0,p3=0,p5=0; // 想象初始化3个有序链表的第一个元素，分别为2、3、5为基数乘的数组\n        int[] dp = new int[n];\n        dp[0] = 1;\n        for(int i=1;i<n;i++){\n            // 返回的下一个丑数应该是*2,*3,*5之后的最小丑数\n            dp[i] = math.min(dp[p2]*2,math.min(dp[p3]*3,dp[p5]*5));\n            if(dp[i]==dp[p2]*2) p2++;\n            if(dp[i]==dp[p3]*3) p3++;\n            if(dp[i]==dp[p5]*5) p5++;\n        }\n        return dp[n-1];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# java代码2\n\nclass solution {\n    public int nthuglynumber(int n) {\n        int[] basenum = new int[]{2, 3, 5};\n        hashset<long> set = new hashset<>();\n        queue<long> queue = new priorityqueue<>();\n        set.add(1l);\n        queue.offer(1l);\n        int ugly = 0;\n        for (int i = 0; i < n; i++) {\n            long cur = queue.poll();\n            ugly = (int) cur;\n            for (integer j : basenum) {\n                long next = cur * j;\n                if (set.add(next)) {\n                    queue.offer(next);\n                }\n            }\n        }\n        return ugly;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题50-第一次只出现一次的字符",frontmatter:{title:"LeetCode-面试题50-第一次只出现一次的字符",date:"2020-05-08T19:23:20.000Z",description:"第一次只出现一次的字符",tags:["Python","Java","Easy","剑指Offer"],keywords:"Java,Python,Easy,剑指Offer",permalink:"/pages/105b9d/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/44.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9850-%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6.html",relativePath:"06.算法/01.剑指Offer/44.LeetCode-面试题50-第一次只出现一次的字符.md",key:"v-70612210",path:"/pages/105b9d/",headers:[{level:2,title:"LeetCode-面试题50-第一次只出现一次的字符",slug:"leetcode-面试题50-第一次只出现一次的字符",normalizedTitle:"leetcode-面试题50-第一次只出现一次的字符",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:166},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:319},{level:3,title:"Python代码1",slug:"python代码1",normalizedTitle:"python代码1",charIndex:1014}],headersStr:"LeetCode-面试题50-第一次只出现一次的字符 解题思路 Java代码 Python代码1",content:"# LeetCode-面试题50-第一次只出现一次的字符\n\n在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。\n\n示例1：\n\ns = \"abaccdeff\"\n返回 \"b\"\n\ns = \"\" \n返回 \" \"\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n说明：\n\n0 <= s 的长度 <= 50000\n\n\n# 解题思路\n\n哈希表：\n\n每出现一次字符就把字符放入hash表中，如果有重复的就把对应位置+1\n\n遍历的时候由于hash表重新put改变了原本的先后顺序(Java的hashmap不能原地改变，Python的dict可以原地改变)，所以需要按照字符顺序遍历，当第1次value为1的时候，就返回该字符\n\n\n# Java代码\n\nclass Solution {\n    public char firstUniqChar(String s) {\n        if (s == null || s.length() == 0)\n            return ' ';\n        HashMap<Character, Integer> maps = new HashMap<>();\n        char[] chars = s.toCharArray();\n        for (char c : chars) {\n            if (!maps.containsKey(c)) {\n                maps.put(c, 1);\n            } else {\n                maps.put(c, maps.get(c) + 1);\n            }\n        }\n\n        for (char c : chars) {\n            if (maps.get(c) == 1) {\n                return c;\n            }\n        }\n        return ' ';\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# Python代码1\n\nclass Solution:\n    def firstUniqChar(self, s: str) -> str:\n        if not s or len(s)==0:\n            return ' '\n        d = {}\n        for i in s:\n            if i not in d:\n                d[i] = 1\n            else:\n                d[i]+=1\n        for k,v in d.items():\n            if v==1:\n                return k\n        return ' '\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n",normalizedContent:"# leetcode-面试题50-第一次只出现一次的字符\n\n在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。\n\n示例1：\n\ns = \"abaccdeff\"\n返回 \"b\"\n\ns = \"\" \n返回 \" \"\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n说明：\n\n0 <= s 的长度 <= 50000\n\n\n# 解题思路\n\n哈希表：\n\n每出现一次字符就把字符放入hash表中，如果有重复的就把对应位置+1\n\n遍历的时候由于hash表重新put改变了原本的先后顺序(java的hashmap不能原地改变，python的dict可以原地改变)，所以需要按照字符顺序遍历，当第1次value为1的时候，就返回该字符\n\n\n# java代码\n\nclass solution {\n    public char firstuniqchar(string s) {\n        if (s == null || s.length() == 0)\n            return ' ';\n        hashmap<character, integer> maps = new hashmap<>();\n        char[] chars = s.tochararray();\n        for (char c : chars) {\n            if (!maps.containskey(c)) {\n                maps.put(c, 1);\n            } else {\n                maps.put(c, maps.get(c) + 1);\n            }\n        }\n\n        for (char c : chars) {\n            if (maps.get(c) == 1) {\n                return c;\n            }\n        }\n        return ' ';\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# python代码1\n\nclass solution:\n    def firstuniqchar(self, s: str) -> str:\n        if not s or len(s)==0:\n            return ' '\n        d = {}\n        for i in s:\n            if i not in d:\n                d[i] = 1\n            else:\n                d[i]+=1\n        for k,v in d.items():\n            if v==1:\n                return k\n        return ' '\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题51-数组中的逆序对",frontmatter:{title:"LeetCode-面试题51-数组中的逆序对",date:"2020-05-09T18:33:02.000Z",description:"数组中的逆序对",tags:["数组","分治","Java","Python","Hard","剑指Offer"],keywords:"数组,分治,Java,Python,Hard,剑指Offer",permalink:"/pages/3fafb8/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/45.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9851-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9.html",relativePath:"06.算法/01.剑指Offer/45.LeetCode-面试题51-数组中的逆序对.md",key:"v-38a4108f",path:"/pages/3fafb8/",headers:[{level:2,title:"LeetCode-面试题51-数组中的逆序对",slug:"leetcode-面试题51-数组中的逆序对",normalizedTitle:"leetcode-面试题51-数组中的逆序对",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:157},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:486},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:2682}],headersStr:"LeetCode-面试题51-数组中的逆序对 解题思路 Java代码 Python代码",content:"# LeetCode-面试题51-数组中的逆序对\n\n在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。\n\n示例1：\n\n输入: [7,5,6,4]\n输出: 5\n\n\n1\n2\n\n1\n2\n\n\n说明：\n\n0 <= 数组长度 <= 50000\n\n\n# 解题思路\n\n方法1、暴力破解(超时)：\n\n两个指针循环判断后面的数是不是小于前面的数，是就+1，但这样超时了。算一个没办法的解法吧\n\n方法2、归并排序：\n\n基本上代码就是归并排序的思想，但递归的终止条件有了变化，因为分裂区间需要判断是否有逆序数的关系\n\n当区间的left==right的时候，说明这个区间只有一个数字了，一个数字不能组成逆序数，因此这个区间的逆序数为0\n\n在跨区间逆序数计算时，如果左边区间比较小就需要先把左边区间的数放入temp数组中，这个时候代表左边的数比又边的数小，但此时不是逆序的关系，不需要统计逆序对；只有当右边区间比左边区间小的时候，需要统计逆序对个数，此时的逆序对个数为，左边区间还剩下的数的个数即mid-left+1\n\n\n# Java代码\n\nclass Solution {\n    public int reversePairs(int[] nums) {\n        int len = nums.length;\n        if (len < 2) {\n            return 0;\n        }\n        int[] copy = new int[len];\n        for (int i = 0; i < len; i++) {\n            copy[i] = nums[i];\n        }\n        int[] temp = new int[len];\n        return MergeSort(copy, 0, len - 1, temp);\n\n    }\n\n    private int MergeSort(int[] nums, int left, int right, int[] temp) {\n        // 当这个区间只剩一个元素时，这个子区间就不存在逆序数，返回0\n        if (left == right) {\n            return 0;\n        }\n        // int mid = (left+right)/2;\n        // 防止int溢出\n        int mid = left + (right - left) / 2;\n        int leftPairs = MergeSort(nums, left, mid, temp);\n        int rightPairs = MergeSort(nums, mid + 1, right, temp);\n        // 如果分出来的数组本身有序，则返回左边+右边\n        if (nums[mid] <= nums[mid + 1]) {\n            return leftPairs + rightPairs;\n        }\n        int crossPairs = mergeAndCount(nums, left, mid, right, temp);\n        return leftPairs + rightPairs + crossPairs;\n    }\n\n    private int mergeAndCount(int[] nums, int left, int mid, int right, int[] temp) {\n        for (int i = left; i <=right; i++) {\n            temp[i] = nums[i];\n        }\n        int i = left;\n        int j = mid + 1;\n        int count = 0;\n        for (int k = left; k <= right; k++) {\n            // 如果左边数组遍历完了，就直接把右边拷贝回去\n            if (i == mid + 1) {\n                nums[k] = temp[j];\n                j++;\n            } else if (j == right + 1) {\n                // 如果右边数组遍历完了，就直接把左边拷贝回去\n                nums[k] = temp[i];\n                i++;\n            } else if (temp[i] <= temp[j]) {\n                nums[k] = temp[i];\n                i++;\n            } else {\n                nums[k] = temp[j];\n                j++;\n                count += (mid - i + 1);\n            }\n        }\n        return count;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n\n\n# Python代码\n\n暴力破解失败.....\n\nclass Solution:\n    def reversePairs(self, nums: List[int]) -> int:\n        i,j,count = 0,0,0\n        for i in range(len(nums)):\n            for j in range(1,len(nums)):\n                if(nums[j]<nums[i]):\n                    count+=1\n        return count\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n",normalizedContent:"# leetcode-面试题51-数组中的逆序对\n\n在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。\n\n示例1：\n\n输入: [7,5,6,4]\n输出: 5\n\n\n1\n2\n\n1\n2\n\n\n说明：\n\n0 <= 数组长度 <= 50000\n\n\n# 解题思路\n\n方法1、暴力破解(超时)：\n\n两个指针循环判断后面的数是不是小于前面的数，是就+1，但这样超时了。算一个没办法的解法吧\n\n方法2、归并排序：\n\n基本上代码就是归并排序的思想，但递归的终止条件有了变化，因为分裂区间需要判断是否有逆序数的关系\n\n当区间的left==right的时候，说明这个区间只有一个数字了，一个数字不能组成逆序数，因此这个区间的逆序数为0\n\n在跨区间逆序数计算时，如果左边区间比较小就需要先把左边区间的数放入temp数组中，这个时候代表左边的数比又边的数小，但此时不是逆序的关系，不需要统计逆序对；只有当右边区间比左边区间小的时候，需要统计逆序对个数，此时的逆序对个数为，左边区间还剩下的数的个数即mid-left+1\n\n\n# java代码\n\nclass solution {\n    public int reversepairs(int[] nums) {\n        int len = nums.length;\n        if (len < 2) {\n            return 0;\n        }\n        int[] copy = new int[len];\n        for (int i = 0; i < len; i++) {\n            copy[i] = nums[i];\n        }\n        int[] temp = new int[len];\n        return mergesort(copy, 0, len - 1, temp);\n\n    }\n\n    private int mergesort(int[] nums, int left, int right, int[] temp) {\n        // 当这个区间只剩一个元素时，这个子区间就不存在逆序数，返回0\n        if (left == right) {\n            return 0;\n        }\n        // int mid = (left+right)/2;\n        // 防止int溢出\n        int mid = left + (right - left) / 2;\n        int leftpairs = mergesort(nums, left, mid, temp);\n        int rightpairs = mergesort(nums, mid + 1, right, temp);\n        // 如果分出来的数组本身有序，则返回左边+右边\n        if (nums[mid] <= nums[mid + 1]) {\n            return leftpairs + rightpairs;\n        }\n        int crosspairs = mergeandcount(nums, left, mid, right, temp);\n        return leftpairs + rightpairs + crosspairs;\n    }\n\n    private int mergeandcount(int[] nums, int left, int mid, int right, int[] temp) {\n        for (int i = left; i <=right; i++) {\n            temp[i] = nums[i];\n        }\n        int i = left;\n        int j = mid + 1;\n        int count = 0;\n        for (int k = left; k <= right; k++) {\n            // 如果左边数组遍历完了，就直接把右边拷贝回去\n            if (i == mid + 1) {\n                nums[k] = temp[j];\n                j++;\n            } else if (j == right + 1) {\n                // 如果右边数组遍历完了，就直接把左边拷贝回去\n                nums[k] = temp[i];\n                i++;\n            } else if (temp[i] <= temp[j]) {\n                nums[k] = temp[i];\n                i++;\n            } else {\n                nums[k] = temp[j];\n                j++;\n                count += (mid - i + 1);\n            }\n        }\n        return count;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n\n\n# python代码\n\n暴力破解失败.....\n\nclass solution:\n    def reversepairs(self, nums: list[int]) -> int:\n        i,j,count = 0,0,0\n        for i in range(len(nums)):\n            for j in range(1,len(nums)):\n                if(nums[j]<nums[i]):\n                    count+=1\n        return count\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题53-1-在排序数组中查找数字I",frontmatter:{title:"LeetCode-面试题53-1-在排序数组中查找数字I",date:"2020-05-12T14:24:43.000Z",description:"在排序数组中查找数字I",tags:["数组","Java","Easy","剑指Offer"],keywords:"数组,Java,Easy,剑指Offer",permalink:"/pages/c7c072/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/46.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9853-1-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97I.html",relativePath:"06.算法/01.剑指Offer/46.LeetCode-面试题53-1-在排序数组中查找数字I.md",key:"v-6632c0ce",path:"/pages/c7c072/",headers:[{level:2,title:"LeetCode-面试题53-1-在排序数组中查找数字I",slug:"leetcode-面试题53-1-在排序数组中查找数字i",normalizedTitle:"leetcode-面试题53-1-在排序数组中查找数字i",charIndex:2},{level:3,title:"解题思路1",slug:"解题思路1",normalizedTitle:"解题思路1",charIndex:215},{level:3,title:"解题思路2",slug:"解题思路2",normalizedTitle:"解题思路2",charIndex:276},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:317},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:2070},{level:3,title:"Java代码3",slug:"java代码3",normalizedTitle:"java代码3",charIndex:3201}],headersStr:"LeetCode-面试题53-1-在排序数组中查找数字I 解题思路1 解题思路2 Java代码 Java代码2 Java代码3",content:"# LeetCode-面试题53-1-在排序数组中查找数字I\n\n统计一个数字在排序数组中出现的次数。\n\n示例1：\n\n输入: nums = [5,7,7,8,8,10], target = 8\n输出: 2\n\n\n1\n2\n\n1\n2\n\n\n示例2：\n\n输入: nums = [5,7,7,8,8,10], target = 6\n输出: 0\n\n\n1\n2\n\n1\n2\n\n\n * 限制：\n   \n   0 <= 数组长度 <= 50000\n\n\n# 解题思路1\n\n在有序的数组中二分查找，确定第一个k出现的位置和最后一个k出现的位置，然后两个位置相减即是出现次数\n\n\n# 解题思路2\n\nhash表，遍历的过程中把次数加上去即可，速度慢于2分查找\n\n\n# Java代码\n\nclass Solution {\n    public int search(int[] nums, int target) {\n        int len = nums.length;\n        int count = 0;\n        if(nums!=null&&len>0){\n            int first = GetFristK(nums,len,target,0,len-1);\n            int last = GetLastK(nums,len,target,0,len-1);\n            if(first>-1&&last>-1){\n                count = last-first+1;\n            }\n        }\n        return count;\n    }\n    public int GetFristK(int[] nums,int len,int target,int start,int end){\n        if(start>end)\n            return -1;\n        int mid = (start+end)/2;\n        int midData = nums[mid];\n        if(midData==target){\n            // 找到第一个k的位置\n            if(mid>0&&nums[mid-1]!=target||mid==0)\n                return mid;\n            else // 如果前面还有k，缩小范围继续找\n                end = mid-1;\n        }else if(midData>target)\n            end = mid-1;\n        else\n            start = mid+1;\n        return GetFristK(nums,len,target,start,end);\n    }\n    public int GetLastK(int[] nums,int len,int target,int start,int end){\n        if(start>end)\n            return -1;\n        int mid = (start+end)/2;\n        int midData = nums[mid];\n        if(midData==target){\n            // 找到最后一个k的位置\n            if(mid<len-1&&nums[mid+1]!=target||mid==len-1)\n                return mid;\n            else\n                start = mid+1;\n        }else if(midData<target)\n            start = mid+1;\n        else\n            end = mid-1;\n        return GetLastK(nums,len,target,start,end);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n# Java代码2\n\nclass Solution {\n    public int search(int[] nums, int target) {\n        int len = nums.length;\n        if (len == 0) return 0;\n        int left = 0;\n        int right = len-1;\n        // 通过控制等号控制是左边界还是右边界\n        while(left<=right){\n            int mid = left+(right-left)/2;\n            // 当小于等于target时一直移动左指针\n            if(nums[mid]<=target){\n                left = mid+1;\n            } else { // 当大于target时才移动右指针，这样保障了右指针指向重复target的最后一个位置\n                right = mid-1;\n            }\n        }\n        int rightIndex = right;\n        left = 0;\n        right = len-1;\n        while(left<=right){\n            int mid = left+(right-left)/2;\n            // 当大于等于target时一直移动右指针收缩\n            if(nums[mid]>=target){\n                right = mid-1;\n            } else { // 当小于target时才移动左指针，保障左指针指向重复target的第一个位置\n                left = mid+1;\n            }\n        }\n        int leftIndex = left;\n        return rightIndex-leftIndex+1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# Java代码3\n\nclass Solution {\n    public int search(int[] nums, int target) {\n        HashMap<Integer,Integer> map = new HashMap<>();\n        for(int i : nums){\n            map.put(i,map.getOrDefault(i,0)+1);\n        }\n        return map.containsKey(target)?map.get(target):0;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n",normalizedContent:"# leetcode-面试题53-1-在排序数组中查找数字i\n\n统计一个数字在排序数组中出现的次数。\n\n示例1：\n\n输入: nums = [5,7,7,8,8,10], target = 8\n输出: 2\n\n\n1\n2\n\n1\n2\n\n\n示例2：\n\n输入: nums = [5,7,7,8,8,10], target = 6\n输出: 0\n\n\n1\n2\n\n1\n2\n\n\n * 限制：\n   \n   0 <= 数组长度 <= 50000\n\n\n# 解题思路1\n\n在有序的数组中二分查找，确定第一个k出现的位置和最后一个k出现的位置，然后两个位置相减即是出现次数\n\n\n# 解题思路2\n\nhash表，遍历的过程中把次数加上去即可，速度慢于2分查找\n\n\n# java代码\n\nclass solution {\n    public int search(int[] nums, int target) {\n        int len = nums.length;\n        int count = 0;\n        if(nums!=null&&len>0){\n            int first = getfristk(nums,len,target,0,len-1);\n            int last = getlastk(nums,len,target,0,len-1);\n            if(first>-1&&last>-1){\n                count = last-first+1;\n            }\n        }\n        return count;\n    }\n    public int getfristk(int[] nums,int len,int target,int start,int end){\n        if(start>end)\n            return -1;\n        int mid = (start+end)/2;\n        int middata = nums[mid];\n        if(middata==target){\n            // 找到第一个k的位置\n            if(mid>0&&nums[mid-1]!=target||mid==0)\n                return mid;\n            else // 如果前面还有k，缩小范围继续找\n                end = mid-1;\n        }else if(middata>target)\n            end = mid-1;\n        else\n            start = mid+1;\n        return getfristk(nums,len,target,start,end);\n    }\n    public int getlastk(int[] nums,int len,int target,int start,int end){\n        if(start>end)\n            return -1;\n        int mid = (start+end)/2;\n        int middata = nums[mid];\n        if(middata==target){\n            // 找到最后一个k的位置\n            if(mid<len-1&&nums[mid+1]!=target||mid==len-1)\n                return mid;\n            else\n                start = mid+1;\n        }else if(middata<target)\n            start = mid+1;\n        else\n            end = mid-1;\n        return getlastk(nums,len,target,start,end);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n# java代码2\n\nclass solution {\n    public int search(int[] nums, int target) {\n        int len = nums.length;\n        if (len == 0) return 0;\n        int left = 0;\n        int right = len-1;\n        // 通过控制等号控制是左边界还是右边界\n        while(left<=right){\n            int mid = left+(right-left)/2;\n            // 当小于等于target时一直移动左指针\n            if(nums[mid]<=target){\n                left = mid+1;\n            } else { // 当大于target时才移动右指针，这样保障了右指针指向重复target的最后一个位置\n                right = mid-1;\n            }\n        }\n        int rightindex = right;\n        left = 0;\n        right = len-1;\n        while(left<=right){\n            int mid = left+(right-left)/2;\n            // 当大于等于target时一直移动右指针收缩\n            if(nums[mid]>=target){\n                right = mid-1;\n            } else { // 当小于target时才移动左指针，保障左指针指向重复target的第一个位置\n                left = mid+1;\n            }\n        }\n        int leftindex = left;\n        return rightindex-leftindex+1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# java代码3\n\nclass solution {\n    public int search(int[] nums, int target) {\n        hashmap<integer,integer> map = new hashmap<>();\n        for(int i : nums){\n            map.put(i,map.getordefault(i,0)+1);\n        }\n        return map.containskey(target)?map.get(target):0;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题33-二叉搜索树的后序遍历序列",frontmatter:{title:"LeetCode-面试题33-二叉搜索树的后序遍历序列",date:"2020-04-22T16:37:05.000Z",description:"从上到下打印二叉树",tags:["树","Java","Python","Medium","剑指Offer"],keywords:"树,Java,Python,Medium,剑指Offer",permalink:"/pages/fe51d2/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/47.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9833-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97.html",relativePath:"06.算法/01.剑指Offer/47.LeetCode-面试题33-二叉搜索树的后序遍历序列.md",key:"v-3a95fe52",path:"/pages/fe51d2/",headers:[{level:2,title:"LeetCode-面试题33-二叉搜索树的后序遍历序列",slug:"leetcode-面试题33-二叉搜索树的后序遍历序列",normalizedTitle:"leetcode-面试题33-二叉搜索树的后序遍历序列",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:298},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:470},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:1138}],headersStr:"LeetCode-面试题33-二叉搜索树的后序遍历序列 解题思路 Java代码 Python代码",content:"# LeetCode-面试题33-二叉搜索树的后序遍历序列\n\n输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。\n\n参考以下这颗二叉搜索树：\n\n     5\n    / \\\n   2   6\n  / \\\n 1   3\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n示例1：\n\n输入: [1,6,3,2,5]\n输出: false\n\n\n1\n2\n\n1\n2\n\n\n示例2：\n\n输入: [1,3,2,6,5]\n输出: true\n\n\n1\n2\n\n1\n2\n\n\n提示：\n\n 1. 节点总数 <= 1000\n\n\n# 解题思路\n\n递归：\n\n二叉树中根节点的左节点始终比根节点小，右节点始终比根节点大，题目中数组末尾为根节点\n\n通过与root节点的大小比较，能够找到左子树的边界，从而划开左右子树\n\n在右子树中节点值始终比root节点大，如果不是，则这个序列不是后序遍历序列\n\n当找到划分边界后进行递归，判断左子树中哪些是左节点，哪些是又节点。右子树同理\n\n\n# Java代码\n\nclass Solution {\n    public boolean verifyPostorder(int[] postorder) {\n        return helper(postorder,0,postorder.length-1);\n    }\n\n    public boolean helper(int[] postorder,int start,int end){\n        if(start>=end) return true;\n        int i = 0;\n        for(i=start;i<end;i++){\n            if(postorder[i]>postorder[end])\n                break;\n        }\n        for(int j = i;j<end;j++){\n            if(postorder[j]<postorder[end])\n                return false;\n        }\n        return helper(postorder,start,i-1)&&helper(postorder,i,end-1);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# Python代码\n\nclass Solution:\n    def verifyPostorder(self, postorder: List[int]) -> bool:\n        length = len(postorder);\n        if not postorder:\n            return True\n        root = postorder[-1]\n        # 二叉树中左子树始终比根节点小，右子树比根节点大\n        # 寻找左子树边界\n        i = 0\n        for i in range(length):\n            if postorder[i]>root:\n                break;\n        j = i\n        for j in range(j,length):\n            if postorder[j]<root:\n                return False\n        # 判断左子树是不是二叉搜索树\n        left = True\n        if i>0: left = self.verifyPostorder(postorder[:i])\n        # 判断右子树是不是二叉搜索树\n        right = True\n        if i<length-1: right = self.verifyPostorder(postorder[i:-1])\n        return left and right\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n",normalizedContent:"# leetcode-面试题33-二叉搜索树的后序遍历序列\n\n输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。\n\n参考以下这颗二叉搜索树：\n\n     5\n    / \\\n   2   6\n  / \\\n 1   3\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n示例1：\n\n输入: [1,6,3,2,5]\n输出: false\n\n\n1\n2\n\n1\n2\n\n\n示例2：\n\n输入: [1,3,2,6,5]\n输出: true\n\n\n1\n2\n\n1\n2\n\n\n提示：\n\n 1. 节点总数 <= 1000\n\n\n# 解题思路\n\n递归：\n\n二叉树中根节点的左节点始终比根节点小，右节点始终比根节点大，题目中数组末尾为根节点\n\n通过与root节点的大小比较，能够找到左子树的边界，从而划开左右子树\n\n在右子树中节点值始终比root节点大，如果不是，则这个序列不是后序遍历序列\n\n当找到划分边界后进行递归，判断左子树中哪些是左节点，哪些是又节点。右子树同理\n\n\n# java代码\n\nclass solution {\n    public boolean verifypostorder(int[] postorder) {\n        return helper(postorder,0,postorder.length-1);\n    }\n\n    public boolean helper(int[] postorder,int start,int end){\n        if(start>=end) return true;\n        int i = 0;\n        for(i=start;i<end;i++){\n            if(postorder[i]>postorder[end])\n                break;\n        }\n        for(int j = i;j<end;j++){\n            if(postorder[j]<postorder[end])\n                return false;\n        }\n        return helper(postorder,start,i-1)&&helper(postorder,i,end-1);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# python代码\n\nclass solution:\n    def verifypostorder(self, postorder: list[int]) -> bool:\n        length = len(postorder);\n        if not postorder:\n            return true\n        root = postorder[-1]\n        # 二叉树中左子树始终比根节点小，右子树比根节点大\n        # 寻找左子树边界\n        i = 0\n        for i in range(length):\n            if postorder[i]>root:\n                break;\n        j = i\n        for j in range(j,length):\n            if postorder[j]<root:\n                return false\n        # 判断左子树是不是二叉搜索树\n        left = true\n        if i>0: left = self.verifypostorder(postorder[:i])\n        # 判断右子树是不是二叉搜索树\n        right = true\n        if i<length-1: right = self.verifypostorder(postorder[i:-1])\n        return left and right\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题54-二叉搜索树的第k大节点",frontmatter:{title:"LeetCode-面试题54-二叉搜索树的第k大节点",date:"2020-05-12T16:34:23.000Z",description:"二叉搜索树的第k大节点",tags:["树","DFS","Java","Python","Easy","剑指Offer"],keywords:"树,Java,Easy,剑指Offer",permalink:"/pages/23d089/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/48.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9854-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9.html",relativePath:"06.算法/01.剑指Offer/48.LeetCode-面试题54-二叉搜索树的第k大节点.md",key:"v-9056ec2c",path:"/pages/23d089/",headers:[{level:2,title:"LeetCode-面试题54-二叉搜索树的第k大节点",slug:"leetcode-面试题54-二叉搜索树的第k大节点",normalizedTitle:"leetcode-面试题54-二叉搜索树的第k大节点",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:344},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:647},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:1388},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:1837}],headersStr:"LeetCode-面试题54-二叉搜索树的第k大节点 解题思路 Java代码 Java代码2 Python代码",content:"# LeetCode-面试题54-二叉搜索树的第k大节点\n\n给定一棵二叉搜索树，请找出其中第k大的节点。\n\n示例1：\n\n输入: root = [3,1,4,null,2], k = 1\n   3\n  / \\\n 1   4\n  \\\n   2\n输出: 4\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n示例2：\n\n输入: root = [5,3,6,2,4,null,null,1], k = 3\n       5\n      / \\\n     3   6\n    / \\\n   2   4\n  /\n 1\n输出: 4\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n * 限制：\n   \n   1 ≤ k ≤ 二叉搜索树元素个数\n\n\n# 解题思路\n\n方法1、中序遍历的倒序：\n\n对于二叉搜索树，左节点总是比根节点小，右节点总是比根节点大\n\n观察可以得知，中序遍历后得到的序列是递增的，求第K个大的节点可以转化为求中序遍历的倒序的第k个节点\n\n中序遍历序列一般可以用DFS得到\n\n对此可以先遍历右子节点，每遍历一个右子节点，计数器加1，之后遍历左子节点\n\n当计数器等于k时，返回对应节点的值\n\n方法2、栈式迭代：\n\n对于DFS和BFS问题，都可以利用一个栈来进行迭代计算，这里依旧采用倒序，先把所有的右子节点加入到stack中\n\n之后弹出栈顶元素，如果k==n，则返回当前节点值，否则，node=node.left，按照右中左的顺序遍历\n\n\n# Java代码\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    int res = 0, count = 0;\n    public int kthLargest(TreeNode root, int k) {\n        if(root==null||k==0)\n            return 0;\n        DFS(root,k);\n        return res;\n    }\n    public void DFS(TreeNode root,int k){\n        if(root == null) return;\n        DFS(root.right,k);\n        count++;\n        if(count==k){\n            res = root.val;\n        }\n        DFS(root.left,k);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# Java代码2\n\nclass Solution {\n    private List<Integer> res = new ArrayList<>();\n\n    public int kthLargest(TreeNode root, int k) {\n        dfs(root);\n        return res.get(k-1);\n    }\n\n    public void dfs(TreeNode root){\n        if(root==null){\n            return;\n        }\n        dfs(root.right);\n        res.add(root.val);\n        dfs(root.left);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# Python代码\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def kthLargest(self, root: TreeNode, k: int) -> int:\n        if not root:\n            return None\n        stack = []\n        node = root\n        while stack or node:\n            while node:\n                stack.append(node)\n                node = node.right\n            k -= 1\n            node = stack.pop()\n            if k == 0:\n                return node.val\n            node = node.left\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n",normalizedContent:"# leetcode-面试题54-二叉搜索树的第k大节点\n\n给定一棵二叉搜索树，请找出其中第k大的节点。\n\n示例1：\n\n输入: root = [3,1,4,null,2], k = 1\n   3\n  / \\\n 1   4\n  \\\n   2\n输出: 4\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n示例2：\n\n输入: root = [5,3,6,2,4,null,null,1], k = 3\n       5\n      / \\\n     3   6\n    / \\\n   2   4\n  /\n 1\n输出: 4\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n * 限制：\n   \n   1 ≤ k ≤ 二叉搜索树元素个数\n\n\n# 解题思路\n\n方法1、中序遍历的倒序：\n\n对于二叉搜索树，左节点总是比根节点小，右节点总是比根节点大\n\n观察可以得知，中序遍历后得到的序列是递增的，求第k个大的节点可以转化为求中序遍历的倒序的第k个节点\n\n中序遍历序列一般可以用dfs得到\n\n对此可以先遍历右子节点，每遍历一个右子节点，计数器加1，之后遍历左子节点\n\n当计数器等于k时，返回对应节点的值\n\n方法2、栈式迭代：\n\n对于dfs和bfs问题，都可以利用一个栈来进行迭代计算，这里依旧采用倒序，先把所有的右子节点加入到stack中\n\n之后弹出栈顶元素，如果k==n，则返回当前节点值，否则，node=node.left，按照右中左的顺序遍历\n\n\n# java代码\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    int res = 0, count = 0;\n    public int kthlargest(treenode root, int k) {\n        if(root==null||k==0)\n            return 0;\n        dfs(root,k);\n        return res;\n    }\n    public void dfs(treenode root,int k){\n        if(root == null) return;\n        dfs(root.right,k);\n        count++;\n        if(count==k){\n            res = root.val;\n        }\n        dfs(root.left,k);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# java代码2\n\nclass solution {\n    private list<integer> res = new arraylist<>();\n\n    public int kthlargest(treenode root, int k) {\n        dfs(root);\n        return res.get(k-1);\n    }\n\n    public void dfs(treenode root){\n        if(root==null){\n            return;\n        }\n        dfs(root.right);\n        res.add(root.val);\n        dfs(root.left);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# python代码\n\n# definition for a binary tree node.\n# class treenode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = none\n#         self.right = none\n\nclass solution:\n    def kthlargest(self, root: treenode, k: int) -> int:\n        if not root:\n            return none\n        stack = []\n        node = root\n        while stack or node:\n            while node:\n                stack.append(node)\n                node = node.right\n            k -= 1\n            node = stack.pop()\n            if k == 0:\n                return node.val\n            node = node.left\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题55-1-二叉树的深度",frontmatter:{title:"LeetCode-面试题55-1-二叉树的深度",date:"2020-05-14T18:54:51.000Z",description:"二叉树的深度",tags:["树","DFS","BFS","Java","Python","Easy","剑指Offer"],keywords:"树,DFS,BFS,Java,Easy,剑指Offer",permalink:"/pages/485921/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/49.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9855-1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6.html",relativePath:"06.算法/01.剑指Offer/49.LeetCode-面试题55-1-二叉树的深度.md",key:"v-7eeb95da",path:"/pages/485921/",headers:[{level:2,title:"LeetCode-面试题55-1-二叉树的深度",slug:"leetcode-面试题55-1-二叉树的深度",normalizedTitle:"leetcode-面试题55-1-二叉树的深度",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:241},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:378},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:895}],headersStr:"LeetCode-面试题55-1-二叉树的深度 解题思路 Java代码 Python代码",content:"# LeetCode-面试题55-1-二叉树的深度\n\n输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。\n\n示例1：\n\n给定二叉树 [3,9,20,null,null,15,7]，\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n返回它的最大深度 3 。\n\n * 提示：\n   1. 节点总数 <= 10000\n\n\n# 解题思路\n\n方法1、DFS：\n\n既然要求树的深度自然少不了深度优先遍历，通过比较左子树的深度和右子树的深度判断最大深度，之后加上根节点\n\n方法2、BFS：\n\n层序遍历一般也就是广度优先遍历，在原本队列的实现基础上，对一个层进行循环约束即可，每遍历完一层，深度就+1\n\n\n# Java代码\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root==null)\n            return 0;\n        int nleft = maxDepth(root.left);\n        int nright = maxDepth(root.right);\n        return Math.max(nleft,nright)+1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# Python代码\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def maxDepth(self, root: TreeNode) -> int:\n        if not root: return 0\n        queue , depth = [] , 0\n        queue.append(root)\n        while queue:\n            for i in range(len(queue)):\n                temp = queue.pop(0)\n                if temp.left:\n                    queue.append(temp.left)\n                if temp.right:\n                    queue.append(temp.right)\n            depth+=1\n        return depth\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n",normalizedContent:"# leetcode-面试题55-1-二叉树的深度\n\n输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。\n\n示例1：\n\n给定二叉树 [3,9,20,null,null,15,7]，\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n返回它的最大深度 3 。\n\n * 提示：\n   1. 节点总数 <= 10000\n\n\n# 解题思路\n\n方法1、dfs：\n\n既然要求树的深度自然少不了深度优先遍历，通过比较左子树的深度和右子树的深度判断最大深度，之后加上根节点\n\n方法2、bfs：\n\n层序遍历一般也就是广度优先遍历，在原本队列的实现基础上，对一个层进行循环约束即可，每遍历完一层，深度就+1\n\n\n# java代码\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public int maxdepth(treenode root) {\n        if(root==null)\n            return 0;\n        int nleft = maxdepth(root.left);\n        int nright = maxdepth(root.right);\n        return math.max(nleft,nright)+1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# python代码\n\n# definition for a binary tree node.\n# class treenode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = none\n#         self.right = none\n\nclass solution:\n    def maxdepth(self, root: treenode) -> int:\n        if not root: return 0\n        queue , depth = [] , 0\n        queue.append(root)\n        while queue:\n            for i in range(len(queue)):\n                temp = queue.pop(0)\n                if temp.left:\n                    queue.append(temp.left)\n                if temp.right:\n                    queue.append(temp.right)\n            depth+=1\n        return depth\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题12-矩阵中的路径",frontmatter:{title:"LeetCode-面试题12-矩阵中的路径",date:"2020-04-10T21:57:56.000Z",description:"矩阵中的路径",tags:["数组","回溯","Java","Python","Medium","剑指Offer"],keywords:"数组,回溯,Java,Python,Medium,剑指Offer",permalink:"/pages/254f95/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/50.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9812-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84.html",relativePath:"06.算法/01.剑指Offer/50.LeetCode-面试题12-矩阵中的路径.md",key:"v-7ea8e75a",path:"/pages/254f95/",headers:[{level:2,title:"LeetCode-面试题12-矩阵中的路径",slug:"leetcode-面试题12-矩阵中的路径",normalizedTitle:"leetcode-面试题12-矩阵中的路径",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:555},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:831},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:2598}],headersStr:"LeetCode-面试题12-矩阵中的路径 解题思路 Java代码 Python代码",content:'# LeetCode-面试题12-矩阵中的路径\n\n请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。\n\n[["a","b","c","e"], ["s","f","c","s"], ["a","d","e","e"]]\n\n但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。\n\n示例1\n\n输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"\n输出：true\n\n\n1\n2\n\n1\n2\n\n\n示例2\n\n输入：board = [["a","b"],["c","d"]], word = "abcd"\n输出：false\n\n\n1\n2\n\n1\n2\n\n\n提示：\n\n * 1 <= board.length <= 200\n * 1 <= board[i].length <= 200\n\n\n# 解题思路\n\n找路径可以用回溯法，递归实现。在矩阵中选择任意一个格子作为路径的七点，假设矩阵中某个格子的字符为ch，并且这个格子将对应于路径上的第i个字符。如果路径上的第i个字符不是ch，那么这个格子不可能处在路径上的第i个位置。如果路径上的第i个字符正好是ch，那么到相邻的格子寻找路径上的第i+1个字符。除矩阵边界上的格子之外，其他格子都有4个相邻的格子，重复这个过程，直到路径上的所有字符都在矩阵中找到相应的位置。\n\n需要递归的部分则是搜索一个格子的上下左右位置有没有下一个字符，如果都没有则说明当前位置不正确，范围上一个位置再进行搜索。\n\n\n# Java代码\n\nclass Solution {\n    public boolean exist(char[][] board, String word) {\n        int rowlen = board.length;\n        int collen = board[0].length;\n        boolean[][] visited = new boolean[rowlen][collen];\n        int pathlen = 0;\n        for (int row = 0; row < rowlen; row++) {\n            for (int col = 0; col < collen; col++) {\n                if (searchPath(board, row, rowlen, col, collen, word, visited, pathlen)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public boolean searchPath(char[][] board, int row, int rowlen, int col, int collen, String word, boolean[][] visited, int pathlen) {\n        if (pathlen == word.length())\n            return true;\n        boolean falg = false;\n        if (row >= 0 && row < rowlen && col >= 0 && col < collen\n                && board[row][col] == word.charAt(pathlen)\n                && !visited[row][col]) {\n            pathlen++;\n            visited[row][col] = true;\n            falg = searchPath(board, row - 1, rowlen, col, collen, word, visited, pathlen) ||\n                    searchPath(board, row + 1, rowlen, col, collen, word, visited, pathlen) ||\n                    searchPath(board, row, rowlen, col - 1, collen, word, visited, pathlen) ||\n                    searchPath(board, row, rowlen, col + 1, collen, word, visited, pathlen);\n            // 当都没有找到的时候，返回上一个位置\n            if (!falg) {\n                pathlen--;\n                visited[row][col] = false;\n            }\n        }\n        return falg;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# Python代码\n\nclass Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        def dfs(i, j, k):\n            if not 0 <= i < len(board) or not 0 <= j < len(board[0]) or board[i][j] != word[k]:                     return False\n            if k == len(word) - 1: return True\n            tmp, board[i][j] = board[i][j], \'/\'\n            res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)\n            board[i][j] = tmp\n            return res\n\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(i, j, 0): return True\n        return False\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n',normalizedContent:'# leetcode-面试题12-矩阵中的路径\n\n请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。\n\n[["a","b","c","e"], ["s","f","c","s"], ["a","d","e","e"]]\n\n但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。\n\n示例1\n\n输入：board = [["a","b","c","e"],["s","f","c","s"],["a","d","e","e"]], word = "abcced"\n输出：true\n\n\n1\n2\n\n1\n2\n\n\n示例2\n\n输入：board = [["a","b"],["c","d"]], word = "abcd"\n输出：false\n\n\n1\n2\n\n1\n2\n\n\n提示：\n\n * 1 <= board.length <= 200\n * 1 <= board[i].length <= 200\n\n\n# 解题思路\n\n找路径可以用回溯法，递归实现。在矩阵中选择任意一个格子作为路径的七点，假设矩阵中某个格子的字符为ch，并且这个格子将对应于路径上的第i个字符。如果路径上的第i个字符不是ch，那么这个格子不可能处在路径上的第i个位置。如果路径上的第i个字符正好是ch，那么到相邻的格子寻找路径上的第i+1个字符。除矩阵边界上的格子之外，其他格子都有4个相邻的格子，重复这个过程，直到路径上的所有字符都在矩阵中找到相应的位置。\n\n需要递归的部分则是搜索一个格子的上下左右位置有没有下一个字符，如果都没有则说明当前位置不正确，范围上一个位置再进行搜索。\n\n\n# java代码\n\nclass solution {\n    public boolean exist(char[][] board, string word) {\n        int rowlen = board.length;\n        int collen = board[0].length;\n        boolean[][] visited = new boolean[rowlen][collen];\n        int pathlen = 0;\n        for (int row = 0; row < rowlen; row++) {\n            for (int col = 0; col < collen; col++) {\n                if (searchpath(board, row, rowlen, col, collen, word, visited, pathlen)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public boolean searchpath(char[][] board, int row, int rowlen, int col, int collen, string word, boolean[][] visited, int pathlen) {\n        if (pathlen == word.length())\n            return true;\n        boolean falg = false;\n        if (row >= 0 && row < rowlen && col >= 0 && col < collen\n                && board[row][col] == word.charat(pathlen)\n                && !visited[row][col]) {\n            pathlen++;\n            visited[row][col] = true;\n            falg = searchpath(board, row - 1, rowlen, col, collen, word, visited, pathlen) ||\n                    searchpath(board, row + 1, rowlen, col, collen, word, visited, pathlen) ||\n                    searchpath(board, row, rowlen, col - 1, collen, word, visited, pathlen) ||\n                    searchpath(board, row, rowlen, col + 1, collen, word, visited, pathlen);\n            // 当都没有找到的时候，返回上一个位置\n            if (!falg) {\n                pathlen--;\n                visited[row][col] = false;\n            }\n        }\n        return falg;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# python代码\n\nclass solution:\n    def exist(self, board: list[list[str]], word: str) -> bool:\n        def dfs(i, j, k):\n            if not 0 <= i < len(board) or not 0 <= j < len(board[0]) or board[i][j] != word[k]:                     return false\n            if k == len(word) - 1: return true\n            tmp, board[i][j] = board[i][j], \'/\'\n            res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)\n            board[i][j] = tmp\n            return res\n\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(i, j, 0): return true\n        return false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题30-包含min函数的栈",frontmatter:{title:"LeetCode-面试题30-包含min函数的栈",date:"2020-04-21T14:42:06.000Z",description:"包含min函数的栈",tags:["栈","Java","Easy","剑指Offer"],keywords:"栈,Java,Easy,剑指Offer",permalink:"/pages/c9ae12/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/51.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9830-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88.html",relativePath:"06.算法/01.剑指Offer/51.LeetCode-面试题30-包含min函数的栈.md",key:"v-2e0e850c",path:"/pages/c9ae12/",headers:[{level:2,title:"LeetCode-面试题30-包含min函数的栈",slug:"leetcode-面试题30-包含min函数的栈",normalizedTitle:"leetcode-面试题30-包含min函数的栈",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:378},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:554}],headersStr:"LeetCode-面试题30-包含min函数的栈 解题思路 Java代码",content:"# LeetCode-面试题30-包含min函数的栈\n\n定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。\n\n示例1：\n\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.min();   --\x3e 返回 -3.\nminStack.pop();\nminStack.top();      --\x3e 返回 0.\nminStack.min();   --\x3e 返回 -2.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n提示：\n\n 1. 各函数的调用总次数不超过 20000 次\n\n\n# 解题思路\n\n辅助栈：数据栈再压入元素的时候与辅助栈的顶层元素(即之前数据栈的最小元素)做比较，如果比它小，就把值x同时压入数据栈和辅助栈。如果比它大，说明此时最小元素仍然是之前的最小元素，把辅助栈的栈顶取出来，数据栈压入x，辅助栈压入原本的辅助栈栈顶元素。这样就能保证辅助栈始终存放当前数据栈的最小值，在弹出数据时，同时弹出数据栈和辅助栈栈顶\n\n\n# Java代码\n\nclass MinStack {\n    private Stack<Integer> stack_data;\n    private Stack<Integer> stack_min;\n    /** initialize your data structure here. */\n    public MinStack() {\n        stack_data = new Stack<>();\n        stack_min = new Stack<>();\n    }\n    \n    public void push(int x) {\n        stack_data.push(x);\n        if(stack_min.size()==0||x<stack_min.peek())\n            stack_min.push(x);\n        else\n            stack_min.push(stack_min.peek());\n    }\n    \n    public void pop() {\n        stack_data.pop();\n        stack_min.pop();\n    }\n    \n    public int top() {\n        return stack_data.peek();\n    }\n    \n    public int min() {\n        return stack_min.peek();\n    }\n}\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack obj = new MinStack();\n * obj.push(x);\n * obj.pop();\n * int param_3 = obj.top();\n * int param_4 = obj.min();\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n",normalizedContent:"# leetcode-面试题30-包含min函数的栈\n\n定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 o(1)。\n\n示例1：\n\nminstack minstack = new minstack();\nminstack.push(-2);\nminstack.push(0);\nminstack.push(-3);\nminstack.min();   --\x3e 返回 -3.\nminstack.pop();\nminstack.top();      --\x3e 返回 0.\nminstack.min();   --\x3e 返回 -2.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n提示：\n\n 1. 各函数的调用总次数不超过 20000 次\n\n\n# 解题思路\n\n辅助栈：数据栈再压入元素的时候与辅助栈的顶层元素(即之前数据栈的最小元素)做比较，如果比它小，就把值x同时压入数据栈和辅助栈。如果比它大，说明此时最小元素仍然是之前的最小元素，把辅助栈的栈顶取出来，数据栈压入x，辅助栈压入原本的辅助栈栈顶元素。这样就能保证辅助栈始终存放当前数据栈的最小值，在弹出数据时，同时弹出数据栈和辅助栈栈顶\n\n\n# java代码\n\nclass minstack {\n    private stack<integer> stack_data;\n    private stack<integer> stack_min;\n    /** initialize your data structure here. */\n    public minstack() {\n        stack_data = new stack<>();\n        stack_min = new stack<>();\n    }\n    \n    public void push(int x) {\n        stack_data.push(x);\n        if(stack_min.size()==0||x<stack_min.peek())\n            stack_min.push(x);\n        else\n            stack_min.push(stack_min.peek());\n    }\n    \n    public void pop() {\n        stack_data.pop();\n        stack_min.pop();\n    }\n    \n    public int top() {\n        return stack_data.peek();\n    }\n    \n    public int min() {\n        return stack_min.peek();\n    }\n}\n\n/**\n * your minstack object will be instantiated and called as such:\n * minstack obj = new minstack();\n * obj.push(x);\n * obj.pop();\n * int param_3 = obj.top();\n * int param_4 = obj.min();\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题34-二叉树中和为某一值的路径",frontmatter:{title:"LeetCode-面试题34-二叉树中和为某一值的路径",date:"2020-04-22T18:32:02.000Z",description:"二叉树中和为某一值的路径",tags:["树","回溯","DFS","Java","Python","Medium","剑指Offer"],keywords:"树,回溯,DFS,Java,Python,Medium,剑指Offer",permalink:"/pages/e52256/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/52.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9834-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84.html",relativePath:"06.算法/01.剑指Offer/52.LeetCode-面试题34-二叉树中和为某一值的路径.md",key:"v-6adf3070",path:"/pages/e52256/",headers:[{level:2,title:"LeetCode-面试题34-二叉树中和为某一值的路径",slug:"leetcode-面试题34-二叉树中和为某一值的路径",normalizedTitle:"leetcode-面试题34-二叉树中和为某一值的路径",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:378},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:684},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:1600}],headersStr:"LeetCode-面试题34-二叉树中和为某一值的路径 解题思路 Java代码 Python代码",content:"# LeetCode-面试题34-二叉树中和为某一值的路径\n\n输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。\n\n示例：\n\n给定如下二叉树，以及目标和 sum = 22，\n\n              5\n             / \\\n            4   8\n           /   / \\\n          11  13  4\n         /  \\    / \\\n        7    2  5   1\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n返回\n\n[\n   [5,4,11,2],\n   [5,8,4,5]\n]\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n提示：\n\n 1. 节点总数 <= 10000\n\n\n# 解题思路\n\n初始化2个全局数组，之后进行DFS递归遍历\n\n对于TreeSearch函数：\n\n * 递归参数：当前节点node，当前目标值tar\n\n * 终止条件：若node为空，直接返回\n\n * 递归工作：\n   \n   路径更新：将node.val加入到路径path\n   \n   目标值更新：tar = tar-node.val，当目标值为0时说明路径符合要求\n   \n   路径记录：当node为叶子节点且路径值tar==0，则将path加入res\n   \n   先序遍历：递归左右子节点\n   \n   路径回溯：向上回溯前，需要将当前节点从路径path中删除，即删去path路径的最后一个节点值\n\n\n# Java代码\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    LinkedList<List<Integer>> res = new LinkedList<>();\n    LinkedList<Integer> path = new LinkedList<>();\n    public List<List<Integer>> pathSum(TreeNode root, int sum) {\n        TreeSearch(root,sum);\n        return res;\n    }\n    public void TreeSearch(TreeNode node,int tar){\n        if(node==null) return;\n        path.add(node.val);\n        tar-=node.val;\n        if(tar==0&&node.left==null&&node.right==null)\n            res.add(new LinkedList(path));\n        TreeSearch(node.left,tar);\n        TreeSearch(node.right,tar);\n        path.removeLast();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# Python代码\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def pathSum(self, root: TreeNode, sum: int) -> List[List[int]]:\n        if not root: return [];\n        res,stack = [],[]\n        def TreeSearch(root,curSum):\n            stack.append(root.val)\n            curSum +=root.val\n            if(curSum==sum) and not root.left and not root.right:\n                res.append(list(stack))\n            if root.left:\n                TreeSearch(root.left,curSum)\n            if root.right:\n                TreeSearch(root.right,curSum)\n            stack.pop()\n        TreeSearch(root,0)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n",normalizedContent:"# leetcode-面试题34-二叉树中和为某一值的路径\n\n输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。\n\n示例：\n\n给定如下二叉树，以及目标和 sum = 22，\n\n              5\n             / \\\n            4   8\n           /   / \\\n          11  13  4\n         /  \\    / \\\n        7    2  5   1\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n返回\n\n[\n   [5,4,11,2],\n   [5,8,4,5]\n]\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n提示：\n\n 1. 节点总数 <= 10000\n\n\n# 解题思路\n\n初始化2个全局数组，之后进行dfs递归遍历\n\n对于treesearch函数：\n\n * 递归参数：当前节点node，当前目标值tar\n\n * 终止条件：若node为空，直接返回\n\n * 递归工作：\n   \n   路径更新：将node.val加入到路径path\n   \n   目标值更新：tar = tar-node.val，当目标值为0时说明路径符合要求\n   \n   路径记录：当node为叶子节点且路径值tar==0，则将path加入res\n   \n   先序遍历：递归左右子节点\n   \n   路径回溯：向上回溯前，需要将当前节点从路径path中删除，即删去path路径的最后一个节点值\n\n\n# java代码\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    linkedlist<list<integer>> res = new linkedlist<>();\n    linkedlist<integer> path = new linkedlist<>();\n    public list<list<integer>> pathsum(treenode root, int sum) {\n        treesearch(root,sum);\n        return res;\n    }\n    public void treesearch(treenode node,int tar){\n        if(node==null) return;\n        path.add(node.val);\n        tar-=node.val;\n        if(tar==0&&node.left==null&&node.right==null)\n            res.add(new linkedlist(path));\n        treesearch(node.left,tar);\n        treesearch(node.right,tar);\n        path.removelast();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# python代码\n\n# definition for a binary tree node.\n# class treenode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = none\n#         self.right = none\n\nclass solution:\n    def pathsum(self, root: treenode, sum: int) -> list[list[int]]:\n        if not root: return [];\n        res,stack = [],[]\n        def treesearch(root,cursum):\n            stack.append(root.val)\n            cursum +=root.val\n            if(cursum==sum) and not root.left and not root.right:\n                res.append(list(stack))\n            if root.left:\n                treesearch(root.left,cursum)\n            if root.right:\n                treesearch(root.right,cursum)\n            stack.pop()\n        treesearch(root,0)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题46-把数字翻译成字符串",frontmatter:{title:"LeetCode-面试题46-把数字翻译成字符串",date:"2020-05-07T15:56:27.000Z",description:"把数字翻译成字符串",tags:["DP","回溯","数组","Java","Python","Medium","剑指Offer"],keywords:"DP,回溯,数组,Java,Python,Medium,剑指Offer",permalink:"/pages/73554a/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/53.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9846-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html",relativePath:"06.算法/01.剑指Offer/53.LeetCode-面试题46-把数字翻译成字符串.md",key:"v-2a14cc38",path:"/pages/73554a/",headers:[{level:2,title:"LeetCode-面试题46-把数字翻译成字符串",slug:"leetcode-面试题46-把数字翻译成字符串",normalizedTitle:"leetcode-面试题46-把数字翻译成字符串",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:271},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:764},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:1296}],headersStr:"LeetCode-面试题46-把数字翻译成字符串 解题思路 Java代码 Python代码",content:'# LeetCode-面试题46-把数字翻译成字符串\n\n给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。\n\n示例1：\n\n输入: 12258\n输出: 5\n解释: 12258有5种不同的翻译，分别是"bccfi", "bwfi", "bczi", "mcfi"和"mzi"\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n限制：\n\n * 0 <= num < 2^31\n\n\n# 解题思路\n\n动态规划：\n\n初始化dp[0]=dp[1]=1，即翻译"无数字"和"第1位数字"的翻译方法数量均为1\n\n当num的第1，2位的组成的数字属于[10,25]时，dp[2]=dp[1]+dp[0]=2，有2种翻译方法，显然dp[1]=1，所以dp[0]=1\n\n * 当1个数被翻译为1个字母时，剩下的方案即dp[i-1]，dp[i]=dp[i-1]\n * 当2个数组合在[10,25]的范围时，方案有2种，一是翻译1个数，二是翻译2个组合的数，dp[i] = dp[i-1]+dp[i-2]\n\n为了优化空间，这里使用2个变量，分别代表dp[i]和dp[i-1]，当i从2开始时，dp[2]就可以通过dp0+dp1得到，之后顺序递推这两个数值\n\n递归(回溯)：\n\n想象成一棵二叉树，可以选择翻译1个数，也可以选择翻译1个组合数\n\n当二叉树走的深度没有达到字符串长度时，就要进行判断\n\n * 如果组合数符合[10,25]，则翻译的可能性有使用1个数字i+1和使用2个数字i+2两种可能，开启2种可能的递归调用。\n * 如果不符合，则翻译只有一种可能，即i+1深度下的可能性\n\n\n# Java代码\n\nclass Solution {\n    public int translateNum(int num) {\n        if(num<0)\n            return 0;\n        String s = String.valueOf(num);\n        int dp0 = 1;\n        int dp1 = 1;\n        for(int i=2;i<=s.length();i++){\n            String temp = s.substring(i-2,i);\n            int res = temp.compareTo("10")>=0&&temp.compareTo("25")<=0 ? dp0 + dp1 : dp1;\n            dp0 = dp1;\n            dp1 = res;\n        }\n        return dp1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# Python代码\n\nclass Solution:\n    def translateNum(self, num: int) -> int:\n        s = str(num)\n        length = len(s)-1\n        return self.Sum(s,0,length)\n    \n    def Sum(self,s,i,length):\n        if i >=length:\n            return 1\n        if i<=length-1:\n            nsum = int(s[i])*10+int(s[i+1])\n            if nsum>=10 and nsum<=25:\n                return self.Sum(s,i+1,length)+self.Sum(s,i+2,length)\n            else:\n                return self.Sum(s,i+1,length)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n',normalizedContent:'# leetcode-面试题46-把数字翻译成字符串\n\n给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。\n\n示例1：\n\n输入: 12258\n输出: 5\n解释: 12258有5种不同的翻译，分别是"bccfi", "bwfi", "bczi", "mcfi"和"mzi"\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n限制：\n\n * 0 <= num < 2^31\n\n\n# 解题思路\n\n动态规划：\n\n初始化dp[0]=dp[1]=1，即翻译"无数字"和"第1位数字"的翻译方法数量均为1\n\n当num的第1，2位的组成的数字属于[10,25]时，dp[2]=dp[1]+dp[0]=2，有2种翻译方法，显然dp[1]=1，所以dp[0]=1\n\n * 当1个数被翻译为1个字母时，剩下的方案即dp[i-1]，dp[i]=dp[i-1]\n * 当2个数组合在[10,25]的范围时，方案有2种，一是翻译1个数，二是翻译2个组合的数，dp[i] = dp[i-1]+dp[i-2]\n\n为了优化空间，这里使用2个变量，分别代表dp[i]和dp[i-1]，当i从2开始时，dp[2]就可以通过dp0+dp1得到，之后顺序递推这两个数值\n\n递归(回溯)：\n\n想象成一棵二叉树，可以选择翻译1个数，也可以选择翻译1个组合数\n\n当二叉树走的深度没有达到字符串长度时，就要进行判断\n\n * 如果组合数符合[10,25]，则翻译的可能性有使用1个数字i+1和使用2个数字i+2两种可能，开启2种可能的递归调用。\n * 如果不符合，则翻译只有一种可能，即i+1深度下的可能性\n\n\n# java代码\n\nclass solution {\n    public int translatenum(int num) {\n        if(num<0)\n            return 0;\n        string s = string.valueof(num);\n        int dp0 = 1;\n        int dp1 = 1;\n        for(int i=2;i<=s.length();i++){\n            string temp = s.substring(i-2,i);\n            int res = temp.compareto("10")>=0&&temp.compareto("25")<=0 ? dp0 + dp1 : dp1;\n            dp0 = dp1;\n            dp1 = res;\n        }\n        return dp1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# python代码\n\nclass solution:\n    def translatenum(self, num: int) -> int:\n        s = str(num)\n        length = len(s)-1\n        return self.sum(s,0,length)\n    \n    def sum(self,s,i,length):\n        if i >=length:\n            return 1\n        if i<=length-1:\n            nsum = int(s[i])*10+int(s[i+1])\n            if nsum>=10 and nsum<=25:\n                return self.sum(s,i+1,length)+self.sum(s,i+2,length)\n            else:\n                return self.sum(s,i+1,length)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题55-2-平衡二叉树",frontmatter:{title:"LeetCode-面试题55-2-平衡二叉树",date:"2020-05-18T12:58:06.000Z",description:"平衡二叉树",tags:["树","DFS","Java","Python","Easy","剑指Offer"],keywords:"树,DFS,Java,Python,Easy,剑指Offer",permalink:"/pages/8564b7/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/54.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9855-2-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html",relativePath:"06.算法/01.剑指Offer/54.LeetCode-面试题55-2-平衡二叉树.md",key:"v-61cc9f77",path:"/pages/8564b7/",headers:[{level:2,title:"LeetCode-面试题55-2-平衡二叉树",slug:"leetcode-面试题55-2-平衡二叉树",normalizedTitle:"leetcode-面试题55-2-平衡二叉树",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:388},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:678},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:1522}],headersStr:"LeetCode-面试题55-2-平衡二叉树 解题思路 Java代码 Python代码",content:"# LeetCode-面试题55-2-平衡二叉树\n\n输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。\n\n示例1：\n\n给定二叉树 [3,9,20,null,null,15,7]，\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n返回true 。\n\n示例 2:\n\n给定二叉树 [1,2,2,3,3,null,null,4,4]\n\n       1\n      / \\\n     2   2\n    / \\\n   3   3\n  / \\\n 4   4\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n返回 false 。\n\n * 限制：\n   1. 1 <= 树的结点个数 <= 10000\n\n\n# 解题思路\n\n方法1、DFS分别求深度：\n\n这种方法就是上一个题的延续了，但是由于需要对每一个节点求对应的左右子树的深度，会造成很多重复计算。这是一个简单的解法但是不是好的解法\n\n方法2、后序遍历+剪枝：\n\n这是一个从底至顶的解法，当节点的左右子树的深度差<=1时，就返回当前子树的深度\n\n当前子树的深度由max(left,right)+1计算得到，如果不满足深度差条件，则说明子树不平衡，直接返回-1\n\n递归的终止条件是，当root为空，说明越过叶子节点，返回深度0\n\n当左右子树的深度不平衡时，即left==-1||right==-1时，提前终止递归进行剪枝，返回-1\n\n\n# Java代码\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public boolean isBalanced(TreeNode root) {\n        if(root==null) return true;\n        int nleft = DFS(root.left);\n        int nright = DFS(root.right);\n        int n = Math.abs(nleft-nright);\n        if(n>1)\n            return false;\n        return isBalanced(root.left)&&isBalanced(root.right);\n    }\n    public int DFS(TreeNode root){\n        if(root==null) return 0;\n        int nleft = DFS(root.left);\n        int nright = DFS(root.right);\n        return Math.max(nleft,nright)+1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# Python代码\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def isBalanced(self, root: TreeNode) -> bool:\n        return self.helper(root)!=-1\n\n    def helper(self,root:TreeNode)-> int:\n        if not root: return 0\n        left = self.helper(root.left)\n        if left==-1: return -1\n        right = self.helper(root.right)\n        if right==-1: return -1\n        return max(left,right)+1 if abs(left-right)<=1 else -1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n",normalizedContent:"# leetcode-面试题55-2-平衡二叉树\n\n输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。\n\n示例1：\n\n给定二叉树 [3,9,20,null,null,15,7]，\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n返回true 。\n\n示例 2:\n\n给定二叉树 [1,2,2,3,3,null,null,4,4]\n\n       1\n      / \\\n     2   2\n    / \\\n   3   3\n  / \\\n 4   4\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n返回 false 。\n\n * 限制：\n   1. 1 <= 树的结点个数 <= 10000\n\n\n# 解题思路\n\n方法1、dfs分别求深度：\n\n这种方法就是上一个题的延续了，但是由于需要对每一个节点求对应的左右子树的深度，会造成很多重复计算。这是一个简单的解法但是不是好的解法\n\n方法2、后序遍历+剪枝：\n\n这是一个从底至顶的解法，当节点的左右子树的深度差<=1时，就返回当前子树的深度\n\n当前子树的深度由max(left,right)+1计算得到，如果不满足深度差条件，则说明子树不平衡，直接返回-1\n\n递归的终止条件是，当root为空，说明越过叶子节点，返回深度0\n\n当左右子树的深度不平衡时，即left==-1||right==-1时，提前终止递归进行剪枝，返回-1\n\n\n# java代码\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public boolean isbalanced(treenode root) {\n        if(root==null) return true;\n        int nleft = dfs(root.left);\n        int nright = dfs(root.right);\n        int n = math.abs(nleft-nright);\n        if(n>1)\n            return false;\n        return isbalanced(root.left)&&isbalanced(root.right);\n    }\n    public int dfs(treenode root){\n        if(root==null) return 0;\n        int nleft = dfs(root.left);\n        int nright = dfs(root.right);\n        return math.max(nleft,nright)+1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# python代码\n\n# definition for a binary tree node.\n# class treenode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = none\n#         self.right = none\n\nclass solution:\n    def isbalanced(self, root: treenode) -> bool:\n        return self.helper(root)!=-1\n\n    def helper(self,root:treenode)-> int:\n        if not root: return 0\n        left = self.helper(root.left)\n        if left==-1: return -1\n        right = self.helper(root.right)\n        if right==-1: return -1\n        return max(left,right)+1 if abs(left-right)<=1 else -1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题56-1-数组中数字出现的次数",frontmatter:{title:"LeetCode-面试题56-1-数组中数字出现的次数",date:"2020-05-18T16:06:08.000Z",description:"数组中数字出现的次数",tags:["数组","Java","Medium","剑指Offer"],keywords:"数组,Java,Medium,剑指Offer",permalink:"/pages/0dd136/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/55.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9856-1-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B01.html",relativePath:"06.算法/01.剑指Offer/55.LeetCode-面试题56-1-数组中数字出现的次数1.md",key:"v-54199694",path:"/pages/0dd136/",headers:[{level:2,title:"LeetCode-面试题56-1-数组中数字出现的次数",slug:"leetcode-面试题56-1-数组中数字出现的次数",normalizedTitle:"leetcode-面试题56-1-数组中数字出现的次数",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:275},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:537}],headersStr:"LeetCode-面试题56-1-数组中数字出现的次数 解题思路 Java代码",content:"# LeetCode-面试题56-1-数组中数字出现的次数\n\n一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。\n\n示例1：\n\n输入：nums = [4,1,4,6]\n输出：[1,6] 或 [6,1]\n\n\n1\n2\n\n1\n2\n\n\n示例 2:\n\n输入：nums = [1,2,10,4,1,4,3,3]\n输出：[2,10] 或 [10,2]\n\n\n1\n2\n\n1\n2\n\n\n * 限制：\n   \n   2 <= nums.length <= 10000\n\n\n# 解题思路\n\n异或运算(单1为1，其余0)：\n\n根据异或运算的特点，相同的数字会在异或的时候抵消了，不相同的数字，其不相同的位会被保留\n\n如果数组中有2个数字是不相同的，所以对数组整体异或之后，剩下的数字肯定至少有一位为1\n\n如果能够找到第一个为1的那一位，那么就能够通过判断这一位是否为1，而划分数组为2个子数组\n\n这样问题就分解成了，分别寻找2个子数组中，只出现一次的数字\n\n由于判断位的条件具有二分性，当判断出一个不相同的数字位为1时，另一个数字该位则不为1，于是划分的子数组中自然一个数组会包含一个不相同数字\n\n\n# Java代码\n\nclass Solution {\n    public int[] singleNumbers(int[] nums) {\n        int temp=0;\n        // 数组整体异或\n        for(int i:nums)\n            temp^=i;\n        // 初始化mask=1\n        int mask = 1;\n        // 通过mask，判断第一次出现1的位数\n        while((temp&mask)==0){\n            mask<<=1;\n        }\n        int num1 = 0;\n        int num2 = 0;\n        for(int j:nums){\n            // 通过判断1出现的位置和数组元素与运算结果是否为0，来二分数组\n            if((j&mask)==0){ // 相同的数字会分在一起，但不同的数字会因此隔开\n                num1^=j;\n            }else{\n                num2^=j;\n            }\n        }\n        return new int[]{num1,num2};\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n",normalizedContent:"# leetcode-面试题56-1-数组中数字出现的次数\n\n一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是o(n)，空间复杂度是o(1)。\n\n示例1：\n\n输入：nums = [4,1,4,6]\n输出：[1,6] 或 [6,1]\n\n\n1\n2\n\n1\n2\n\n\n示例 2:\n\n输入：nums = [1,2,10,4,1,4,3,3]\n输出：[2,10] 或 [10,2]\n\n\n1\n2\n\n1\n2\n\n\n * 限制：\n   \n   2 <= nums.length <= 10000\n\n\n# 解题思路\n\n异或运算(单1为1，其余0)：\n\n根据异或运算的特点，相同的数字会在异或的时候抵消了，不相同的数字，其不相同的位会被保留\n\n如果数组中有2个数字是不相同的，所以对数组整体异或之后，剩下的数字肯定至少有一位为1\n\n如果能够找到第一个为1的那一位，那么就能够通过判断这一位是否为1，而划分数组为2个子数组\n\n这样问题就分解成了，分别寻找2个子数组中，只出现一次的数字\n\n由于判断位的条件具有二分性，当判断出一个不相同的数字位为1时，另一个数字该位则不为1，于是划分的子数组中自然一个数组会包含一个不相同数字\n\n\n# java代码\n\nclass solution {\n    public int[] singlenumbers(int[] nums) {\n        int temp=0;\n        // 数组整体异或\n        for(int i:nums)\n            temp^=i;\n        // 初始化mask=1\n        int mask = 1;\n        // 通过mask，判断第一次出现1的位数\n        while((temp&mask)==0){\n            mask<<=1;\n        }\n        int num1 = 0;\n        int num2 = 0;\n        for(int j:nums){\n            // 通过判断1出现的位置和数组元素与运算结果是否为0，来二分数组\n            if((j&mask)==0){ // 相同的数字会分在一起，但不同的数字会因此隔开\n                num1^=j;\n            }else{\n                num2^=j;\n            }\n        }\n        return new int[]{num1,num2};\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题56-2-数组中数字出现的次数2",frontmatter:{title:"LeetCode-面试题56-2-数组中数字出现的次数2",date:"2020-05-18T17:13:05.000Z",description:"数组中数字出现的次数2",tags:["数组","Java","Python","Medium","剑指Offer"],keywords:"数组,Java,Python,Medium,剑指Offer",permalink:"/pages/322274/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/56.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9856-2-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B02.html",relativePath:"06.算法/01.剑指Offer/56.LeetCode-面试题56-2-数组中数字出现的次数2.md",key:"v-25a72634",path:"/pages/322274/",headers:[{level:2,title:"LeetCode-面试题56-2-数组中数字出现的次数2",slug:"leetcode-面试题56-2-数组中数字出现的次数2",normalizedTitle:"leetcode-面试题56-2-数组中数字出现的次数2",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:250},{level:3,title:"Java代码1",slug:"java代码1",normalizedTitle:"java代码1",charIndex:489},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:1473},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:1882}],headersStr:"LeetCode-面试题56-2-数组中数字出现的次数2 解题思路 Java代码1 Python代码 Java代码2",content:"# LeetCode-面试题56-2-数组中数字出现的次数2\n\n在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。\n\n示例1：\n\n输入：nums = [3,4,3,3]\n输出：4\n\n\n1\n2\n\n1\n2\n\n\n示例 2:\n\n输入：nums = [9,1,7,9,7,9,7]\n输出：1\n\n\n1\n2\n\n1\n2\n\n\n * 限制：\n   \n   * 1 <= nums.length <= 10000\n   * 1 <= nums[i] < 2^31\n\n\n# 解题思路\n\n方法1、异或运算(单1为1，其余0)：\n\n先对所有数字的各个位求和，求和之后的数字，能够被3整除的，则该位为0，不能够被整除的，则该位为1，之后就能够通过2进制求出对应的数字\n\n方法2、字典：\n\n遇到没在字典的加入，在字典就+1，最后取value为1的key即可\n\n方法3、数组：\n\n先给数组排序，排序之后判断当前位和后面2位是否相等，如果相等则跳过这3位，i+3\n\n如果不相等，则说明当前为就是要找的数字\n\n如果前面都没有找到，则最后一位必定是要找的数字\n\n\n# Java代码1\n\nclass Solution {\n    public int singleNumber(int[] nums) {\n        if(nums==null||nums.length<=0)\n            return -1;\n        int[] bitSum = new int[32]; // 最高2^31次方数字\n        for(int i =0;i<nums.length;i++){\n            int bitMask = 1;\n            // 累加各个位置的二进制表示\n            // 这里从数组末尾开始，对应二进制最小位\n            for(int j = 31;j>=0;j--){\n                int bit = nums[i]&bitMask;\n                if(bit!=0)\n                    bitSum[j]+=1;\n                    bitMask<<=1;\n            }\n        }\n        int result = 0;\n        // 从数组0位开始，对应于数字的高位，当遍历到余数为1时，res仅为1，比如数字8的二进制为0100\n        // 从左到右遍历，当遍历到数字1时\n        // 此时res为1，想要从1变成8，需要向左移动2位，而for循环剩下的次数就是需要<<左移的次数，最后得到res才是正确的\n        for(int i =0;i<32;i++){\n            result = result<<1;\n            result+=bitSum[i]%3;\n        }\n        return result;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# Python代码\n\nclass Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        if not nums: return -1\n        dic = {}\n        for i in nums:\n            if i not in dic:\n                dic[i] = 1\n            else:\n                dic[i] +=1\n        for i in dic:\n            if dic[i]==1:\n                return i\n        return -1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# Java代码2\n\nclass Solution {\n    public int singleNumber(int[] nums) {\n        if(nums==null||nums.length<=0)\n            return -1;\n        Arrays.sort(nums);\n        for(int i = 0;i<nums.length-3;){\n            if(nums[i]==nums[i+1]&&nums[i+1]==nums[i+2])\n                i+=3;\n            else\n                return nums[i];\n        }\n        return nums[nums.length-1];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n",normalizedContent:"# leetcode-面试题56-2-数组中数字出现的次数2\n\n在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。\n\n示例1：\n\n输入：nums = [3,4,3,3]\n输出：4\n\n\n1\n2\n\n1\n2\n\n\n示例 2:\n\n输入：nums = [9,1,7,9,7,9,7]\n输出：1\n\n\n1\n2\n\n1\n2\n\n\n * 限制：\n   \n   * 1 <= nums.length <= 10000\n   * 1 <= nums[i] < 2^31\n\n\n# 解题思路\n\n方法1、异或运算(单1为1，其余0)：\n\n先对所有数字的各个位求和，求和之后的数字，能够被3整除的，则该位为0，不能够被整除的，则该位为1，之后就能够通过2进制求出对应的数字\n\n方法2、字典：\n\n遇到没在字典的加入，在字典就+1，最后取value为1的key即可\n\n方法3、数组：\n\n先给数组排序，排序之后判断当前位和后面2位是否相等，如果相等则跳过这3位，i+3\n\n如果不相等，则说明当前为就是要找的数字\n\n如果前面都没有找到，则最后一位必定是要找的数字\n\n\n# java代码1\n\nclass solution {\n    public int singlenumber(int[] nums) {\n        if(nums==null||nums.length<=0)\n            return -1;\n        int[] bitsum = new int[32]; // 最高2^31次方数字\n        for(int i =0;i<nums.length;i++){\n            int bitmask = 1;\n            // 累加各个位置的二进制表示\n            // 这里从数组末尾开始，对应二进制最小位\n            for(int j = 31;j>=0;j--){\n                int bit = nums[i]&bitmask;\n                if(bit!=0)\n                    bitsum[j]+=1;\n                    bitmask<<=1;\n            }\n        }\n        int result = 0;\n        // 从数组0位开始，对应于数字的高位，当遍历到余数为1时，res仅为1，比如数字8的二进制为0100\n        // 从左到右遍历，当遍历到数字1时\n        // 此时res为1，想要从1变成8，需要向左移动2位，而for循环剩下的次数就是需要<<左移的次数，最后得到res才是正确的\n        for(int i =0;i<32;i++){\n            result = result<<1;\n            result+=bitsum[i]%3;\n        }\n        return result;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# python代码\n\nclass solution:\n    def singlenumber(self, nums: list[int]) -> int:\n        if not nums: return -1\n        dic = {}\n        for i in nums:\n            if i not in dic:\n                dic[i] = 1\n            else:\n                dic[i] +=1\n        for i in dic:\n            if dic[i]==1:\n                return i\n        return -1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# java代码2\n\nclass solution {\n    public int singlenumber(int[] nums) {\n        if(nums==null||nums.length<=0)\n            return -1;\n        arrays.sort(nums);\n        for(int i = 0;i<nums.length-3;){\n            if(nums[i]==nums[i+1]&&nums[i+1]==nums[i+2])\n                i+=3;\n            else\n                return nums[i];\n        }\n        return nums[nums.length-1];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题57-和为s的两个数字",frontmatter:{title:"LeetCode-面试题57-和为s的两个数字",date:"2020-05-19T09:15:38.000Z",description:"和为s的两个数字",tags:["数组","Java","Python","Easy","剑指Offer"],keywords:"数组,Java,Python,Easy,剑指Offer",permalink:"/pages/64b7a6/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/57.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9857-1-%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97.html",relativePath:"06.算法/01.剑指Offer/57.LeetCode-面试题57-1-和为s的两个数字.md",key:"v-38ae4266",path:"/pages/64b7a6/",headers:[{level:2,title:"LeetCode-面试题57-和为s的两个数字",slug:"leetcode-面试题57-和为s的两个数字",normalizedTitle:"leetcode-面试题57-和为s的两个数字",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:308},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:424},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:1007}],headersStr:"LeetCode-面试题57-和为s的两个数字 解题思路 Java代码 Python代码",content:"# LeetCode-面试题57-和为s的两个数字\n\n输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。\n\n示例1：\n\n输入：nums = [2,7,11,15], target = 9\n输出：[2,7] 或者 [7,2]\n\n\n1\n2\n\n1\n2\n\n\n示例 2:\n\n输入：nums = [10,26,30,31,47,60], target = 40\n输出：[10,30] 或者 [30,10]\n\n\n1\n2\n\n1\n2\n\n\n限制：\n\n * 1 <= nums.length <= 10^5\n * 1 <= nums[i] <= 10^6\n\n\n# 解题思路\n\n查找思想：\n\n一个头指针一个尾指针，在递增排序的数组中，\n\n如果对应位置之和大于target，说明需要取小一点，左移尾指针让数值变小\n\n如果对应位置之和小于target，说明需要取大一点，右移头指针，让数值变大\n\n\n# Java代码\n\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        if(nums==null||nums.length<=0)\n            return new int[0];\n        int start = 0;\n        int end = nums.length-1;\n        while(start<end){\n            if(nums[start]+nums[end]<target)\n                start+=1;\n            else if(nums[start]+nums[end]>target)\n                end-=1;\n            else\n                return new int[]{nums[start],nums[end]};\n        }\n        return new int[0];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# Python代码\n\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        start,end = 0,len(nums)-1\n        while start<end:\n            if nums[start]+nums[end]>target:\n                end-=1\n            elif nums[start]+nums[end]<target:\n                start+=1\n            else: return nums[start],nums[end]\n        return []\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n",normalizedContent:"# leetcode-面试题57-和为s的两个数字\n\n输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。\n\n示例1：\n\n输入：nums = [2,7,11,15], target = 9\n输出：[2,7] 或者 [7,2]\n\n\n1\n2\n\n1\n2\n\n\n示例 2:\n\n输入：nums = [10,26,30,31,47,60], target = 40\n输出：[10,30] 或者 [30,10]\n\n\n1\n2\n\n1\n2\n\n\n限制：\n\n * 1 <= nums.length <= 10^5\n * 1 <= nums[i] <= 10^6\n\n\n# 解题思路\n\n查找思想：\n\n一个头指针一个尾指针，在递增排序的数组中，\n\n如果对应位置之和大于target，说明需要取小一点，左移尾指针让数值变小\n\n如果对应位置之和小于target，说明需要取大一点，右移头指针，让数值变大\n\n\n# java代码\n\nclass solution {\n    public int[] twosum(int[] nums, int target) {\n        if(nums==null||nums.length<=0)\n            return new int[0];\n        int start = 0;\n        int end = nums.length-1;\n        while(start<end){\n            if(nums[start]+nums[end]<target)\n                start+=1;\n            else if(nums[start]+nums[end]>target)\n                end-=1;\n            else\n                return new int[]{nums[start],nums[end]};\n        }\n        return new int[0];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# python代码\n\nclass solution:\n    def twosum(self, nums: list[int], target: int) -> list[int]:\n        start,end = 0,len(nums)-1\n        while start<end:\n            if nums[start]+nums[end]>target:\n                end-=1\n            elif nums[start]+nums[end]<target:\n                start+=1\n            else: return nums[start],nums[end]\n        return []\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题58-1-翻转单词顺序",frontmatter:{title:"LeetCode-面试题58-1-翻转单词顺序",date:"2020-05-19T11:09:40.000Z",description:"翻转单词顺序",tags:["字符串","Java","Python","Easy","剑指Offer"],keywords:"字符串,Java,Python,Easy,剑指Offer",permalink:"/pages/9fdad5/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/58.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9858-1-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F.html",relativePath:"06.算法/01.剑指Offer/58.LeetCode-面试题58-1-翻转单词顺序.md",key:"v-1edd9c60",path:"/pages/9fdad5/",headers:[{level:2,title:"LeetCode-面试题58-1-翻转单词顺序",slug:"leetcode-面试题58-1-翻转单词顺序",normalizedTitle:"leetcode-面试题58-1-翻转单词顺序",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:501},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:753},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:1354}],headersStr:"LeetCode-面试题58-1-翻转单词顺序 解题思路 Java代码 Python代码",content:'# LeetCode-面试题58-1-翻转单词顺序\n\n输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串"I am a student. "，则输出"student. a am I"。\n\n示例1：\n\n输入: "the sky is blue"\n输出: "blue is sky the"\n\n\n1\n2\n\n1\n2\n\n\n示例 2:\n\n输入: "  hello world!  "\n输出: "world! hello"\n解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例3：\n\n输入: "a good   example"\n输出: "example good a"\n解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n说明：\n\n * 无空格字符构成一个单词。\n * 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。\n * 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。\n\n\n# 解题思路\n\n双指针切割交换(Python)：\n\n多余的空格直接用split()函数就能够处理，切分之后，利用双指针不断首尾交换，就能够固定单词，翻转单词位置，之后返回字符串即可，这种方法比较偷懒\n\n双指针记录位置(Java)：\n\n初始化两个指针从数组的末尾开始\n\n * 当遇到的字符不是空格时，移动start指针，找到单词的开头，然后利用substring方法截取单词\n * 当遇到的字符是空格时，继续移动start指针，找到下一个单词的末尾，将end指针移动到start位置，重复以上步骤即可\n\n\n# Java代码\n\nclass Solution {\n    public String reverseWords(String s) {\n        s = s.trim();\n        int start =  s.length()-1;\n        int end = start;\n        StringBuilder res = new StringBuilder();\n        while(start>=0){\n            while(start>=0&&s.charAt(start)!=\' \')\n                start--;\n            res.append(s.substring(start+1,end+1)+" ");\n            while(start>=0&&s.charAt(start)==\' \')\n                start--;\n            end=start;\n        }\n        return res.toString().trim();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# Python代码\n\nclass Solution:\n    def reverseWords(self, s: str) -> str:\n        arr = s.split()\n        start = 0\n        end = len(arr)-1\n        while start<end:\n            temp = arr[start]\n            arr[start] = arr[end]\n            arr[end] = temp\n            start+=1\n            end-=1\n        return " ".join(arr)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n',normalizedContent:'# leetcode-面试题58-1-翻转单词顺序\n\n输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串"i am a student. "，则输出"student. a am i"。\n\n示例1：\n\n输入: "the sky is blue"\n输出: "blue is sky the"\n\n\n1\n2\n\n1\n2\n\n\n示例 2:\n\n输入: "  hello world!  "\n输出: "world! hello"\n解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例3：\n\n输入: "a good   example"\n输出: "example good a"\n解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n说明：\n\n * 无空格字符构成一个单词。\n * 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。\n * 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。\n\n\n# 解题思路\n\n双指针切割交换(python)：\n\n多余的空格直接用split()函数就能够处理，切分之后，利用双指针不断首尾交换，就能够固定单词，翻转单词位置，之后返回字符串即可，这种方法比较偷懒\n\n双指针记录位置(java)：\n\n初始化两个指针从数组的末尾开始\n\n * 当遇到的字符不是空格时，移动start指针，找到单词的开头，然后利用substring方法截取单词\n * 当遇到的字符是空格时，继续移动start指针，找到下一个单词的末尾，将end指针移动到start位置，重复以上步骤即可\n\n\n# java代码\n\nclass solution {\n    public string reversewords(string s) {\n        s = s.trim();\n        int start =  s.length()-1;\n        int end = start;\n        stringbuilder res = new stringbuilder();\n        while(start>=0){\n            while(start>=0&&s.charat(start)!=\' \')\n                start--;\n            res.append(s.substring(start+1,end+1)+" ");\n            while(start>=0&&s.charat(start)==\' \')\n                start--;\n            end=start;\n        }\n        return res.tostring().trim();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# python代码\n\nclass solution:\n    def reversewords(self, s: str) -> str:\n        arr = s.split()\n        start = 0\n        end = len(arr)-1\n        while start<end:\n            temp = arr[start]\n            arr[start] = arr[end]\n            arr[end] = temp\n            start+=1\n            end-=1\n        return " ".join(arr)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题58-2-左旋转字符串",frontmatter:{title:"LeetCode-面试题58-2-左旋转字符串",date:"2020-05-19T14:47:01.000Z",description:"左旋转字符串",tags:["字符串","Java","Python","Easy","剑指Offer"],keywords:"字符串,Java,Python,Easy,剑指Offer",permalink:"/pages/7c648d/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/59.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9858-2-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html",relativePath:"06.算法/01.剑指Offer/59.LeetCode-面试题58-2-左旋转字符串.md",key:"v-199b1610",path:"/pages/7c648d/",headers:[{level:2,title:"LeetCode-面试题58-2-左旋转字符串",slug:"leetcode-面试题58-2-左旋转字符串",normalizedTitle:"leetcode-面试题58-2-左旋转字符串",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:292},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:402},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:913}],headersStr:"LeetCode-面试题58-2-左旋转字符串 解题思路 Java代码 Python代码",content:'# LeetCode-面试题58-2-左旋转字符串\n\n字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。\n\n示例1：\n\n输入: s = "abcdefg", k = 2\n输出: "cdefgab"\n\n\n1\n2\n\n1\n2\n\n\n示例 2:\n\n输入: s = "lrloseumgh", k = 6\n输出: "umghlrlose"\n\n\n1\n2\n\n1\n2\n\n\n限制：\n\n * 1 <= k < s.length <= 10000\n\n\n# 解题思路\n\n线性遍历：\n\nn已经给出来了，第一部分字符串就是从n到字符末尾，第二部分字符串是从字符开始到n，用StringBuilder添加进去最后转化为String即可\n\n切片：\n\ns[n:]+s[:n]搞定\n\n\n# Java代码\n\nclass Solution {\n    public String reverseLeftWords(String s, int n) {\n        if(s==null||s.length()<=0) return "";\n        StringBuilder res = new StringBuilder();\n        if(s!=null){\n            for(int i=n;i<s.length();i++){\n                res.append(s.charAt(i));\n            }\n            for(int j=0;j<n;j++){\n                res.append(s.charAt(j));\n            }\n        }\n        return res.toString();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# Python代码\n\nclass Solution:\n    def reverseLeftWords(self, s: str, n: int) -> str:\n        if not s: return ""\n        if s:\n            return s[n:]+s[:n]\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n',normalizedContent:'# leetcode-面试题58-2-左旋转字符串\n\n字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。\n\n示例1：\n\n输入: s = "abcdefg", k = 2\n输出: "cdefgab"\n\n\n1\n2\n\n1\n2\n\n\n示例 2:\n\n输入: s = "lrloseumgh", k = 6\n输出: "umghlrlose"\n\n\n1\n2\n\n1\n2\n\n\n限制：\n\n * 1 <= k < s.length <= 10000\n\n\n# 解题思路\n\n线性遍历：\n\nn已经给出来了，第一部分字符串就是从n到字符末尾，第二部分字符串是从字符开始到n，用stringbuilder添加进去最后转化为string即可\n\n切片：\n\ns[n:]+s[:n]搞定\n\n\n# java代码\n\nclass solution {\n    public string reverseleftwords(string s, int n) {\n        if(s==null||s.length()<=0) return "";\n        stringbuilder res = new stringbuilder();\n        if(s!=null){\n            for(int i=n;i<s.length();i++){\n                res.append(s.charat(i));\n            }\n            for(int j=0;j<n;j++){\n                res.append(s.charat(j));\n            }\n        }\n        return res.tostring();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# python代码\n\nclass solution:\n    def reverseleftwords(self, s: str, n: int) -> str:\n        if not s: return ""\n        if s:\n            return s[n:]+s[:n]\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题59-2-队列的最大值",frontmatter:{title:"LeetCode-面试题59-2-队列的最大值",date:"2020-05-19T16:39:45.000Z",description:"队列的最大值",tags:["队列","Java","Medium","剑指Offer"],keywords:"队列,Java,Medium,剑指Offer",permalink:"/pages/0c523d/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/60.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9859-2-%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC.html",relativePath:"06.算法/01.剑指Offer/60.LeetCode-面试题59-2-队列的最大值.md",key:"v-45814dca",path:"/pages/0c523d/",headers:[{level:2,title:"LeetCode-面试题59-2-队列的最大值",slug:"leetcode-面试题59-2-队列的最大值",normalizedTitle:"leetcode-面试题59-2-队列的最大值",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:484},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:823},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:2032}],headersStr:"LeetCode-面试题59-2-队列的最大值 解题思路 Java代码 Java代码2",content:'# LeetCode-面试题59-2-队列的最大值\n\n请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。\n\n若队列为空，pop_front 和 max_value 需要返回 -1\n\n示例1：\n\n输入: \n["MaxQueue","push_back","push_back","max_value","pop_front","max_value"]\n[[],[1],[2],[],[],[]]\n输出: [null,null,null,2,1,2]\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n示例2:\n\n输入: \n["MaxQueue","pop_front","max_value"]\n[[],[],[]]\n输出: [null,-1,-1]\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n限制：\n\n * 1 <= push_back,pop_front,max_value的总操作数 <= 10000\n * 1 <= value <= 10^5\n\n\n# 解题思路\n\n双队列：\n\n利用一个队列Queue存储原本的数据，一个双端队列Deque存储最大值\n\n两个队列联合实现一个MaxQueue\n\n * 当新的值大于deque的尾部的值时，小的值都应该从deque尾部删去，添加大的值到尾部；同时queue实现常规的数值添加。这样保证了deque首位始终存储的是当前队列最大值\n * 当需要取得队列中的最大值时，如果deque为空，根据题意返回-1，如果不为空则取得最大值(不从双端队列中删除)\n * 当需要弹出队列首位时，需要判断原本的队列是否为空，为空则返回-1，不为空则需要判断出队的元素是否是当前最大值，如果是最大值，则原本的队列最大值出队了，deque中的最大值自然也不存在了，需要弹出首位。此时返回原本队列的首位即可\n\n\n# Java代码\n\nclass MaxQueue {\n    Deque<Integer> deque;\n    Queue<Integer> queue;\n    public MaxQueue() {\n        deque = new LinkedList<>();\n        queue = new LinkedList<>();\n    }\n    \n    public int max_value() {\n        if(deque.isEmpty())\n            return -1;\n        return deque.getFirst();\n    }\n    \n    public void push_back(int value) {\n        // 保证deque里面放的是最大值\n        while(!deque.isEmpty() && deque.getLast()<value)\n            deque.removeLast();\n        deque.addLast(value);\n        queue.offer(value);\n    }\n    \n    public int pop_front() {\n        if(queue.isEmpty())\n            return -1;\n        // 如果出队的元素是当前最大值，则deque也要出队\n        int temp = queue.poll();\n        if(deque.getFirst()==temp)\n            deque.removeFirst();\n        return temp;\n    }\n}\n\n/**\n * Your MaxQueue object will be instantiated and called as such:\n * MaxQueue obj = new MaxQueue();\n * int param_1 = obj.max_value();\n * obj.push_back(value);\n * int param_3 = obj.pop_front();\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# Java代码2\n\n注释版\n\nclass MaxQueue {\n\n    // 数据队列\n    private Queue<Integer> dataStack;\n\n    // 最大值双端队列\n    private Deque<Integer> maxStack;\n\n    public MaxQueue() {\n        this.dataStack = new LinkedList<>();\n        this.maxStack = new ArrayDeque<>();\n    }\n\n    public int max_value() {\n        // 最大值队列为空返回-1，否则返回最先的最大值\n        return this.maxStack.isEmpty() ? -1 : this.maxStack.peekFirst();\n    }\n\n    public void push_back(int value) {\n        // 数据队列添加数据\n        this.dataStack.offer(value);\n        // 当最大值队列不为空时，循环判断数据是否比双端队列最后要大，如果是就弹出\n        while (!this.maxStack.isEmpty() && this.maxStack.peekLast() < value) {\n            this.maxStack.pollLast();\n        }\n        // 更新或新增当前值到最大值队列尾部\n        this.maxStack.offerLast(value);\n    }\n\n    public int pop_front() {\n        // 当数据队列不为空时，判断要弹出的数据是否等于最大值队列的首个，因为队列首是最先添加的最大值\n        if (!this.dataStack.isEmpty()) {\n            int res = this.dataStack.poll();\n            // 如果等于则同步移除最大值队列中的元素\n            if (this.maxStack.peekFirst() == res) {\n                this.maxStack.pollFirst();\n            }\n            return res;\n        } else {\n            // 数据队列为空返回-1\n            return -1;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n',normalizedContent:'# leetcode-面试题59-2-队列的最大值\n\n请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是o(1)。\n\n若队列为空，pop_front 和 max_value 需要返回 -1\n\n示例1：\n\n输入: \n["maxqueue","push_back","push_back","max_value","pop_front","max_value"]\n[[],[1],[2],[],[],[]]\n输出: [null,null,null,2,1,2]\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n示例2:\n\n输入: \n["maxqueue","pop_front","max_value"]\n[[],[],[]]\n输出: [null,-1,-1]\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n限制：\n\n * 1 <= push_back,pop_front,max_value的总操作数 <= 10000\n * 1 <= value <= 10^5\n\n\n# 解题思路\n\n双队列：\n\n利用一个队列queue存储原本的数据，一个双端队列deque存储最大值\n\n两个队列联合实现一个maxqueue\n\n * 当新的值大于deque的尾部的值时，小的值都应该从deque尾部删去，添加大的值到尾部；同时queue实现常规的数值添加。这样保证了deque首位始终存储的是当前队列最大值\n * 当需要取得队列中的最大值时，如果deque为空，根据题意返回-1，如果不为空则取得最大值(不从双端队列中删除)\n * 当需要弹出队列首位时，需要判断原本的队列是否为空，为空则返回-1，不为空则需要判断出队的元素是否是当前最大值，如果是最大值，则原本的队列最大值出队了，deque中的最大值自然也不存在了，需要弹出首位。此时返回原本队列的首位即可\n\n\n# java代码\n\nclass maxqueue {\n    deque<integer> deque;\n    queue<integer> queue;\n    public maxqueue() {\n        deque = new linkedlist<>();\n        queue = new linkedlist<>();\n    }\n    \n    public int max_value() {\n        if(deque.isempty())\n            return -1;\n        return deque.getfirst();\n    }\n    \n    public void push_back(int value) {\n        // 保证deque里面放的是最大值\n        while(!deque.isempty() && deque.getlast()<value)\n            deque.removelast();\n        deque.addlast(value);\n        queue.offer(value);\n    }\n    \n    public int pop_front() {\n        if(queue.isempty())\n            return -1;\n        // 如果出队的元素是当前最大值，则deque也要出队\n        int temp = queue.poll();\n        if(deque.getfirst()==temp)\n            deque.removefirst();\n        return temp;\n    }\n}\n\n/**\n * your maxqueue object will be instantiated and called as such:\n * maxqueue obj = new maxqueue();\n * int param_1 = obj.max_value();\n * obj.push_back(value);\n * int param_3 = obj.pop_front();\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# java代码2\n\n注释版\n\nclass maxqueue {\n\n    // 数据队列\n    private queue<integer> datastack;\n\n    // 最大值双端队列\n    private deque<integer> maxstack;\n\n    public maxqueue() {\n        this.datastack = new linkedlist<>();\n        this.maxstack = new arraydeque<>();\n    }\n\n    public int max_value() {\n        // 最大值队列为空返回-1，否则返回最先的最大值\n        return this.maxstack.isempty() ? -1 : this.maxstack.peekfirst();\n    }\n\n    public void push_back(int value) {\n        // 数据队列添加数据\n        this.datastack.offer(value);\n        // 当最大值队列不为空时，循环判断数据是否比双端队列最后要大，如果是就弹出\n        while (!this.maxstack.isempty() && this.maxstack.peeklast() < value) {\n            this.maxstack.polllast();\n        }\n        // 更新或新增当前值到最大值队列尾部\n        this.maxstack.offerlast(value);\n    }\n\n    public int pop_front() {\n        // 当数据队列不为空时，判断要弹出的数据是否等于最大值队列的首个，因为队列首是最先添加的最大值\n        if (!this.datastack.isempty()) {\n            int res = this.datastack.poll();\n            // 如果等于则同步移除最大值队列中的元素\n            if (this.maxstack.peekfirst() == res) {\n                this.maxstack.pollfirst();\n            }\n            return res;\n        } else {\n            // 数据队列为空返回-1\n            return -1;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题60-n个骰子的点数",frontmatter:{title:"LeetCode-面试题60-n个骰子的点数",date:"2020-05-20T13:15:38.000Z",description:"n个骰子的点数",tags:["数组","DP","Java","Medium","剑指Offer"],keywords:"数组,DP,Java,Medium,剑指Offer",permalink:"/pages/517e93/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/61.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9860-n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0%20-%20%E5%89%AF%E6%9C%AC.html",relativePath:"06.算法/01.剑指Offer/61.LeetCode-面试题60-n个骰子的点数 - 副本.md",key:"v-48886aed",path:"/pages/517e93/",headers:[{level:2,title:"LeetCode-面试题60-n个骰子的点数",slug:"leetcode-面试题60-n个骰子的点数",normalizedTitle:"leetcode-面试题60-n个骰子的点数",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:353},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:949}],headersStr:"LeetCode-面试题60-n个骰子的点数 解题思路 Java代码",content:"# LeetCode-面试题60-n个骰子的点数\n\n把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。\n\n你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。\n\n示例1：\n\n输入: 1\n输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]\n\n\n1\n2\n\n1\n2\n\n\n示例2:\n\n输入: 2\n输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]\n\n\n1\n2\n\n1\n2\n\n\n限制：\n\n1 <= n <= 11\n\n\n# 解题思路\n\n动态规划：\n\n问题分析\n\n单个骰子可能的数字和是1,2,3,4,5,6\n\n假设有n个骰子，第n个骰子数字和值域为[n,6n]\n\nn个骰子的所有排列组合次数为6^n\n\n输出的概率就是各个数字和次数/6^n\n\n使用一个二维数组来记录，第i个骰子的，数字和j出现的次数\n\n第1维表示第几个骰子，第2维表示各个点数出现的次数\n\n第1个骰子，其可能的数字和为1,2,3,4,5,6；数组中第2维存储出现的次数即1,1,1,1,1,1\n\n第2个骰子，其可能的数字和为2-12，而2-12的数值由2组1-6分别累加而成，对于数字和7其出现的次数是6种，数字和8出现5种......数字和12出现1种\n\n第2个骰子的数字和可以由第1个骰子数字和组合得到，相应的j次数，就是组合位置次数相加\n\n可以得出投掷第i个骰子后，数字和j出现的次数，可以通过第n-1个骰子，对应点数j-1,j-2,j-3,...,j-6出现的次数之和转化得到，即第2个骰子的7,8,9,10,11,12可以由第1个骰子的1,2,3,4,5,6出现的次数转化得到\n\n由于求解第2个骰子数字和次数基于第1个骰子和次数，所以可以使用动态规划，每多一个骰子就会多出6个数字和\n\n状态转移方程\n\nfor(int i=1;i<=6;i++){\n\tdp[i][j]+=dp[i-1][j-i]\n}\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n\n# Java代码\n\nclass Solution {\n    public double[] twoSum(int n) {\n        if(n<1) return new double[]{0.0};\n        // 第一维表示n个骰子，第二维表示可能的数字和出现的次数\n        int[][] dp = new int[n+1][6*n+1];\n        // 初始化第1个骰子，1-6\n        for(int i=1;i<=6;i++)\n            dp[1][i] = 1;\n        for(int i=2;i<=n;i++){ // 第n个骰子\n            for(int j=i;j<=6*i;j++){ // 骰子和[n,6n]\n                for(int k=1;k<=6;k++){ // 单个骰子可能的点数\n                    if(j-k<0) break; // 越界跳出\n                    // 第n个骰子的和为j的值出现的次数，可以由n-1个骰子的j-1,j-2,j-3....j-6和当前数值相加得到\n                    // 比如第1个骰子可能的和是1,2,3,4,5,6\n                    // 第2个骰子依然是1,2,3,4,5,6，可能的数字和从2-12\n                    // 出现7的次数是6种,出现8的次数是5种,出现9的次数是4种,出现10的次数是3种\n                    // 出现11的次数是2种,出现12的次数是1种\n                    // 每一个位置j都可以由当前位置前6个出现的次数相加得到\n                    dp[i][j]+=dp[i-1][j-k]; \n                }\n            }\n        }\n        double[] res = new double[6*n-n+1];\n        double total = Math.pow(6,n);\n        for(int i=n;i<=6*n;i++){\n            res[i-n] = dp[n][i]/total;\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n",normalizedContent:"# leetcode-面试题60-n个骰子的点数\n\n把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。\n\n你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。\n\n示例1：\n\n输入: 1\n输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]\n\n\n1\n2\n\n1\n2\n\n\n示例2:\n\n输入: 2\n输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]\n\n\n1\n2\n\n1\n2\n\n\n限制：\n\n1 <= n <= 11\n\n\n# 解题思路\n\n动态规划：\n\n问题分析\n\n单个骰子可能的数字和是1,2,3,4,5,6\n\n假设有n个骰子，第n个骰子数字和值域为[n,6n]\n\nn个骰子的所有排列组合次数为6^n\n\n输出的概率就是各个数字和次数/6^n\n\n使用一个二维数组来记录，第i个骰子的，数字和j出现的次数\n\n第1维表示第几个骰子，第2维表示各个点数出现的次数\n\n第1个骰子，其可能的数字和为1,2,3,4,5,6；数组中第2维存储出现的次数即1,1,1,1,1,1\n\n第2个骰子，其可能的数字和为2-12，而2-12的数值由2组1-6分别累加而成，对于数字和7其出现的次数是6种，数字和8出现5种......数字和12出现1种\n\n第2个骰子的数字和可以由第1个骰子数字和组合得到，相应的j次数，就是组合位置次数相加\n\n可以得出投掷第i个骰子后，数字和j出现的次数，可以通过第n-1个骰子，对应点数j-1,j-2,j-3,...,j-6出现的次数之和转化得到，即第2个骰子的7,8,9,10,11,12可以由第1个骰子的1,2,3,4,5,6出现的次数转化得到\n\n由于求解第2个骰子数字和次数基于第1个骰子和次数，所以可以使用动态规划，每多一个骰子就会多出6个数字和\n\n状态转移方程\n\nfor(int i=1;i<=6;i++){\n\tdp[i][j]+=dp[i-1][j-i]\n}\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n\n# java代码\n\nclass solution {\n    public double[] twosum(int n) {\n        if(n<1) return new double[]{0.0};\n        // 第一维表示n个骰子，第二维表示可能的数字和出现的次数\n        int[][] dp = new int[n+1][6*n+1];\n        // 初始化第1个骰子，1-6\n        for(int i=1;i<=6;i++)\n            dp[1][i] = 1;\n        for(int i=2;i<=n;i++){ // 第n个骰子\n            for(int j=i;j<=6*i;j++){ // 骰子和[n,6n]\n                for(int k=1;k<=6;k++){ // 单个骰子可能的点数\n                    if(j-k<0) break; // 越界跳出\n                    // 第n个骰子的和为j的值出现的次数，可以由n-1个骰子的j-1,j-2,j-3....j-6和当前数值相加得到\n                    // 比如第1个骰子可能的和是1,2,3,4,5,6\n                    // 第2个骰子依然是1,2,3,4,5,6，可能的数字和从2-12\n                    // 出现7的次数是6种,出现8的次数是5种,出现9的次数是4种,出现10的次数是3种\n                    // 出现11的次数是2种,出现12的次数是1种\n                    // 每一个位置j都可以由当前位置前6个出现的次数相加得到\n                    dp[i][j]+=dp[i-1][j-k]; \n                }\n            }\n        }\n        double[] res = new double[6*n-n+1];\n        double total = math.pow(6,n);\n        for(int i=n;i<=6*n;i++){\n            res[i-n] = dp[n][i]/total;\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题61-扑克牌中的顺子",frontmatter:{title:"LeetCode-面试题61-扑克牌中的顺子",date:"2020-05-20T15:46:36.000Z",description:"扑克牌中的顺子",tags:["数组","Java","Easy","剑指Offer"],keywords:"数组,Java,Easy,剑指Offer",permalink:"/pages/a7687d/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/62.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9861-%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90.html",relativePath:"06.算法/01.剑指Offer/62.LeetCode-面试题61-扑克牌中的顺子.md",key:"v-dd580c7a",path:"/pages/a7687d/",headers:[{level:2,title:"LeetCode-面试题61-扑克牌中的顺子",slug:"leetcode-面试题61-扑克牌中的顺子",normalizedTitle:"leetcode-面试题61-扑克牌中的顺子",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:242},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:332}],headersStr:"LeetCode-面试题61-扑克牌中的顺子 解题思路 Java代码",content:"# LeetCode-面试题61-扑克牌中的顺子\n\n从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。\n\n示例1：\n\n输入: [1,2,3,4,5]\n输出: True\n\n\n1\n2\n\n1\n2\n\n\n示例2:\n\n输入: [0,0,1,2,5]\n输出: True\n\n\n1\n2\n\n1\n2\n\n\n限制：\n\n数组长度为 5\n\n数组的数取值为 [0, 13]\n\n\n# 解题思路\n\n先给数组排序，统计0的个数，如果数组欠缺的几个数字个数正好等于0的个数，则数组可以变成连续的\n\n如果从越过0开始的地方，出现两个数值相等，则说明数组不可能连续\n\n\n# Java代码\n\nclass Solution {\n    public boolean isStraight(int[] nums) {\n        if(nums==null||nums.length<=0)\n            return false;\n        Arrays.sort(nums);\n        int zeroCount = 0;\n        int gapCount = 0;\n        for(int i=0;i<nums.length;i++){\n            if(nums[i]==0)\n                zeroCount++;\n        }\n        int start = zeroCount;\n        int end = start+1;\n        while(end<nums.length){\n            if(nums[start]==nums[end])\n                return false;\n            gapCount+=nums[end]-nums[start]-1;\n            start=end;\n            end++;\n        }\n        return (gapCount>zeroCount)?false:true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n",normalizedContent:"# leetcode-面试题61-扑克牌中的顺子\n\n从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，a为1，j为11，q为12，k为13，而大、小王为 0 ，可以看成任意数字。a 不能视为 14。\n\n示例1：\n\n输入: [1,2,3,4,5]\n输出: true\n\n\n1\n2\n\n1\n2\n\n\n示例2:\n\n输入: [0,0,1,2,5]\n输出: true\n\n\n1\n2\n\n1\n2\n\n\n限制：\n\n数组长度为 5\n\n数组的数取值为 [0, 13]\n\n\n# 解题思路\n\n先给数组排序，统计0的个数，如果数组欠缺的几个数字个数正好等于0的个数，则数组可以变成连续的\n\n如果从越过0开始的地方，出现两个数值相等，则说明数组不可能连续\n\n\n# java代码\n\nclass solution {\n    public boolean isstraight(int[] nums) {\n        if(nums==null||nums.length<=0)\n            return false;\n        arrays.sort(nums);\n        int zerocount = 0;\n        int gapcount = 0;\n        for(int i=0;i<nums.length;i++){\n            if(nums[i]==0)\n                zerocount++;\n        }\n        int start = zerocount;\n        int end = start+1;\n        while(end<nums.length){\n            if(nums[start]==nums[end])\n                return false;\n            gapcount+=nums[end]-nums[start]-1;\n            start=end;\n            end++;\n        }\n        return (gapcount>zerocount)?false:true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题62-圆圈中最后剩下的数字",frontmatter:{title:"LeetCode-面试题62-圆圈中最后剩下的数字",date:"2020-05-20T16:08:25.000Z",description:"圆圈中最后剩下的数字",tags:["数组","Java","Easy","剑指Offer"],keywords:"数组,Java,Easy,剑指Offer",permalink:"/pages/9ca7ff/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/63.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9862-%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97.html",relativePath:"06.算法/01.剑指Offer/63.LeetCode-面试题62-圆圈中最后剩下的数字.md",key:"v-2788ef08",path:"/pages/9ca7ff/",headers:[{level:2,title:"LeetCode-面试题62-圆圈中最后剩下的数字",slug:"leetcode-面试题62-圆圈中最后剩下的数字",normalizedTitle:"leetcode-面试题62-圆圈中最后剩下的数字",charIndex:2},{level:3,title:"解题思路1",slug:"解题思路1",normalizedTitle:"解题思路1",charIndex:296},{level:3,title:"解题思路2",slug:"解题思路2",normalizedTitle:"解题思路2",charIndex:549},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:574},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:865}],headersStr:"LeetCode-面试题62-圆圈中最后剩下的数字 解题思路1 解题思路2 Java代码 Java代码2",content:"# LeetCode-面试题62-圆圈中最后剩下的数字\n\n0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。\n\n例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。\n\n示例1：\n\n输入: n = 5, m = 3\n输出: 3\n\n\n1\n2\n\n1\n2\n\n\n示例2:\n\n输入: n = 10, m = 17\n输出: 2\n\n\n1\n2\n\n1\n2\n\n\n限制：\n\n * 1 <= n <= 10^5\n * 1 <= m <= 10^6\n\n\n# 解题思路1\n\n著名的约瑟夫环问题\n\n第一轮[0,1,2,3,4]，删去2\n\n第二轮[3,4,0,1]，删去0\n\n第三轮[1,3,4]，删去4\n\n第四轮[1,3]，删去1\n\n最后一轮得到3，实际上每次删去的都是加粗部分位置，第四轮由于只有2个数，补全成环之后，实际上也是加粗部分位置，如[1,3,1,3]\n\n原始数组是有序递增的，所以下标就是数组值\n\n最后一轮3的下标是0，如果我们能够从最后的数字下标反推回到原始数组，就能找到最终答案\n\n反推的方程，(curIndex+m)%上一轮剩余数字的个数\n\n\n# 解题思路2\n\n模拟，利用list进行模拟\n\n\n# Java代码\n\nclass Solution {\n    public int lastRemaining(int n, int m) {\n        if(n<1||m<1) return -1;\n        int curindex = 0;\n        for(int i=2;i<=n;i++){\n            curindex = (curindex+m)%i;\n        }\n        return curindex;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# Java代码2\n\nclass Solution {\n    public int lastRemaining(int n, int m) {\n        List<Integer> list = new ArrayList<>();\n        for(int i = 0;i<n;i++){\n            list.add(i);\n        }\n        int index = 0;\n        while(n>1){\n            index = (index+m-1)%n;\n            list.remove(index);\n            n--;\n        }\n        return list.get(0);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n",normalizedContent:"# leetcode-面试题62-圆圈中最后剩下的数字\n\n0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。\n\n例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。\n\n示例1：\n\n输入: n = 5, m = 3\n输出: 3\n\n\n1\n2\n\n1\n2\n\n\n示例2:\n\n输入: n = 10, m = 17\n输出: 2\n\n\n1\n2\n\n1\n2\n\n\n限制：\n\n * 1 <= n <= 10^5\n * 1 <= m <= 10^6\n\n\n# 解题思路1\n\n著名的约瑟夫环问题\n\n第一轮[0,1,2,3,4]，删去2\n\n第二轮[3,4,0,1]，删去0\n\n第三轮[1,3,4]，删去4\n\n第四轮[1,3]，删去1\n\n最后一轮得到3，实际上每次删去的都是加粗部分位置，第四轮由于只有2个数，补全成环之后，实际上也是加粗部分位置，如[1,3,1,3]\n\n原始数组是有序递增的，所以下标就是数组值\n\n最后一轮3的下标是0，如果我们能够从最后的数字下标反推回到原始数组，就能找到最终答案\n\n反推的方程，(curindex+m)%上一轮剩余数字的个数\n\n\n# 解题思路2\n\n模拟，利用list进行模拟\n\n\n# java代码\n\nclass solution {\n    public int lastremaining(int n, int m) {\n        if(n<1||m<1) return -1;\n        int curindex = 0;\n        for(int i=2;i<=n;i++){\n            curindex = (curindex+m)%i;\n        }\n        return curindex;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# java代码2\n\nclass solution {\n    public int lastremaining(int n, int m) {\n        list<integer> list = new arraylist<>();\n        for(int i = 0;i<n;i++){\n            list.add(i);\n        }\n        int index = 0;\n        while(n>1){\n            index = (index+m-1)%n;\n            list.remove(index);\n            n--;\n        }\n        return list.get(0);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题63-股票的最大利润",frontmatter:{title:"LeetCode-面试题63-股票的最大利润",date:"2020-05-20T16:58:09.000Z",description:"股票的最大利润",tags:["数组","Java","Easy","剑指Offer"],keywords:"数组,Java,Easy,剑指Offer",permalink:"/pages/610009/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/64.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9863-%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6.html",relativePath:"06.算法/01.剑指Offer/64.LeetCode-面试题63-股票的最大利润.md",key:"v-3b164efb",path:"/pages/610009/",headers:[{level:2,title:"LeetCode-面试题63-股票的最大利润",slug:"leetcode-面试题63-股票的最大利润",normalizedTitle:"leetcode-面试题63-股票的最大利润",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:334},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:393}],headersStr:"LeetCode-面试题63-股票的最大利润 解题思路 Java代码",content:"# LeetCode-面试题63-股票的最大利润\n\n假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？\n\n示例1：\n\n输入: [7,1,5,3,6,4]\n输出: 5\n解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。\n     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n示例2:\n\n输入: [7,6,4,3,1]\n输出: 0\n解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n限制：\n\n * 0 <= 数组长度 <= 10^5\n\n\n# 解题思路\n\n始终记录当前位置前的最小数字，遇到更小的就更新min，之后看当前的最大利润和存储的最大利润谁更大\n\n\n# Java代码\n\nclass Solution {\n    public int maxProfit(int[] prices) {\n        if(prices==null||prices.length<2)\n            return 0;\n        int min = prices[0];\n        int maxPrice = 0;\n        for(int i=1;i<prices.length;i++){\n            if(prices[i]<min){\n                min = prices[i];\n            }else{\n                maxPrice = Math.max(maxPrice,prices[i]-min);\n            }\n        }\n        return maxPrice;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n",normalizedContent:"# leetcode-面试题63-股票的最大利润\n\n假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？\n\n示例1：\n\n输入: [7,1,5,3,6,4]\n输出: 5\n解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。\n     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n示例2:\n\n输入: [7,6,4,3,1]\n输出: 0\n解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n限制：\n\n * 0 <= 数组长度 <= 10^5\n\n\n# 解题思路\n\n始终记录当前位置前的最小数字，遇到更小的就更新min，之后看当前的最大利润和存储的最大利润谁更大\n\n\n# java代码\n\nclass solution {\n    public int maxprofit(int[] prices) {\n        if(prices==null||prices.length<2)\n            return 0;\n        int min = prices[0];\n        int maxprice = 0;\n        for(int i=1;i<prices.length;i++){\n            if(prices[i]<min){\n                min = prices[i];\n            }else{\n                maxprice = math.max(maxprice,prices[i]-min);\n            }\n        }\n        return maxprice;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题64-求1+2+到+n",frontmatter:{title:"LeetCode-面试题64-求1+2+到+n",date:"2020-05-20T18:20:48.000Z",description:"求1+2+...+n",tags:["Java","Python","Medium","剑指Offer"],keywords:"Java,Python,Medium,剑指Offer",permalink:"/pages/4abc2f/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/65.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9864-%E6%B1%821+2+%E5%88%B0+n.html",relativePath:"06.算法/01.剑指Offer/65.LeetCode-面试题64-求1+2+到+n.md",key:"v-e24f836e",path:"/pages/4abc2f/",headers:[{level:2,title:"LeetCode-面试题64-求1+2+...+n",slug:"leetcode-面试题64-求1-2-n",normalizedTitle:"leetcode-面试题64-求1+2+...+n",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:201},{level:3,title:"解题思路2",slug:"解题思路2",normalizedTitle:"解题思路2",charIndex:299},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:328},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:483},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:601}],headersStr:"LeetCode-面试题64-求1+2+...+n 解题思路 解题思路2 Java代码 Python代码 Java代码2",content:"# LeetCode-面试题64-求1+2+...+n\n\n求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。\n\n示例1：\n\n输入: n = 3\n输出: 6\n\n\n1\n2\n\n1\n2\n\n\n示例2:\n\n输入: n = 9\n输出: 45\n\n\n1\n2\n\n1\n2\n\n\n限制：\n\n * 1 <= n <= 10000\n\n\n# 解题思路\n\n很多运算不能够使用，这道题主要是考察的，能不能多角度的解决问题\n\n不难想到for循环的方式可以有递归的实现，从n走到1就可以了\n\n然而Python不受本题限制....一行搞定\n\n\n# 解题思路2\n\n高斯定理：(首项+末项)x项数/2\n\n\n# Java代码\n\nclass Solution {\n    public int sumNums(int n) {\n        if(n==1) return 1;\n        return n+sumNums(n-1);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n\n# Python代码\n\nclass Solution:\n    def sumNums(self, n: int) -> int:\n        return sum(range(1,n+1));\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n\n# Java代码2\n\nclass Solution {\n    public int sumNums(int n) {\n        return (n+1)*n/2;\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n",normalizedContent:"# leetcode-面试题64-求1+2+...+n\n\n求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（a?b:c）。\n\n示例1：\n\n输入: n = 3\n输出: 6\n\n\n1\n2\n\n1\n2\n\n\n示例2:\n\n输入: n = 9\n输出: 45\n\n\n1\n2\n\n1\n2\n\n\n限制：\n\n * 1 <= n <= 10000\n\n\n# 解题思路\n\n很多运算不能够使用，这道题主要是考察的，能不能多角度的解决问题\n\n不难想到for循环的方式可以有递归的实现，从n走到1就可以了\n\n然而python不受本题限制....一行搞定\n\n\n# 解题思路2\n\n高斯定理：(首项+末项)x项数/2\n\n\n# java代码\n\nclass solution {\n    public int sumnums(int n) {\n        if(n==1) return 1;\n        return n+sumnums(n-1);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n\n# python代码\n\nclass solution:\n    def sumnums(self, n: int) -> int:\n        return sum(range(1,n+1));\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n\n# java代码2\n\nclass solution {\n    public int sumnums(int n) {\n        return (n+1)*n/2;\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题65-不用加减乘除做加法",frontmatter:{title:"LeetCode-面试题65-不用加减乘除做加法",date:"2020-05-20T20:06:48.000Z",description:"不用加减乘除做加法",tags:["位运算","Java","Easy","剑指Offer"],keywords:"位运算,Java,Easy,剑指Offer",permalink:"/pages/808f6a/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/66.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9865-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95.html",relativePath:"06.算法/01.剑指Offer/66.LeetCode-面试题65-不用加减乘除做加法.md",key:"v-37cdc6f8",path:"/pages/808f6a/",headers:[{level:2,title:"LeetCode-面试题65-不用加减乘除做加法",slug:"leetcode-面试题65-不用加减乘除做加法",normalizedTitle:"leetcode-面试题65-不用加减乘除做加法",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:165},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:318}],headersStr:"LeetCode-面试题65-不用加减乘除做加法 解题思路 Java代码",content:"# LeetCode-面试题65-不用加减乘除做加法\n\n写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。\n\n示例1：\n\n输入: a = 1, b = 1\n输出: 2\n\n\n1\n2\n\n1\n2\n\n\n限制：\n\n * a, b 均可能是负数或 0\n * 结果不会溢出 32 位整数\n\n\n# 解题思路\n\n不能使用加减乘除，就只能用位运算了\n\n按照3步走：\n\n * 不算进位相加\n * 计算进位\n * 两数相加\n\n其中最后一步可以整合到第一步，不算进位相加符合异或逻辑，进位需要两个位置都为1，其余为0，符合与运算。之后左移一位就是进位位置。当进位不为0时，一直计算直到进位为0得到最后数值\n\n\n# Java代码\n\nclass Solution {\n    public int add(int a, int b) {\n        int sum = 0;\n        int carry = 0;\n        do{\n            sum = a^b; // 两数相加,且不考虑进位\n            carry = (a&b)<<1; //得到进位\n            a = sum;\n            b = carry;\n        }while(b!=0);\n        return a;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n",normalizedContent:"# leetcode-面试题65-不用加减乘除做加法\n\n写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。\n\n示例1：\n\n输入: a = 1, b = 1\n输出: 2\n\n\n1\n2\n\n1\n2\n\n\n限制：\n\n * a, b 均可能是负数或 0\n * 结果不会溢出 32 位整数\n\n\n# 解题思路\n\n不能使用加减乘除，就只能用位运算了\n\n按照3步走：\n\n * 不算进位相加\n * 计算进位\n * 两数相加\n\n其中最后一步可以整合到第一步，不算进位相加符合异或逻辑，进位需要两个位置都为1，其余为0，符合与运算。之后左移一位就是进位位置。当进位不为0时，一直计算直到进位为0得到最后数值\n\n\n# java代码\n\nclass solution {\n    public int add(int a, int b) {\n        int sum = 0;\n        int carry = 0;\n        do{\n            sum = a^b; // 两数相加,且不考虑进位\n            carry = (a&b)<<1; //得到进位\n            a = sum;\n            b = carry;\n        }while(b!=0);\n        return a;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题66-构建乘积数组",frontmatter:{title:"LeetCode-面试题66-构建乘积数组",date:"2020-05-21T15:08:46.000Z",description:"构建乘积数组",tags:["数组","Java","Easy","剑指Offer"],keywords:"数组,Java,Easy,剑指Offer",permalink:"/pages/bcd8dc/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/67.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9866-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84.html",relativePath:"06.算法/01.剑指Offer/67.LeetCode-面试题66-构建乘积数组.md",key:"v-6397ae1b",path:"/pages/bcd8dc/",headers:[{level:2,title:"LeetCode-面试题66-构建乘积数组",slug:"leetcode-面试题66-构建乘积数组",normalizedTitle:"leetcode-面试题66-构建乘积数组",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:236},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:712},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:1253}],headersStr:"LeetCode-面试题66-构建乘积数组 解题思路 Java代码 Java代码2",content:"# LeetCode-面试题66-构建乘积数组\n\n给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B 中的元素 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。\n\n示例1：\n\n输入: [1,2,3,4,5]\n输出: [120,60,40,30,24]\n\n\n1\n2\n\n1\n2\n\n\n限制：\n\n * 所有元素乘积之和不会溢出 32 位整数\n * a.length <= 100000\n\n\n# 解题思路\n\n将A[0]×A[1]×…×A[i-1]分为一个数组记为C[i]，A[i+1]×…×A[n-1]分为一个数组记为D[i]，数组B可以由这两个数组的乘积得到，把B看成一个矩阵其左对角线为全1，分开上述2个数组 B=\n\nB0&1 & A1 & A2 & ... & An-2 & An-1\nB1& A0 & 1 & A2 & ...&An-2 & An-1\nB2& A0 & A1 & 1 & ...&An-2 & An-1\n...& A0 & A1 & ... & 1 &An-2& An-1\nBn-2& A0 & A1 & ... & An-3&1 & An-1\nBn-1& A0 & A1 & ... & An-3 &An-2& 1\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\nA[0]×A[1]×…×A[i-1]可以自上而下，从左至右的顺序计算得到，对应于C[i] = C[i-1]*A[i-1]\n\nA[i+1]×…×A[n-1]可以自下而上，从右至左的顺序计算得到，对应于D[i] = D[i+1]*A[i+1]\n\n\n# Java代码\n\nclass Solution {\n    public int[] constructArr(int[] a) {\n        if(a.length==0) return new int[0];\n        int[] b = new int[a.length];\n        b[0]=1;\n        int temp=1;\n        // 循环控制从上至下，累乘从左至右\n        for(int i=1;i<a.length;i++){\n            b[i] = b[i-1]*a[i-1];\n        }\n        // 循环控制从下至上，累乘从右至左\n        for(int j=a.length-2;j>=0;j--){\n            temp*=a[j+1];\n            b[j]*=temp;\n        }\n        return b;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# Java代码2\n\nclass Solution {\n    public int[] constructArr(int[] a) {\n        int[] res = new int[a.length];\n        for(int i=0,cur=1;i<a.length;i++){\n            res[i] = cur; // 先乘左边的数(不包括自己)\n            cur*=a[i];\n        }\n        for(int i=a.length-1,cur=1;i>=0;i--){\n            res[i] *= cur; // 再乘右边的数(不包括自己)\n            cur*=a[i];\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n",normalizedContent:"# leetcode-面试题66-构建乘积数组\n\n给定一个数组 a[0,1,…,n-1]，请构建一个数组 b[0,1,…,n-1]，其中 b 中的元素 b[i]=a[0]×a[1]×…×a[i-1]×a[i+1]×…×a[n-1]。不能使用除法。\n\n示例1：\n\n输入: [1,2,3,4,5]\n输出: [120,60,40,30,24]\n\n\n1\n2\n\n1\n2\n\n\n限制：\n\n * 所有元素乘积之和不会溢出 32 位整数\n * a.length <= 100000\n\n\n# 解题思路\n\n将a[0]×a[1]×…×a[i-1]分为一个数组记为c[i]，a[i+1]×…×a[n-1]分为一个数组记为d[i]，数组b可以由这两个数组的乘积得到，把b看成一个矩阵其左对角线为全1，分开上述2个数组 b=\n\nb0&1 & a1 & a2 & ... & an-2 & an-1\nb1& a0 & 1 & a2 & ...&an-2 & an-1\nb2& a0 & a1 & 1 & ...&an-2 & an-1\n...& a0 & a1 & ... & 1 &an-2& an-1\nbn-2& a0 & a1 & ... & an-3&1 & an-1\nbn-1& a0 & a1 & ... & an-3 &an-2& 1\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\na[0]×a[1]×…×a[i-1]可以自上而下，从左至右的顺序计算得到，对应于c[i] = c[i-1]*a[i-1]\n\na[i+1]×…×a[n-1]可以自下而上，从右至左的顺序计算得到，对应于d[i] = d[i+1]*a[i+1]\n\n\n# java代码\n\nclass solution {\n    public int[] constructarr(int[] a) {\n        if(a.length==0) return new int[0];\n        int[] b = new int[a.length];\n        b[0]=1;\n        int temp=1;\n        // 循环控制从上至下，累乘从左至右\n        for(int i=1;i<a.length;i++){\n            b[i] = b[i-1]*a[i-1];\n        }\n        // 循环控制从下至上，累乘从右至左\n        for(int j=a.length-2;j>=0;j--){\n            temp*=a[j+1];\n            b[j]*=temp;\n        }\n        return b;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# java代码2\n\nclass solution {\n    public int[] constructarr(int[] a) {\n        int[] res = new int[a.length];\n        for(int i=0,cur=1;i<a.length;i++){\n            res[i] = cur; // 先乘左边的数(不包括自己)\n            cur*=a[i];\n        }\n        for(int i=a.length-1,cur=1;i>=0;i--){\n            res[i] *= cur; // 再乘右边的数(不包括自己)\n            cur*=a[i];\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题67-把字符串转化成整数",frontmatter:{title:"LeetCode-面试题67-把字符串转化成整数",date:"2020-05-21T16:22:23.000Z",description:"把字符串转化成整数",tags:["字符串","Java","Medium","剑指Offer"],keywords:"字符串,Java,Medium,剑指Offer",permalink:"/pages/bd49ec/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/68.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9867-%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E5%8C%96%E6%88%90%E6%95%B4%E6%95%B0.html",relativePath:"06.算法/01.剑指Offer/68.LeetCode-面试题67-把字符串转化成整数.md",key:"v-52aba3b4",path:"/pages/bd49ec/",headers:[{level:2,title:"LeetCode-面试题67-把字符串转化成整数",slug:"leetcode-面试题67-把字符串转化成整数",normalizedTitle:"leetcode-面试题67-把字符串转化成整数",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:942},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:1368}],headersStr:"LeetCode-面试题67-把字符串转化成整数 解题思路 Java代码",content:"# LeetCode-面试题67-把字符串转化成整数\n\n写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。\n\n首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。\n\n当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。\n\n该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。\n\n注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。\n\n在任何情况下，若函数不能进行有效的转换时，请返回 0。\n\n示例1：\n\n输入: \"42\"\n输出: 42\n\n\n1\n2\n\n1\n2\n\n\n示例2：\n\n输入: \"   -42\"\n输出: -42\n解释: 第一个非空白字符为 '-', 它是一个负号。\n     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n示例3：\n\n输入: \"4193 with words\"\n输出: 4193\n解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例4：\n\n输入: \"words and 987\"\n输出: 0\n解释: 第一个非空字符是 'w', 但它不是数字或正、负号。\n     因此无法执行有效的转换。\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n示例5：\n\n输入: \"-91283472332\"\n输出: -2147483648\n解释: 数字 \"-91283472332\" 超过 32 位有符号整数范围。 \n     因此返回 INT_MIN (−231) 。\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n说明：\n\n假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。\n\n\n# 解题思路\n\n按照题目一步一步来\n\n首先是去掉首尾空格\n\n之后设置一个符号位存储正负，当遇到-号就转化为-1\n\n最重要的一步是边界处理，题目给定的数值范围在INT类型内，如果使用res边加边乘进行判断，当越界时int类型会自己触发保护削减数值，这时候就无法通过与MAX_VALUE和MIN_VALUE比大小判断到底是不是越界了。一种省事的方法是使用long类型的res，但这不符合题意。\n\n我们可以在每一轮数字拼接前判断，当前的值是否超过 2147483647/10，如果超过则下一次拼接10*res必定是越界的。\n\n第二种情况是当前值是2147483647/10，没有发生越界，但拼接后越界了，即当前位置>7越界。\n\n对于上界溢出，判断符号位是否是1，即正数，返回正数最大值；如果是-1，则返回负数最大值\n\n注意：因为这里已经转化为CharArray，所以判断s[i]>'7'不能写成s[i]-'0'>'7'，这会使ASCALL码减小判断失败\n\n\n# Java代码\n\nclass Solution {\n    public int strToInt(String str) {\n        char[] s = str.trim().toCharArray();\n        if (s.length == 0) {\n            return 0;\n        }\n        int sign = 1;\n        int i = 0;\n        int res = 0;\n        int MAX = Integer.MAX_VALUE / 10;\n        if (s[0] == '-') sign = -1;\n        if (s[0] == '+' || s[0] == '-') i++;\n        while (i < s.length && s[i] >= '0' && s[i] <= '9') {\n            if (res > MAX || res == MAX && s[i] > '7') {\n                return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n            }\n            res = res * 10 + (s[i] - '0');\n            i++;\n        }\n        return res * sign;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n",normalizedContent:"# leetcode-面试题67-把字符串转化成整数\n\n写一个函数 strtoint，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。\n\n首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。\n\n当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。\n\n该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。\n\n注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。\n\n在任何情况下，若函数不能进行有效的转换时，请返回 0。\n\n示例1：\n\n输入: \"42\"\n输出: 42\n\n\n1\n2\n\n1\n2\n\n\n示例2：\n\n输入: \"   -42\"\n输出: -42\n解释: 第一个非空白字符为 '-', 它是一个负号。\n     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n示例3：\n\n输入: \"4193 with words\"\n输出: 4193\n解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例4：\n\n输入: \"words and 987\"\n输出: 0\n解释: 第一个非空字符是 'w', 但它不是数字或正、负号。\n     因此无法执行有效的转换。\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n示例5：\n\n输入: \"-91283472332\"\n输出: -2147483648\n解释: 数字 \"-91283472332\" 超过 32 位有符号整数范围。 \n     因此返回 int_min (−231) 。\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n说明：\n\n假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回 int_max (231 − 1) 或 int_min (−231) 。\n\n\n# 解题思路\n\n按照题目一步一步来\n\n首先是去掉首尾空格\n\n之后设置一个符号位存储正负，当遇到-号就转化为-1\n\n最重要的一步是边界处理，题目给定的数值范围在int类型内，如果使用res边加边乘进行判断，当越界时int类型会自己触发保护削减数值，这时候就无法通过与max_value和min_value比大小判断到底是不是越界了。一种省事的方法是使用long类型的res，但这不符合题意。\n\n我们可以在每一轮数字拼接前判断，当前的值是否超过 2147483647/10，如果超过则下一次拼接10*res必定是越界的。\n\n第二种情况是当前值是2147483647/10，没有发生越界，但拼接后越界了，即当前位置>7越界。\n\n对于上界溢出，判断符号位是否是1，即正数，返回正数最大值；如果是-1，则返回负数最大值\n\n注意：因为这里已经转化为chararray，所以判断s[i]>'7'不能写成s[i]-'0'>'7'，这会使ascall码减小判断失败\n\n\n# java代码\n\nclass solution {\n    public int strtoint(string str) {\n        char[] s = str.trim().tochararray();\n        if (s.length == 0) {\n            return 0;\n        }\n        int sign = 1;\n        int i = 0;\n        int res = 0;\n        int max = integer.max_value / 10;\n        if (s[0] == '-') sign = -1;\n        if (s[0] == '+' || s[0] == '-') i++;\n        while (i < s.length && s[i] >= '0' && s[i] <= '9') {\n            if (res > max || res == max && s[i] > '7') {\n                return sign == 1 ? integer.max_value : integer.min_value;\n            }\n            res = res * 10 + (s[i] - '0');\n            i++;\n        }\n        return res * sign;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题68-1-二叉搜索树的最近公共祖先",frontmatter:{title:"LeetCode-面试题68-1-二叉搜索树的最近公共祖先",date:"2020-05-29T10:05:04.000Z",description:"二叉搜索树的最近公共祖先",tags:["二叉树","Java","Python","Easy","剑指Offer"],keywords:"二叉树,Java,Python,Easy,剑指Offer",permalink:"/pages/2295ef/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/69.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9868-1-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html",relativePath:"06.算法/01.剑指Offer/69.LeetCode-面试题68-1-二叉搜索树的最近公共祖先.md",key:"v-0018d08d",path:"/pages/2295ef/",headers:[{level:2,title:"LeetCode-面试题68-1-二叉搜索树的最近公共祖先",slug:"leetcode-面试题68-1-二叉搜索树的最近公共祖先",normalizedTitle:"leetcode-面试题68-1-二叉搜索树的最近公共祖先",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:512},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:720},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:1352}],headersStr:"LeetCode-面试题68-1-二叉搜索树的最近公共祖先 解题思路 Java代码 Python代码",content:"# LeetCode-面试题68-1-二叉搜索树的最近公共祖先\n\n给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。\n\n百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n\n例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]\n\n示例1：\n\n输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\n输出: 6 \n解释: 节点 2 和节点 8 的最近公共祖先是 6。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2：\n\n输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4\n输出: 2\n解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n说明：\n\n * 所有节点的值都是唯一的。\n * p、q 为不同节点且均存在于给定的二叉搜索树中。\n\n\n# 解题思路\n\n方法1、递归：\n\n比较当前的值和传入的2个节点值的大小，根据二叉搜索树的性质，比根节点小的数在左边，比根节点大的数在右边。如果当前值比2个节点值大，则最近的公共祖先应该在左子树\n\n如果当前值比2个节点值小，则最近的公共祖先应该在右子树\n\n如果当前值在2个节点值中间，或者等于2个节点值中的一个，则当前节点就是最近公共祖先\n\n方法2、迭代：\n\n迭代思路与递归类似，只是当找到节点时跳出循环返回即可\n\n\n# Java代码\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if(root.val>p.val&&root.val>q.val){\n            return lowestCommonAncestor(root.left,p,q);\n        }else if(root.val<p.val&&root.val<q.val){\n            return lowestCommonAncestor(root.right,p,q);\n        }\n        return root;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# Python代码\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n        while root:\n            if root.val>p.val and root.val>q.val:\n                root = root.left\n            elif root.val<p.val and root.val<q.val:\n                root = root.right\n            else:\n                break\n        return root\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n",normalizedContent:"# leetcode-面试题68-1-二叉搜索树的最近公共祖先\n\n给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。\n\n百度百科中最近公共祖先的定义为：“对于有根树 t 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n\n例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]\n\n示例1：\n\n输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\n输出: 6 \n解释: 节点 2 和节点 8 的最近公共祖先是 6。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2：\n\n输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4\n输出: 2\n解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n说明：\n\n * 所有节点的值都是唯一的。\n * p、q 为不同节点且均存在于给定的二叉搜索树中。\n\n\n# 解题思路\n\n方法1、递归：\n\n比较当前的值和传入的2个节点值的大小，根据二叉搜索树的性质，比根节点小的数在左边，比根节点大的数在右边。如果当前值比2个节点值大，则最近的公共祖先应该在左子树\n\n如果当前值比2个节点值小，则最近的公共祖先应该在右子树\n\n如果当前值在2个节点值中间，或者等于2个节点值中的一个，则当前节点就是最近公共祖先\n\n方法2、迭代：\n\n迭代思路与递归类似，只是当找到节点时跳出循环返回即可\n\n\n# java代码\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public treenode lowestcommonancestor(treenode root, treenode p, treenode q) {\n        if(root.val>p.val&&root.val>q.val){\n            return lowestcommonancestor(root.left,p,q);\n        }else if(root.val<p.val&&root.val<q.val){\n            return lowestcommonancestor(root.right,p,q);\n        }\n        return root;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# python代码\n\n# definition for a binary tree node.\n# class treenode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = none\n#         self.right = none\n\nclass solution:\n    def lowestcommonancestor(self, root: 'treenode', p: 'treenode', q: 'treenode') -> 'treenode':\n        while root:\n            if root.val>p.val and root.val>q.val:\n                root = root.left\n            elif root.val<p.val and root.val<q.val:\n                root = root.right\n            else:\n                break\n        return root\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题07-重建二叉树",frontmatter:{title:"LeetCode-面试题07-重建二叉树",date:"2020-04-04T14:08:05.000Z",description:"重建二叉树",tags:["树","Java","Python","Medium","剑指Offer"],keywords:"树,Java,Python,Medium,剑指Offer",permalink:"/pages/88652a/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/71.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9807-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91.html",relativePath:"06.算法/01.剑指Offer/71.LeetCode-面试题07-重建二叉树.md",key:"v-02c2afad",path:"/pages/88652a/",headers:[{level:2,title:"LeetCode-面试题07-重建二叉树",slug:"leetcode-面试题07-重建二叉树",normalizedTitle:"leetcode-面试题07-重建二叉树",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:277},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:557},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:2553}],headersStr:"LeetCode-面试题07-重建二叉树 解题思路 Java代码 Python代码",content:'# LeetCode-面试题07-重建二叉树\n\n输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。\n\n例如，给出\n\n前序遍历 preorder = [3,9,20,15,7]\n中序遍历 inorder = [9,3,15,20,7]\n\n\n1\n2\n\n1\n2\n\n\n返回如下的二叉树：\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n   \n限制：\n0 <= 节点个数 <= 5000\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 解题思路\n\n方法1、递归\n\n前序遍历的序列第一个位置就是root节点，后面分别是左子树和右子树，一开始无法知道哪些是左子树数字，哪些是右子树数字，但数字按照左——>右的顺序排列的。通过利用中序遍历序列可以得知，3的左边是左子树，3的右边是右子树。对于左子树，我们也能够获得其对应的前序和中序遍历，右子树同理。这样就将二叉树的建立转化为了一个递归问题：先在前序遍历确定根节点，然后确定中序中左子树开始和结束位置，以及右子树开始和结束位置，通过左子树前序和中序重建左子树，通过右子树前序和中序重建右子树，再向root添加左右子树的根节点，重建整个二叉树。\n\n\n# Java代码\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        if (preorder == null || preorder.length == 0) {\n            return null;\n        }\n        Map<Integer, Integer> dict = new HashMap<>();\n        // 建立中序map，快速获取位置\n        int length = preorder.length - 1;\n        for (int i = 0; i < inorder.length; i++) {\n            dict.put(inorder[i], i);\n        }\n        TreeNode root = reconstrTree(preorder, 0, length, inorder, 0, length, dict);\n        return root;\n    }\n    public TreeNode reconstrTree(int[] preorder, int postart, int poend, int[] inorder, int iostart, int ioend, Map<Integer, Integer> dict) {\n        if (postart > poend) { // 二叉树没有节点\n            return null;\n        }\n        int rootNode = preorder[postart]; // 对于前序序列，root节点就是第一个\n        TreeNode root = new TreeNode(rootNode);\n        if (postart == poend) { // 开始等于结束时，只有一个节点，就是root\n            return root;\n        } else {\n            int rootIndex = dict.get(rootNode); // 获取root节点在中序序列的坐标\n            int leftRange = rootIndex - iostart; // 得到左子树个数\n            int rightRange = ioend - rootIndex; // 得到右子树个数\n            // 传递左子树的前序和中序序列，建立左子树\n            TreeNode leftTree = reconstrTree(preorder, postart + 1, postart + leftRange,inorder,iostart, rootIndex - 1, dict);\n            // 传递右子树的前序和中序序列，建立右子树\n            TreeNode rightTree = reconstrTree(preorder, poend - rightRange + 1, poend,inorder,rootIndex + 1, ioend, dict);\n            root.left = leftTree;\n            root.right = rightTree;\n            return root;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# Python代码\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n        def buildTree(self, preorder, inorder):\n            """\n            :type preorder: List[int]\n            :type inorder: List[int]\n            :rtype: TreeNode\n            """\n            self.dict1 = {}\n            self.po = preorder\n            polen = len(preorder)\n            if (polen == 0):\n                return\n            for index, value in enumerate(inorder):\n                self.dict1[value] = index\n            return self.reconstrTree(0, 0, len(inorder) - 1)\n\n        def reconstrTree(self, postart, instart, inend):\n            if instart > inend: return\n            root = TreeNode(self.po[postart])\n            root_index = self.dict1[self.po[postart]]\n            root.left = self.reconstrTree(postart + 1, instart, root_index - 1)\n            root.right = self.reconstrTree(root_index - instart + postart + 1, root_index + 1, inend)\n            return root\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n',normalizedContent:'# leetcode-面试题07-重建二叉树\n\n输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。\n\n例如，给出\n\n前序遍历 preorder = [3,9,20,15,7]\n中序遍历 inorder = [9,3,15,20,7]\n\n\n1\n2\n\n1\n2\n\n\n返回如下的二叉树：\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n   \n限制：\n0 <= 节点个数 <= 5000\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 解题思路\n\n方法1、递归\n\n前序遍历的序列第一个位置就是root节点，后面分别是左子树和右子树，一开始无法知道哪些是左子树数字，哪些是右子树数字，但数字按照左——>右的顺序排列的。通过利用中序遍历序列可以得知，3的左边是左子树，3的右边是右子树。对于左子树，我们也能够获得其对应的前序和中序遍历，右子树同理。这样就将二叉树的建立转化为了一个递归问题：先在前序遍历确定根节点，然后确定中序中左子树开始和结束位置，以及右子树开始和结束位置，通过左子树前序和中序重建左子树，通过右子树前序和中序重建右子树，再向root添加左右子树的根节点，重建整个二叉树。\n\n\n# java代码\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public treenode buildtree(int[] preorder, int[] inorder) {\n        if (preorder == null || preorder.length == 0) {\n            return null;\n        }\n        map<integer, integer> dict = new hashmap<>();\n        // 建立中序map，快速获取位置\n        int length = preorder.length - 1;\n        for (int i = 0; i < inorder.length; i++) {\n            dict.put(inorder[i], i);\n        }\n        treenode root = reconstrtree(preorder, 0, length, inorder, 0, length, dict);\n        return root;\n    }\n    public treenode reconstrtree(int[] preorder, int postart, int poend, int[] inorder, int iostart, int ioend, map<integer, integer> dict) {\n        if (postart > poend) { // 二叉树没有节点\n            return null;\n        }\n        int rootnode = preorder[postart]; // 对于前序序列，root节点就是第一个\n        treenode root = new treenode(rootnode);\n        if (postart == poend) { // 开始等于结束时，只有一个节点，就是root\n            return root;\n        } else {\n            int rootindex = dict.get(rootnode); // 获取root节点在中序序列的坐标\n            int leftrange = rootindex - iostart; // 得到左子树个数\n            int rightrange = ioend - rootindex; // 得到右子树个数\n            // 传递左子树的前序和中序序列，建立左子树\n            treenode lefttree = reconstrtree(preorder, postart + 1, postart + leftrange,inorder,iostart, rootindex - 1, dict);\n            // 传递右子树的前序和中序序列，建立右子树\n            treenode righttree = reconstrtree(preorder, poend - rightrange + 1, poend,inorder,rootindex + 1, ioend, dict);\n            root.left = lefttree;\n            root.right = righttree;\n            return root;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# python代码\n\n# definition for a binary tree node.\n# class treenode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = none\n#         self.right = none\n\nclass solution(object):\n        def buildtree(self, preorder, inorder):\n            """\n            :type preorder: list[int]\n            :type inorder: list[int]\n            :rtype: treenode\n            """\n            self.dict1 = {}\n            self.po = preorder\n            polen = len(preorder)\n            if (polen == 0):\n                return\n            for index, value in enumerate(inorder):\n                self.dict1[value] = index\n            return self.reconstrtree(0, 0, len(inorder) - 1)\n\n        def reconstrtree(self, postart, instart, inend):\n            if instart > inend: return\n            root = treenode(self.po[postart])\n            root_index = self.dict1[self.po[postart]]\n            root.left = self.reconstrtree(postart + 1, instart, root_index - 1)\n            root.right = self.reconstrtree(root_index - instart + postart + 1, root_index + 1, inend)\n            return root\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题68-2-二叉搜索树的最近公共祖先",frontmatter:{title:"LeetCode-面试题68-2-二叉搜索树的最近公共祖先",date:"2020-05-29T10:35:42.000Z",description:"二叉搜索树的最近公共祖先",tags:["二叉树","Java","Easy","剑指Offer"],keywords:"二叉树,Java,Easy,剑指Offer",permalink:"/pages/10adcf/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/70.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9868-2-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html",relativePath:"06.算法/01.剑指Offer/70.LeetCode-面试题68-2-二叉搜索树的最近公共祖先.md",key:"v-51972726",path:"/pages/10adcf/",headers:[{level:2,title:"LeetCode-面试题68-2-二叉搜索树的最近公共祖先",slug:"leetcode-面试题68-2-二叉搜索树的最近公共祖先",normalizedTitle:"leetcode-面试题68-2-二叉搜索树的最近公共祖先",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:508},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:675}],headersStr:"LeetCode-面试题68-2-二叉搜索树的最近公共祖先 解题思路 Java代码",content:"# LeetCode-面试题68-2-二叉搜索树的最近公共祖先\n\n给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\n\n百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n\n例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]\n\n示例1：\n\n输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n输出: 3\n解释: 节点 5 和节点 1 的最近公共祖先是节点 3。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2：\n\n输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n输出: 5\n解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n说明：\n\n * 所有节点的值都是唯一的。\n * p、q 为不同节点且均存在于给定的二叉树中。\n\n\n# 解题思路\n\n递归：\n\n如果当前节点为空或者当前节点等于p和q的其中一个，则直接返回root，符合示例2条件\n\n如果当前节点的左右子树分别包括了p和q，那么这个节点就是最近公共祖先root\n\n如果左子树找不到p或者q，则说明p和q都在右子树上，返回right\n\n如果右子树找不到p或者q，则说明p和q都在左子树上，返回left\n\n\n# Java代码\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if(root==null||root==p||root==q) return root;\n        TreeNode left = lowestCommonAncestor(root.left,p,q);\n        TreeNode right = lowestCommonAncestor(root.right,p,q);\n        if(left==null) return right;\n        if(right==null) return left;\n        return root;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n",normalizedContent:"# leetcode-面试题68-2-二叉搜索树的最近公共祖先\n\n给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\n\n百度百科中最近公共祖先的定义为：“对于有根树 t 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n\n例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]\n\n示例1：\n\n输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n输出: 3\n解释: 节点 5 和节点 1 的最近公共祖先是节点 3。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2：\n\n输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n输出: 5\n解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n说明：\n\n * 所有节点的值都是唯一的。\n * p、q 为不同节点且均存在于给定的二叉树中。\n\n\n# 解题思路\n\n递归：\n\n如果当前节点为空或者当前节点等于p和q的其中一个，则直接返回root，符合示例2条件\n\n如果当前节点的左右子树分别包括了p和q，那么这个节点就是最近公共祖先root\n\n如果左子树找不到p或者q，则说明p和q都在右子树上，返回right\n\n如果右子树找不到p或者q，则说明p和q都在左子树上，返回left\n\n\n# java代码\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public treenode lowestcommonancestor(treenode root, treenode p, treenode q) {\n        if(root==null||root==p||root==q) return root;\n        treenode left = lowestcommonancestor(root.left,p,q);\n        treenode right = lowestcommonancestor(root.right,p,q);\n        if(left==null) return right;\n        if(right==null) return left;\n        return root;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题52-两个链表的第一个公共节点",frontmatter:{title:"LeetCode-面试题52-两个链表的第一个公共节点",date:"2020-05-12T12:55:26.000Z",description:"两个链表的第一个公共节点",tags:["链表","Java","Python","Easy","剑指Offer"],keywords:"链表,Java,Python,Easy,剑指Offer",permalink:"/pages/a0e6b3/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/72.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9852-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9.html",relativePath:"06.算法/01.剑指Offer/72.LeetCode-面试题52-两个链表的第一个公共节点.md",key:"v-62e48c45",path:"/pages/a0e6b3/",headers:[{level:2,title:"LeetCode-面试题52-两个链表的第一个公共节点",slug:"leetcode-面试题52-两个链表的第一个公共节点",normalizedTitle:"leetcode-面试题52-两个链表的第一个公共节点",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:932},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:1208},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:2466},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:2965}],headersStr:"LeetCode-面试题52-两个链表的第一个公共节点 解题思路 Java代码 Python代码 Java代码2",content:"# LeetCode-面试题52-两个链表的第一个公共节点\n\n输入两个链表，找出它们的第一个公共节点。\n\n示例1：\n\n输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\n输出：Reference of the node with value = 8\n输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2：\n\n输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n输出：Reference of the node with value = 2\n输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例3：\n\n输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n输出：null\n输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n解释：这两个链表不相交，因此返回 null。\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n说明：\n\n * 如果两个链表没有交点，返回 null.\n * 在返回结果后，两个链表仍须保持原有的结构。\n * 可假定整个链表结构中没有循环。\n * 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。\n\n\n# 解题思路\n\n方法1、双指针+先遍历：\n\n因为链表一长一短，所以先让长的一方走到和短的一方开始的位置，然后用双指针同时进行遍历，出现第一个相同的节点时就返回对应指针\n\n方法2、双指针+重置：\n\n同样是双指针，因为一长一短的关系，有一个指针会先到达末尾，当第一个指针pA先到末尾时，将他重置到链表B的开始位置，当第二个指针pB到达末尾时，将他重置到链表A开始的位置。由于有一个先到达先重置，在等待第二个指针走到末尾的过程中，先达到的指针pA将会走这段A比B多出的长度。这样当第二个指针重置时，两个指针都在一个位置开始，之后遍历到相同的节点返回即可\n\n\n# Java代码\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        int lenA = getTreelen(headA);\n        int lenB = getTreelen(headB);\n        int firstStep = Math.abs(lenA-lenB);\n        ListNode pLong = headA;\n        ListNode pShort = headB;\n        if(lenA<lenB){\n            pLong = headB;\n            pShort = headA;\n        }\n        // 长的先走几步\n        for(int i=0;i<firstStep;i++){\n            pLong = pLong.next;\n        }\n        while(pLong!=null&&pShort!=null&&pLong!=pShort){\n            pLong = pLong.next;\n            pShort = pShort.next;\n        }\n        return pLong;\n    }\n    public int getTreelen(ListNode head){\n        int lenTree = 0;\n        while(head!=null){\n            lenTree++;\n            head = head.next;\n        }\n        return lenTree;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n# Python代码\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        node1, node2 = headA, headB\n        while node1 != node2:\n            node1 = node1.next if node1 else headB\n            node2 = node2.next if node2 else headA\n        return node1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# Java代码2\n\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode p1 = headA;\n        ListNode p2 = headB;\n        while(p1!=p2){\n            if(p1!=null){\n                p1 = p1.next;\n            } else {\n                p1 = headB;\n            }\n            if(p2!=null){\n                p2 = p2.next;\n            } else {\n                p2 = headA;\n            }\n        }\n        return p1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n",normalizedContent:"# leetcode-面试题52-两个链表的第一个公共节点\n\n输入两个链表，找出它们的第一个公共节点。\n\n示例1：\n\n输入：intersectval = 8, lista = [4,1,8,4,5], listb = [5,0,1,8,4,5], skipa = 2, skipb = 3\n输出：reference of the node with value = 8\n输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 a 为 [4,1,8,4,5]，链表 b 为 [5,0,1,8,4,5]。在 a 中，相交节点前有 2 个节点；在 b 中，相交节点前有 3 个节点。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2：\n\n输入：intersectval = 2, lista = [0,9,1,2,4], listb = [3,2,4], skipa = 3, skipb = 1\n输出：reference of the node with value = 2\n输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 a 为 [0,9,1,2,4]，链表 b 为 [3,2,4]。在 a 中，相交节点前有 3 个节点；在 b 中，相交节点前有 1 个节点。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例3：\n\n输入：intersectval = 0, lista = [2,6,4], listb = [1,5], skipa = 3, skipb = 2\n输出：null\n输入解释：从各自的表头开始算起，链表 a 为 [2,6,4]，链表 b 为 [1,5]。由于这两个链表不相交，所以 intersectval 必须为 0，而 skipa 和 skipb 可以是任意值。\n解释：这两个链表不相交，因此返回 null。\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n说明：\n\n * 如果两个链表没有交点，返回 null.\n * 在返回结果后，两个链表仍须保持原有的结构。\n * 可假定整个链表结构中没有循环。\n * 程序尽量满足 o(n) 时间复杂度，且仅用 o(1) 内存。\n\n\n# 解题思路\n\n方法1、双指针+先遍历：\n\n因为链表一长一短，所以先让长的一方走到和短的一方开始的位置，然后用双指针同时进行遍历，出现第一个相同的节点时就返回对应指针\n\n方法2、双指针+重置：\n\n同样是双指针，因为一长一短的关系，有一个指针会先到达末尾，当第一个指针pa先到末尾时，将他重置到链表b的开始位置，当第二个指针pb到达末尾时，将他重置到链表a开始的位置。由于有一个先到达先重置，在等待第二个指针走到末尾的过程中，先达到的指针pa将会走这段a比b多出的长度。这样当第二个指针重置时，两个指针都在一个位置开始，之后遍历到相同的节点返回即可\n\n\n# java代码\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class solution {\n    public listnode getintersectionnode(listnode heada, listnode headb) {\n        int lena = gettreelen(heada);\n        int lenb = gettreelen(headb);\n        int firststep = math.abs(lena-lenb);\n        listnode plong = heada;\n        listnode pshort = headb;\n        if(lena<lenb){\n            plong = headb;\n            pshort = heada;\n        }\n        // 长的先走几步\n        for(int i=0;i<firststep;i++){\n            plong = plong.next;\n        }\n        while(plong!=null&&pshort!=null&&plong!=pshort){\n            plong = plong.next;\n            pshort = pshort.next;\n        }\n        return plong;\n    }\n    public int gettreelen(listnode head){\n        int lentree = 0;\n        while(head!=null){\n            lentree++;\n            head = head.next;\n        }\n        return lentree;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n# python代码\n\n# definition for singly-linked list.\n# class listnode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = none\n\nclass solution:\n    def getintersectionnode(self, heada: listnode, headb: listnode) -> listnode:\n        node1, node2 = heada, headb\n        while node1 != node2:\n            node1 = node1.next if node1 else headb\n            node2 = node2.next if node2 else heada\n        return node1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# java代码2\n\npublic class solution {\n    public listnode getintersectionnode(listnode heada, listnode headb) {\n        listnode p1 = heada;\n        listnode p2 = headb;\n        while(p1!=p2){\n            if(p1!=null){\n                p1 = p1.next;\n            } else {\n                p1 = headb;\n            }\n            if(p2!=null){\n                p2 = p2.next;\n            } else {\n                p2 = heada;\n            }\n        }\n        return p1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题53-2-0到n-1中缺失的数字",frontmatter:{title:"LeetCode-面试题53-2-0到n-1中缺失的数字",date:"2020-05-12T16:10:46.000Z",description:"0到n-1中缺失的数字",tags:["数组","Java","Easy","剑指Offer"],keywords:"数组,Java,Easy,剑指Offer",permalink:"/pages/f558cf/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/73.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9853-2-0%E5%88%B0n-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97.html",relativePath:"06.算法/01.剑指Offer/73.LeetCode-面试题53-2-0到n-1中缺失的数字.md",key:"v-5e1b404a",path:"/pages/f558cf/",headers:[{level:2,title:"LeetCode-面试题53-2-0到n-1中缺失的数字",slug:"leetcode-面试题53-2-0到n-1中缺失的数字",normalizedTitle:"leetcode-面试题53-2-0到n-1中缺失的数字",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:240},{level:3,title:"Java代码1",slug:"java代码1",normalizedTitle:"java代码1",charIndex:1148},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:1558},{level:3,title:"Java代码3",slug:"java代码3",normalizedTitle:"java代码3",charIndex:1860},{level:3,title:"Java代码3",slug:"java代码3-2",normalizedTitle:"java代码3",charIndex:1860}],headersStr:"LeetCode-面试题53-2-0到n-1中缺失的数字 解题思路 Java代码1 Java代码2 Java代码3 Java代码3",content:'# LeetCode-面试题53-2-0到n-1中缺失的数字\n\n一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。\n\n示例1：\n\n输入: [0,1,3]\n输出: 2\n\n\n1\n2\n\n1\n2\n\n\n示例2：\n\n输入: [0,1,2,3,4,5,6,7,9]\n输出: 8\n\n\n1\n2\n\n1\n2\n\n\n * 限制：\n   \n   1 <= 数组长度 <= 10000\n\n\n# 解题思路\n\n方法1、二分查找：\n\n递增且数字范围在0~n-1的数组**(有序数组)**，数字和它对应的下标一定是相等的，缺失的数子会造成，该数字之后的数组下标在原本相等的情况下+1\n\n排序数组中的搜索问题，首先想到二分查找解决\n\n分析可知，数组可以分为左右子数组2部分：\n\n * 左子数组：nums[i]=i\n * 右子数组：nums[i]!=i\n\n缺失的数字=右子数组的首位元素对应的索引\n\n 1. 初始化头尾指针start，end\n 2. 当start<end时，计算mid = (start+end)/2\n 3. 若nums[mid] = mid，则"右子数组的首位元素"一定在闭区间[mid+1,end]中，因此执行start = mid+1;\n 4. 若nums[mid]!=mid，则"左子数组的末位元素"一定在闭区间[start,mid-1]中，因此end = mid -1;\n 5. 跳出时，start就是指向右子数组的首位元素，end指向左子数组的末位元素，因此返回start即可\n\n时间复杂度O(logN)，空间复杂度O(1)\n\n方法2、异或运算：\n\n异或运算，可以使得相同的数字异或为0，如bb=0，ab^b=a\n\n由于数组有序且递增，除了缺失数字外，每一位元素和索引进行异或均为0\n\n 1. 初始化res=0，即先假设这个数字为0，先把数组的[0,n-1]范围内的数组异或一遍，此时等于n个数字全部异或，再把他和对应的[0,n-1]索引下标异或一遍，这两个操作可以在一个循环中搞定。\n 2. 因为元素和下标是相等的，异或为0，所以缺失的数字一定会在异或2次操作后剩下，因为缺失的数字和下标是不等的\n 3. 最后再将res异或上数组下标n也就是此时i的值(因为此时，数组已经异或了n个，而下标只异或了n-1个，所以循环之外还需要再次异或数组下标i++即n)，就可以得到缺失的数字。\n\n方法3、遍历下标比对：\n\n先获得数组的长度记为n，由于数组内数字在0~n-1范围内，所以可以直接遍历数组，当当前的数组下标和数组值不相等时就是答案，否则说明缺失的数组值不在数组中，直接返回数组长度即可\n\n\n# Java代码1\n\nclass Solution {\n    public int missingNumber(int[] nums) {\n        int start = 0, end = nums.length - 1;\n        while(start <= end) {\n            int mid = (start + end) / 2;\n            if(nums[mid] == mid) \n                start = mid + 1;\n            else \n                end = mid - 1;\n        }\n        return start;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# Java代码2\n\nclass Solution {\n    public int missingNumber(int[] nums) {\n        int n = nums.length;\n        int res = 0;\n        for (int i=0;i<nums.length;i++){\n            res^=nums[i];\n            res^=i;\n        }\n        return res^n;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# Java代码3\n\nclass Solution {\n    public int missingNumber(int[] nums) {\n        int n = nums.length;\n        for(int i=0;i<n;i++){\n            if(nums[i]!=i){\n                return i;\n            } \n        }\n        return nums.length;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n提示\n\n2020年8月29日 22:10:10更新，当数组是无序的时候，且数组范围在[1,n-1]，应该怎么去做？\n\n方法、异或运算：\n\n数组无序的情况依旧可以使用异或运算进行处理\n\n先初始化r=0，将r与数组所有值异或一次，之后将r和数组i+1异或一次(因为下标从1开始，但循环从0开始)，由于补全之后，数组的长度是n，当前的数组长度为n-1，所以还需要再异或最后一位数字的索引，因为数组的范围从1开始，所以最后的异或同样有1的偏移，即nums.length+1，才能得到缺失的数字。\n\n无论数组是否有序，异或2次之后，缺失的数字就是剩下的，如果不缺失则2次异或完毕的结果为0\n\n\n# Java代码3\n\npublic class LeetCode53_2 {\n    public static void main(String[] args) {\n        int[] nums = new int[]{1, 3, 2, 5, 4, 7, 8};\n        int r = 0;\n        for (int i = 0; i < nums.length; i++) {\n            r ^= (nums[i] ^ (i+1));\n        }\n        System.out.println(r ^ (nums.length+1));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n',normalizedContent:'# leetcode-面试题53-2-0到n-1中缺失的数字\n\n一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。\n\n示例1：\n\n输入: [0,1,3]\n输出: 2\n\n\n1\n2\n\n1\n2\n\n\n示例2：\n\n输入: [0,1,2,3,4,5,6,7,9]\n输出: 8\n\n\n1\n2\n\n1\n2\n\n\n * 限制：\n   \n   1 <= 数组长度 <= 10000\n\n\n# 解题思路\n\n方法1、二分查找：\n\n递增且数字范围在0~n-1的数组**(有序数组)**，数字和它对应的下标一定是相等的，缺失的数子会造成，该数字之后的数组下标在原本相等的情况下+1\n\n排序数组中的搜索问题，首先想到二分查找解决\n\n分析可知，数组可以分为左右子数组2部分：\n\n * 左子数组：nums[i]=i\n * 右子数组：nums[i]!=i\n\n缺失的数字=右子数组的首位元素对应的索引\n\n 1. 初始化头尾指针start，end\n 2. 当start<end时，计算mid = (start+end)/2\n 3. 若nums[mid] = mid，则"右子数组的首位元素"一定在闭区间[mid+1,end]中，因此执行start = mid+1;\n 4. 若nums[mid]!=mid，则"左子数组的末位元素"一定在闭区间[start,mid-1]中，因此end = mid -1;\n 5. 跳出时，start就是指向右子数组的首位元素，end指向左子数组的末位元素，因此返回start即可\n\n时间复杂度o(logn)，空间复杂度o(1)\n\n方法2、异或运算：\n\n异或运算，可以使得相同的数字异或为0，如bb=0，ab^b=a\n\n由于数组有序且递增，除了缺失数字外，每一位元素和索引进行异或均为0\n\n 1. 初始化res=0，即先假设这个数字为0，先把数组的[0,n-1]范围内的数组异或一遍，此时等于n个数字全部异或，再把他和对应的[0,n-1]索引下标异或一遍，这两个操作可以在一个循环中搞定。\n 2. 因为元素和下标是相等的，异或为0，所以缺失的数字一定会在异或2次操作后剩下，因为缺失的数字和下标是不等的\n 3. 最后再将res异或上数组下标n也就是此时i的值(因为此时，数组已经异或了n个，而下标只异或了n-1个，所以循环之外还需要再次异或数组下标i++即n)，就可以得到缺失的数字。\n\n方法3、遍历下标比对：\n\n先获得数组的长度记为n，由于数组内数字在0~n-1范围内，所以可以直接遍历数组，当当前的数组下标和数组值不相等时就是答案，否则说明缺失的数组值不在数组中，直接返回数组长度即可\n\n\n# java代码1\n\nclass solution {\n    public int missingnumber(int[] nums) {\n        int start = 0, end = nums.length - 1;\n        while(start <= end) {\n            int mid = (start + end) / 2;\n            if(nums[mid] == mid) \n                start = mid + 1;\n            else \n                end = mid - 1;\n        }\n        return start;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# java代码2\n\nclass solution {\n    public int missingnumber(int[] nums) {\n        int n = nums.length;\n        int res = 0;\n        for (int i=0;i<nums.length;i++){\n            res^=nums[i];\n            res^=i;\n        }\n        return res^n;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# java代码3\n\nclass solution {\n    public int missingnumber(int[] nums) {\n        int n = nums.length;\n        for(int i=0;i<n;i++){\n            if(nums[i]!=i){\n                return i;\n            } \n        }\n        return nums.length;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n提示\n\n2020年8月29日 22:10:10更新，当数组是无序的时候，且数组范围在[1,n-1]，应该怎么去做？\n\n方法、异或运算：\n\n数组无序的情况依旧可以使用异或运算进行处理\n\n先初始化r=0，将r与数组所有值异或一次，之后将r和数组i+1异或一次(因为下标从1开始，但循环从0开始)，由于补全之后，数组的长度是n，当前的数组长度为n-1，所以还需要再异或最后一位数字的索引，因为数组的范围从1开始，所以最后的异或同样有1的偏移，即nums.length+1，才能得到缺失的数字。\n\n无论数组是否有序，异或2次之后，缺失的数字就是剩下的，如果不缺失则2次异或完毕的结果为0\n\n\n# java代码3\n\npublic class leetcode53_2 {\n    public static void main(string[] args) {\n        int[] nums = new int[]{1, 3, 2, 5, 4, 7, 8};\n        int r = 0;\n        for (int i = 0; i < nums.length; i++) {\n            r ^= (nums[i] ^ (i+1));\n        }\n        system.out.println(r ^ (nums.length+1));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题57-2-和为s的连续正数序列",frontmatter:{title:"LeetCode-面试题57-2-和为s的连续正数序列",date:"2020-05-19T10:00:38.000Z",description:"和为s的两个数字",tags:["数组","滑动窗口","Java","Python","Easy","剑指Offer"],keywords:"数组,滑动窗口,Java,Python,Easy,剑指Offer",permalink:"/pages/a09b75/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/74.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9857-2-%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97.html",relativePath:"06.算法/01.剑指Offer/74.LeetCode-面试题57-2-和为s的连续正数序列.md",key:"v-d43ad834",path:"/pages/a09b75/",headers:[{level:2,title:"LeetCode-面试题57-2-和为s的连续正数序列",slug:"leetcode-面试题57-2-和为s的连续正数序列",normalizedTitle:"leetcode-面试题57-2-和为s的连续正数序列",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:263},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:768},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:749}],headersStr:"LeetCode-面试题57-2-和为s的连续正数序列 解题思路 Java代码 Python代码",content:"# LeetCode-面试题57-2-和为s的连续正数序列\n\n输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。\n\n序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。\n\n示例1：\n\n输入：target = 9\n输出：[[2,3,4],[4,5]]\n\n\n1\n2\n\n1\n2\n\n\n示例 2:\n\n输入：target = 15\n输出：[[1,2,3,4,5],[4,5,6],[7,8]]\n\n\n1\n2\n\n1\n2\n\n\n限制：\n\n * 1 <= target <= 10^5\n\n\n# 解题思路\n\n滑动窗口：\n\n序列至少包含2个数，窗口从1(small)，2(big)开始，且small指针不会超过中值，简单例子，比如15=8+small，small是不可能比8大的，当small都已经跨过中值，big肯定也比small大，两个的组合不可能得到target，所以small<mid即可\n\n接下来分为3种情况讨论：\n\n * 当序列和curSum<target时，说明需要扩大窗口，这里恒向右扩大，指针右移big++，当前序列值也需要加上big，curSum+=big\n * 当序列和curSum>target时，说明需要缩小窗口，从最小的值开始缩小，curSum-=small，之后指针左移small--\n * 当序列和curSum==target时，说明序列和满足要求，由于要求二维数组存储，这里新开辟一个big-small+1大小的数组，存储[small,big]范围内的数字，之后添加进res中。之后使big指针右移，curSum+=big，继续下一轮的窗口计算\n\n实际上序列和可以由公式(left+right)*(right-left+1)//2得到，Python代码返回更加轻松\n\n\n# Java代码\n\nclass Solution {\n    public int[][] findContinuousSequence(int target) {\n        int small = 1;\n        int big = 2;\n        int mid = (target+1)/2;\n        int curSum = small+big;\n        List<int[]> res = new ArrayList<>();\n        while(small<mid){\n            if(curSum==target){\n                int[] nums = new int[big-small+1];\n                int i = 0;\n                for(int k=small;k<=big;k++){\n                    nums[i] = k;\n                    i++;\n                }\n                res.add(nums);\n                big++;\n                curSum+=big;\n            }\n            else if(curSum<target){\n                big++;\n                curSum+=big;\n            }else{\n                curSum-=small;\n                small++;\n            }\n        }\n        return res.toArray(new int[res.size()][]);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# Python代码\n\nclass Solution:\n    def findContinuousSequence(self, target: int) -> List[List[int]]:\n        res = []\n        left,right = 1,2\n        mid = (target+1)//2\n        while left<mid:\n            sum = (left+right)*(right-left+1)//2\n            tlist = []\n            if sum<target:\n                right+=1\n            elif sum>target:\n                left+=1\n            else:\n                for i in range(left,right+1):\n                    tlist.append(i)\n                res.append(tlist)\n                left+=1\n                right+=1\n        return res\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n",normalizedContent:"# leetcode-面试题57-2-和为s的连续正数序列\n\n输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。\n\n序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。\n\n示例1：\n\n输入：target = 9\n输出：[[2,3,4],[4,5]]\n\n\n1\n2\n\n1\n2\n\n\n示例 2:\n\n输入：target = 15\n输出：[[1,2,3,4,5],[4,5,6],[7,8]]\n\n\n1\n2\n\n1\n2\n\n\n限制：\n\n * 1 <= target <= 10^5\n\n\n# 解题思路\n\n滑动窗口：\n\n序列至少包含2个数，窗口从1(small)，2(big)开始，且small指针不会超过中值，简单例子，比如15=8+small，small是不可能比8大的，当small都已经跨过中值，big肯定也比small大，两个的组合不可能得到target，所以small<mid即可\n\n接下来分为3种情况讨论：\n\n * 当序列和cursum<target时，说明需要扩大窗口，这里恒向右扩大，指针右移big++，当前序列值也需要加上big，cursum+=big\n * 当序列和cursum>target时，说明需要缩小窗口，从最小的值开始缩小，cursum-=small，之后指针左移small--\n * 当序列和cursum==target时，说明序列和满足要求，由于要求二维数组存储，这里新开辟一个big-small+1大小的数组，存储[small,big]范围内的数字，之后添加进res中。之后使big指针右移，cursum+=big，继续下一轮的窗口计算\n\n实际上序列和可以由公式(left+right)*(right-left+1)//2得到，python代码返回更加轻松\n\n\n# java代码\n\nclass solution {\n    public int[][] findcontinuoussequence(int target) {\n        int small = 1;\n        int big = 2;\n        int mid = (target+1)/2;\n        int cursum = small+big;\n        list<int[]> res = new arraylist<>();\n        while(small<mid){\n            if(cursum==target){\n                int[] nums = new int[big-small+1];\n                int i = 0;\n                for(int k=small;k<=big;k++){\n                    nums[i] = k;\n                    i++;\n                }\n                res.add(nums);\n                big++;\n                cursum+=big;\n            }\n            else if(cursum<target){\n                big++;\n                cursum+=big;\n            }else{\n                cursum-=small;\n                small++;\n            }\n        }\n        return res.toarray(new int[res.size()][]);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# python代码\n\nclass solution:\n    def findcontinuoussequence(self, target: int) -> list[list[int]]:\n        res = []\n        left,right = 1,2\n        mid = (target+1)//2\n        while left<mid:\n            sum = (left+right)*(right-left+1)//2\n            tlist = []\n            if sum<target:\n                right+=1\n            elif sum>target:\n                left+=1\n            else:\n                for i in range(left,right+1):\n                    tlist.append(i)\n                res.append(tlist)\n                left+=1\n                right+=1\n        return res\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题59-1-滑动窗口的最大值",frontmatter:{title:"LeetCode-面试题59-1-滑动窗口的最大值",date:"2020-05-19T15:13:10.000Z",description:"滑动窗口的最大值",tags:["数组","滑动窗口","Java","Hard","剑指Offer"],keywords:"数组,Java,滑动窗口,Hard,剑指Offer",permalink:"/pages/e91bb1/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/75.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9859-1-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC.html",relativePath:"06.算法/01.剑指Offer/75.LeetCode-面试题59-1-滑动窗口的最大值.md",key:"v-01211f8e",path:"/pages/e91bb1/",headers:[{level:2,title:"LeetCode-面试题59-1-滑动窗口的最大值",slug:"leetcode-面试题59-1-滑动窗口的最大值",normalizedTitle:"leetcode-面试题59-1-滑动窗口的最大值",charIndex:2},{level:3,title:"解题思路1",slug:"解题思路1",normalizedTitle:"解题思路1",charIndex:520},{level:3,title:"解题思路2",slug:"解题思路2",normalizedTitle:"解题思路2",charIndex:852},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:991},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:2401},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:3036}],headersStr:"LeetCode-面试题59-1-滑动窗口的最大值 解题思路1 解题思路2 Java代码 Python代码 Java代码2",content:"# LeetCode-面试题59-1-滑动窗口的最大值\n\n给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。\n\n示例：\n\n输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3\n输出: [3,3,5,5,6,7] \n解释: \n\n  滑动窗口的位置                最大值\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n提示：\n\n你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。\n\n\n# 解题思路1\n\n常规的想法是滑动一次窗口遍历一次窗口值，返回最大值，但这样的时间复杂度是O(nk)\n\n双端队列：\n\n把有可能成为滑动窗口最大值的数字存入双端队列中，最大值始终放在队列头部\n\n对于前k个数值，当队列不为空的情况下，如果当前遍历的元素要>=队列尾部元素，则说明队列尾部的值不可能是最大值，弹出队列尾部，添加当前值\n\n对于[k,nums.length]区间的数值，需要判断队列中的值是否仍然在滑动窗口内部，如果不在内部需要弹出队列头部。如果当前遍历的元素要>=队列尾部元素，则说明队列尾部的值不可能是最大值，弹出队列尾部。遍历时恒添加当前元素到末尾。\n\n为了便于判断队列头部是否还在滑动窗口内部，队列存储的并非是真正的元素，而是元素在数组中的下标\n\n\n# 解题思路2\n\n三指针：\n\n当初始化时，首先直接遍历找到当前窗口的最大值，并记录位置。当移动左右指针时，判断最大值是否因为移动左指针，而不在窗口内了，不在窗口内则重新遍历。如果在窗口内，则只需要判断右指针新进来的数值是否比窗口内最大值大，谁大就作为当前窗口内的最大值下标\n\n\n# Java代码\n\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        List<Integer> res = new LinkedList<>();\n        if (nums.length >= k && k >= 1) {\n            Deque<Integer> deque = new LinkedList<>();\n            // 前k个\n            for (int i = 0; i < k; i++) {\n                // 队列不为空，且当前元素>=队列尾部，则尾部不可能是最大值，弹出\n                while (!deque.isEmpty() && nums[i] >= nums[deque.getLast()])\n                    deque.removeLast();\n                deque.addLast(i);\n            }\n            // k到末尾个\n            for (int i = k; i < nums.length; i++) {\n                // 添加最大值\n                res.add(nums[deque.getFirst()]);\n                // 队列不为空，且当前元素>=队列尾部，则尾部不可能是最大值，弹出\n                while (!deque.isEmpty() && nums[i] >= nums[deque.getLast()])\n                    deque.removeLast();\n                // 判断队列头部是否还在滑动窗口内，如果当前处理元素的下标i减去窗口大小k>=队列头部下标\n                // 说明头部不在滑动窗口内，需要弹出\n                if (!deque.isEmpty() && deque.getFirst() <= (i - k))\n                    deque.removeFirst();\n                deque.addLast(i);\n            }\n            // 添加最后一个滑动窗口的最大值\n            res.add(nums[deque.getFirst()]);\n        }\n        return res.stream().mapToInt(Integer::intValue).toArray();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# Python代码\n\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        if not nums or k == 0: return []\n        deque = collections.deque()\n        for i in range(k):\n            while deque and deque[-1] < nums[i]: deque.pop()\n            deque.append(nums[i])\n        res = [deque[0]]\n        for i in range(k, len(nums)):\n            if deque[0] == nums[i - k]: deque.popleft()\n            while deque and deque[-1] < nums[i]: deque.pop()\n            deque.append(nums[i])\n            res.append(deque[0])\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# Java代码2\n\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        if (nums == null || nums.length == 0) {\n            return new int[0];\n        }\n        if (nums.length == 1) {\n            return nums;\n        }\n        int[] res = new int[nums.length + 1 - k];\n        // 窗口起始位置\n        int left = 0;\n        // 窗口结束位置\n        int right = k - 1;\n        // 记录最大值的位置\n        int maxIndex = 0;\n        // 结果位置\n        int j = 0;\n        while (right < nums.length) {\n            // 当初始化时，首先直接遍历找到当前窗口的最大值，并记录位置\n            // 当移动左右指针时，判断最大值是否因为移动左指针，而不在窗口内了，不在窗口内则重新遍历\n            // 如果在窗口内，则只需要判断右指针新进来的数值是否比窗口内最大值大，谁大就作为当前窗口内的最大值下标\n            if (left > maxIndex || left == 0) {\n                maxIndex = left;\n                for (int i = left; i <= right; i++) {\n                    maxIndex = nums[i] > nums[maxIndex] ? i : maxIndex;\n                }\n            } else {\n                maxIndex = nums[right] > nums[maxIndex] ? right : maxIndex;\n            }\n            res[j++] = nums[maxIndex];\n            left++;\n            right++;\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n",normalizedContent:"# leetcode-面试题59-1-滑动窗口的最大值\n\n给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。\n\n示例：\n\n输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3\n输出: [3,3,5,5,6,7] \n解释: \n\n  滑动窗口的位置                最大值\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n提示：\n\n你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。\n\n\n# 解题思路1\n\n常规的想法是滑动一次窗口遍历一次窗口值，返回最大值，但这样的时间复杂度是o(nk)\n\n双端队列：\n\n把有可能成为滑动窗口最大值的数字存入双端队列中，最大值始终放在队列头部\n\n对于前k个数值，当队列不为空的情况下，如果当前遍历的元素要>=队列尾部元素，则说明队列尾部的值不可能是最大值，弹出队列尾部，添加当前值\n\n对于[k,nums.length]区间的数值，需要判断队列中的值是否仍然在滑动窗口内部，如果不在内部需要弹出队列头部。如果当前遍历的元素要>=队列尾部元素，则说明队列尾部的值不可能是最大值，弹出队列尾部。遍历时恒添加当前元素到末尾。\n\n为了便于判断队列头部是否还在滑动窗口内部，队列存储的并非是真正的元素，而是元素在数组中的下标\n\n\n# 解题思路2\n\n三指针：\n\n当初始化时，首先直接遍历找到当前窗口的最大值，并记录位置。当移动左右指针时，判断最大值是否因为移动左指针，而不在窗口内了，不在窗口内则重新遍历。如果在窗口内，则只需要判断右指针新进来的数值是否比窗口内最大值大，谁大就作为当前窗口内的最大值下标\n\n\n# java代码\n\nclass solution {\n    public int[] maxslidingwindow(int[] nums, int k) {\n        list<integer> res = new linkedlist<>();\n        if (nums.length >= k && k >= 1) {\n            deque<integer> deque = new linkedlist<>();\n            // 前k个\n            for (int i = 0; i < k; i++) {\n                // 队列不为空，且当前元素>=队列尾部，则尾部不可能是最大值，弹出\n                while (!deque.isempty() && nums[i] >= nums[deque.getlast()])\n                    deque.removelast();\n                deque.addlast(i);\n            }\n            // k到末尾个\n            for (int i = k; i < nums.length; i++) {\n                // 添加最大值\n                res.add(nums[deque.getfirst()]);\n                // 队列不为空，且当前元素>=队列尾部，则尾部不可能是最大值，弹出\n                while (!deque.isempty() && nums[i] >= nums[deque.getlast()])\n                    deque.removelast();\n                // 判断队列头部是否还在滑动窗口内，如果当前处理元素的下标i减去窗口大小k>=队列头部下标\n                // 说明头部不在滑动窗口内，需要弹出\n                if (!deque.isempty() && deque.getfirst() <= (i - k))\n                    deque.removefirst();\n                deque.addlast(i);\n            }\n            // 添加最后一个滑动窗口的最大值\n            res.add(nums[deque.getfirst()]);\n        }\n        return res.stream().maptoint(integer::intvalue).toarray();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# python代码\n\nclass solution:\n    def maxslidingwindow(self, nums: list[int], k: int) -> list[int]:\n        if not nums or k == 0: return []\n        deque = collections.deque()\n        for i in range(k):\n            while deque and deque[-1] < nums[i]: deque.pop()\n            deque.append(nums[i])\n        res = [deque[0]]\n        for i in range(k, len(nums)):\n            if deque[0] == nums[i - k]: deque.popleft()\n            while deque and deque[-1] < nums[i]: deque.pop()\n            deque.append(nums[i])\n            res.append(deque[0])\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# java代码2\n\nclass solution {\n    public int[] maxslidingwindow(int[] nums, int k) {\n        if (nums == null || nums.length == 0) {\n            return new int[0];\n        }\n        if (nums.length == 1) {\n            return nums;\n        }\n        int[] res = new int[nums.length + 1 - k];\n        // 窗口起始位置\n        int left = 0;\n        // 窗口结束位置\n        int right = k - 1;\n        // 记录最大值的位置\n        int maxindex = 0;\n        // 结果位置\n        int j = 0;\n        while (right < nums.length) {\n            // 当初始化时，首先直接遍历找到当前窗口的最大值，并记录位置\n            // 当移动左右指针时，判断最大值是否因为移动左指针，而不在窗口内了，不在窗口内则重新遍历\n            // 如果在窗口内，则只需要判断右指针新进来的数值是否比窗口内最大值大，谁大就作为当前窗口内的最大值下标\n            if (left > maxindex || left == 0) {\n                maxindex = left;\n                for (int i = left; i <= right; i++) {\n                    maxindex = nums[i] > nums[maxindex] ? i : maxindex;\n                }\n            } else {\n                maxindex = nums[right] > nums[maxindex] ? right : maxindex;\n            }\n            res[j++] = nums[maxindex];\n            left++;\n            right++;\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题28-对称的二叉树",frontmatter:{title:"LeetCode-面试题28-对称的二叉树",date:"2020-04-20T17:21:41.000Z",description:"对称的二叉树",tags:["树","Python","Java","Easy","剑指Offer"],keywords:"树,Java,Python,Easy,剑指Offer",permalink:"/pages/28dd80/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/76.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9828-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91.html",relativePath:"06.算法/01.剑指Offer/76.LeetCode-面试题28-对称的二叉树.md",key:"v-b661f760",path:"/pages/28dd80/",headers:[{level:2,title:"LeetCode-面试题28-对称的二叉树",slug:"leetcode-面试题28-对称的二叉树",normalizedTitle:"leetcode-面试题28-对称的二叉树",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:414},{level:3,title:"Java代码1",slug:"java代码1",normalizedTitle:"java代码1",charIndex:871},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:2151},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:2759}],headersStr:"LeetCode-面试题28-对称的二叉树 解题思路 Java代码1 Python代码 Java代码2",content:"# LeetCode-面试题28-对称的二叉树\n\n请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。\n\n例如，二叉树 [1,2,2,3,4,4,3] 是对称的。\n\n    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:\n\n    1\n   / \\\n  2   2\n   \\   \\\n   3    3\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n示例1：\n\n输入：root = [1,2,2,3,4,4,3]\n输出：true\n\n\n1\n2\n\n1\n2\n\n\n示例2：\n\n输入：root = [1,2,2,null,3,null,3]\n输出：false\n\n\n1\n2\n\n1\n2\n\n\n限制：\n\n0 <= 节点个数 <= 1000\n\n\n# 解题思路\n\n方法1：栈\n\n利用栈一次性拿出2个节点进行比较\n\n将左子树的left节点和右子树的right节点放入栈\n\n之后将左子树的right节点和右子树的left节点放入栈，比较2个值是否相等\n\n方法2：递归\n\n终止条件：\n\n * 与栈的条件类似，当L和R同时越过叶子节点(即左右子节点为null)，则这个树从顶到底都是对称的，返回True\n * 当L和R只有一个越过叶子节点(即左/右子节点有一个为null)，则这个树不是对称的，返回False\n * 当L和R的值不相等时，则这个树不是对称的，返回False\n\n开启递归：\n\n * 判断两个节点L.left和R.right是否是对称的\n * 判断两个节点L.right和R.left是否是对称的\n\n方法3：队列\n\n先入队列根节点的左右节点，按层遍历，queue入队顺序和判断逻辑相同，判断左子树的左节点和右子树的右节点是否相等，左子树的右节点和右子树的左节点是否相等。当左右同时为空时，跳过。当左右只有一个为空时，此时二叉树不可能对称，返回false\n\n\n# Java代码1\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public boolean isSymmetric(TreeNode root) {\n        if(root==null||root.left==null&&root.right==null)\n            return true;\n        Stack<TreeNode> stack = new Stack<>();\n        stack.push(root.left);\n        stack.push(root.right);\n        while(!stack.isEmpty()){\n            TreeNode rightnode = stack.pop();\n            TreeNode leftnode = stack.pop();\n            // 如果两个节点都为空就跳过，说明拿出来的左右节点至少是相等的\n            // 如果两个节点有一个为空，则说明不是对称的，返回false\n            if(leftnode==null&&rightnode==null)\n                continue;\n            if(leftnode==null||rightnode==null)\n                return false;\n            if(leftnode.val!=rightnode.val)\n                return false;\n            stack.push(leftnode.left);\n            stack.push(rightnode.right);\n            stack.push(leftnode.right);\n            stack.push(rightnode.left);\n        }\n        return true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# Python代码\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def isSymmetric(self, root: TreeNode) -> bool:\n        def helper(L,R):\n            if not L and not R: return True\n            if not L or not R: return False\n            if L.val != R.val: return False\n            return helper(L.left,R.right) and helper(L.right,R.left)\n        return helper(root.left,root.right) if root else True\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# Java代码2\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public boolean isSymmetric(TreeNode root) {\n        if(root==null)\n            return true;\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root.left);\n        queue.offer(root.right);\n        while(!queue.isEmpty()){\n            int size = queue.size();\n            for(int i=0;i<size;i++){\n                TreeNode leftNode = queue.poll();\n                TreeNode rightNode = queue.poll();\n                if(leftNode==null&&rightNode==null){\n                    continue;\n                }\n                if(leftNode==null||rightNode==null){\n                    return false;\n                }\n                if(leftNode.val!=rightNode.val){\n                    return false;\n                }\n                queue.offer(leftNode.left);\n                queue.offer(rightNode.right);\n                queue.offer(leftNode.right);\n                queue.offer(rightNode.left);\n            }\n        }\n        return true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n",normalizedContent:"# leetcode-面试题28-对称的二叉树\n\n请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。\n\n例如，二叉树 [1,2,2,3,4,4,3] 是对称的。\n\n    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:\n\n    1\n   / \\\n  2   2\n   \\   \\\n   3    3\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n示例1：\n\n输入：root = [1,2,2,3,4,4,3]\n输出：true\n\n\n1\n2\n\n1\n2\n\n\n示例2：\n\n输入：root = [1,2,2,null,3,null,3]\n输出：false\n\n\n1\n2\n\n1\n2\n\n\n限制：\n\n0 <= 节点个数 <= 1000\n\n\n# 解题思路\n\n方法1：栈\n\n利用栈一次性拿出2个节点进行比较\n\n将左子树的left节点和右子树的right节点放入栈\n\n之后将左子树的right节点和右子树的left节点放入栈，比较2个值是否相等\n\n方法2：递归\n\n终止条件：\n\n * 与栈的条件类似，当l和r同时越过叶子节点(即左右子节点为null)，则这个树从顶到底都是对称的，返回true\n * 当l和r只有一个越过叶子节点(即左/右子节点有一个为null)，则这个树不是对称的，返回false\n * 当l和r的值不相等时，则这个树不是对称的，返回false\n\n开启递归：\n\n * 判断两个节点l.left和r.right是否是对称的\n * 判断两个节点l.right和r.left是否是对称的\n\n方法3：队列\n\n先入队列根节点的左右节点，按层遍历，queue入队顺序和判断逻辑相同，判断左子树的左节点和右子树的右节点是否相等，左子树的右节点和右子树的左节点是否相等。当左右同时为空时，跳过。当左右只有一个为空时，此时二叉树不可能对称，返回false\n\n\n# java代码1\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public boolean issymmetric(treenode root) {\n        if(root==null||root.left==null&&root.right==null)\n            return true;\n        stack<treenode> stack = new stack<>();\n        stack.push(root.left);\n        stack.push(root.right);\n        while(!stack.isempty()){\n            treenode rightnode = stack.pop();\n            treenode leftnode = stack.pop();\n            // 如果两个节点都为空就跳过，说明拿出来的左右节点至少是相等的\n            // 如果两个节点有一个为空，则说明不是对称的，返回false\n            if(leftnode==null&&rightnode==null)\n                continue;\n            if(leftnode==null||rightnode==null)\n                return false;\n            if(leftnode.val!=rightnode.val)\n                return false;\n            stack.push(leftnode.left);\n            stack.push(rightnode.right);\n            stack.push(leftnode.right);\n            stack.push(rightnode.left);\n        }\n        return true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# python代码\n\n# definition for a binary tree node.\n# class treenode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = none\n#         self.right = none\n\nclass solution:\n    def issymmetric(self, root: treenode) -> bool:\n        def helper(l,r):\n            if not l and not r: return true\n            if not l or not r: return false\n            if l.val != r.val: return false\n            return helper(l.left,r.right) and helper(l.right,r.left)\n        return helper(root.left,root.right) if root else true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# java代码2\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public boolean issymmetric(treenode root) {\n        if(root==null)\n            return true;\n        queue<treenode> queue = new linkedlist<>();\n        queue.offer(root.left);\n        queue.offer(root.right);\n        while(!queue.isempty()){\n            int size = queue.size();\n            for(int i=0;i<size;i++){\n                treenode leftnode = queue.poll();\n                treenode rightnode = queue.poll();\n                if(leftnode==null&&rightnode==null){\n                    continue;\n                }\n                if(leftnode==null||rightnode==null){\n                    return false;\n                }\n                if(leftnode.val!=rightnode.val){\n                    return false;\n                }\n                queue.offer(leftnode.left);\n                queue.offer(rightnode.right);\n                queue.offer(leftnode.right);\n                queue.offer(rightnode.left);\n            }\n        }\n        return true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-54-螺旋矩阵",frontmatter:{title:"LeetCode-54-螺旋矩阵",date:"2020-03-30T19:21:08.000Z",tags:["二维数组","Java","Python","Medium"],permalink:"/pages/b2b5b5/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/01.LeetCode-54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5.html",relativePath:"06.算法/02.LeetCode/01.LeetCode-54-螺旋矩阵.md",key:"v-29a56b4e",path:"/pages/b2b5b5/",headers:[{level:2,title:"LeetCode-54-螺旋矩阵",slug:"leetcode-54-螺旋矩阵",normalizedTitle:"leetcode-54-螺旋矩阵",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:318},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:976},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:2547}],headersStr:"LeetCode-54-螺旋矩阵 解题思路 Java代码 Python代码",content:"# LeetCode-54-螺旋矩阵\n\n给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。\n\n示例 1:\n\n输入:\n[\n [ 1, 2, 3 ],\n [ 4, 5, 6 ],\n [ 7, 8, 9 ]\n]\n输出: [1,2,3,6,9,8,7,4,5]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n示例 2:\n\n输入:\n[\n  [1, 2, 3, 4],\n  [5, 6, 7, 8],\n  [9,10,11,12]\n]\n输出: [1,2,3,4,8,12,11,10,9,5,6,7]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 解题思路\n\n**方法1、**圈层\n\n 1. 记录左右和上下两个边界的点，按照上下左右算一圈，下一圈开始的时候初始位置+1，直到数组长度达到元素个数为止。Tips：注意几个初始点不参与遍历的变化。\n 2. 首先遍历第一行，记录最左的列位置，初始化left为0，一直遍历到right为矩阵列数为止，遍历完成后此时行数应该+1，即top+1。\n 3. 然后开始最右边一列的遍历，从top+1行开始，遍历到底部位置，之后应该从列数-1的位置开始下一次遍历，即right-1。然后进行底部一行的遍历，从right-1位置遍历到left位置，遍历完成之后应该从底部行向上移动开始下一次遍历，即bottom-1。\n 4. 最后进行最左边一列的遍历，从bottom-1位置直到top行，这样就完成了第一圈的遍历，然后使初始left+1，到达下一圈，此时其他数个点已经缩至下一圈范围。完成之后即可得到螺旋矩阵元素。\n\n**方法2、**模拟(官方解法)\n\n绘制螺旋轨迹路径，我们发现当路径超出界限或者进入之前访问过的单元格时，会顺时针旋转方向。\n\n假设数组有R 行 C 列，seen[r,c]表示第 r 行第 c 列的单元格之前已经被访问过了。当前所在位置为(r, c)，前进方向是 di。我们希望访问所有R x C 个单元格。\n\n当我们遍历整个矩阵，下一步候选移动位置是(cr, cc)。如果这个候选位置在矩阵范围内并且没有被访问过，那么它将会变成下一步移动的位置；否则，我们将前进方向顺时针旋转之后再计算下一步的移动位置。\n\n\n# Java代码\n\nclass Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        List<Integer> list = new ArrayList<>();\n        if(matrix.length==0){\n            return list;\n        }\n        int rowlen = matrix.length;\n        int collen = matrix[0].length;\n        int total_num = 0;\n        int left = 0;\n        int right = collen - 1;\n        int top = 0;\n        int bottom = rowlen - 1;\n        while (total_num != rowlen * collen) {\n            for (int i = left; i <= right; i++) {\n                list.add(matrix[top][i]);\n                total_num++;\n            }\n            if (total_num == rowlen * collen) break;\n            top++;\n            for (int i = top; i <= bottom; i++) {\n                list.add(matrix[i][right]);\n                total_num++;\n            }\n            if (total_num == rowlen * collen) break;\n            right--;\n            for (int i = right; i >= left; i--) {\n                list.add(matrix[bottom][i]);\n                total_num++;\n            }\n            if (total_num == rowlen * collen) break;\n            bottom--;\n            for (int i = bottom; i >= top; i--) {\n                list.add(matrix[i][left]);\n                total_num++;\n            }\n            if (total_num == rowlen * collen) break;\n            left++;\n        }\n        return list;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# Python代码\n\ndef spiralOrder(matrix):\n    if not matrix: return []\n    R, C = len(matrix), len(matrix[0])\n    seen = [[False] * C for _ in matrix]\n    ans = []\n    # 改变方向时，row和col变化的数值，di仅在改变方向时移动\n    dr = [0, 1, 0, -1]\n    dc = [1, 0, -1, 0]\n    r = c = di = 0\n    for _ in range(R * C):\n        ans.append(matrix[r][c])\n        seen[r][c] = True\n        cr, cc = r + dr[di], c + dc[di]\n        if 0 <= cr < R and 0 <= cc < C and not seen[cr][cc]:\n            r, c = cr, cc\n        else:\n            di = (di + 1) % 4\n            r, c = r + dr[di], c + dc[di]\n    return ans\n\nif __name__=='__main__':\n    # 输入二维数组\n    row ,col = [int(n) for n in input().split()]\n    list = [[0]*col]*row\n    for i in range(row):\n        list[i] = [int(i) for i in input().split()]\n    result = spiralOrder(list)\n    print(result)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n",normalizedContent:"# leetcode-54-螺旋矩阵\n\n给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。\n\n示例 1:\n\n输入:\n[\n [ 1, 2, 3 ],\n [ 4, 5, 6 ],\n [ 7, 8, 9 ]\n]\n输出: [1,2,3,6,9,8,7,4,5]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n示例 2:\n\n输入:\n[\n  [1, 2, 3, 4],\n  [5, 6, 7, 8],\n  [9,10,11,12]\n]\n输出: [1,2,3,4,8,12,11,10,9,5,6,7]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 解题思路\n\n**方法1、**圈层\n\n 1. 记录左右和上下两个边界的点，按照上下左右算一圈，下一圈开始的时候初始位置+1，直到数组长度达到元素个数为止。tips：注意几个初始点不参与遍历的变化。\n 2. 首先遍历第一行，记录最左的列位置，初始化left为0，一直遍历到right为矩阵列数为止，遍历完成后此时行数应该+1，即top+1。\n 3. 然后开始最右边一列的遍历，从top+1行开始，遍历到底部位置，之后应该从列数-1的位置开始下一次遍历，即right-1。然后进行底部一行的遍历，从right-1位置遍历到left位置，遍历完成之后应该从底部行向上移动开始下一次遍历，即bottom-1。\n 4. 最后进行最左边一列的遍历，从bottom-1位置直到top行，这样就完成了第一圈的遍历，然后使初始left+1，到达下一圈，此时其他数个点已经缩至下一圈范围。完成之后即可得到螺旋矩阵元素。\n\n**方法2、**模拟(官方解法)\n\n绘制螺旋轨迹路径，我们发现当路径超出界限或者进入之前访问过的单元格时，会顺时针旋转方向。\n\n假设数组有r 行 c 列，seen[r,c]表示第 r 行第 c 列的单元格之前已经被访问过了。当前所在位置为(r, c)，前进方向是 di。我们希望访问所有r x c 个单元格。\n\n当我们遍历整个矩阵，下一步候选移动位置是(cr, cc)。如果这个候选位置在矩阵范围内并且没有被访问过，那么它将会变成下一步移动的位置；否则，我们将前进方向顺时针旋转之后再计算下一步的移动位置。\n\n\n# java代码\n\nclass solution {\n    public list<integer> spiralorder(int[][] matrix) {\n        list<integer> list = new arraylist<>();\n        if(matrix.length==0){\n            return list;\n        }\n        int rowlen = matrix.length;\n        int collen = matrix[0].length;\n        int total_num = 0;\n        int left = 0;\n        int right = collen - 1;\n        int top = 0;\n        int bottom = rowlen - 1;\n        while (total_num != rowlen * collen) {\n            for (int i = left; i <= right; i++) {\n                list.add(matrix[top][i]);\n                total_num++;\n            }\n            if (total_num == rowlen * collen) break;\n            top++;\n            for (int i = top; i <= bottom; i++) {\n                list.add(matrix[i][right]);\n                total_num++;\n            }\n            if (total_num == rowlen * collen) break;\n            right--;\n            for (int i = right; i >= left; i--) {\n                list.add(matrix[bottom][i]);\n                total_num++;\n            }\n            if (total_num == rowlen * collen) break;\n            bottom--;\n            for (int i = bottom; i >= top; i--) {\n                list.add(matrix[i][left]);\n                total_num++;\n            }\n            if (total_num == rowlen * collen) break;\n            left++;\n        }\n        return list;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# python代码\n\ndef spiralorder(matrix):\n    if not matrix: return []\n    r, c = len(matrix), len(matrix[0])\n    seen = [[false] * c for _ in matrix]\n    ans = []\n    # 改变方向时，row和col变化的数值，di仅在改变方向时移动\n    dr = [0, 1, 0, -1]\n    dc = [1, 0, -1, 0]\n    r = c = di = 0\n    for _ in range(r * c):\n        ans.append(matrix[r][c])\n        seen[r][c] = true\n        cr, cc = r + dr[di], c + dc[di]\n        if 0 <= cr < r and 0 <= cc < c and not seen[cr][cc]:\n            r, c = cr, cc\n        else:\n            di = (di + 1) % 4\n            r, c = r + dr[di], c + dc[di]\n    return ans\n\nif __name__=='__main__':\n    # 输入二维数组\n    row ,col = [int(n) for n in input().split()]\n    list = [[0]*col]*row\n    for i in range(row):\n        list[i] = [int(i) for i in input().split()]\n    result = spiralorder(list)\n    print(result)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-67-二进制求和",frontmatter:{title:"LeetCode-67-二进制求和",date:"2020-04-14T14:25:51.000Z",tags:["字符串","Java","Python","Easy"],permalink:"/pages/7d3b6e/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/02.LeetCode-67-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C.html",relativePath:"06.算法/02.LeetCode/02.LeetCode-67-二进制求和.md",key:"v-db5d6e9c",path:"/pages/7d3b6e/",headers:[{level:2,title:"LeetCode-67-二进制求和",slug:"leetcode-67-二进制求和",normalizedTitle:"leetcode-67-二进制求和",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:283},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:475},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:1456}],headersStr:"LeetCode-67-二进制求和 解题思路 Java代码 Python代码",content:'# LeetCode-67-二进制求和\n\n给你两个二进制字符串，返回它们的和（用二进制表示）。\n\n输入为 非空 字符串且只包含数字 1 和 0。\n\n示例 1:\n\n输入: a = "11", b = "1"\n输出: "100"\n\n\n1\n2\n\n1\n2\n\n\n示例 2:\n\n输入: a = "1010", b = "1011"\n输出: "10101"\n\n\n1\n2\n\n1\n2\n\n\n提示：\n\n * 每个字符串仅由字符 \'0\' 或 \'1\' 组成。\n\n * 1 <= a.length, b.length <= 10^4\n\n * 字符串如果不是 "0" ，就都不含前导零。\n\n\n# 解题思路\n\n不适用思路：二进制转十进制，十进制相加转二进制，容易溢出直接淘汰。\n\n先把两个字符串长度对齐，设置一个进位符号falg=0，从两个字符串的末尾开始逐一相加，除此之外还要加上进位，如果3者之和>=2，说明此处有进位，设置falg=1，往字符串中添加数字和对2求余的结果就是当前的位置的值。最后如果有进位则添加1，翻转字符串后就是结果。\n\nPython偷个懒哈哈哈~\n\n\n# Java代码\n\nclass Solution {\n    public String addBinary(String a, String b) {\n        int alen = a.length();\n        int blen = b.length();\n        while (alen > blen) {\n            b = \'0\' + b;\n            blen++;\n        }\n        while (alen < blen) {\n            a = \'0\' + a;\n            alen++;\n        }\n        StringBuilder res = new StringBuilder();\n        int falg = 0;\n        for (int i = alen - 1; i >= 0; i--) {\n            int sum = falg + a.charAt(i) + b.charAt(i) - \'0\';\n            if (sum>= \'2\') {\n                res.append(sum%2);\n                falg = 1;\n            }\n            else {\n                res.append(sum%2);\n                falg = 0;\n            }\n        }\n        if (falg == 1) {\n            res.append(1);\n        }\n        return res.reverse().toString();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# Python代码\n\nclass Solution:\n    def addBinary(self, a: str, b: str) -> str:\n        return bin(int(a,2)+int(b,2))[2:]\n\n\n1\n2\n3\n\n1\n2\n3\n',normalizedContent:'# leetcode-67-二进制求和\n\n给你两个二进制字符串，返回它们的和（用二进制表示）。\n\n输入为 非空 字符串且只包含数字 1 和 0。\n\n示例 1:\n\n输入: a = "11", b = "1"\n输出: "100"\n\n\n1\n2\n\n1\n2\n\n\n示例 2:\n\n输入: a = "1010", b = "1011"\n输出: "10101"\n\n\n1\n2\n\n1\n2\n\n\n提示：\n\n * 每个字符串仅由字符 \'0\' 或 \'1\' 组成。\n\n * 1 <= a.length, b.length <= 10^4\n\n * 字符串如果不是 "0" ，就都不含前导零。\n\n\n# 解题思路\n\n不适用思路：二进制转十进制，十进制相加转二进制，容易溢出直接淘汰。\n\n先把两个字符串长度对齐，设置一个进位符号falg=0，从两个字符串的末尾开始逐一相加，除此之外还要加上进位，如果3者之和>=2，说明此处有进位，设置falg=1，往字符串中添加数字和对2求余的结果就是当前的位置的值。最后如果有进位则添加1，翻转字符串后就是结果。\n\npython偷个懒哈哈哈~\n\n\n# java代码\n\nclass solution {\n    public string addbinary(string a, string b) {\n        int alen = a.length();\n        int blen = b.length();\n        while (alen > blen) {\n            b = \'0\' + b;\n            blen++;\n        }\n        while (alen < blen) {\n            a = \'0\' + a;\n            alen++;\n        }\n        stringbuilder res = new stringbuilder();\n        int falg = 0;\n        for (int i = alen - 1; i >= 0; i--) {\n            int sum = falg + a.charat(i) + b.charat(i) - \'0\';\n            if (sum>= \'2\') {\n                res.append(sum%2);\n                falg = 1;\n            }\n            else {\n                res.append(sum%2);\n                falg = 0;\n            }\n        }\n        if (falg == 1) {\n            res.append(1);\n        }\n        return res.reverse().tostring();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# python代码\n\nclass solution:\n    def addbinary(self, a: str, b: str) -> str:\n        return bin(int(a,2)+int(b,2))[2:]\n\n\n1\n2\n3\n\n1\n2\n3\n',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-83-删除排序链表中的重复元素",frontmatter:{title:"LeetCode-83-删除排序链表中的重复元素",date:"2020-04-15T18:22:08.000Z",tags:["链表","Java","Python","Easy"],permalink:"/pages/fb7a5f/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/03.LeetCode-83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0.html",relativePath:"06.算法/02.LeetCode/03.LeetCode-83-删除排序链表中的重复元素.md",key:"v-3bc6e2d0",path:"/pages/fb7a5f/",headers:[{level:2,title:"LeetCode-83-删除排序链表中的重复元素",slug:"leetcode-83-删除排序链表中的重复元素",normalizedTitle:"leetcode-83-删除排序链表中的重复元素",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:155},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:313},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:983}],headersStr:"LeetCode-83-删除排序链表中的重复元素 解题思路 Java代码 Python代码",content:"# LeetCode-83-删除排序链表中的重复元素\n\n给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。\n\n示例 1:\n\n输入: 1->1->2\n输出: 1->2\n\n\n1\n2\n\n1\n2\n\n\n示例 2:\n\n输入: 1->1->2->3->3\n输出: 1->2->3\n\n\n1\n2\n\n1\n2\n\n\n\n# 解题思路\n\n初始化1个指针，指向头部，判断后一个数和前一个是不是相等，相等则要把后面一个数覆盖前面一个数，当发现不相等时，cur指针顺移1位，即对于1、1、2、3、3这样的数据，cur会将后一个重复的数字替换前一个重复数字，当重复数字之后一位数不和当前相等时，cur指针改变指向到下一个数，再进行重复判断。\n\n\n# Java代码\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head==null||head.next==null) return head;\n        ListNode cur = head;\n        while(cur.next!=null){\n            if(cur.next.val==cur.val){\n                cur.next = cur.next.next;\n            }\n            else{\n                cur = cur.next;\n            }\n        }\n        return head;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# Python代码\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\n        cur = head;\n        while cur and cur.next:\n            if cur.next.val==cur.val:\n                cur.next = cur.next.next\n            else:\n                cur = cur.next\n        return head\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n",normalizedContent:"# leetcode-83-删除排序链表中的重复元素\n\n给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。\n\n示例 1:\n\n输入: 1->1->2\n输出: 1->2\n\n\n1\n2\n\n1\n2\n\n\n示例 2:\n\n输入: 1->1->2->3->3\n输出: 1->2->3\n\n\n1\n2\n\n1\n2\n\n\n\n# 解题思路\n\n初始化1个指针，指向头部，判断后一个数和前一个是不是相等，相等则要把后面一个数覆盖前面一个数，当发现不相等时，cur指针顺移1位，即对于1、1、2、3、3这样的数据，cur会将后一个重复的数字替换前一个重复数字，当重复数字之后一位数不和当前相等时，cur指针改变指向到下一个数，再进行重复判断。\n\n\n# java代码\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode(int x) { val = x; }\n * }\n */\nclass solution {\n    public listnode deleteduplicates(listnode head) {\n        if(head==null||head.next==null) return head;\n        listnode cur = head;\n        while(cur.next!=null){\n            if(cur.next.val==cur.val){\n                cur.next = cur.next.next;\n            }\n            else{\n                cur = cur.next;\n            }\n        }\n        return head;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# python代码\n\n# definition for singly-linked list.\n# class listnode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = none\n\nclass solution:\n    def deleteduplicates(self, head: listnode) -> listnode:\n        cur = head;\n        while cur and cur.next:\n            if cur.next.val==cur.val:\n                cur.next = cur.next.next\n            else:\n                cur = cur.next\n        return head\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-415-字符串相加",frontmatter:{title:"LeetCode-415-字符串相加",date:"2020-04-15T15:44:22.000Z",tags:["字符串","大数问题","Java","Python","Easy"],permalink:"/pages/9c3f56/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/04.LeetCode-415-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0.html",relativePath:"06.算法/02.LeetCode/04.LeetCode-415-字符串相加.md",key:"v-c76ded1a",path:"/pages/9c3f56/",headers:[{level:2,title:"LeetCode-415-字符串相加",slug:"leetcode-415-字符串相加",normalizedTitle:"leetcode-415-字符串相加",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:197},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:363},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:1177}],headersStr:"LeetCode-415-字符串相加 解题思路 Java代码 Python代码",content:"# LeetCode-415-字符串相加\n\n给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。\n\n注意：\n\n 1. num1 和num2 的长度都小于 5100.\n 2. num1 和num2 都只包含数字 0-9.\n 3. num1 和num2 都不包含任何前导零。\n 4. 你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。\n\n\n# 解题思路\n\n两数相加可以看成一个大数问题，只是这里是String类型的，思路都差不多。直接从字符串尾部开始遍历，设置一个进位符号，如果三者相加比10大说明有进位，此时的数应该%10即可，符号为设置为1，当没有进位的时候设置为0。两个字符串可能不是等长的，超过遍历的情况默认为0。循环结束之后，符号位为1的话说明最高位要进1\n\n\n# Java代码\n\nclass Solution {\n    public String addStrings(String num1, String num2) {\n        int alen = num1.length()-1,blen = num2.length()-1,carry = 0;\n        StringBuilder res = new StringBuilder();\n        while(alen>=0||blen>=0){\n            int n1 = alen>=0?num1.charAt(alen)-'0':0;\n            int n2 = blen>=0?num2.charAt(blen)-'0':0;\n            int sum = n1+n2+carry;\n            if(sum>=10){\n                carry = 1;\n                res.append(sum%10);\n            }else{\n                carry = 0;\n                res.append(sum);\n            }\n            alen--;\n            blen--;\n        }\n        if(carry==1) res.append(1);\n        return res.reverse().toString();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# Python代码\n\nclass Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        alen,blen,carry = len(num1)-1,len(num2)-1,0\n        res = \"\";\n        while alen>=0 or blen>=0:\n            n1 = int(num1[alen]) if alen>=0 else 0\n            n2 = int(num2[blen]) if blen>=0 else 0\n            sum = n1+n2+carry\n            carry = sum//10\n            res = str(sum%10)+res\n            alen = alen-1\n            blen = blen-1\n        return \"1\"+res if carry else res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n",normalizedContent:"# leetcode-415-字符串相加\n\n给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。\n\n注意：\n\n 1. num1 和num2 的长度都小于 5100.\n 2. num1 和num2 都只包含数字 0-9.\n 3. num1 和num2 都不包含任何前导零。\n 4. 你不能使用任何內建 biginteger 库， 也不能直接将输入的字符串转换为整数形式。\n\n\n# 解题思路\n\n两数相加可以看成一个大数问题，只是这里是string类型的，思路都差不多。直接从字符串尾部开始遍历，设置一个进位符号，如果三者相加比10大说明有进位，此时的数应该%10即可，符号为设置为1，当没有进位的时候设置为0。两个字符串可能不是等长的，超过遍历的情况默认为0。循环结束之后，符号位为1的话说明最高位要进1\n\n\n# java代码\n\nclass solution {\n    public string addstrings(string num1, string num2) {\n        int alen = num1.length()-1,blen = num2.length()-1,carry = 0;\n        stringbuilder res = new stringbuilder();\n        while(alen>=0||blen>=0){\n            int n1 = alen>=0?num1.charat(alen)-'0':0;\n            int n2 = blen>=0?num2.charat(blen)-'0':0;\n            int sum = n1+n2+carry;\n            if(sum>=10){\n                carry = 1;\n                res.append(sum%10);\n            }else{\n                carry = 0;\n                res.append(sum);\n            }\n            alen--;\n            blen--;\n        }\n        if(carry==1) res.append(1);\n        return res.reverse().tostring();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# python代码\n\nclass solution:\n    def addstrings(self, num1: str, num2: str) -> str:\n        alen,blen,carry = len(num1)-1,len(num2)-1,0\n        res = \"\";\n        while alen>=0 or blen>=0:\n            n1 = int(num1[alen]) if alen>=0 else 0\n            n2 = int(num2[blen]) if blen>=0 else 0\n            sum = n1+n2+carry\n            carry = sum//10\n            res = str(sum%10)+res\n            alen = alen-1\n            blen = blen-1\n        return \"1\"+res if carry else res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-498-对角线遍历",frontmatter:{title:"LeetCode-498-对角线遍历",date:"2020-03-26T14:25:12.000Z",tags:["二维数组","Java","Python","Medium"],permalink:"/pages/45d832/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/05.LeetCode-498-%E5%AF%B9%E8%A7%92%E7%BA%BF%E9%81%8D%E5%8E%86.html",relativePath:"06.算法/02.LeetCode/05.LeetCode-498-对角线遍历.md",key:"v-c39498e0",path:"/pages/45d832/",headers:[{level:2,title:"LeetCode-498-对角线遍历",slug:"leetcode-498-对角线遍历",normalizedTitle:"leetcode-498-对角线遍历",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:243},{level:3,title:"Java代码1",slug:"java代码1",normalizedTitle:"java代码1",charIndex:484},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:1579},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:3201}],headersStr:"LeetCode-498-对角线遍历 解题思路 Java代码1 Java代码2 Python代码",content:"# LeetCode-498-对角线遍历\n\n给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示。\n\n\n\n示例:\n\n输入:\n[\n [ 1, 2, 3 ],\n [ 4, 5, 6 ],\n [ 7, 8, 9 ]\n]\n\n输出:  [1,2,4,7,5,3,6,8,9]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n说明:\n\n 1. 给定矩阵中的元素总数不会超过 100000 。\n\n\n# 解题思路\n\n方法1、模拟路径，观察图可以知道对角线位置的横纵坐标之和等于第一行的该对角线元素索引号，以第一行为例，奇数往右上走，偶数往左下走，对于越界的不添加，将他按左下或右上移动，直到到矩阵位置里面进行添加。这种方法的缺点是遍历了很多没有用的位置，浪费了时间，运行时间93ms\n\n方法2、简化问题，直接遍历每个对角线，翻转奇数对角线数值即可，外层循环为所有对角线初始点。运行时间7ms\n\n还有一些其他更简单的方法，时间和空间上消耗都比较少，可以右转leetcode看看~\n\n\n# Java代码1\n\npublic static int[] findDiagonalOrder(int[][] matrix) {\n        if (matrix == null || matrix.length == 0) {\n            return new int[0];\n        }\n        int row = matrix.length;\n        int col = matrix[0].length;\n        int[] out = new int[row * col];\n        int k =0;\n        List<Integer> in = new ArrayList<>();\n        for (int i = 0; i < row + col - 1; i++) {\n            in.clear();\n            // 找到对角线坐标点\n            int r = i < col ? 0 : i - col + 1;\n            int c = i < col ? i : col - 1;\n            // 遍历对角线元素\n            while (r < row && c > -1) {\n                in.add(matrix[r][c]);\n                ++r;\n                --c;\n            }\n            if (i % 2 == 0) {\n                Collections.reverse(in);\n            }\n            // 将一个对角线元素赋值\n            for (int j = 0; j < in.size(); j++) {\n                out[k++] = in.get(j);\n            }\n        }\n        return out;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# Java代码2\n\npublic static int[] findDiagonalOrder(int[][] matrix) {\n    // 按索引坐标分为奇数和偶数情况，奇数右上走，偶数左下走，当前行数+当前列数=索引值\n    // 越界的不管到边界里面再加入\n    if (matrix.length == 0) {\n        return new int[0];\n    }\n    int rowlen = matrix.length;\n    int collen = matrix[0].length;\n    List<Integer> list = new ArrayList<>(rowlen * collen);\n    int[] out = new int[rowlen * collen];\n    rowlen--;\n    collen--;\n    for (int sum = 0; sum < rowlen + collen + 1; sum++) {\n        if (sum % 2 == 0) { // 偶数情况\n            int row = rowlen;\n            int col = sum - row;\n            while (row >= 0 && col <= collen) {\n                if (col < 0) {\n                    col += 1;\n                    row -= 1;\n                    continue;\n                }\n                list.add(matrix[row][col]);\n                row -= 1;\n                col += 1;\n            }\n        } else { // 奇数情况\n            int row = 0;\n            int col = sum - row;\n            while (row <= rowlen && col >= 0) {\n                if (col > collen) {\n                    col -= 1;\n                    row += 1;\n                    continue;\n                }\n                list.add(matrix[row][col]);\n                row = row + 1;\n                col = col - 1;\n            }\n        }\n    }\n    for (int i = 0; i < list.size(); i++) {\n        out[i] = list.get(i);\n    }\n    return out;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# Python代码\n\nclass Solution:\n    def findDiagonalOrder(self, matrix):\n        if not matrix or not matrix[0]:\n            return []\n        N, M = len(matrix), len(matrix[0])\n        result, intermediate = [], []\n        for d in range(N + M - 1):\n            intermediate.clear()\n            r, c = 0 if d < M else d - M + 1, d if d < M else M - 1\n            while r < N and c > -1:\n                intermediate.append(matrix[r][c])\n                r += 1\n                c -= 1\n            if d % 2 == 0:\n                result.extend(intermediate[::-1])\n            else:\n                result.extend(intermediate)\n        return result\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n",normalizedContent:"# leetcode-498-对角线遍历\n\n给定一个含有 m x n 个元素的矩阵（m 行，n 列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示。\n\n\n\n示例:\n\n输入:\n[\n [ 1, 2, 3 ],\n [ 4, 5, 6 ],\n [ 7, 8, 9 ]\n]\n\n输出:  [1,2,4,7,5,3,6,8,9]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n说明:\n\n 1. 给定矩阵中的元素总数不会超过 100000 。\n\n\n# 解题思路\n\n方法1、模拟路径，观察图可以知道对角线位置的横纵坐标之和等于第一行的该对角线元素索引号，以第一行为例，奇数往右上走，偶数往左下走，对于越界的不添加，将他按左下或右上移动，直到到矩阵位置里面进行添加。这种方法的缺点是遍历了很多没有用的位置，浪费了时间，运行时间93ms\n\n方法2、简化问题，直接遍历每个对角线，翻转奇数对角线数值即可，外层循环为所有对角线初始点。运行时间7ms\n\n还有一些其他更简单的方法，时间和空间上消耗都比较少，可以右转leetcode看看~\n\n\n# java代码1\n\npublic static int[] finddiagonalorder(int[][] matrix) {\n        if (matrix == null || matrix.length == 0) {\n            return new int[0];\n        }\n        int row = matrix.length;\n        int col = matrix[0].length;\n        int[] out = new int[row * col];\n        int k =0;\n        list<integer> in = new arraylist<>();\n        for (int i = 0; i < row + col - 1; i++) {\n            in.clear();\n            // 找到对角线坐标点\n            int r = i < col ? 0 : i - col + 1;\n            int c = i < col ? i : col - 1;\n            // 遍历对角线元素\n            while (r < row && c > -1) {\n                in.add(matrix[r][c]);\n                ++r;\n                --c;\n            }\n            if (i % 2 == 0) {\n                collections.reverse(in);\n            }\n            // 将一个对角线元素赋值\n            for (int j = 0; j < in.size(); j++) {\n                out[k++] = in.get(j);\n            }\n        }\n        return out;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# java代码2\n\npublic static int[] finddiagonalorder(int[][] matrix) {\n    // 按索引坐标分为奇数和偶数情况，奇数右上走，偶数左下走，当前行数+当前列数=索引值\n    // 越界的不管到边界里面再加入\n    if (matrix.length == 0) {\n        return new int[0];\n    }\n    int rowlen = matrix.length;\n    int collen = matrix[0].length;\n    list<integer> list = new arraylist<>(rowlen * collen);\n    int[] out = new int[rowlen * collen];\n    rowlen--;\n    collen--;\n    for (int sum = 0; sum < rowlen + collen + 1; sum++) {\n        if (sum % 2 == 0) { // 偶数情况\n            int row = rowlen;\n            int col = sum - row;\n            while (row >= 0 && col <= collen) {\n                if (col < 0) {\n                    col += 1;\n                    row -= 1;\n                    continue;\n                }\n                list.add(matrix[row][col]);\n                row -= 1;\n                col += 1;\n            }\n        } else { // 奇数情况\n            int row = 0;\n            int col = sum - row;\n            while (row <= rowlen && col >= 0) {\n                if (col > collen) {\n                    col -= 1;\n                    row += 1;\n                    continue;\n                }\n                list.add(matrix[row][col]);\n                row = row + 1;\n                col = col - 1;\n            }\n        }\n    }\n    for (int i = 0; i < list.size(); i++) {\n        out[i] = list.get(i);\n    }\n    return out;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# python代码\n\nclass solution:\n    def finddiagonalorder(self, matrix):\n        if not matrix or not matrix[0]:\n            return []\n        n, m = len(matrix), len(matrix[0])\n        result, intermediate = [], []\n        for d in range(n + m - 1):\n            intermediate.clear()\n            r, c = 0 if d < m else d - m + 1, d if d < m else m - 1\n            while r < n and c > -1:\n                intermediate.append(matrix[r][c])\n                r += 1\n                c -= 1\n            if d % 2 == 0:\n                result.extend(intermediate[::-1])\n            else:\n                result.extend(intermediate)\n        return result\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-724-寻找数组的中心索引",frontmatter:{title:"LeetCode-724-寻找数组的中心索引",date:"2020-03-19T16:33:43.000Z",tags:["数组","Java","Python","Easy"],permalink:"/pages/f095b3/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/06.LeetCode-724-%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95.html",relativePath:"06.算法/02.LeetCode/06.LeetCode-724-寻找数组的中心索引.md",key:"v-86a00068",path:"/pages/f095b3/",headers:[{level:2,title:"LeetCode-724-寻找数组的中心索引",slug:"leetcode-724-寻找数组的中心索引",normalizedTitle:"leetcode-724-寻找数组的中心索引",charIndex:2},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:586},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:1721}],headersStr:"LeetCode-724-寻找数组的中心索引 Java代码 Python代码",content:'# LeetCode-724-寻找数组的中心索引\n\n日常学习任务实在是太多，所以很久没有更新博客了，今天开始刷题，从最简单的开始吧！ 给定一个整数类型的数组 nums，请编写一个能够返回数组**“中心索引”**的方法。\n\n我们是这样定义数组中心索引的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。\n\n如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。\n\n示例 1:\n\n输入: \nnums = [1, 7, 3, 6, 5, 6]\n输出: 3\n解释: \n索引3 (nums[3] = 6) 的左侧数之和(1 + 7 + 3 = 11)，与右侧数之和(5 + 6 = 11)相等。\n同时, 3 也是第一个符合要求的中心索引。\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n示例 2:\n\n输入: \nnums = [1, 2, 3]\n输出: -1\n解释: \n数组中不存在满足此条件的中心索引。\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n说明:\n\nnums的长度范围为 [0, 10000]。 任何一个 nums[i]将会是一个范围在 [-1000, 1000]的整数。\n\n###解题思路\n\n\n\n计算第i个位置左右两边的和比较一下就行了，右边=总和-当前位置值-当前位置左边的和\n\n\n# Java代码\n\npublic class SearchIndex {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        String input = in.nextLine().toString();\n        String[] s = input.split(" ");\n        int[] array = new int[s.length];\n        for (int i = 0; i < array.length; i++) {\n            array[i] = Integer.parseInt(s[i]);\n        }\n        int Output = pivotIndex(array);\n        System.out.println(Output);\n    }\n\n    public static int pivotIndex(int[] nums) {\n        int Left = 0;\n        int Right = 0;\n        int sum = 0;\n        for (int n : nums) {\n            sum += n;\n        }\n        for (int i = 0; i < nums.length; i++) {\n            if (i == 0) {\n                Left = 0;\n            } else {\n                Left += nums[i - 1];\n            }\n            Right = sum - Left - nums[i];\n            if (Left == Right) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# Python代码\n\ndef pivotIndex(self, nums):\n        """\n        :type nums: List[int]\n        :rtype: int\n        """\n        Left, Right, sum = 0, 0, 0\n        for i in nums:\n            sum += i\n        for index, j in enumerate(nums):\n            if (index == 0):\n                Left = 0\n            else:\n                Left += nums[index - 1]\n            Right = sum - Left - nums[index]\n            if (Left == Right):\n                return index\n        return -1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n',normalizedContent:'# leetcode-724-寻找数组的中心索引\n\n日常学习任务实在是太多，所以很久没有更新博客了，今天开始刷题，从最简单的开始吧！ 给定一个整数类型的数组 nums，请编写一个能够返回数组**“中心索引”**的方法。\n\n我们是这样定义数组中心索引的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。\n\n如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。\n\n示例 1:\n\n输入: \nnums = [1, 7, 3, 6, 5, 6]\n输出: 3\n解释: \n索引3 (nums[3] = 6) 的左侧数之和(1 + 7 + 3 = 11)，与右侧数之和(5 + 6 = 11)相等。\n同时, 3 也是第一个符合要求的中心索引。\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n示例 2:\n\n输入: \nnums = [1, 2, 3]\n输出: -1\n解释: \n数组中不存在满足此条件的中心索引。\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n说明:\n\nnums的长度范围为 [0, 10000]。 任何一个 nums[i]将会是一个范围在 [-1000, 1000]的整数。\n\n###解题思路\n\n\n\n计算第i个位置左右两边的和比较一下就行了，右边=总和-当前位置值-当前位置左边的和\n\n\n# java代码\n\npublic class searchindex {\n    public static void main(string[] args) {\n        scanner in = new scanner(system.in);\n        string input = in.nextline().tostring();\n        string[] s = input.split(" ");\n        int[] array = new int[s.length];\n        for (int i = 0; i < array.length; i++) {\n            array[i] = integer.parseint(s[i]);\n        }\n        int output = pivotindex(array);\n        system.out.println(output);\n    }\n\n    public static int pivotindex(int[] nums) {\n        int left = 0;\n        int right = 0;\n        int sum = 0;\n        for (int n : nums) {\n            sum += n;\n        }\n        for (int i = 0; i < nums.length; i++) {\n            if (i == 0) {\n                left = 0;\n            } else {\n                left += nums[i - 1];\n            }\n            right = sum - left - nums[i];\n            if (left == right) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# python代码\n\ndef pivotindex(self, nums):\n        """\n        :type nums: list[int]\n        :rtype: int\n        """\n        left, right, sum = 0, 0, 0\n        for i in nums:\n            sum += i\n        for index, j in enumerate(nums):\n            if (index == 0):\n                left = 0\n            else:\n                left += nums[index - 1]\n            right = sum - left - nums[index]\n            if (left == right):\n                return index\n        return -1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"动态规划问题——最长上升子序列(LIS)(一)",frontmatter:{title:"动态规划问题——最长上升子序列(LIS)(一)",date:"2018-08-25T15:43:49.000Z",tags:["算法","Java","Python","DP"],permalink:"/pages/6ddb3f/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/07.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97(LIS)(%E4%B8%80).html",relativePath:"06.算法/02.LeetCode/07.动态规划问题——最长上升子序列(LIS)(一).md",key:"v-7f617a74",path:"/pages/6ddb3f/",headers:[{level:2,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:516},{level:2,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:1499},{level:2,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:1519},{level:2,title:"运行结果",slug:"运行结果-2",normalizedTitle:"运行结果",charIndex:1499}],headersStr:"Java代码 运行结果 Python代码 运行结果",content:"样本代码时间复杂度为〇(n²)\n\n如：求 2 7 1 5 6 4 3 8 9 的最长上升子序列。我们定义d(i) (i∈[1,n])来表示前i个数以A[i]结尾的最长上升子序列长度。\n\n * 前1个数 d(1)=1 子序列为2；\n * 前2个数 7前面有2小于7 d(2)=d(1)+1=2 子序列为2 7\n * 前3个数 在1前面没有比1更小的，1自身组成长度为1的子序列 d(3)=1 子序列为1\n * 前4个数 5前面有2小于5 d(4)=d(1)+1=2 子序列为2 5\n * 前5个数 6前面有2 5小于6 d(5)=d(4)+1=3 子序列为2 5 6\n * 前6个数 4前面有2小于4 d(6)=d(1)+1=2 子序列为2 4\n * 前7个数 3前面有2小于3 d(3)=d(1)+1=2 子序列为2 3\n * 前8个数 8前面有2 5 6小于8 d(8)=d(5)+1=4 子序列为2 5 6 8\n * 前9个数 9前面有2 5 6 8小于9 d(9)=d(8)+1=5 子序列为2 5 6 8 9\n * d(i)=max{d(1),d(2),……,d(i)} 我们可以看出这9个数的LIS为d(9)=5\n\n\n# Java代码\n\npublic class Main {\n    int LIS(int A[], int n) {\n        int d[] = new int[n];\n        int len = 1;\n        int i, j;\n        for (i = 0; i < n; i++) {\n            d[i] = 1;\n            for (j = 0; j < i; j++) {\n                // 当前的位置的数与之前的数比较，如果数列是上升的，且序列长度+1比当前序列长度大或相等\n                if (A[j] <= A[i] && (d[j] + 1) >= d[i])\n                    //使这个数之前的最大长度加1（最长上升序列加上这个数）\n                    d[i] = d[j] + 1;\n            }\n            // 把当前d[i]的最大长度赋值给len\n            if (d[i] > len)\n                len = d[i];\n        }\n        // 返回最长上升子序列的长度\n        return len;\n    }\n\n    public static void main(String[] args) {\n        int A[] = {2, 7, 1, 5, 6, 4, 3, 8, 9};\n        int n = A.length;\n        Main test = new Main();\n        int count = test.LIS(A, n);\n        System.out.println(count);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 运行结果\n\n5\n\n\n1\n\n1\n\n\n\n# Python代码\n\n# 第一种写法\ndef longestIncreasingSubsequence(nums, length):\n    # 如果列表为空或者列表长度为0就直接返回0\n    if nums == None or len(nums) == 0:\n        return 0\n    # 初始化列表为length个0，用来记录到当前位置的最长升序序列的长度\n    sublongest = [0 for i in range(length)]\n    sublongest[0] = 1\n    longest = 0\n    for i in range(1, length):\n        sublong = 0\n        for j in range(0, i):\n            # 如果当前元素比前面的元素大\n            if nums[j] <= nums[i]:\n                # 则将前面元素的最长序列和当前的最长序列比较大小，把大的赋值给sublong\n                sublong = max(sublongest[j], sublong)\n        # 加上到自身位置那个元素\n        sublongest[i] = sublong + 1\n        # 比较长度列表末尾的元素和longest的大小，把两者大的赋值给longest\n        longest = max(sublongest[i], longest)\n    return longest\n\n# 第二种写法\ndef longestIncreasingSubsequence2(Testarray, num):\n    d = [0 for i in range(num)]\n    longest = 1\n    for i in range(num):\n        d[i] = 1\n        for j in range(i):\n            if (Testarray[j] <= Testarray[i]) and (d[j] + 1) >= d[i]:\n                d[i] = d[j] + 1\n        if d[i] > longest:\n            longest = d[i]\n    return longest\n\n\nif '__name__ = __main__':\n    a = [2, 7, 1, 5, 6, 4, 3, 8, 9]\n    # count = longestIncreasingSubsequence(a,len(a))\n    count = longestIncreasingSubsequence2(a, len(a))\n    print(count)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 运行结果\n\n5\n\n\n1\n\n1\n",normalizedContent:"样本代码时间复杂度为〇(n²)\n\n如：求 2 7 1 5 6 4 3 8 9 的最长上升子序列。我们定义d(i) (i∈[1,n])来表示前i个数以a[i]结尾的最长上升子序列长度。\n\n * 前1个数 d(1)=1 子序列为2；\n * 前2个数 7前面有2小于7 d(2)=d(1)+1=2 子序列为2 7\n * 前3个数 在1前面没有比1更小的，1自身组成长度为1的子序列 d(3)=1 子序列为1\n * 前4个数 5前面有2小于5 d(4)=d(1)+1=2 子序列为2 5\n * 前5个数 6前面有2 5小于6 d(5)=d(4)+1=3 子序列为2 5 6\n * 前6个数 4前面有2小于4 d(6)=d(1)+1=2 子序列为2 4\n * 前7个数 3前面有2小于3 d(3)=d(1)+1=2 子序列为2 3\n * 前8个数 8前面有2 5 6小于8 d(8)=d(5)+1=4 子序列为2 5 6 8\n * 前9个数 9前面有2 5 6 8小于9 d(9)=d(8)+1=5 子序列为2 5 6 8 9\n * d(i)=max{d(1),d(2),……,d(i)} 我们可以看出这9个数的lis为d(9)=5\n\n\n# java代码\n\npublic class main {\n    int lis(int a[], int n) {\n        int d[] = new int[n];\n        int len = 1;\n        int i, j;\n        for (i = 0; i < n; i++) {\n            d[i] = 1;\n            for (j = 0; j < i; j++) {\n                // 当前的位置的数与之前的数比较，如果数列是上升的，且序列长度+1比当前序列长度大或相等\n                if (a[j] <= a[i] && (d[j] + 1) >= d[i])\n                    //使这个数之前的最大长度加1（最长上升序列加上这个数）\n                    d[i] = d[j] + 1;\n            }\n            // 把当前d[i]的最大长度赋值给len\n            if (d[i] > len)\n                len = d[i];\n        }\n        // 返回最长上升子序列的长度\n        return len;\n    }\n\n    public static void main(string[] args) {\n        int a[] = {2, 7, 1, 5, 6, 4, 3, 8, 9};\n        int n = a.length;\n        main test = new main();\n        int count = test.lis(a, n);\n        system.out.println(count);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 运行结果\n\n5\n\n\n1\n\n1\n\n\n\n# python代码\n\n# 第一种写法\ndef longestincreasingsubsequence(nums, length):\n    # 如果列表为空或者列表长度为0就直接返回0\n    if nums == none or len(nums) == 0:\n        return 0\n    # 初始化列表为length个0，用来记录到当前位置的最长升序序列的长度\n    sublongest = [0 for i in range(length)]\n    sublongest[0] = 1\n    longest = 0\n    for i in range(1, length):\n        sublong = 0\n        for j in range(0, i):\n            # 如果当前元素比前面的元素大\n            if nums[j] <= nums[i]:\n                # 则将前面元素的最长序列和当前的最长序列比较大小，把大的赋值给sublong\n                sublong = max(sublongest[j], sublong)\n        # 加上到自身位置那个元素\n        sublongest[i] = sublong + 1\n        # 比较长度列表末尾的元素和longest的大小，把两者大的赋值给longest\n        longest = max(sublongest[i], longest)\n    return longest\n\n# 第二种写法\ndef longestincreasingsubsequence2(testarray, num):\n    d = [0 for i in range(num)]\n    longest = 1\n    for i in range(num):\n        d[i] = 1\n        for j in range(i):\n            if (testarray[j] <= testarray[i]) and (d[j] + 1) >= d[i]:\n                d[i] = d[j] + 1\n        if d[i] > longest:\n            longest = d[i]\n    return longest\n\n\nif '__name__ = __main__':\n    a = [2, 7, 1, 5, 6, 4, 3, 8, 9]\n    # count = longestincreasingsubsequence(a,len(a))\n    count = longestincreasingsubsequence2(a, len(a))\n    print(count)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 运行结果\n\n5\n\n\n1\n\n1\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"动态规划问题——最长上升子序列(LIS)(二)",frontmatter:{title:"动态规划问题——最长上升子序列(LIS)(二)",date:"2018-08-25T17:44:35.000Z",description:null,tags:["算法","Java","Python","DP"],permalink:"/pages/1f5b98/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/08.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97(LIS)(%E4%BA%8C).html",relativePath:"06.算法/02.LeetCode/08.动态规划问题——最长上升子序列(LIS)(二).md",key:"v-2fa92128",path:"/pages/1f5b98/",headers:[{level:2,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:27},{level:2,title:"输入描述",slug:"输入描述",normalizedTitle:"输入描述",charIndex:193},{level:2,title:"输出描述",slug:"输出描述",normalizedTitle:"输出描述",charIndex:278},{level:2,title:"输入",slug:"输入",normalizedTitle:"输入",charIndex:193},{level:2,title:"输出",slug:"输出",normalizedTitle:"输出",charIndex:278},{level:2,title:"说明",slug:"说明",normalizedTitle:"说明",charIndex:371},{level:2,title:"备注",slug:"备注",normalizedTitle:"备注",charIndex:501},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:920},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:2098},{level:3,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:3690}],headersStr:"题目描述 输入描述 输出描述 输入 输出 说明 备注 Java代码 Python代码 运行结果",content:'样本代码时间复杂度为〇(nlogn),笔试题\n\n\n# 题目描述\n\n一天，小凯同学震惊的发现，自己无内的PM2.5指标是有规律的！小凯采样了PM2.5数值，发现PM2.5数值以小时为周期循环，即任意时刻的PM2.5总是和一小时前相等！他的室友小文同学提出了这样一个问题，在t小时内的所有采样点中，选取若干采样点的数值，能否找到一个PM2.5不曾下降过的序列？这个序列最长是多少？\n\n\n# 输入描述\n\n第一行有两个整数n和t，表示每小时的采样点个数，和询问多少个小时的结果。第二行有n个整数，以空格分割，表示一小时内，每个采样点观测到的PM2.5数值\n\n\n# 输出描述\n\n一个整数，表示T小时内，最长的PM2.5不曾下降过的序列的长度\n\n\n# 输入\n\n4 3\n10 3 7 5\n\n\n1\n2\n\n1\n2\n\n\n\n# 输出\n\n4\n\n\n1\n\n1\n\n\n\n# 说明\n\n3小时内的所有采样点为\n\n10 3 7 5 10 3 7 5 10 3 7 5\n\n选取第2，3，5，9个采样点，可以得到一个不曾下降过的序列\n\n3 7 10 10\n\n使用其他的方法也可以得到长为4的满足条件的序列，但无法得到长度超过4的结果。\n\n\n# 备注\n\n对于20%的数据，t=1\n对于50%的数据，t<=1000\n对于80%的数据，PM2.5数值不超过200\n对于100%的数据，1<=n<=1000,\n1<=t<=1000000，PM2.5数值为正整数，且不超过1000000000\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n优化时间复杂度(外层为n，内层为logn)\n\n这里是定义一个testarray数组，存储这个升序子序列，对于新来的元素，通过二分查找，插入到这个testarray数组中，当大于或者等于testarray数组最后一个元素的时候直接在最后插入，如果在testarray数组中间位置，就直接在中间位置插入,(Tips：说明中间位置额那个数比需要插入的数字大，我们找的是最长的升序子序列，比他大的当然需要被小的替代了)，由于testarray数组是动态变化的，最后testarray数组的大小就是最长升序子序列，并且其存储的数就是这个升序子序列。\n\n\n# Java代码\n\npublic class Solution {\n    \n    public int longestIncreasingSubsequence(int[] nums) {\n        int len = nums.length;\n        if(nums == null || len ==0)\n            return 0;\n        ArrayList<Integer> dp = new ArrayList<Integer>();\n        for(int i=0;i<len ;i++){\n            if(dp.isEmpty() || dp.get(dp.size() - 1) <= nums[i])\n                dp.add(nums[i]);\n            else{\n                int index = findFirstLargeEqual(dp,nums[i]);\n                dp.set(index,nums[i]);//  用指定的元素替代此列表中指定位置上的元素。 \n            }\n        }\n        return dp.size();\n    }\n    public int findFirstLargeEqual(ArrayList<Integer> list,int num){\n        int left = 0;\n        int right = list.size() - 1;\n        while(left <=right){\n            int mid = (left + right)/2;\n            if(list.get(mid) > num) \n                right = mid -1;\n            else if(list.get(mid) < num)\n                left = mid + 1;\n            else\n                return mid;\n        }\n        return left;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# Python代码\n\ndef longestIncreasingSubsequence(nums):\n    if nums == None or len(nums) == 0:\n        return 0\n    testarray = list()\n    for i in range(len(nums)):\n        # 如果是第一个位置就直接添加进新的列表里面，如果后一个元素比新列表的最后一个元素大或者等于，则添加该元素到新列表末尾\n        if len(testarray) == 0 or nums[i] >= testarray[len(testarray) - 1]:\n            testarray.append(nums[i])\n        else:\n            # 如果这个新元素不大于等于最后一个元素的时候，利用二分查找找到他在新列表中应该插入的位置\n            index = findFirstLargeEqual(testarray, nums[i])\n            # 将新元素替换对应位置的列表里面的元素\n            testarray[index] = nums[i]\n    return len(testarray)\n\n\n# 利用二分查找法\ndef findFirstLargeEqual(testarray, target):\n    left = 0\n    right = len(testarray) - 1\n    if testarray[0] == target:\n        return 0\n    while left <= right:\n        # 双斜杠整除\n        mid = (left + right) // 2\n        if testarray[mid] > target:\n            right = mid - 1\n        elif testarray[mid] < target:\n            left = mid + 1\n        else:\n            return mid\n    return left\n\n\nif __name__ == "__main__":\n    a = list()\n    # 输入n m\n    n, m = input().split()\n    # 输入采样点\n    n = int(n)\n    a = input().split()\n    # 截取输入的前n个（控制输入）\n    a = a[:n]\n    # 全部转化为整形\n    for i in range(n):\n        a[i] = int(a[i])\n    # 按照小时数重复\n    a = a * int(m)\n    count = longestIncreasingSubsequence(a)\n    print(count)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n\n# 运行结果\n\n4 3\n10 3 7 5\n4\n\n\n1\n2\n3\n\n1\n2\n3\n',normalizedContent:'样本代码时间复杂度为〇(nlogn),笔试题\n\n\n# 题目描述\n\n一天，小凯同学震惊的发现，自己无内的pm2.5指标是有规律的！小凯采样了pm2.5数值，发现pm2.5数值以小时为周期循环，即任意时刻的pm2.5总是和一小时前相等！他的室友小文同学提出了这样一个问题，在t小时内的所有采样点中，选取若干采样点的数值，能否找到一个pm2.5不曾下降过的序列？这个序列最长是多少？\n\n\n# 输入描述\n\n第一行有两个整数n和t，表示每小时的采样点个数，和询问多少个小时的结果。第二行有n个整数，以空格分割，表示一小时内，每个采样点观测到的pm2.5数值\n\n\n# 输出描述\n\n一个整数，表示t小时内，最长的pm2.5不曾下降过的序列的长度\n\n\n# 输入\n\n4 3\n10 3 7 5\n\n\n1\n2\n\n1\n2\n\n\n\n# 输出\n\n4\n\n\n1\n\n1\n\n\n\n# 说明\n\n3小时内的所有采样点为\n\n10 3 7 5 10 3 7 5 10 3 7 5\n\n选取第2，3，5，9个采样点，可以得到一个不曾下降过的序列\n\n3 7 10 10\n\n使用其他的方法也可以得到长为4的满足条件的序列，但无法得到长度超过4的结果。\n\n\n# 备注\n\n对于20%的数据，t=1\n对于50%的数据，t<=1000\n对于80%的数据，pm2.5数值不超过200\n对于100%的数据，1<=n<=1000,\n1<=t<=1000000，pm2.5数值为正整数，且不超过1000000000\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n优化时间复杂度(外层为n，内层为logn)\n\n这里是定义一个testarray数组，存储这个升序子序列，对于新来的元素，通过二分查找，插入到这个testarray数组中，当大于或者等于testarray数组最后一个元素的时候直接在最后插入，如果在testarray数组中间位置，就直接在中间位置插入,(tips：说明中间位置额那个数比需要插入的数字大，我们找的是最长的升序子序列，比他大的当然需要被小的替代了)，由于testarray数组是动态变化的，最后testarray数组的大小就是最长升序子序列，并且其存储的数就是这个升序子序列。\n\n\n# java代码\n\npublic class solution {\n    \n    public int longestincreasingsubsequence(int[] nums) {\n        int len = nums.length;\n        if(nums == null || len ==0)\n            return 0;\n        arraylist<integer> dp = new arraylist<integer>();\n        for(int i=0;i<len ;i++){\n            if(dp.isempty() || dp.get(dp.size() - 1) <= nums[i])\n                dp.add(nums[i]);\n            else{\n                int index = findfirstlargeequal(dp,nums[i]);\n                dp.set(index,nums[i]);//  用指定的元素替代此列表中指定位置上的元素。 \n            }\n        }\n        return dp.size();\n    }\n    public int findfirstlargeequal(arraylist<integer> list,int num){\n        int left = 0;\n        int right = list.size() - 1;\n        while(left <=right){\n            int mid = (left + right)/2;\n            if(list.get(mid) > num) \n                right = mid -1;\n            else if(list.get(mid) < num)\n                left = mid + 1;\n            else\n                return mid;\n        }\n        return left;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# python代码\n\ndef longestincreasingsubsequence(nums):\n    if nums == none or len(nums) == 0:\n        return 0\n    testarray = list()\n    for i in range(len(nums)):\n        # 如果是第一个位置就直接添加进新的列表里面，如果后一个元素比新列表的最后一个元素大或者等于，则添加该元素到新列表末尾\n        if len(testarray) == 0 or nums[i] >= testarray[len(testarray) - 1]:\n            testarray.append(nums[i])\n        else:\n            # 如果这个新元素不大于等于最后一个元素的时候，利用二分查找找到他在新列表中应该插入的位置\n            index = findfirstlargeequal(testarray, nums[i])\n            # 将新元素替换对应位置的列表里面的元素\n            testarray[index] = nums[i]\n    return len(testarray)\n\n\n# 利用二分查找法\ndef findfirstlargeequal(testarray, target):\n    left = 0\n    right = len(testarray) - 1\n    if testarray[0] == target:\n        return 0\n    while left <= right:\n        # 双斜杠整除\n        mid = (left + right) // 2\n        if testarray[mid] > target:\n            right = mid - 1\n        elif testarray[mid] < target:\n            left = mid + 1\n        else:\n            return mid\n    return left\n\n\nif __name__ == "__main__":\n    a = list()\n    # 输入n m\n    n, m = input().split()\n    # 输入采样点\n    n = int(n)\n    a = input().split()\n    # 截取输入的前n个（控制输入）\n    a = a[:n]\n    # 全部转化为整形\n    for i in range(n):\n        a[i] = int(a[i])\n    # 按照小时数重复\n    a = a * int(m)\n    count = longestincreasingsubsequence(a)\n    print(count)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n\n# 运行结果\n\n4 3\n10 3 7 5\n4\n\n\n1\n2\n3\n\n1\n2\n3\n',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"动态规划问题——最长上升子序列(LIS)(三)",frontmatter:{title:"动态规划问题——最长上升子序列(LIS)(三)",date:"2018-08-26T14:23:08.000Z",description:null,tags:["算法","Java","Python","DP"],permalink:"/pages/f98f70/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/09.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97(LIS)(%E4%B8%89).html",relativePath:"06.算法/02.LeetCode/09.动态规划问题——最长上升子序列(LIS)(三).md",key:"v-3f1b4b82",path:"/pages/f98f70/",headers:[{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:269},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:3224},{level:3,title:"运行结果",slug:"运行结果",normalizedTitle:"运行结果",charIndex:5447}],headersStr:"Java代码 Python代码 运行结果",content:'样本代码时间复杂度为〇(nlogn),笔试题\n\n上一个版本用二分法优化了时间复杂度，但其实根据数据的样本观察可知，后面的数据都是重复的，我们只需要当列表遍历到一小时数据的最后时将后面数据的最大数加入到列表即可，这样可以快速跳出循环，避免后面不必要的查找\n\n以下代码略有区别，一种是计算数目，一种是使用新列表存储，但大致思路类似。\n\n写完之后发现可以考虑的情况还是有的，还可以继续优化，不过优化到这里应该也差不多了，列表的append方法性能上是非常好的。两个版本Java耗时0.000196s，Python耗时0.000050s\n\n\n# Java代码\n\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n        while (true) {\n            int k = scan.nextInt();\n            int t = scan.nextInt();\n            int[] arr = new int[k];\n            for (int i = 0; i < arr.length; ++i)\n                arr[i] = scan.nextInt();\n            System.out.println(new Main().lengthOfLIS(arr, t));\n        }\n    }\n    \n    public int lengthOfLIS(int[] nums, int count) {\n\n        int[] dp = new int[nums.length];\n        dp[0] = -1;\n        // 获取nums数组里面的最大数字\n        int[] maxCount = getMaxCount(nums);\n        int maxLen = 0, t = 1;\n        boolean flag = true;\n        for (; t <= count; t++) {\n            int count2 = 0;\n            if (flag) {\n                for (int i = 0; i < nums.length; i++) {\n                    if (maxLen == 0) {\n                        dp[maxLen++] = nums[i];\n                    } else {\n                        if (nums[i] >= dp[maxLen - 1]) {\n                            if (nums[i] == maxCount[0])\n                                count2++;\n                            dp[maxLen++] = nums[i];\n                            if (maxLen - 1 == nums.length - 1) {\n                                flag = false;\n                                maxLen += maxCount[1] - count2;\n                                break;\n                            }\n                        } else {\n                            int index = binarySearch(dp, maxLen - 1, nums[i]);\n                            dp[index] = nums[i];\n                        }\n                    }\n                }\n                if (!flag)\n                    break;\n            }\n        }\n        return maxLen + (count - t) * maxCount[1];\n    }\n\n    public int binarySearch(int[] dp, int len, int target) {\n        int start = 0, end = len - 1;\n        while (start <= end) {\n            int mid = (start + end) / 2;\n            if (dp[mid] > target)\n                end = mid - 1;\n            else if (dp[mid] > target)\n                start = mid + 1;\n            else\n                return mid;\n        }\n        return start;\n    }\n\n    public int[] getMaxCount(int[] nums) {\n\n        int max = Integer.MIN_VALUE, count = 0;\n        for (int i = 0; i < nums.length; i++)\n            max = Math.max(max, nums[i]);\n        for (int i = 0; i < nums.length; i++) {\n            if (max == nums[i])\n                count++;\n        }\n        return new int[]{max, count};\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n\n\n\n# Python代码\n\ndef longestIncreasingSubsequence(nums, n, m):\n    if nums == None or len(nums) == 0:\n        return 0\n    testarray = list()\n    maxNum = max(nums)\n    minNum = min(nums)\n    count = 0\n    for i in range(len(nums)):\n        if i == n:\n            for j in range(m - 1):\n                testarray.append(maxNum)\n            break\n        # 如果是第一个位置就直接添加进新的列表里面，如果后一个元素比新列表的最后一个元素大或者等于，则添加该元素到新列表末尾\n        if len(testarray) == 0 or nums[i] >= testarray[len(testarray) - 1]:\n            testarray.append(nums[i])\n        # 这一行的目的是保证新列表中的数据全部都是顺序递增的，不让后面的小的数据插入到前面，防止数列个数对了，但是实际上数据不是正序的情况\n        # 1、如果是一小时采样点的最后一个，比如8 6 7 4，  4就是一小时中最后一个采样点，而且这个数是最小值，就跳过本次循环\n        # 2、如果是一小时采样点的最后一个，比如10 3 7 5， 5就是一小时中最后一个采样点，而且这个数比之前数列的最后一个值小，就跳过本次循环\n        elif nums[i] == minNum and (i % (n - 1) == 0) or nums[i] < testarray[len(testarray) - 1] and (i % (n - 1) == 0):\n            continue\n        else:\n            # 如果这个新元素不大于等于最后一个元素的时候，利用二分查找找到他在新列表中应该插入的位置\n            index = findFirstLargeEqual(testarray, nums[i])\n            # 将新元素替换对应位置的列表里面的元素\n            testarray[index] = nums[i]\n    return len(testarray)\n\n\n# 利用二分查找法\ndef findFirstLargeEqual(testarray, target):\n    left = 0\n    right = len(testarray) - 1\n    if testarray[0] == target:\n        return 0\n    while left <= right:\n        # 双斜杠整除\n        mid = (left + right) // 2\n        if testarray[mid] > target:\n            right = mid - 1\n        elif testarray[mid] < target:\n            left = mid + 1\n        else:\n            return mid\n    return left\n\n\nif __name__ == "__main__":\n    a = list()\n    # 输入n m\n    n, m = input().split()\n    # 输入采样点\n    n = int(n)\n    a = input().split()\n    # 截取输入的前n个（控制输入）\n    a = a[:n]\n    # 全部转化为整形\n    for i in range(n):\n        a[i] = int(a[i])\n    # 按照小时数重复\n    a = a * int(m)\n    count = longestIncreasingSubsequence(a, n, int(m))\n    print(count)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n\n# 运行结果\n\n5 10\n5 6 7 9 1\n13\n\n\n1\n2\n3\n\n1\n2\n3\n',normalizedContent:'样本代码时间复杂度为〇(nlogn),笔试题\n\n上一个版本用二分法优化了时间复杂度，但其实根据数据的样本观察可知，后面的数据都是重复的，我们只需要当列表遍历到一小时数据的最后时将后面数据的最大数加入到列表即可，这样可以快速跳出循环，避免后面不必要的查找\n\n以下代码略有区别，一种是计算数目，一种是使用新列表存储，但大致思路类似。\n\n写完之后发现可以考虑的情况还是有的，还可以继续优化，不过优化到这里应该也差不多了，列表的append方法性能上是非常好的。两个版本java耗时0.000196s，python耗时0.000050s\n\n\n# java代码\n\nimport java.util.*;\n\npublic class main {\n    public static void main(string[] args) {\n        scanner scan = new scanner(system.in);\n        while (true) {\n            int k = scan.nextint();\n            int t = scan.nextint();\n            int[] arr = new int[k];\n            for (int i = 0; i < arr.length; ++i)\n                arr[i] = scan.nextint();\n            system.out.println(new main().lengthoflis(arr, t));\n        }\n    }\n    \n    public int lengthoflis(int[] nums, int count) {\n\n        int[] dp = new int[nums.length];\n        dp[0] = -1;\n        // 获取nums数组里面的最大数字\n        int[] maxcount = getmaxcount(nums);\n        int maxlen = 0, t = 1;\n        boolean flag = true;\n        for (; t <= count; t++) {\n            int count2 = 0;\n            if (flag) {\n                for (int i = 0; i < nums.length; i++) {\n                    if (maxlen == 0) {\n                        dp[maxlen++] = nums[i];\n                    } else {\n                        if (nums[i] >= dp[maxlen - 1]) {\n                            if (nums[i] == maxcount[0])\n                                count2++;\n                            dp[maxlen++] = nums[i];\n                            if (maxlen - 1 == nums.length - 1) {\n                                flag = false;\n                                maxlen += maxcount[1] - count2;\n                                break;\n                            }\n                        } else {\n                            int index = binarysearch(dp, maxlen - 1, nums[i]);\n                            dp[index] = nums[i];\n                        }\n                    }\n                }\n                if (!flag)\n                    break;\n            }\n        }\n        return maxlen + (count - t) * maxcount[1];\n    }\n\n    public int binarysearch(int[] dp, int len, int target) {\n        int start = 0, end = len - 1;\n        while (start <= end) {\n            int mid = (start + end) / 2;\n            if (dp[mid] > target)\n                end = mid - 1;\n            else if (dp[mid] > target)\n                start = mid + 1;\n            else\n                return mid;\n        }\n        return start;\n    }\n\n    public int[] getmaxcount(int[] nums) {\n\n        int max = integer.min_value, count = 0;\n        for (int i = 0; i < nums.length; i++)\n            max = math.max(max, nums[i]);\n        for (int i = 0; i < nums.length; i++) {\n            if (max == nums[i])\n                count++;\n        }\n        return new int[]{max, count};\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n\n\n\n# python代码\n\ndef longestincreasingsubsequence(nums, n, m):\n    if nums == none or len(nums) == 0:\n        return 0\n    testarray = list()\n    maxnum = max(nums)\n    minnum = min(nums)\n    count = 0\n    for i in range(len(nums)):\n        if i == n:\n            for j in range(m - 1):\n                testarray.append(maxnum)\n            break\n        # 如果是第一个位置就直接添加进新的列表里面，如果后一个元素比新列表的最后一个元素大或者等于，则添加该元素到新列表末尾\n        if len(testarray) == 0 or nums[i] >= testarray[len(testarray) - 1]:\n            testarray.append(nums[i])\n        # 这一行的目的是保证新列表中的数据全部都是顺序递增的，不让后面的小的数据插入到前面，防止数列个数对了，但是实际上数据不是正序的情况\n        # 1、如果是一小时采样点的最后一个，比如8 6 7 4，  4就是一小时中最后一个采样点，而且这个数是最小值，就跳过本次循环\n        # 2、如果是一小时采样点的最后一个，比如10 3 7 5， 5就是一小时中最后一个采样点，而且这个数比之前数列的最后一个值小，就跳过本次循环\n        elif nums[i] == minnum and (i % (n - 1) == 0) or nums[i] < testarray[len(testarray) - 1] and (i % (n - 1) == 0):\n            continue\n        else:\n            # 如果这个新元素不大于等于最后一个元素的时候，利用二分查找找到他在新列表中应该插入的位置\n            index = findfirstlargeequal(testarray, nums[i])\n            # 将新元素替换对应位置的列表里面的元素\n            testarray[index] = nums[i]\n    return len(testarray)\n\n\n# 利用二分查找法\ndef findfirstlargeequal(testarray, target):\n    left = 0\n    right = len(testarray) - 1\n    if testarray[0] == target:\n        return 0\n    while left <= right:\n        # 双斜杠整除\n        mid = (left + right) // 2\n        if testarray[mid] > target:\n            right = mid - 1\n        elif testarray[mid] < target:\n            left = mid + 1\n        else:\n            return mid\n    return left\n\n\nif __name__ == "__main__":\n    a = list()\n    # 输入n m\n    n, m = input().split()\n    # 输入采样点\n    n = int(n)\n    a = input().split()\n    # 截取输入的前n个（控制输入）\n    a = a[:n]\n    # 全部转化为整形\n    for i in range(n):\n        a[i] = int(a[i])\n    # 按照小时数重复\n    a = a * int(m)\n    count = longestincreasingsubsequence(a, n, int(m))\n    print(count)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n\n# 运行结果\n\n5 10\n5 6 7 9 1\n13\n\n\n1\n2\n3\n\n1\n2\n3\n',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-144-二叉树的前序遍历",frontmatter:{title:"LeetCode-144-二叉树的前序遍历",date:"2020-05-13T13:01:06.000Z",description:"二叉树的前序遍历",tags:["树","BFS","Java","Medium"],keywords:"树,BFS,Java,Medium",permalink:"/pages/b03f05/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/10.LeetCode-144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.html",relativePath:"06.算法/02.LeetCode/10.LeetCode-144-二叉树的前序遍历.md",key:"v-fa0dbca4",path:"/pages/b03f05/",headers:[{level:2,title:"LeetCode-144-二叉树的前序遍历",slug:"leetcode-144-二叉树的前序遍历",normalizedTitle:"leetcode-144-二叉树的前序遍历",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:237},{level:3,title:"Java代码(递归)",slug:"java代码-递归",normalizedTitle:"java代码(递归)",charIndex:453},{level:3,title:"Java代码(迭代Queue)",slug:"java代码-迭代queue",normalizedTitle:"java代码(迭代queue)",charIndex:1140},{level:3,title:"Java代码(迭代Stack)",slug:"java代码-迭代stack",normalizedTitle:"java代码(迭代stack)",charIndex:2e3}],headersStr:"LeetCode-144-二叉树的前序遍历 解题思路 Java代码(递归) Java代码(迭代Queue) Java代码(迭代Stack)",content:"# LeetCode-144-二叉树的前序遍历\n\n给定一个二叉树，返回它的 前序 遍历。\n\n相关链接：\n\n 1. LeetCode-144-二叉树的前序遍历\n 2. LeetCode-94-二叉树的中序遍历\n 3. LeetCode-145-二叉树的后序遍历\n\n示例 1:\n\n输入: [1,null,2,3]\n   1\n    \\\n     2\n    /\n   3\n\n输出: [1,2,3]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 解题思路\n\n二叉树的遍历问题都有2种解法，一种是递归，一种是迭代\n\n递归：添加根节点，开启左子树递归，开启右子树递归\n\n迭代：前序遍历一般等同于BFS，一般用Queue来实现，先进先出，层序遍历即可。\n\n不过奇怪的是这个题跑不过测试用例.......只能换成栈来做，也就是调整一下加入顺序，需要先添加右子树，再添加左子树，由于pop是后进先出，所以弹出的顺序变为了先弹出左子树，再是右子树，变成了Queue的先进先出的样子\n\n\n# Java代码(递归)\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    List<Integer> res = new ArrayList<>();\n    public List<Integer> preorderTraversal(TreeNode root) {\n        if(root==null) return res;\n        BFS(root);\n        return res;\n    }\n    public void BFS(TreeNode root){\n        if(root!=null){\n            res.add(root.val);\n            BFS(root.left);\n            BFS(root.right);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# Java代码(迭代Queue)\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<Integer> preorderTraversal(TreeNode root) {\n        List<Integer> res = new ArrayList<>();\n        if(root==null) return res;\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.add(root);\n        while(!queue.isEmpty()){\n            TreeNode temp = queue.poll();\n            res.add(temp.val);\n            if(temp.left!=null)\n                queue.add(temp.left);\n            if(temp.right!=null)\n                queue.add(temp.right);\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# Java代码(迭代Stack)\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<Integer> preorderTraversal(TreeNode root) {\n        List<Integer> res = new ArrayList<>();\n        if(root==null) return res;\n        Stack<TreeNode> stack = new Stack<>();\n        stack.add(root);\n        while(!stack.isEmpty()){\n            TreeNode temp = stack.pop();\n            res.add(temp.val);\n            if(temp.right!=null)\n                stack.add(temp.right);\n            if(temp.left!=null)\n                stack.add(temp.left);\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n",normalizedContent:"# leetcode-144-二叉树的前序遍历\n\n给定一个二叉树，返回它的 前序 遍历。\n\n相关链接：\n\n 1. leetcode-144-二叉树的前序遍历\n 2. leetcode-94-二叉树的中序遍历\n 3. leetcode-145-二叉树的后序遍历\n\n示例 1:\n\n输入: [1,null,2,3]\n   1\n    \\\n     2\n    /\n   3\n\n输出: [1,2,3]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 解题思路\n\n二叉树的遍历问题都有2种解法，一种是递归，一种是迭代\n\n递归：添加根节点，开启左子树递归，开启右子树递归\n\n迭代：前序遍历一般等同于bfs，一般用queue来实现，先进先出，层序遍历即可。\n\n不过奇怪的是这个题跑不过测试用例.......只能换成栈来做，也就是调整一下加入顺序，需要先添加右子树，再添加左子树，由于pop是后进先出，所以弹出的顺序变为了先弹出左子树，再是右子树，变成了queue的先进先出的样子\n\n\n# java代码(递归)\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    list<integer> res = new arraylist<>();\n    public list<integer> preordertraversal(treenode root) {\n        if(root==null) return res;\n        bfs(root);\n        return res;\n    }\n    public void bfs(treenode root){\n        if(root!=null){\n            res.add(root.val);\n            bfs(root.left);\n            bfs(root.right);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# java代码(迭代queue)\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public list<integer> preordertraversal(treenode root) {\n        list<integer> res = new arraylist<>();\n        if(root==null) return res;\n        queue<treenode> queue = new linkedlist<>();\n        queue.add(root);\n        while(!queue.isempty()){\n            treenode temp = queue.poll();\n            res.add(temp.val);\n            if(temp.left!=null)\n                queue.add(temp.left);\n            if(temp.right!=null)\n                queue.add(temp.right);\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# java代码(迭代stack)\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public list<integer> preordertraversal(treenode root) {\n        list<integer> res = new arraylist<>();\n        if(root==null) return res;\n        stack<treenode> stack = new stack<>();\n        stack.add(root);\n        while(!stack.isempty()){\n            treenode temp = stack.pop();\n            res.add(temp.val);\n            if(temp.right!=null)\n                stack.add(temp.right);\n            if(temp.left!=null)\n                stack.add(temp.left);\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"最小字典序字符串",frontmatter:{title:"最小字典序字符串",date:"2020-08-10T10:22:22.000Z",description:"最小字典序字符串",tags:["字符串","Java","Medium"],keywords:"字符串,Java,Medium,LeetCode",permalink:"/pages/bac26b/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/100.%E6%9C%80%E5%B0%8F%E5%AD%97%E5%85%B8%E5%BA%8F%E5%AD%97%E7%AC%A6%E4%B8%B2.html",relativePath:"06.算法/02.LeetCode/100.最小字典序字符串.md",key:"v-1b0cd9f8",path:"/pages/bac26b/",headers:[{level:2,title:"网易2021秋招-最小字典序字符串",slug:"网易2021秋招-最小字典序字符串",normalizedTitle:"网易2021秋招-最小字典序字符串",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:242},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:677}],headersStr:"网易2021秋招-最小字典序字符串 解题思路 Java代码",content:'# 网易2021秋招-最小字典序字符串\n\n第一行输入2个数字\n\n第一个数字n代表字符串应该扩充为多少位，第二个数字m代表字符串当前有多少个字符\n\n第二行输入m个数字，代表当前字符串\n\n第三行为输出，输出需要满足在不改变当前字符串前后位置的情况下，扩充为长度为n的最小字典序的字符串\n\n每个数字仅可以选择1次\n\n示例1：\n\n5 3\n2 3 5\n1 2 3 4 5\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2：\n\n5 2\n4 2\n1 3 4 2 5\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n\n# 解题思路\n\n观察用例可以输入的n就是扩展后字符的最大数，且每个数字只可以选择1次\n\n现有的数字的前后顺序不变，想要字典序最小，插入的数字需要和现有的数字进行比较，小的数字优先插入到现有数字之前。\n\n可以利用一个队列Queue存储当前的字符，保证先后顺序，同时需要一个n+1的数组，用来保存数字是否被选择的状态。\n\n将原始的字符串在对应位置置为true，表示已经选择，之后的插入数字中不能从中选择这类数字。同时将这些数字加入Queue保证先后顺序\n\n利用StringBuilder来进行最终答案的拼接\n\n * 循环从1开始到n，进行插入数字和队列数字的大小判断：\n * 当队列不为空且队列的头部小于新选择数字i时，从队列中取出头部原始的数字加入到结果res中\n * 如果不小于，则说明未选择的数字应该插入到前面，res.append(i + " ");\n * 如果循环完了，队列中还有值，直接把队列中所有数字按顺序加入res即可\n * 最后去除首尾空格，返回结果\n\n\n# Java代码\n\nimport java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        boolean[] visited = new boolean[n + 1];\n        Queue<Integer> queue = new LinkedList<>();\n        for (int i = 0; i < m; i++) {\n            int num = sc.nextInt();\n            visited[num] = true;\n            queue.offer(num);\n        }\n        StringBuilder res = new StringBuilder();\n        for (int i = 1; i <= n; i++) {\n            if (visited[i]) continue;\n            while (!queue.isEmpty() && queue.peek() < i) {\n                res.append(queue.poll() + " ");\n            }\n            res.append(i + " ");\n        }\n        while (!queue.isEmpty()) {\n            res.append(queue.poll() + " ");\n        }\n        System.out.println(res.toString().trim());\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n',normalizedContent:'# 网易2021秋招-最小字典序字符串\n\n第一行输入2个数字\n\n第一个数字n代表字符串应该扩充为多少位，第二个数字m代表字符串当前有多少个字符\n\n第二行输入m个数字，代表当前字符串\n\n第三行为输出，输出需要满足在不改变当前字符串前后位置的情况下，扩充为长度为n的最小字典序的字符串\n\n每个数字仅可以选择1次\n\n示例1：\n\n5 3\n2 3 5\n1 2 3 4 5\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2：\n\n5 2\n4 2\n1 3 4 2 5\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n\n# 解题思路\n\n观察用例可以输入的n就是扩展后字符的最大数，且每个数字只可以选择1次\n\n现有的数字的前后顺序不变，想要字典序最小，插入的数字需要和现有的数字进行比较，小的数字优先插入到现有数字之前。\n\n可以利用一个队列queue存储当前的字符，保证先后顺序，同时需要一个n+1的数组，用来保存数字是否被选择的状态。\n\n将原始的字符串在对应位置置为true，表示已经选择，之后的插入数字中不能从中选择这类数字。同时将这些数字加入queue保证先后顺序\n\n利用stringbuilder来进行最终答案的拼接\n\n * 循环从1开始到n，进行插入数字和队列数字的大小判断：\n * 当队列不为空且队列的头部小于新选择数字i时，从队列中取出头部原始的数字加入到结果res中\n * 如果不小于，则说明未选择的数字应该插入到前面，res.append(i + " ");\n * 如果循环完了，队列中还有值，直接把队列中所有数字按顺序加入res即可\n * 最后去除首尾空格，返回结果\n\n\n# java代码\n\nimport java.util.*;\n\npublic class solution {\n    public static void main(string[] args) {\n        scanner sc = new scanner(system.in);\n        int n = sc.nextint();\n        int m = sc.nextint();\n        boolean[] visited = new boolean[n + 1];\n        queue<integer> queue = new linkedlist<>();\n        for (int i = 0; i < m; i++) {\n            int num = sc.nextint();\n            visited[num] = true;\n            queue.offer(num);\n        }\n        stringbuilder res = new stringbuilder();\n        for (int i = 1; i <= n; i++) {\n            if (visited[i]) continue;\n            while (!queue.isempty() && queue.peek() < i) {\n                res.append(queue.poll() + " ");\n            }\n            res.append(i + " ");\n        }\n        while (!queue.isempty()) {\n            res.append(queue.poll() + " ");\n        }\n        system.out.println(res.tostring().trim());\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-1-两数之和",frontmatter:{title:"LeetCode-1-两数之和",date:"2020-06-16T09:30:40.000Z",description:"两数之和",tags:["数组","Java","Easy","LeetCode"],keywords:"数组,Java,Easy,LeetCode",permalink:"/pages/005df6/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/101.LeetCode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html",relativePath:"06.算法/02.LeetCode/101.LeetCode-1-两数之和.md",key:"v-6b40286e",path:"/pages/005df6/",headers:[{level:2,title:"LeetCode-1-两数之和",slug:"leetcode-1-两数之和",normalizedTitle:"leetcode-1-两数之和",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:235},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:498},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:1010}],headersStr:"LeetCode-1-两数之和 解题思路 Java代码 Java代码2",content:"# LeetCode-1-两数之和\n\n给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。\n\n示例 1:\n\n给定 nums = [2, 7, 11, 15], target = 9\n\n因为 nums[0] + nums[1] = 2 + 7 = 9\n所以返回 [0, 1]\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n\n# 解题思路\n\n**方法1、**暴力破解：\n\n暴力破解就是固定一个往后面挨个找，时间上比较耗时\n\n**方法2、**哈希表：\n\n暴力破解比较耗时，那么有没有更快的方法，比如一次遍历搞定？\n\n通过思考可以发现，数字固定一个再往后面找，这种方法不变的是数字，变化的是数字加和的顺序\n\n把数字全部存储起来，并得到target和当前数字的差值，如果这个差值在存储的数字里面，就说明和为target找到了，返回对应下标即可。\n\n于是可以利用hash表存储对应的数字和下标，按照这个思路实现，一次遍历就可以完成target下标和的寻找\n\n\n# Java代码\n\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        if(nums.length==0||nums==null) return nums;\n        int sum = 0;\n        for(int i=0;i<nums.length-1;i++){\n            for(int j=i+1;j<nums.length;j++){\n                sum = nums[i] + nums[j];\n                if(sum==target){\n                    return new int[]{i,j};\n                }\n            }\n        }\n        return new int[]{0};\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# Java代码2\n\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        if(nums.length==0||nums==null) return nums;\n        Map<Integer,Integer> map = new HashMap<>();\n        for(int i=0;i<nums.length;i++){\n            int out = target-nums[i];\n            if(map.containsKey(out)){\n                return new int[]{map.get(out),i};\n            }\n            map.put(nums[i],i);\n        }\n        return new int[]{0};\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n",normalizedContent:"# leetcode-1-两数之和\n\n给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。\n\n示例 1:\n\n给定 nums = [2, 7, 11, 15], target = 9\n\n因为 nums[0] + nums[1] = 2 + 7 = 9\n所以返回 [0, 1]\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n\n# 解题思路\n\n**方法1、**暴力破解：\n\n暴力破解就是固定一个往后面挨个找，时间上比较耗时\n\n**方法2、**哈希表：\n\n暴力破解比较耗时，那么有没有更快的方法，比如一次遍历搞定？\n\n通过思考可以发现，数字固定一个再往后面找，这种方法不变的是数字，变化的是数字加和的顺序\n\n把数字全部存储起来，并得到target和当前数字的差值，如果这个差值在存储的数字里面，就说明和为target找到了，返回对应下标即可。\n\n于是可以利用hash表存储对应的数字和下标，按照这个思路实现，一次遍历就可以完成target下标和的寻找\n\n\n# java代码\n\nclass solution {\n    public int[] twosum(int[] nums, int target) {\n        if(nums.length==0||nums==null) return nums;\n        int sum = 0;\n        for(int i=0;i<nums.length-1;i++){\n            for(int j=i+1;j<nums.length;j++){\n                sum = nums[i] + nums[j];\n                if(sum==target){\n                    return new int[]{i,j};\n                }\n            }\n        }\n        return new int[]{0};\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# java代码2\n\nclass solution {\n    public int[] twosum(int[] nums, int target) {\n        if(nums.length==0||nums==null) return nums;\n        map<integer,integer> map = new hashmap<>();\n        for(int i=0;i<nums.length;i++){\n            int out = target-nums[i];\n            if(map.containskey(out)){\n                return new int[]{map.get(out),i};\n            }\n            map.put(nums[i],i);\n        }\n        return new int[]{0};\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-16-最接近的三数之和",frontmatter:{title:"LeetCode-16-最接近的三数之和",date:"2020-09-08T10:20:20.000Z",description:"最接近的三数之和",tags:["数组","Java","Medium","LeetCode"],keywords:"数组,Java,Medium,LeetCode",permalink:"/pages/ce722a/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/102.LeetCode-16-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html",relativePath:"06.算法/02.LeetCode/102.LeetCode-16-最接近的三数之和.md",key:"v-23e575be",path:"/pages/ce722a/",headers:[{level:2,title:"LeetCode-16-最接近的三数之和",slug:"leetcode-16-最接近的三数之和",normalizedTitle:"leetcode-16-最接近的三数之和",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:314},{level:3,title:"Java代码1",slug:"java代码1",normalizedTitle:"java代码1",charIndex:578},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:1393}],headersStr:"LeetCode-16-最接近的三数之和 解题思路 Java代码1 Java代码2",content:"# LeetCode-16-最接近的三数之和\n\n给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。\n\n示例 1:\n\n输入：nums = [-1,2,1,-4], target = 1\n输出：2\n解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n提示：\n\n * 3 <= nums.length <= 10^3\n * -10^3 <= nums[i] <= 10^3\n * -10^4 <= target <= 10^4\n\n\n# 解题思路\n\n方法1、回溯：\n\n回溯穷举所有可能的排列，如果当前深度达到3，且当前sum值更接近target就更新答案res\n\n从deep=0，sum=0，index=0开始遍历\n\n回溯前深度+1，sum加上当前的nums[i]\n\n回溯之后深度-1，sum减去上一轮加入的值\n\n方法2、排序+双指针：\n\n详见https://leetcode-cn.com/problems/3sum-closest/solution/zui-jie-jin-de-san-shu-zhi-he-by-leetcode-solution/\n\n\n# Java代码1\n\nclass Solution {\n    int res = 0;\n    public int threeSumClosest(int[] nums, int target) {\n        res = nums[0] + nums[1] + nums[2];\n        backtrace(nums, target, 0, 0, 0);\n        return res;\n    }\n\n    private void backtrace(int[] nums, int target, int deep, int sum,  int index) {\n        if (deep == 3) {\n            if (Math.abs(target - res) > Math.abs(sum - target)) {\n                res = sum;\n            }\n            return;\n        }\n        for (int i = index; i < nums.length; i++) {\n            sum += nums[i];\n            deep++;\n            backtrace(nums, target, deep, sum,  i + 1);\n            sum -= nums[i];\n            deep--;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# Java代码2\n\nclass Solution {\n    public int threeSumClosest(int[] nums, int target) {\n        Arrays.sort(nums);\n        int min = Integer.MAX_VALUE;\n        int ans = 0;\n        int len = nums.length;\n        for (int i = 0; i < len; i++) {\n            if (i > 0 && nums[i] == nums[i - 1]) {\n                continue;\n            }\n            int start = i + 1;\n            int end = len - 1;\n            while (start < end) {\n                int value = nums[i] + nums[start] + nums[end];\n                if (value == target) {\n                    return value;\n                }\n                if (Math.abs(value - target) < min) {\n                    min = Math.abs(value - target);\n                    ans = value;\n                }\n                if (value > target) {\n                    end--;\n                } else {\n                    start++;\n                }\n            }\n        }\n        return ans;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n",normalizedContent:"# leetcode-16-最接近的三数之和\n\n给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。\n\n示例 1:\n\n输入：nums = [-1,2,1,-4], target = 1\n输出：2\n解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n提示：\n\n * 3 <= nums.length <= 10^3\n * -10^3 <= nums[i] <= 10^3\n * -10^4 <= target <= 10^4\n\n\n# 解题思路\n\n方法1、回溯：\n\n回溯穷举所有可能的排列，如果当前深度达到3，且当前sum值更接近target就更新答案res\n\n从deep=0，sum=0，index=0开始遍历\n\n回溯前深度+1，sum加上当前的nums[i]\n\n回溯之后深度-1，sum减去上一轮加入的值\n\n方法2、排序+双指针：\n\n详见https://leetcode-cn.com/problems/3sum-closest/solution/zui-jie-jin-de-san-shu-zhi-he-by-leetcode-solution/\n\n\n# java代码1\n\nclass solution {\n    int res = 0;\n    public int threesumclosest(int[] nums, int target) {\n        res = nums[0] + nums[1] + nums[2];\n        backtrace(nums, target, 0, 0, 0);\n        return res;\n    }\n\n    private void backtrace(int[] nums, int target, int deep, int sum,  int index) {\n        if (deep == 3) {\n            if (math.abs(target - res) > math.abs(sum - target)) {\n                res = sum;\n            }\n            return;\n        }\n        for (int i = index; i < nums.length; i++) {\n            sum += nums[i];\n            deep++;\n            backtrace(nums, target, deep, sum,  i + 1);\n            sum -= nums[i];\n            deep--;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# java代码2\n\nclass solution {\n    public int threesumclosest(int[] nums, int target) {\n        arrays.sort(nums);\n        int min = integer.max_value;\n        int ans = 0;\n        int len = nums.length;\n        for (int i = 0; i < len; i++) {\n            if (i > 0 && nums[i] == nums[i - 1]) {\n                continue;\n            }\n            int start = i + 1;\n            int end = len - 1;\n            while (start < end) {\n                int value = nums[i] + nums[start] + nums[end];\n                if (value == target) {\n                    return value;\n                }\n                if (math.abs(value - target) < min) {\n                    min = math.abs(value - target);\n                    ans = value;\n                }\n                if (value > target) {\n                    end--;\n                } else {\n                    start++;\n                }\n            }\n        }\n        return ans;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-679-24点游戏",frontmatter:{title:"LeetCode-679-24点游戏",date:"2020-09-20T10:32:30.000Z",description:"24点游戏",tags:["数组","Java","Hard","LeetCode"],keywords:"数组,Java,Hard,LeetCode",permalink:"/pages/ebc391/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/103.LeetCode-679-24%E7%82%B9%E6%B8%B8%E6%88%8F.html",relativePath:"06.算法/02.LeetCode/103.LeetCode-679-24点游戏.md",key:"v-2203410d",path:"/pages/ebc391/",headers:[{level:2,title:"LeetCode-679-24点游戏",slug:"leetcode-679-24点游戏",normalizedTitle:"leetcode-679-24点游戏",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:393},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:1305}],headersStr:"LeetCode-679-24点游戏 解题思路 Java代码",content:"# LeetCode-679-24点游戏\n\n你有 4 张写有 1 到 9 数字的牌。你需要判断是否能通过 *，/，+，-，(，) 的运算得到 24。\n\n示例 1:\n\n输入: [4, 1, 8, 7]\n输出: True\n解释: (8-4) * (7-1) = 24\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2：\n\n输入: [1, 2, 1, 2]\n输出: False\n\n\n1\n2\n\n1\n2\n\n\n注意:\n\n 1. 除法运算符 / 表示实数除法，而不是整数除法。例如 4 / (1 - 2/3) = 12 。\n 2. 每个运算符对两个数进行运算。特别是我们不能用 - 作为一元运算符。例如，[1, 1, 1, 1] 作为输入时，表达式 -1 - 1 - 1 - 1 是不允许的。\n 3. 你不能将数字连接在一起。例如，输入为 [1, 2, 1, 2] 时，不能写成 12 + 12 。\n\n\n# 解题思路\n\n题解来自https://leetcode-cn.com/problems/24-game/solution/24-dian-you-xi-by-leetcode-solution/\n\n方法1、回溯：\n\n一共有 4 个数和 3 个运算操作，因此可能性非常有限。一共有多少种可能性呢？\n\n首先从 4 个数字中有序地选出 2 个数字，共有 4×3=12 种选法，并选择加、减、乘、除 4 种运算操作之一，用得到的结果取代选出的 2个数字，剩下 3个数字。\n\n然后在剩下的 3 个数字中有序地选出 2 个数字，共有3×2=6 种选法，并选择 4 种运算操作之一，用得到的结果取代选出的 2 个数字，剩下 2 个数字。\n\n最后剩下 2 个数字，有 2 种不同的顺序，并选择 4 种运算操作之一。\n\n因此，一共有12×4×6×4×2×4=9216 种不同的可能性。\n\n可以通过回溯的方法遍历所有不同的可能性。具体做法是，使用一个列表存储目前的全部数字，每次从列表中选出 2 个数字，再选择一种运算操作，用计算得到的结果取代选出的 2 个数字，这样列表中的数字就减少了 1 个。重复上述步骤，直到列表中只剩下 1 个数字，这个数字就是一种可能性的结果，如果结果等于 24，则说明可以通过运算得到 24。如果所有的可能性的结果都不等于 24，则说明无法通过运算得到 24。\n\n实现时，有一些细节需要注意。\n\n * 除法运算为实数除法，因此结果为浮点数，列表中存储的数字也都是浮点数。在判断结果是否等于 2424 时应考虑精度误差，这道题中，误差小于 10^{-6}可以认为是相等。\n\n * 进行除法运算时，除数不能为 0，如果遇到除数为 0 的情况，则这种可能性可以直接排除。由于列表中存储的数字是浮点数，因此判断除数是否为 00 时应考虑精度误差，这道题中，当一个数字的绝对值小于 10^{-6} 时，可以认为该数字等于 00。\n\n还有一个可以优化的点。\n\n * 加法和乘法都满足交换律，因此如果选择的运算操作是加法或乘法，则对于选出的 22 个数字不需要考虑不同的顺序，在遇到第二种顺序时可以不进行运算，直接跳过。\n\n\n# Java代码\n\nclass Solution {\n    static final int TARGET = 24;\n    static final double EPSILON = 1e-6;\n    static final int ADD = 0, MULTIPLY = 1, SUBTRACT = 2, DIVIDE = 3;\n\n    public boolean judgePoint24(int[] nums) {\n        List<Double> list = new ArrayList<Double>();\n        for (int num : nums) {\n            list.add((double) num);\n        }\n        return solve(list);\n    }\n\n    public boolean solve(List<Double> list) {\n        if (list.size() == 0) {\n            return false;\n        }\n        if (list.size() == 1) {\n            return Math.abs(list.get(0) - TARGET) < EPSILON;\n        }\n        int size = list.size();\n        for (int i = 0; i < size; i++) {\n            for (int j = 0; j < size; j++) {\n                if (i != j) {\n                    List<Double> list2 = new ArrayList<Double>();\n                    for (int k = 0; k < size; k++) {\n                        if (k != i && k != j) {\n                            list2.add(list.get(k));\n                        }\n                    }\n                    for (int k = 0; k < 4; k++) {\n                        if (k < 2 && i > j) {\n                            continue;\n                        }\n                        if (k == ADD) {\n                            list2.add(list.get(i) + list.get(j));\n                        } else if (k == MULTIPLY) {\n                            list2.add(list.get(i) * list.get(j));\n                        } else if (k == SUBTRACT) {\n                            list2.add(list.get(i) - list.get(j));\n                        } else if (k == DIVIDE) {\n                            if (Math.abs(list.get(j)) < EPSILON) {\n                                continue;\n                            } else {\n                                list2.add(list.get(i) / list.get(j));\n                            }\n                        }\n                        if (solve(list2)) {\n                            return true;\n                        }\n                        list2.remove(list2.size() - 1);\n                    }\n                }\n            }\n        }\n        return false;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n",normalizedContent:"# leetcode-679-24点游戏\n\n你有 4 张写有 1 到 9 数字的牌。你需要判断是否能通过 *，/，+，-，(，) 的运算得到 24。\n\n示例 1:\n\n输入: [4, 1, 8, 7]\n输出: true\n解释: (8-4) * (7-1) = 24\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2：\n\n输入: [1, 2, 1, 2]\n输出: false\n\n\n1\n2\n\n1\n2\n\n\n注意:\n\n 1. 除法运算符 / 表示实数除法，而不是整数除法。例如 4 / (1 - 2/3) = 12 。\n 2. 每个运算符对两个数进行运算。特别是我们不能用 - 作为一元运算符。例如，[1, 1, 1, 1] 作为输入时，表达式 -1 - 1 - 1 - 1 是不允许的。\n 3. 你不能将数字连接在一起。例如，输入为 [1, 2, 1, 2] 时，不能写成 12 + 12 。\n\n\n# 解题思路\n\n题解来自https://leetcode-cn.com/problems/24-game/solution/24-dian-you-xi-by-leetcode-solution/\n\n方法1、回溯：\n\n一共有 4 个数和 3 个运算操作，因此可能性非常有限。一共有多少种可能性呢？\n\n首先从 4 个数字中有序地选出 2 个数字，共有 4×3=12 种选法，并选择加、减、乘、除 4 种运算操作之一，用得到的结果取代选出的 2个数字，剩下 3个数字。\n\n然后在剩下的 3 个数字中有序地选出 2 个数字，共有3×2=6 种选法，并选择 4 种运算操作之一，用得到的结果取代选出的 2 个数字，剩下 2 个数字。\n\n最后剩下 2 个数字，有 2 种不同的顺序，并选择 4 种运算操作之一。\n\n因此，一共有12×4×6×4×2×4=9216 种不同的可能性。\n\n可以通过回溯的方法遍历所有不同的可能性。具体做法是，使用一个列表存储目前的全部数字，每次从列表中选出 2 个数字，再选择一种运算操作，用计算得到的结果取代选出的 2 个数字，这样列表中的数字就减少了 1 个。重复上述步骤，直到列表中只剩下 1 个数字，这个数字就是一种可能性的结果，如果结果等于 24，则说明可以通过运算得到 24。如果所有的可能性的结果都不等于 24，则说明无法通过运算得到 24。\n\n实现时，有一些细节需要注意。\n\n * 除法运算为实数除法，因此结果为浮点数，列表中存储的数字也都是浮点数。在判断结果是否等于 2424 时应考虑精度误差，这道题中，误差小于 10^{-6}可以认为是相等。\n\n * 进行除法运算时，除数不能为 0，如果遇到除数为 0 的情况，则这种可能性可以直接排除。由于列表中存储的数字是浮点数，因此判断除数是否为 00 时应考虑精度误差，这道题中，当一个数字的绝对值小于 10^{-6} 时，可以认为该数字等于 00。\n\n还有一个可以优化的点。\n\n * 加法和乘法都满足交换律，因此如果选择的运算操作是加法或乘法，则对于选出的 22 个数字不需要考虑不同的顺序，在遇到第二种顺序时可以不进行运算，直接跳过。\n\n\n# java代码\n\nclass solution {\n    static final int target = 24;\n    static final double epsilon = 1e-6;\n    static final int add = 0, multiply = 1, subtract = 2, divide = 3;\n\n    public boolean judgepoint24(int[] nums) {\n        list<double> list = new arraylist<double>();\n        for (int num : nums) {\n            list.add((double) num);\n        }\n        return solve(list);\n    }\n\n    public boolean solve(list<double> list) {\n        if (list.size() == 0) {\n            return false;\n        }\n        if (list.size() == 1) {\n            return math.abs(list.get(0) - target) < epsilon;\n        }\n        int size = list.size();\n        for (int i = 0; i < size; i++) {\n            for (int j = 0; j < size; j++) {\n                if (i != j) {\n                    list<double> list2 = new arraylist<double>();\n                    for (int k = 0; k < size; k++) {\n                        if (k != i && k != j) {\n                            list2.add(list.get(k));\n                        }\n                    }\n                    for (int k = 0; k < 4; k++) {\n                        if (k < 2 && i > j) {\n                            continue;\n                        }\n                        if (k == add) {\n                            list2.add(list.get(i) + list.get(j));\n                        } else if (k == multiply) {\n                            list2.add(list.get(i) * list.get(j));\n                        } else if (k == subtract) {\n                            list2.add(list.get(i) - list.get(j));\n                        } else if (k == divide) {\n                            if (math.abs(list.get(j)) < epsilon) {\n                                continue;\n                            } else {\n                                list2.add(list.get(i) / list.get(j));\n                            }\n                        }\n                        if (solve(list2)) {\n                            return true;\n                        }\n                        list2.remove(list2.size() - 1);\n                    }\n                }\n            }\n        }\n        return false;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-141-环形链表",frontmatter:{title:"LeetCode-141-环形链表",date:"2020-06-10T16:16:00.000Z",description:"环形链表",tags:["链表","Java","Easy","LeetCode"],keywords:"链表,Java,Easy,LeetCode",permalink:"/pages/edad8f/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/104.LeetCode-141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8.html",relativePath:"06.算法/02.LeetCode/104.LeetCode-141-环形链表.md",key:"v-67adcffe",path:"/pages/edad8f/",headers:[{level:2,title:"LeetCode-141-环形链表",slug:"leetcode-141-环形链表",normalizedTitle:"leetcode-141-环形链表",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:379},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:718},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:2734}],headersStr:"LeetCode-141-环形链表 解题思路 Java代码 Java代码2",content:"# LeetCode-141-环形链表\n\n给定一个链表，判断链表中是否有环。\n\n为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。\n\n示例1：\n\n输入：head = [3,2,0,-4], pos = 1\n输出：true\n解释：链表中有一个环，其尾部连接到第二个节点。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2：\n\n输入：head = [1,2], pos = 0\n输出：true\n解释：链表中有一个环，其尾部连接到第一个节点。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例3：\n\n输入：head = [1], pos = -1\n输出：false\n解释：链表中没有环。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n进阶：\n\n你能用 O(1)（即，常量）内存解决此问题吗？\n\n\n# 解题思路\n\n快慢指针：\n\n要找到一个链表有没有环，可以通过设置快慢指针的方式\n\n如果快的指针赶上了慢的指针说明链表中有环，如果不存在环那么其中一个指针必定会等于null\n\n初始化慢指针slow=head.next，如果他等于null说明链表只有一个节点，不存在环，返回false\n\n初始化快指针fast=slow.next，当快慢指针都不为空的时候，判断是否相等，相等则有环\n\n如果不相等，则移动慢指针1步，移动快指针2步，但快指针移动一步之后需要判断是否为null，不为null才能移动第二步，否则没有环，跳出循环返回false\n\nHashSet：\n\n使用hashset存储访问过的节点，如果有重复的节点试图添加进set中，此次的添加操作必定会失败，同时说明链表有环\n\n\n# Java代码\n\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n        if(head==null) return false;\n        ListNode slow = head.next;\n        if(slow==null) return false;\n        ListNode fast = slow.next;\n        while(fast!=null&&slow!=null){\n            if(fast==slow) return true;\n            slow = slow.next;\n            fast = fast.next;\n            if(fast!=null){\n                fast = fast.next;\n            }\n        }\n        return false;\n    }\n}\n\n// 类似可以通过的写法还有以下两种\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n        if(head==null||head.next==null){\n            return false;\n        }\n        ListNode slow = head;\n        ListNode fast = head;\n        while(fast!=null&&fast.next!=null){\n            slow = slow.next;\n            fast = fast.next.next;\n            if(slow==fast){\n                return true;\n            }\n        }\n        if(fast==null||fast.next==null){\n            return false;\n        }\n        return false;\n    }\n}\n\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n        if(head==null||head.next==null){\n            return false;\n        }\n        ListNode slow = head;\n        ListNode fast = head.next;\n        while(slow!=fast){\n            if(fast==null||fast.next==null){\n                return false;\n            }\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n\n\n# Java代码2\n\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n        if (head == null || head.next == null) {\n            return false;\n        }\n        HashSet<ListNode> set = new HashSet<>();\n        while(head!=null){\n            if(!set.add(head)){\n                return true;\n            }\n            head = head.next;\n        }\n        return false;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n",normalizedContent:"# leetcode-141-环形链表\n\n给定一个链表，判断链表中是否有环。\n\n为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。\n\n示例1：\n\n输入：head = [3,2,0,-4], pos = 1\n输出：true\n解释：链表中有一个环，其尾部连接到第二个节点。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2：\n\n输入：head = [1,2], pos = 0\n输出：true\n解释：链表中有一个环，其尾部连接到第一个节点。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例3：\n\n输入：head = [1], pos = -1\n输出：false\n解释：链表中没有环。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n进阶：\n\n你能用 o(1)（即，常量）内存解决此问题吗？\n\n\n# 解题思路\n\n快慢指针：\n\n要找到一个链表有没有环，可以通过设置快慢指针的方式\n\n如果快的指针赶上了慢的指针说明链表中有环，如果不存在环那么其中一个指针必定会等于null\n\n初始化慢指针slow=head.next，如果他等于null说明链表只有一个节点，不存在环，返回false\n\n初始化快指针fast=slow.next，当快慢指针都不为空的时候，判断是否相等，相等则有环\n\n如果不相等，则移动慢指针1步，移动快指针2步，但快指针移动一步之后需要判断是否为null，不为null才能移动第二步，否则没有环，跳出循环返回false\n\nhashset：\n\n使用hashset存储访问过的节点，如果有重复的节点试图添加进set中，此次的添加操作必定会失败，同时说明链表有环\n\n\n# java代码\n\n/**\n * definition for singly-linked list.\n * class listnode {\n *     int val;\n *     listnode next;\n *     listnode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class solution {\n    public boolean hascycle(listnode head) {\n        if(head==null) return false;\n        listnode slow = head.next;\n        if(slow==null) return false;\n        listnode fast = slow.next;\n        while(fast!=null&&slow!=null){\n            if(fast==slow) return true;\n            slow = slow.next;\n            fast = fast.next;\n            if(fast!=null){\n                fast = fast.next;\n            }\n        }\n        return false;\n    }\n}\n\n// 类似可以通过的写法还有以下两种\npublic class solution {\n    public boolean hascycle(listnode head) {\n        if(head==null||head.next==null){\n            return false;\n        }\n        listnode slow = head;\n        listnode fast = head;\n        while(fast!=null&&fast.next!=null){\n            slow = slow.next;\n            fast = fast.next.next;\n            if(slow==fast){\n                return true;\n            }\n        }\n        if(fast==null||fast.next==null){\n            return false;\n        }\n        return false;\n    }\n}\n\npublic class solution {\n    public boolean hascycle(listnode head) {\n        if(head==null||head.next==null){\n            return false;\n        }\n        listnode slow = head;\n        listnode fast = head.next;\n        while(slow!=fast){\n            if(fast==null||fast.next==null){\n                return false;\n            }\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n\n\n# java代码2\n\npublic class solution {\n    public boolean hascycle(listnode head) {\n        if (head == null || head.next == null) {\n            return false;\n        }\n        hashset<listnode> set = new hashset<>();\n        while(head!=null){\n            if(!set.add(head)){\n                return true;\n            }\n            head = head.next;\n        }\n        return false;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-155-最小栈",frontmatter:{title:"LeetCode-155-最小栈",date:"2020-07-13T09:46:46.000Z",description:"最小栈",tags:["栈","Java","Easy"],keywords:"栈,Java,Easy,LeetCode",permalink:"/pages/2fc7af/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/105.LeetCode-155-%E6%9C%80%E5%B0%8F%E6%A0%88.html",relativePath:"06.算法/02.LeetCode/105.LeetCode-155-最小栈.md",key:"v-b14ebb44",path:"/pages/2fc7af/",headers:[{level:2,title:"LeetCode-155-最小栈",slug:"leetcode-155-最小栈",normalizedTitle:"leetcode-155-最小栈",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:744},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:953},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:2095}],headersStr:"LeetCode-155-最小栈 解题思路 Java代码 Java代码2",content:'# LeetCode-155-最小栈\n\n设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。\n\n * push(x) —— 将元素 x 推入栈中。\n * pop() —— 删除栈顶的元素。\n * top() —— 获取栈顶元素。\n * getMin() —— 检索栈中的最小元素。\n\n示例1：\n\n输入：\n["MinStack","push","push","push","getMin","pop","top","getMin"]\n[[],[-2],[0],[-3],[],[],[],[]]\n\n输出：\n[null,null,null,null,-3,null,0,-2]\n\n解释：\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin();   --\x3e 返回 -3.\nminStack.pop();\nminStack.top();      --\x3e 返回 0.\nminStack.getMin();   --\x3e 返回 -2.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n提示：\n\n * pop、top 和 getMin 操作总是在 非空栈 上调用。\n\n * 如果两个链表没有交点，返回 null.\n\n * 在返回结果后，两个链表仍须保持原有的结构。\n\n * 可假定整个链表结构中没有循环。\n\n * 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。\n\n\n# 解题思路\n\n方法1、两个栈：\n\n需要一个数据栈，一个最小栈\n\n最小栈始终存储当前的最小值\n\n在push进数据栈的同时，判断最小栈是否为空或者新值是否小于最小栈的顶部值，\n\n如果小于则加入新值到最小栈，如果不小于则加入最小栈栈顶(即上一个最小元素)入最小栈\n\n当需要pop的时候，同时弹出最小栈和数据栈数值\n\n当需要getMin时，返回最小栈的栈顶元素即是当前最小元素\n\n当需要拿到top时，返回数据栈栈顶元素\n\n\n# Java代码\n\nclass MinStack {\n\n    private Stack<Integer> stack_data;\n    private Stack<Integer> stack_min;\n\n    /** initialize your data structure here. */\n    public MinStack() {\n        stack_data = new Stack<>();\n        stack_min = new Stack<>();\n    }\n    \n    public void push(int x) {\n        stack_data.push(x);\n        if(stack_min.size()==0||x<stack_min.peek()){\n            stack_min.push(x);\n        }else{\n            stack_min.push(stack_min.peek());\n        }\n    }\n    \n    public void pop() {\n        stack_data.pop();\n        stack_min.pop();\n    }\n    \n    public int top() {\n        return stack_data.peek();\n    }\n    \n    public int getMin() {\n        return stack_min.peek();\n    }\n}\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack obj = new MinStack();\n * obj.push(x);\n * obj.pop();\n * int param_3 = obj.top();\n * int param_4 = obj.getMin();\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# Java代码2\n\nclass MinStack {\n\n    private Deque<Integer> stackData;\n    private Deque<Integer> stackMin;\n\n    /** initialize your data structure here. */\n    public MinStack() {\n        stackData = new LinkedList();\n        stackMin = new LinkedList();\n        stackMin.push(Integer.MAX_VALUE);\n    }\n    \n    public void push(int val) {\n        stackData.push(val);\n        stackMin.push(Math.min(val,stackMin.peek()));\n    }\n    \n    public void pop() {\n        stackData.pop();\n        stackMin.pop();\n    }\n    \n    public int top() {\n        return stackData.peek();\n    }\n    \n    public int getMin() {\n        return stackMin.peek();\n    }\n}\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack obj = new MinStack();\n * obj.push(val);\n * obj.pop();\n * int param_3 = obj.top();\n * int param_4 = obj.getMin();\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n',normalizedContent:'# leetcode-155-最小栈\n\n设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。\n\n * push(x) —— 将元素 x 推入栈中。\n * pop() —— 删除栈顶的元素。\n * top() —— 获取栈顶元素。\n * getmin() —— 检索栈中的最小元素。\n\n示例1：\n\n输入：\n["minstack","push","push","push","getmin","pop","top","getmin"]\n[[],[-2],[0],[-3],[],[],[],[]]\n\n输出：\n[null,null,null,null,-3,null,0,-2]\n\n解释：\nminstack minstack = new minstack();\nminstack.push(-2);\nminstack.push(0);\nminstack.push(-3);\nminstack.getmin();   --\x3e 返回 -3.\nminstack.pop();\nminstack.top();      --\x3e 返回 0.\nminstack.getmin();   --\x3e 返回 -2.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n提示：\n\n * pop、top 和 getmin 操作总是在 非空栈 上调用。\n\n * 如果两个链表没有交点，返回 null.\n\n * 在返回结果后，两个链表仍须保持原有的结构。\n\n * 可假定整个链表结构中没有循环。\n\n * 程序尽量满足 o(n) 时间复杂度，且仅用 o(1) 内存。\n\n\n# 解题思路\n\n方法1、两个栈：\n\n需要一个数据栈，一个最小栈\n\n最小栈始终存储当前的最小值\n\n在push进数据栈的同时，判断最小栈是否为空或者新值是否小于最小栈的顶部值，\n\n如果小于则加入新值到最小栈，如果不小于则加入最小栈栈顶(即上一个最小元素)入最小栈\n\n当需要pop的时候，同时弹出最小栈和数据栈数值\n\n当需要getmin时，返回最小栈的栈顶元素即是当前最小元素\n\n当需要拿到top时，返回数据栈栈顶元素\n\n\n# java代码\n\nclass minstack {\n\n    private stack<integer> stack_data;\n    private stack<integer> stack_min;\n\n    /** initialize your data structure here. */\n    public minstack() {\n        stack_data = new stack<>();\n        stack_min = new stack<>();\n    }\n    \n    public void push(int x) {\n        stack_data.push(x);\n        if(stack_min.size()==0||x<stack_min.peek()){\n            stack_min.push(x);\n        }else{\n            stack_min.push(stack_min.peek());\n        }\n    }\n    \n    public void pop() {\n        stack_data.pop();\n        stack_min.pop();\n    }\n    \n    public int top() {\n        return stack_data.peek();\n    }\n    \n    public int getmin() {\n        return stack_min.peek();\n    }\n}\n\n/**\n * your minstack object will be instantiated and called as such:\n * minstack obj = new minstack();\n * obj.push(x);\n * obj.pop();\n * int param_3 = obj.top();\n * int param_4 = obj.getmin();\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# java代码2\n\nclass minstack {\n\n    private deque<integer> stackdata;\n    private deque<integer> stackmin;\n\n    /** initialize your data structure here. */\n    public minstack() {\n        stackdata = new linkedlist();\n        stackmin = new linkedlist();\n        stackmin.push(integer.max_value);\n    }\n    \n    public void push(int val) {\n        stackdata.push(val);\n        stackmin.push(math.min(val,stackmin.peek()));\n    }\n    \n    public void pop() {\n        stackdata.pop();\n        stackmin.pop();\n    }\n    \n    public int top() {\n        return stackdata.peek();\n    }\n    \n    public int getmin() {\n        return stackmin.peek();\n    }\n}\n\n/**\n * your minstack object will be instantiated and called as such:\n * minstack obj = new minstack();\n * obj.push(val);\n * obj.pop();\n * int param_3 = obj.top();\n * int param_4 = obj.getmin();\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-160-相交链表",frontmatter:{title:"LeetCode-160-相交链表",date:"2020-07-11T10:43:04.000Z",description:"相交链表",tags:["链表","Java","Easy"],keywords:"链表,Java,Easy,LeetCode",permalink:"/pages/19f71b/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/106.LeetCode-160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8.html",relativePath:"06.算法/02.LeetCode/106.LeetCode-160-相交链表.md",key:"v-6e6d2c48",path:"/pages/19f71b/",headers:[{level:2,title:"LeetCode-160-相交链表",slug:"leetcode-160-相交链表",normalizedTitle:"leetcode-160-相交链表",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:1123},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:1570},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:2487}],headersStr:"LeetCode-160-相交链表 解题思路 Java代码 Java代码2",content:"# LeetCode-160-相交链表\n\n编写一个程序，找到两个单链表相交的起始节点。\n\n如下面的两个链表**：**\n\n      a1---\x3ea2\n             \\\n              \\\n               c1---\x3ec2---\x3ec3\n              / \n             /  \nb1---\x3eb2---\x3eb3               \n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n在节点c1开始相交\n\n示例1：\n\n输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\n输出：Reference of the node with value = 8\n输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2：\n\n输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n输出：Reference of the node with value = 2\n输入解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例3：\n\n输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n输出：null\n输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n解释：这两个链表不相交，因此返回 null。\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n注意：\n\n * 如果两个链表没有交点，返回 null.\n * 在返回结果后，两个链表仍须保持原有的结构。\n * 可假定整个链表结构中没有循环。\n * 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。\n\n\n# 解题思路\n\n方法1、快慢指针：\n\n短链表的指针会先到达链表末尾，称为快指针，此时将短链表指针指向长链表头部，\n\n当短链表到达末尾时，长链表还剩的节点就是长短链表的相差的个数n，\n\n这个时候短链表和长链表继续向前走，当长链表的慢指针到达尾部的时候，快指针就会从长链表头部走n步，此时再将慢指针变为短链表头部，就能够使得长短链表开始的头部位置相同\n\n继续往下遍历直到链表头部值相等，如果找完了都不相等则返回null\n\n> 为什么判断空的时候不采用如tempA.next!=null，而是采用tempA!=null，因为当两个链表不相交的时候，直接采用next判断将让循环无限下去，而采用如tempA!=null的方式可以很好的结束死循环(一长一短的链表或者相同长度的链表终究会在一定次数内相等为空)。\n\n方法2、HashSet：\n\n哈希集合的思路很简单，先遍历一个链表，将链表中的所有值加入进去，之后遍历第二个链表。当链表中的元素无法加入到集合中时，则说明有相交，否则说明两个链表不相交。\n\n\n# Java代码\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if(headA==null||headB==null) return null;\n        ListNode tempA = headA;\n        ListNode tempB = headB;\n        while(tempA!=tempB){\n            if(tempA!=null){\n                tempA = tempA.next;\n            }else{\n                tempA = headB;\n            }\n            if(tempB!=null){\n                tempB = tempB.next;\n            }else{\n                tempB = headA;\n            }\n        }\n        return tempA;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# Java代码2\n\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if(headA==null||headB==null){\n            return null;\n        }\n        ListNode temp = headA;\n        HashSet<ListNode> set = new HashSet<>();\n        while(temp!=null){\n            set.add(temp);\n            temp = temp.next;\n        }\n        temp = headB;\n        while(temp!=null){\n            if(set.contains(temp)){\n                return temp;\n            }\n            temp = temp.next;\n        }\n        return null;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n",normalizedContent:"# leetcode-160-相交链表\n\n编写一个程序，找到两个单链表相交的起始节点。\n\n如下面的两个链表**：**\n\n      a1---\x3ea2\n             \\\n              \\\n               c1---\x3ec2---\x3ec3\n              / \n             /  \nb1---\x3eb2---\x3eb3               \n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n在节点c1开始相交\n\n示例1：\n\n输入：intersectval = 8, lista = [4,1,8,4,5], listb = [5,0,1,8,4,5], skipa = 2, skipb = 3\n输出：reference of the node with value = 8\n输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 a 为 [4,1,8,4,5]，链表 b 为 [5,0,1,8,4,5]。在 a 中，相交节点前有 2 个节点；在 b 中，相交节点前有 3 个节点。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2：\n\n输入：intersectval = 2, lista = [0,9,1,2,4], listb = [3,2,4], skipa = 3, skipb = 1\n输出：reference of the node with value = 2\n输入解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 a 为 [0,9,1,2,4]，链表 b 为 [3,2,4]。在 a 中，相交节点前有 3 个节点；在 b 中，相交节点前有 1 个节点。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例3：\n\n输入：intersectval = 0, lista = [2,6,4], listb = [1,5], skipa = 3, skipb = 2\n输出：null\n输入解释：从各自的表头开始算起，链表 a 为 [2,6,4]，链表 b 为 [1,5]。由于这两个链表不相交，所以 intersectval 必须为 0，而 skipa 和 skipb 可以是任意值。\n解释：这两个链表不相交，因此返回 null。\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n注意：\n\n * 如果两个链表没有交点，返回 null.\n * 在返回结果后，两个链表仍须保持原有的结构。\n * 可假定整个链表结构中没有循环。\n * 程序尽量满足 o(n) 时间复杂度，且仅用 o(1) 内存。\n\n\n# 解题思路\n\n方法1、快慢指针：\n\n短链表的指针会先到达链表末尾，称为快指针，此时将短链表指针指向长链表头部，\n\n当短链表到达末尾时，长链表还剩的节点就是长短链表的相差的个数n，\n\n这个时候短链表和长链表继续向前走，当长链表的慢指针到达尾部的时候，快指针就会从长链表头部走n步，此时再将慢指针变为短链表头部，就能够使得长短链表开始的头部位置相同\n\n继续往下遍历直到链表头部值相等，如果找完了都不相等则返回null\n\n> 为什么判断空的时候不采用如tempa.next!=null，而是采用tempa!=null，因为当两个链表不相交的时候，直接采用next判断将让循环无限下去，而采用如tempa!=null的方式可以很好的结束死循环(一长一短的链表或者相同长度的链表终究会在一定次数内相等为空)。\n\n方法2、hashset：\n\n哈希集合的思路很简单，先遍历一个链表，将链表中的所有值加入进去，之后遍历第二个链表。当链表中的元素无法加入到集合中时，则说明有相交，否则说明两个链表不相交。\n\n\n# java代码\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class solution {\n    public listnode getintersectionnode(listnode heada, listnode headb) {\n        if(heada==null||headb==null) return null;\n        listnode tempa = heada;\n        listnode tempb = headb;\n        while(tempa!=tempb){\n            if(tempa!=null){\n                tempa = tempa.next;\n            }else{\n                tempa = headb;\n            }\n            if(tempb!=null){\n                tempb = tempb.next;\n            }else{\n                tempb = heada;\n            }\n        }\n        return tempa;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# java代码2\n\npublic class solution {\n    public listnode getintersectionnode(listnode heada, listnode headb) {\n        if(heada==null||headb==null){\n            return null;\n        }\n        listnode temp = heada;\n        hashset<listnode> set = new hashset<>();\n        while(temp!=null){\n            set.add(temp);\n            temp = temp.next;\n        }\n        temp = headb;\n        while(temp!=null){\n            if(set.contains(temp)){\n                return temp;\n            }\n            temp = temp.next;\n        }\n        return null;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"判断一棵二叉树是否为二叉搜索树和完全二叉树",frontmatter:{title:"判断一棵二叉树是否为二叉搜索树和完全二叉树",date:"2020-09-10T16:30:22.000Z",description:"如题",tags:["树","Java","Easy","LeetCode"],keywords:"树,Java,Easy,LeetCode",permalink:"/pages/6d1dda/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/107.%E5%88%A4%E6%96%AD%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%92%8C%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.html",relativePath:"06.算法/02.LeetCode/107.判断一棵二叉树是否为二叉搜索树和完全二叉树.md",key:"v-2d3903dd",path:"/pages/6d1dda/",headers:[{level:2,title:"判断一棵二叉树是否为二叉搜索树和完全二叉树",slug:"判断一棵二叉树是否为二叉搜索树和完全二叉树",normalizedTitle:"判断一棵二叉树是否为二叉搜索树和完全二叉树",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:142},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:159}],headersStr:"判断一棵二叉树是否为二叉搜索树和完全二叉树 解题思路 Java代码",content:"# 判断一棵二叉树是否为二叉搜索树和完全二叉树\n\n给定一棵二叉树，已经其中没有重复值的节点，请判断该二叉树是否为搜索二叉树和完全二叉树。\n\n示例1：\n\n输入：{2,1,3}\n输出：[true,true]\n\n\n1\n2\n\n1\n2\n\n\n备注：\n\nn<=500000\n\n\n1\n\n1\n\n\n\n# 解题思路\n\n详见注释理解\n\n\n# Java代码\n\nimport java.util.*;\n\n/*\n * public class TreeNode {\n *   int val = 0;\n *   TreeNode left = null;\n *   TreeNode right = null;\n * }\n */\n\npublic class Solution {\n    /**\n     * \n     * @param root TreeNode类 the root\n     * @return bool布尔型一维数组\n     */\n    public boolean[] judgeIt(TreeNode root) {\n        // 二叉搜索树的中序遍历严格递增\n        // 每个节点左边节点小于右边节点，左子树的最大值一定小于根节点，小于右子树的最大值\n        if (root == null) {\n            return new boolean[]{false, false};\n        }\n        List<Integer> list = new ArrayList<>();\n        midSearch(root, list);\n        boolean f1 = true;\n        for (int i = 1; i < list.size(); i++) {\n            if (list.get(i) < list.get(i - 1)) {\n                f1 = false;\n                break;\n            }\n        }\n        boolean f2 = isCompleteTree(root);\n        return new boolean[]{f1, f2};\n    }\n    \n    private static boolean isCompleteTree(TreeNode root) {\n        // 完全二叉树，除了最后一层，每一层都是满的\n        // 层序遍历，当遇到节点为null的时候，队列中剩下的节点必须为叶子节点\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        while (!queue.isEmpty()) {\n            TreeNode node = queue.poll();\n            if (node.left == null) {\n                if (node.right != null) return false;\n                while (!queue.isEmpty()) {\n                    TreeNode temp = queue.poll();\n                    if (temp.left != null || temp.right != null) return false;\n                }\n                return true;\n            } else {\n                queue.offer(node.left);\n            }\n            if (node.right == null) {\n                while (!queue.isEmpty()) {\n                    TreeNode temp = queue.poll();\n                    if (temp.left != null || temp.right != null) return false;\n                }\n                return true;\n            } else {\n                queue.offer(node.right);\n            }\n        }\n        return true;\n    }\n\n    private static void midSearch(TreeNode root, List<Integer> list) {\n        if (root == null) return;\n        midSearch(root.left, list);\n        list.add(root.val);\n        midSearch(root.right, list);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n",normalizedContent:"# 判断一棵二叉树是否为二叉搜索树和完全二叉树\n\n给定一棵二叉树，已经其中没有重复值的节点，请判断该二叉树是否为搜索二叉树和完全二叉树。\n\n示例1：\n\n输入：{2,1,3}\n输出：[true,true]\n\n\n1\n2\n\n1\n2\n\n\n备注：\n\nn<=500000\n\n\n1\n\n1\n\n\n\n# 解题思路\n\n详见注释理解\n\n\n# java代码\n\nimport java.util.*;\n\n/*\n * public class treenode {\n *   int val = 0;\n *   treenode left = null;\n *   treenode right = null;\n * }\n */\n\npublic class solution {\n    /**\n     * \n     * @param root treenode类 the root\n     * @return bool布尔型一维数组\n     */\n    public boolean[] judgeit(treenode root) {\n        // 二叉搜索树的中序遍历严格递增\n        // 每个节点左边节点小于右边节点，左子树的最大值一定小于根节点，小于右子树的最大值\n        if (root == null) {\n            return new boolean[]{false, false};\n        }\n        list<integer> list = new arraylist<>();\n        midsearch(root, list);\n        boolean f1 = true;\n        for (int i = 1; i < list.size(); i++) {\n            if (list.get(i) < list.get(i - 1)) {\n                f1 = false;\n                break;\n            }\n        }\n        boolean f2 = iscompletetree(root);\n        return new boolean[]{f1, f2};\n    }\n    \n    private static boolean iscompletetree(treenode root) {\n        // 完全二叉树，除了最后一层，每一层都是满的\n        // 层序遍历，当遇到节点为null的时候，队列中剩下的节点必须为叶子节点\n        queue<treenode> queue = new linkedlist<>();\n        queue.offer(root);\n        while (!queue.isempty()) {\n            treenode node = queue.poll();\n            if (node.left == null) {\n                if (node.right != null) return false;\n                while (!queue.isempty()) {\n                    treenode temp = queue.poll();\n                    if (temp.left != null || temp.right != null) return false;\n                }\n                return true;\n            } else {\n                queue.offer(node.left);\n            }\n            if (node.right == null) {\n                while (!queue.isempty()) {\n                    treenode temp = queue.poll();\n                    if (temp.left != null || temp.right != null) return false;\n                }\n                return true;\n            } else {\n                queue.offer(node.right);\n            }\n        }\n        return true;\n    }\n\n    private static void midsearch(treenode root, list<integer> list) {\n        if (root == null) return;\n        midsearch(root.left, list);\n        list.add(root.val);\n        midsearch(root.right, list);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-169-多数元素",frontmatter:{title:"LeetCode-169-多数元素",date:"2020-07-15T10:43:02.000Z",description:"多数元素",tags:["Java","数组","Easy"],keywords:"Java,数组,Easy,LeetCode",permalink:"/pages/657ad4/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/108.LeetCode-169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0.html",relativePath:"06.算法/02.LeetCode/108.LeetCode-169-多数元素.md",key:"v-864cbdf2",path:"/pages/657ad4/",headers:[{level:2,title:"LeetCode-169-多数元素",slug:"leetcode-169-多数元素",normalizedTitle:"leetcode-169-多数元素",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:191},{level:3,title:"Java代码1",slug:"java代码1",normalizedTitle:"java代码1",charIndex:790},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:1325},{level:3,title:"Java代码3",slug:"java代码3",normalizedTitle:"java代码3",charIndex:1499}],headersStr:"LeetCode-169-多数元素 解题思路 Java代码1 Java代码2 Java代码3",content:"# LeetCode-169-多数元素\n\n给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。\n\n你可以假设数组是非空的，并且给定的数组总是存在多数元素。\n\n示例1：\n\n输入: [3,2,3]\n输出: 3\n\n\n1\n2\n\n1\n2\n\n\n示例2：\n\n输入: [2,2,1,1,1,2,2]\n输出: 2\n\n\n1\n2\n\n1\n2\n\n\n\n# 解题思路\n\n方法1、哈希表：\n\n利用一个哈希表计算频率，当元素的频率大于nums.length/2的时候就是要找的元素\n\n方法2、排序：\n\n由于多数元素在数组中出现的次数大于n/2，于是可以将数组排序，对应nums.length/2的位置就是这个多数元素\n\n方法3、摩尔计数法：\n\n原文链接：https://leetcode-cn.com/problems/majority-element/solution/3chong-fang-fa-by-gfu-2/\n\n候选人(cand_num)初始化为nums[0]，票数count初始化为1。 当遇到与cand_num相同的数，则票数count = count + 1，否则票数count = count - 1。 当票数count为0时，更换候选人，并将票数count重置为1。 遍历完数组后，cand_num即为最终答案。\n\n为何这行得通呢？ 投票法是遇到相同的则票数 + 1，遇到不同的则票数 - 1。 且“多数元素”的个数> ⌊ n/2 ⌋，其余元素的个数总和<= ⌊ n/2 ⌋。 因此“多数元素”的个数 - 其余元素的个数总和 的结果 肯定 >= 1。 这就相当于每个“多数元素”和其他元素 两两相互抵消，抵消到最后肯定还剩余至少1个“多数元素”。\n\n无论数组是1 2 1 2 1，亦或是1 2 2 1 1，总能得到正确的候选人。\n\n\n# Java代码1\n\nclass Solution {\n    public int majorityElement(int[] nums) {\n        Map<Integer,Integer> map = new HashMap<>();\n        int res = Integer.MIN_VALUE;\n        for(Integer num: nums){\n            map.put(num,map.getOrDefault(num,0)+1);\n        }\n        for(Map.Entry<Integer,Integer> entry : map.entrySet()){\n            if(entry.getValue()>nums.length/2){\n                return entry.getKey();\n            }\n        }\n        return 0;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# Java代码2\n\nclass Solution {\n    public int majorityElement(int[] nums) {\n        Arrays.sort(nums);\n        return nums[nums.length/2];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n\n# Java代码3\n\nclass Solution {\n    public int majorityElement(int[] nums) {\n        int cand_num = nums[0], count = 1;\n        for (int i = 1; i < nums.length; ++i) {\n            if (cand_num == nums[i])\n                ++count;\n            else if (--count == 0) {\n                cand_num = nums[i];\n                count = 1;\n            }\n        }\n        return cand_num;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n",normalizedContent:"# leetcode-169-多数元素\n\n给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。\n\n你可以假设数组是非空的，并且给定的数组总是存在多数元素。\n\n示例1：\n\n输入: [3,2,3]\n输出: 3\n\n\n1\n2\n\n1\n2\n\n\n示例2：\n\n输入: [2,2,1,1,1,2,2]\n输出: 2\n\n\n1\n2\n\n1\n2\n\n\n\n# 解题思路\n\n方法1、哈希表：\n\n利用一个哈希表计算频率，当元素的频率大于nums.length/2的时候就是要找的元素\n\n方法2、排序：\n\n由于多数元素在数组中出现的次数大于n/2，于是可以将数组排序，对应nums.length/2的位置就是这个多数元素\n\n方法3、摩尔计数法：\n\n原文链接：https://leetcode-cn.com/problems/majority-element/solution/3chong-fang-fa-by-gfu-2/\n\n候选人(cand_num)初始化为nums[0]，票数count初始化为1。 当遇到与cand_num相同的数，则票数count = count + 1，否则票数count = count - 1。 当票数count为0时，更换候选人，并将票数count重置为1。 遍历完数组后，cand_num即为最终答案。\n\n为何这行得通呢？ 投票法是遇到相同的则票数 + 1，遇到不同的则票数 - 1。 且“多数元素”的个数> ⌊ n/2 ⌋，其余元素的个数总和<= ⌊ n/2 ⌋。 因此“多数元素”的个数 - 其余元素的个数总和 的结果 肯定 >= 1。 这就相当于每个“多数元素”和其他元素 两两相互抵消，抵消到最后肯定还剩余至少1个“多数元素”。\n\n无论数组是1 2 1 2 1，亦或是1 2 2 1 1，总能得到正确的候选人。\n\n\n# java代码1\n\nclass solution {\n    public int majorityelement(int[] nums) {\n        map<integer,integer> map = new hashmap<>();\n        int res = integer.min_value;\n        for(integer num: nums){\n            map.put(num,map.getordefault(num,0)+1);\n        }\n        for(map.entry<integer,integer> entry : map.entryset()){\n            if(entry.getvalue()>nums.length/2){\n                return entry.getkey();\n            }\n        }\n        return 0;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# java代码2\n\nclass solution {\n    public int majorityelement(int[] nums) {\n        arrays.sort(nums);\n        return nums[nums.length/2];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n\n# java代码3\n\nclass solution {\n    public int majorityelement(int[] nums) {\n        int cand_num = nums[0], count = 1;\n        for (int i = 1; i < nums.length; ++i) {\n            if (cand_num == nums[i])\n                ++count;\n            else if (--count == 0) {\n                cand_num = nums[i];\n                count = 1;\n            }\n        }\n        return cand_num;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-234-回文链表",frontmatter:{title:"LeetCode-234-回文链表",date:"2020-07-13T14:28:47.000Z",description:"回文链表",tags:["链表","Java","Easy"],keywords:"链表,Java,Easy,LeetCode",permalink:"/pages/4923ab/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/109.LeetCode-234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8.html",relativePath:"06.算法/02.LeetCode/109.LeetCode-234-回文链表.md",key:"v-055ce36e",path:"/pages/4923ab/",headers:[{level:2,title:"LeetCode-234-回文链表",slug:"leetcode-234-回文链表",normalizedTitle:"leetcode-234-回文链表",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:160},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:522},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:1971}],headersStr:"LeetCode-234-回文链表 解题思路 Java代码 Java代码2",content:"# LeetCode-234-回文链表\n\n请判断一个链表是否为回文链表。\n\n示例1：\n\n输入: 1->2\n输出: false\n\n\n1\n2\n\n1\n2\n\n\n示例2：\n\n输入: 1->2->2->1\n输出: true\n\n\n1\n2\n\n1\n2\n\n\n进阶： 你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？\n\n\n# 解题思路\n\n方法1、快慢指针+反转链表：\n\n 1. 先通过快慢指针找到链表中点\n    \n    奇偶情况不同，奇数情况应该跳过中心节点，偶数情况中心节点为2个，需要翻转的的位置仍然是slow.next开始\n\n 2. 之后进行后半部分的链表反转\n\n 3. 反转完成之后分别从链表的头部开始遍历匹配，当两个链表都不为空的时候，不断移动两端指针比较指针的值是否相等\n\n方法2、栈：\n\n先遍历一遍链表，用栈对链表进行顺序存储。由于栈有先进后出的特点，所以只需要再一次遍历链表将栈顶的值和链表中的值进行比较，这样做等价于栈维护了一个逆序链表，所谓回文的意思就是逆序链表和正序链表相同，如果遍历的过程中出现值不相等，那么证明该链表不是回文链表，反之则是回文链表。当然这并不是最优解，因为消耗了O(n)的空间，也遍历了2次链表\n\n\n# Java代码\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public boolean isPalindrome(ListNode head) {\n        if(head==null||head.next==null) return true;\n        ListNode dummy = new ListNode(-1);\n        dummy.next = head;\n        ListNode fast = dummy;\n        ListNode slow = dummy;\n        while(fast!=null&&fast.next!=null){\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        ListNode head2 = reverseLink(slow.next);\n        slow.next = null;\n        while(head!=null&&head2!=null){\n            if(head.val!=head2.val){\n                return false;\n            }else{\n                head = head.next;\n                head2 = head2.next;\n            }\n        }\n        return true;\n    }\n\n    public ListNode reverseLink(ListNode head){\n        if(head==null||head.next==null) return head;\n        ListNode pre = null;\n        ListNode cur = head;\n        while(cur!=null){\n            ListNode temp = cur.next;\n            cur.next = pre;\n            pre = cur;\n            cur = temp;\n        }\n        return pre;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# Java代码2\n\nclass Solution {\n    public boolean isPalindrome(ListNode head) {\n        if(head==null||head.next==null){\n            return true;\n        }\n        Deque<Integer> stack = new LinkedList<>();\n        ListNode cur = head;\n        while(cur!=null){\n            stack.push(cur.val);\n            cur = cur.next;\n        }\n        while(head!=null){\n            if(head.val!=stack.peek()){\n                return false;\n            }\n            stack.pop();\n            head = head.next;\n        }\n        return true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n",normalizedContent:"# leetcode-234-回文链表\n\n请判断一个链表是否为回文链表。\n\n示例1：\n\n输入: 1->2\n输出: false\n\n\n1\n2\n\n1\n2\n\n\n示例2：\n\n输入: 1->2->2->1\n输出: true\n\n\n1\n2\n\n1\n2\n\n\n进阶： 你能否用 o(n) 时间复杂度和 o(1) 空间复杂度解决此题？\n\n\n# 解题思路\n\n方法1、快慢指针+反转链表：\n\n 1. 先通过快慢指针找到链表中点\n    \n    奇偶情况不同，奇数情况应该跳过中心节点，偶数情况中心节点为2个，需要翻转的的位置仍然是slow.next开始\n\n 2. 之后进行后半部分的链表反转\n\n 3. 反转完成之后分别从链表的头部开始遍历匹配，当两个链表都不为空的时候，不断移动两端指针比较指针的值是否相等\n\n方法2、栈：\n\n先遍历一遍链表，用栈对链表进行顺序存储。由于栈有先进后出的特点，所以只需要再一次遍历链表将栈顶的值和链表中的值进行比较，这样做等价于栈维护了一个逆序链表，所谓回文的意思就是逆序链表和正序链表相同，如果遍历的过程中出现值不相等，那么证明该链表不是回文链表，反之则是回文链表。当然这并不是最优解，因为消耗了o(n)的空间，也遍历了2次链表\n\n\n# java代码\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode(int x) { val = x; }\n * }\n */\nclass solution {\n    public boolean ispalindrome(listnode head) {\n        if(head==null||head.next==null) return true;\n        listnode dummy = new listnode(-1);\n        dummy.next = head;\n        listnode fast = dummy;\n        listnode slow = dummy;\n        while(fast!=null&&fast.next!=null){\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        listnode head2 = reverselink(slow.next);\n        slow.next = null;\n        while(head!=null&&head2!=null){\n            if(head.val!=head2.val){\n                return false;\n            }else{\n                head = head.next;\n                head2 = head2.next;\n            }\n        }\n        return true;\n    }\n\n    public listnode reverselink(listnode head){\n        if(head==null||head.next==null) return head;\n        listnode pre = null;\n        listnode cur = head;\n        while(cur!=null){\n            listnode temp = cur.next;\n            cur.next = pre;\n            pre = cur;\n            cur = temp;\n        }\n        return pre;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# java代码2\n\nclass solution {\n    public boolean ispalindrome(listnode head) {\n        if(head==null||head.next==null){\n            return true;\n        }\n        deque<integer> stack = new linkedlist<>();\n        listnode cur = head;\n        while(cur!=null){\n            stack.push(cur.val);\n            cur = cur.next;\n        }\n        while(head!=null){\n            if(head.val!=stack.peek()){\n                return false;\n            }\n            stack.pop();\n            head = head.next;\n        }\n        return true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-94-二叉树的中序遍历",frontmatter:{title:"LeetCode-94-二叉树的中序遍历",date:"2020-05-13T11:01:06.000Z",description:"二叉树的中序遍历",tags:["树","DFS","Java","Medium"],keywords:"树,DFS,Java,Medium",permalink:"/pages/4517f3/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/11.LeetCode-94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.html",relativePath:"06.算法/02.LeetCode/11.LeetCode-94-二叉树的中序遍历.md",key:"v-39c6fbcd",path:"/pages/4517f3/",headers:[{level:2,title:"LeetCode-94-二叉树的中序遍历",slug:"leetcode-94-二叉树的中序遍历",normalizedTitle:"leetcode-94-二叉树的中序遍历",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:235},{level:3,title:"Java代码(递归)",slug:"java代码-递归",normalizedTitle:"java代码(递归)",charIndex:429},{level:3,title:"Java代码(迭代)",slug:"java代码-迭代",normalizedTitle:"java代码(迭代)",charIndex:1053}],headersStr:"LeetCode-94-二叉树的中序遍历 解题思路 Java代码(递归) Java代码(迭代)",content:"# LeetCode-94-二叉树的中序遍历\n\n给定一个二叉树，返回它的中序 遍历。\n\n相关链接：\n\n 1. LeetCode-144-二叉树的前序遍历\n 2. LeetCode-94-二叉树的中序遍历\n 3. LeetCode-145-二叉树的后序遍历\n\n示例 1:\n\n输入: [1,null,2,3]\n   1\n    \\\n     2\n    /\n   3\n\n输出: [1,3,2]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 解题思路\n\n二叉树的遍历问题都有2种解法，一种是递归，一种是迭代\n\n递归：开启左子树递归，添加根节点，开启右子树递归\n\n迭代：中序遍历一般等同于DFS，用Stack来实现，后进先出。迭代是先把左子树全部添加进Stack中，然后弹出一个尾部，获得对应的val之后遍历右子树，在添加左子树的时候同时也添加了根节点，所以pop弹出时再添加val实际上会对左子树和左子树的根节点进行操作\n\n\n# Java代码(递归)\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    List<Integer> res = new ArrayList<>();\n    public List<Integer> inorderTraversal(TreeNode root) {\n        DFS(root);\n        return res;\n    }\n    public void DFS(TreeNode root){\n        if(root==null) return;\n        DFS(root.left);\n        res.add(root.val);\n        DFS(root.right);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# Java代码(迭代)\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n    \tList<Integer> res = new ArrayList<>();\n        Stack<TreeNode> stack = new Stack<>();\n        TreeNode node = root;\n        while(node!=null||!stack.isEmpty()){\n            while(node!=null){\n                stack.push(node);\n                node = node.left;\n            }\n            node = stack.pop();\n            res.add(node.val);\n            node = node.right;\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n",normalizedContent:"# leetcode-94-二叉树的中序遍历\n\n给定一个二叉树，返回它的中序 遍历。\n\n相关链接：\n\n 1. leetcode-144-二叉树的前序遍历\n 2. leetcode-94-二叉树的中序遍历\n 3. leetcode-145-二叉树的后序遍历\n\n示例 1:\n\n输入: [1,null,2,3]\n   1\n    \\\n     2\n    /\n   3\n\n输出: [1,3,2]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 解题思路\n\n二叉树的遍历问题都有2种解法，一种是递归，一种是迭代\n\n递归：开启左子树递归，添加根节点，开启右子树递归\n\n迭代：中序遍历一般等同于dfs，用stack来实现，后进先出。迭代是先把左子树全部添加进stack中，然后弹出一个尾部，获得对应的val之后遍历右子树，在添加左子树的时候同时也添加了根节点，所以pop弹出时再添加val实际上会对左子树和左子树的根节点进行操作\n\n\n# java代码(递归)\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    list<integer> res = new arraylist<>();\n    public list<integer> inordertraversal(treenode root) {\n        dfs(root);\n        return res;\n    }\n    public void dfs(treenode root){\n        if(root==null) return;\n        dfs(root.left);\n        res.add(root.val);\n        dfs(root.right);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# java代码(迭代)\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public list<integer> inordertraversal(treenode root) {\n    \tlist<integer> res = new arraylist<>();\n        stack<treenode> stack = new stack<>();\n        treenode node = root;\n        while(node!=null||!stack.isempty()){\n            while(node!=null){\n                stack.push(node);\n                node = node.left;\n            }\n            node = stack.pop();\n            res.add(node.val);\n            node = node.right;\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-238-除自身以外数组的乘积",frontmatter:{title:"LeetCode-238-除自身以外数组的乘积",date:"2021-08-25T09:59:56.000Z",description:"除自身以外数组的乘积",tags:["前缀和","Medium","Java","数组"],keywords:"Medium,Java,前缀和,数组",permalink:"/pages/c56f5d/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/110.LeetCode-238-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF.html",relativePath:"06.算法/02.LeetCode/110.LeetCode-238-除自身以外数组的乘积.md",key:"v-abf43b04",path:"/pages/c56f5d/",headers:[{level:2,title:"LeetCode-238-除自身以外数组的乘积",slug:"leetcode-238-除自身以外数组的乘积",normalizedTitle:"leetcode-238-除自身以外数组的乘积",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:381},{level:3,title:"Java代码1",slug:"java代码1",normalizedTitle:"java代码1",charIndex:978},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:1844}],headersStr:"LeetCode-238-除自身以外数组的乘积 解题思路 Java代码1 Java代码2",content:"# LeetCode-238-除自身以外数组的乘积\n\n题目来自于力扣https://leetcode-cn.com/problems/product-of-array-except-self\n\n给你一个长度为 n 的整数数组 nums，其中 n > 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。\n\n示例:\n\n输入: [1,2,3,4]\n输出: [24,12,8,6]\n\n\n1\n2\n\n1\n2\n\n\n提示：题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。\n\n说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。\n\n进阶： 你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。）\n\n\n# 解题思路\n\n我们先假设可以使用除法，那么解题的思路可以为，先计算出所有元素的连续乘积，然后利用最后一个位置的总乘积除以当前元素本身的值就可以得到结果，但是这种情况没有考虑除数为0的情况，且由于题目不允许使用除法，所以可以排除这种方法。\n\n*方法1、乘积结果=当前数左边的乘积(前缀)当前数右边的乘积(后缀)\n\n由于结果的值为除当前值之外的乘积，所以可以利用2个数组来记录当前值左侧的乘积和当前值右侧的乘积，两个乘积结果再进行一次对应位置相乘即为排除当前位置数的所有元素乘积。\n\n最基本的方法是使用2个数组进行左右乘积的存储，最后需要再次遍历一遍数组进行乘积合并，时间和空间复杂度均为O(N)。\n\n方法2、进阶优化：\n\n题目规定存储答案的数组不算空间，所以进阶方法尝试能不能用一个答案数组就可以完成上面三个数组的操作。我们可以发现，res数组其实在最后一轮才使用，所以我们很自然的想到res可以直接替换掉leftDot数组，用res数组乘以rightDot一样能够得到结果，节省了leftDot前缀数组的空间，但是这仍然使用到了O(N)的空间。\n\n进一步进行优化，我们可以使用一个指针right替换掉后缀数组，而采用动态计算的方式来得到后缀乘积。从右侧动态计算后缀的原理和计算前缀原理类似，而此时我们的res为前缀积，在一次循环中，我们可以使用前缀积和动态计算的后缀积相乘得到最终结果。\n\n\n# Java代码1\n\nclass Solution {\n    public int[] productExceptSelf(int[] nums) {\n        int length = nums.length;\n        int[] leftDot = new int[length];\n        int[] rightDot = new int[length];\n        int[] res = new int[length];\n      \t// 因为索引为'0'的元素左侧没有元素，所以leftDot为1\n        leftDot[0] = 1;\n        // 计算前缀乘积\n        for (int i = 1; i < length; i++) {\n            leftDot[i] = nums[i - 1] * leftDot[i - 1];\n        }\n        rightDot[length - 1] = 1;\n        // 计算后缀乘积\n        for (int i = length - 2; i >= 0; i--) {\n            rightDot[i] = nums[i + 1] * rightDot[i + 1];\n        }\n        // 计算乘积结果\n        for (int i = 0; i < length; i++) {\n            res[i] = leftDot[i] * rightDot[i];\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# Java代码2\n\nclass Solution {\n    public int[] productExceptSelf(int[] nums) {\n        int length = nums.length;\n        int[] res = new int[length];\n        res[0] = 1;\n        // 计算前缀乘积\n        for (int i = 1; i < length; i++) {\n            res[i] = nums[i - 1] * res[i - 1];\n        }\n        // 因为right右侧没有任何元素，所以right=1\n        int right = 1;\n        // 计算结果，后缀动态计算\n        for (int i = length - 1; i >= 0; i--) {\n            res[i] = res[i] * right;\n            right *= res[i];\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n",normalizedContent:"# leetcode-238-除自身以外数组的乘积\n\n题目来自于力扣https://leetcode-cn.com/problems/product-of-array-except-self\n\n给你一个长度为 n 的整数数组 nums，其中 n > 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。\n\n示例:\n\n输入: [1,2,3,4]\n输出: [24,12,8,6]\n\n\n1\n2\n\n1\n2\n\n\n提示：题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。\n\n说明: 请不要使用除法，且在 o(n) 时间复杂度内完成此题。\n\n进阶： 你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。）\n\n\n# 解题思路\n\n我们先假设可以使用除法，那么解题的思路可以为，先计算出所有元素的连续乘积，然后利用最后一个位置的总乘积除以当前元素本身的值就可以得到结果，但是这种情况没有考虑除数为0的情况，且由于题目不允许使用除法，所以可以排除这种方法。\n\n*方法1、乘积结果=当前数左边的乘积(前缀)当前数右边的乘积(后缀)\n\n由于结果的值为除当前值之外的乘积，所以可以利用2个数组来记录当前值左侧的乘积和当前值右侧的乘积，两个乘积结果再进行一次对应位置相乘即为排除当前位置数的所有元素乘积。\n\n最基本的方法是使用2个数组进行左右乘积的存储，最后需要再次遍历一遍数组进行乘积合并，时间和空间复杂度均为o(n)。\n\n方法2、进阶优化：\n\n题目规定存储答案的数组不算空间，所以进阶方法尝试能不能用一个答案数组就可以完成上面三个数组的操作。我们可以发现，res数组其实在最后一轮才使用，所以我们很自然的想到res可以直接替换掉leftdot数组，用res数组乘以rightdot一样能够得到结果，节省了leftdot前缀数组的空间，但是这仍然使用到了o(n)的空间。\n\n进一步进行优化，我们可以使用一个指针right替换掉后缀数组，而采用动态计算的方式来得到后缀乘积。从右侧动态计算后缀的原理和计算前缀原理类似，而此时我们的res为前缀积，在一次循环中，我们可以使用前缀积和动态计算的后缀积相乘得到最终结果。\n\n\n# java代码1\n\nclass solution {\n    public int[] productexceptself(int[] nums) {\n        int length = nums.length;\n        int[] leftdot = new int[length];\n        int[] rightdot = new int[length];\n        int[] res = new int[length];\n      \t// 因为索引为'0'的元素左侧没有元素，所以leftdot为1\n        leftdot[0] = 1;\n        // 计算前缀乘积\n        for (int i = 1; i < length; i++) {\n            leftdot[i] = nums[i - 1] * leftdot[i - 1];\n        }\n        rightdot[length - 1] = 1;\n        // 计算后缀乘积\n        for (int i = length - 2; i >= 0; i--) {\n            rightdot[i] = nums[i + 1] * rightdot[i + 1];\n        }\n        // 计算乘积结果\n        for (int i = 0; i < length; i++) {\n            res[i] = leftdot[i] * rightdot[i];\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# java代码2\n\nclass solution {\n    public int[] productexceptself(int[] nums) {\n        int length = nums.length;\n        int[] res = new int[length];\n        res[0] = 1;\n        // 计算前缀乘积\n        for (int i = 1; i < length; i++) {\n            res[i] = nums[i - 1] * res[i - 1];\n        }\n        // 因为right右侧没有任何元素，所以right=1\n        int right = 1;\n        // 计算结果，后缀动态计算\n        for (int i = length - 1; i >= 0; i--) {\n            res[i] = res[i] * right;\n            right *= res[i];\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-283-移动零",frontmatter:{title:"LeetCode-283-移动零",date:"2021-08-24T10:16:39.000Z",description:"移动零",tags:["双指针","Easy","Java"],keywords:"Easy,Java,双指针",permalink:"/pages/b249d6/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/111.LeetCode-283-%E7%A7%BB%E5%8A%A8%E9%9B%B6.html",relativePath:"06.算法/02.LeetCode/111.LeetCode-283-移动零.md",key:"v-5c933400",path:"/pages/b249d6/",headers:[{level:2,title:"LeetCode-283-移动零",slug:"leetcode-283-移动零",normalizedTitle:"leetcode-283-移动零",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:214},{level:3,title:"Java代码1",slug:"java代码1",normalizedTitle:"java代码1",charIndex:513},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:992}],headersStr:"LeetCode-283-移动零 解题思路 Java代码1 Java代码2",content:"# LeetCode-283-移动零\n\n题目来自于力扣https://leetcode-cn.com/problems/move-zeroes\n\n给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。\n\n示例:\n\n输入: [0,1,0,3,12]\n输出: [1,3,12,0,0]\n\n\n1\n2\n\n1\n2\n\n\n说明:\n\n必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。\n\n\n# 解题思路\n\n方法1、0填充法：\n\n用一个指针j来记录非零元素的个数，每出现一个非0元素则j指针++，最终j的位置就是最后一个非零元素的位置，到数组末尾的距离则全用0填充即可。在遍历的过程中要保持数组的相对有序，可以直接采用交换即可。\n\n方法2、一次遍历：\n\n一次遍历的过程中需要一个i指向当前遍历的元素位置，同时建立一个新的指针j，在i遍历的时候进行移动。j移动的规则为，当nums[i]!=0的时候交换nums[i]和nums[j]的值，同时j向右移，这样的方法保证了j指针始终指向了已处理好的数组的尾部。每次交换，均为左指针j指向的0和右指针i的非0进行交换，且保证了非0的相对顺序。\n\n\n# Java代码1\n\nclass Solution {\n    public void moveZeroes(int[] nums) {\n        if(nums==null){\n            return;\n        }\n        int j = 0;\n        for(int i = 0;i < nums.length; i++){\n            if(nums[i]!=0){\n                nums[j] = nums[i];\n                j++;\n            }\n        }\n\n        for(int i = j;i< nums.length; i++){\n            nums[i] = 0;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# Java代码2\n\nclass Solution {\n    public void moveZeroes(int[] nums) {\n        if(nums==null){\n            return;\n        }\n        int j = 0;\n        for(int i = 0;i < nums.length;i++){\n            if(nums[i]!=0){\n                int temp = nums[i];\n                nums[i] = nums[j];\n                nums[j] = temp;\n                j++;\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n",normalizedContent:"# leetcode-283-移动零\n\n题目来自于力扣https://leetcode-cn.com/problems/move-zeroes\n\n给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。\n\n示例:\n\n输入: [0,1,0,3,12]\n输出: [1,3,12,0,0]\n\n\n1\n2\n\n1\n2\n\n\n说明:\n\n必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。\n\n\n# 解题思路\n\n方法1、0填充法：\n\n用一个指针j来记录非零元素的个数，每出现一个非0元素则j指针++，最终j的位置就是最后一个非零元素的位置，到数组末尾的距离则全用0填充即可。在遍历的过程中要保持数组的相对有序，可以直接采用交换即可。\n\n方法2、一次遍历：\n\n一次遍历的过程中需要一个i指向当前遍历的元素位置，同时建立一个新的指针j，在i遍历的时候进行移动。j移动的规则为，当nums[i]!=0的时候交换nums[i]和nums[j]的值，同时j向右移，这样的方法保证了j指针始终指向了已处理好的数组的尾部。每次交换，均为左指针j指向的0和右指针i的非0进行交换，且保证了非0的相对顺序。\n\n\n# java代码1\n\nclass solution {\n    public void movezeroes(int[] nums) {\n        if(nums==null){\n            return;\n        }\n        int j = 0;\n        for(int i = 0;i < nums.length; i++){\n            if(nums[i]!=0){\n                nums[j] = nums[i];\n                j++;\n            }\n        }\n\n        for(int i = j;i< nums.length; i++){\n            nums[i] = 0;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# java代码2\n\nclass solution {\n    public void movezeroes(int[] nums) {\n        if(nums==null){\n            return;\n        }\n        int j = 0;\n        for(int i = 0;i < nums.length;i++){\n            if(nums[i]!=0){\n                int temp = nums[i];\n                nums[i] = nums[j];\n                nums[j] = temp;\n                j++;\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-338-比特位计数",frontmatter:{title:"LeetCode-338-比特位计数",date:"2021-08-31T18:49:29.000Z",description:"比特位计数",tags:["DP","Easy","Java","数组"],keywords:"Easy,Java,数组,DP",permalink:"/pages/4a24f6/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/112.LeetCode-338-%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0.html",relativePath:"06.算法/02.LeetCode/112.LeetCode-338-比特位计数.md",key:"v-31b70a5f",path:"/pages/4a24f6/",headers:[{level:2,title:"LeetCode-338-比特位计数",slug:"leetcode-338-比特位计数",normalizedTitle:"leetcode-338-比特位计数",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:397},{level:3,title:"Java代码1",slug:"java代码1",normalizedTitle:"java代码1",charIndex:687}],headersStr:"LeetCode-338-比特位计数 解题思路 Java代码1",content:"# LeetCode-338-比特位计数\n\n题目来自于力扣https://leetcode-cn.com/problems/counting-bits\n\n给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。\n\n示例 1:\n\n输入: 2\n输出: [0,1,1]\n\n\n1\n2\n\n1\n2\n\n\n示例 2:\n\n输入: 5\n输出: [0,1,1,2,1,2]\n\n\n1\n2\n\n1\n2\n\n\n进阶:\n\n * 给出时间复杂度为**O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)**内用一趟扫描做到吗？\n * 要求算法的空间复杂度为O(n)。\n * 你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount）来执行此操作。\n\n\n# 解题思路\n\n方法1、暴力破解：\n\n从0到n计算每个数的二进制，转换的同时计算1的个数。\n\n当i大于0时，持续对2求余表示计算当前位置的余数，由于是2进制，余数只可能是0或者1，所以res无论i%2是0(不影响结果)还是1都加上，表示当前位置1的个数。\n\n之后将i/2即进行二进制移位，重复此两个步骤计算每一位是否为1。\n\n方法2、动态规划：\n\n没想出来....，参考https://leetcode-cn.com/problems/counting-bits/solution/bei-bi-de-yi-xiang-ren-qiao-miao-de-dong-v6zr/\n\n\n# Java代码1\n\nclass Solution {\n    public int[] countBits(int n) {\n        int[] result = new int[n+1];\n        for(int i = 0; i <= n; i++){\n            result[i] = oneNumsByN(i);\n        }   \n        return result;\n    }\n\n    public int oneNumsByN(int i){\n        int res = 0;\n        while(i>0){\n            res += i%2;\n            i = i/2;\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n",normalizedContent:"# leetcode-338-比特位计数\n\n题目来自于力扣https://leetcode-cn.com/problems/counting-bits\n\n给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。\n\n示例 1:\n\n输入: 2\n输出: [0,1,1]\n\n\n1\n2\n\n1\n2\n\n\n示例 2:\n\n输入: 5\n输出: [0,1,1,2,1,2]\n\n\n1\n2\n\n1\n2\n\n\n进阶:\n\n * 给出时间复杂度为**o(n*sizeof(integer))的解答非常容易。但你可以在线性时间o(n)**内用一趟扫描做到吗？\n * 要求算法的空间复杂度为o(n)。\n * 你能进一步完善解法吗？要求在c++或任何其他语言中不使用任何内置函数（如 c++ 中的 __builtin_popcount）来执行此操作。\n\n\n# 解题思路\n\n方法1、暴力破解：\n\n从0到n计算每个数的二进制，转换的同时计算1的个数。\n\n当i大于0时，持续对2求余表示计算当前位置的余数，由于是2进制，余数只可能是0或者1，所以res无论i%2是0(不影响结果)还是1都加上，表示当前位置1的个数。\n\n之后将i/2即进行二进制移位，重复此两个步骤计算每一位是否为1。\n\n方法2、动态规划：\n\n没想出来....，参考https://leetcode-cn.com/problems/counting-bits/solution/bei-bi-de-yi-xiang-ren-qiao-miao-de-dong-v6zr/\n\n\n# java代码1\n\nclass solution {\n    public int[] countbits(int n) {\n        int[] result = new int[n+1];\n        for(int i = 0; i <= n; i++){\n            result[i] = onenumsbyn(i);\n        }   \n        return result;\n    }\n\n    public int onenumsbyn(int i){\n        int res = 0;\n        while(i>0){\n            res += i%2;\n            i = i/2;\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-797-所有可能的路径",frontmatter:{title:"LeetCode-797-所有可能的路径",date:"2021-08-25T14:56:24.000Z",description:"所有可能的路径",tags:["回溯","Medium","Java","数组","DFS","图"],keywords:"Medium,Java,回溯,数组,图,DFS",permalink:"/pages/0b83ab/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/113.LeetCode-797-%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9A%84%E8%B7%AF%E5%BE%84.html",relativePath:"06.算法/02.LeetCode/113.LeetCode-797-所有可能的路径.md",key:"v-4ae463bf",path:"/pages/0b83ab/",headers:[{level:2,title:"LeetCode-797-所有可能的路径",slug:"leetcode-797-所有可能的路径",normalizedTitle:"leetcode-797-所有可能的路径",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:808},{level:3,title:"Java代码1",slug:"java代码1",normalizedTitle:"java代码1",charIndex:1036}],headersStr:"LeetCode-797-所有可能的路径 解题思路 Java代码1",content:"# LeetCode-797-所有可能的路径\n\n题目来自于力扣https://leetcode-cn.com/problems/all-paths-from-source-to-target\n\n给你一个有 n 个节点的 有向无环图（DAG），请你找出所有从节点 0 到节点 n-1 的路径并输出（不要求按特定顺序）\n\n二维数组的第 i 个数组中的单元都表示有向图中 i 号节点所能到达的下一些节点，空就是没有下一个结点了。\n\n译者注：有向图是有方向的，即规定了 a→b 你就不能从 b→a 。\n\n示例1:\n\n输入：graph = [[1,2],[3],[3],[]]\n输出：[[0,1,3],[0,2,3]]\n解释：有两条路径 0 -> 1 -> 3 和 0 -> 2 -> 3\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2:\n\n输入：graph = [[4,3,1],[3,2,4],[3],[4],[]]\n输出：[[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]\n\n\n1\n2\n\n1\n2\n\n\n示例3:\n\n输入：graph = [[1],[]]\n输出：[[0,1]]\n\n\n1\n2\n\n1\n2\n\n\n示例4:\n\n输入：graph = [[1,2,3],[2],[3],[]]\n输出：[[0,1,2,3],[0,2,3],[0,3]]\n\n\n1\n2\n\n1\n2\n\n\n示例5:\n\n输入：graph = [[1,3],[2],[3],[]]\n输出：[[0,1,2,3],[0,3]]\n\n\n1\n2\n\n1\n2\n\n\n提示：\n\n * n == graph.length\n * 2 <= n <= 15\n * 0 <= graph[i][j] < n\n * graph[i][j] != i（即，不存在自环）\n * graph[i] 中的所有元素 互不相同\n * 保证输入为 有向无环图（DAG）\n\n\n# 解题思路\n\n方法1、DFS\n\n采用深度优先遍历的方式求解所有路径\n\n * **初始状态：**从0号节点出发\n * **递归规则：**固定某一个节点(add操作)，选择一个他的邻居节点(循环遍历二维数组)，并记录他(add操作)，在重复进行这三步\n * **回溯：**当这条路径走完了，或者遍历结束时，移除上一轮加入path中的节点(remove操作)\n * **终止条件：**当目前的深度达到了数组length-1时结束，因为最后一个节点始终是空\n\n\n# Java代码1\n\nclass Solution {\n    List<List<Integer>> res = new ArrayList<>();\n    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {\n        List<Integer> path = new ArrayList<>();\n        path.add(0);\n        dfs(path,graph,0,graph.length-1);\n        return res;\n    }\n\n    public void dfs(List<Integer> path,int[][] graph,int start, int depth){\n        if(start==depth){\n            res.add(new ArrayList<>(path));\n            return;\n        }\n        for(int row : graph[start]){\n            path.add(row);\n            dfs(path,graph,row,depth);\n            path.remove(path.size()-1);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n",normalizedContent:"# leetcode-797-所有可能的路径\n\n题目来自于力扣https://leetcode-cn.com/problems/all-paths-from-source-to-target\n\n给你一个有 n 个节点的 有向无环图（dag），请你找出所有从节点 0 到节点 n-1 的路径并输出（不要求按特定顺序）\n\n二维数组的第 i 个数组中的单元都表示有向图中 i 号节点所能到达的下一些节点，空就是没有下一个结点了。\n\n译者注：有向图是有方向的，即规定了 a→b 你就不能从 b→a 。\n\n示例1:\n\n输入：graph = [[1,2],[3],[3],[]]\n输出：[[0,1,3],[0,2,3]]\n解释：有两条路径 0 -> 1 -> 3 和 0 -> 2 -> 3\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2:\n\n输入：graph = [[4,3,1],[3,2,4],[3],[4],[]]\n输出：[[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]\n\n\n1\n2\n\n1\n2\n\n\n示例3:\n\n输入：graph = [[1],[]]\n输出：[[0,1]]\n\n\n1\n2\n\n1\n2\n\n\n示例4:\n\n输入：graph = [[1,2,3],[2],[3],[]]\n输出：[[0,1,2,3],[0,2,3],[0,3]]\n\n\n1\n2\n\n1\n2\n\n\n示例5:\n\n输入：graph = [[1,3],[2],[3],[]]\n输出：[[0,1,2,3],[0,3]]\n\n\n1\n2\n\n1\n2\n\n\n提示：\n\n * n == graph.length\n * 2 <= n <= 15\n * 0 <= graph[i][j] < n\n * graph[i][j] != i（即，不存在自环）\n * graph[i] 中的所有元素 互不相同\n * 保证输入为 有向无环图（dag）\n\n\n# 解题思路\n\n方法1、dfs\n\n采用深度优先遍历的方式求解所有路径\n\n * **初始状态：**从0号节点出发\n * **递归规则：**固定某一个节点(add操作)，选择一个他的邻居节点(循环遍历二维数组)，并记录他(add操作)，在重复进行这三步\n * **回溯：**当这条路径走完了，或者遍历结束时，移除上一轮加入path中的节点(remove操作)\n * **终止条件：**当目前的深度达到了数组length-1时结束，因为最后一个节点始终是空\n\n\n# java代码1\n\nclass solution {\n    list<list<integer>> res = new arraylist<>();\n    public list<list<integer>> allpathssourcetarget(int[][] graph) {\n        list<integer> path = new arraylist<>();\n        path.add(0);\n        dfs(path,graph,0,graph.length-1);\n        return res;\n    }\n\n    public void dfs(list<integer> path,int[][] graph,int start, int depth){\n        if(start==depth){\n            res.add(new arraylist<>(path));\n            return;\n        }\n        for(int row : graph[start]){\n            path.add(row);\n            dfs(path,graph,row,depth);\n            path.remove(path.size()-1);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-145-二叉树的后序遍历",frontmatter:{title:"LeetCode-145-二叉树的后序遍历",date:"2020-05-13T15:05:04.000Z",description:"二叉树的后序遍历",tags:["树","BFS","Java","Hard"],keywords:"树,DFS,Java,Hard",permalink:"/pages/bc617d/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/12.LeetCode-145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.html",relativePath:"06.算法/02.LeetCode/12.LeetCode-145-二叉树的后序遍历.md",key:"v-7a5d5098",path:"/pages/bc617d/",headers:[{level:2,title:"LeetCode-145-二叉树的后序遍历",slug:"leetcode-145-二叉树的后序遍历",normalizedTitle:"leetcode-145-二叉树的后序遍历",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:240},{level:3,title:"Java代码(递归)",slug:"java代码-递归",normalizedTitle:"java代码(递归)",charIndex:627},{level:3,title:"Java代码(迭代Stack)",slug:"java代码-迭代stack",normalizedTitle:"java代码(迭代stack)",charIndex:1306},{level:3,title:"Java代码(迭代模拟)",slug:"java代码-迭代模拟",normalizedTitle:"java代码(迭代模拟)",charIndex:2201}],headersStr:"LeetCode-145-二叉树的后序遍历 解题思路 Java代码(递归) Java代码(迭代Stack) Java代码(迭代模拟)",content:"# LeetCode-145-二叉树的后序遍历\n\n给定一个二叉树，返回它的 后序 遍历。\n\n相关链接：\n\n 1. LeetCode-144-二叉树的前序遍历\n 2. LeetCode-94-二叉树的中序遍历\n 3. LeetCode-145-二叉树的后序遍历\n\n示例 1:\n\n输入: [1,null,2,3]  \n   1\n    \\\n     2\n    /\n   3 \n\n输出: [3,2,1]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 解题思路\n\n二叉树的遍历问题都有2种解法，一种是递归，一种是迭代\n\n递归：开启左子树递归，开启右子树递归，添加根节点\n\n迭代：后序遍历的方式是左右根，前序遍历是根左右，如果用Stack来实现根左右，那么左边先加入就会后出，右边后加入会先出，于是看似是add(left)之后add(right)，实际上会先访问到right再访问left，从而实现前序遍历得到根右左，即后序遍历的倒序，之后将列表倒序就是后序遍历的结果\n\n迭代模拟：严格按照后序遍历的左右根访问，代码整体与中序遍历很相似，但需要注意其中两个点。\n\n思想来源于这里\n\n第一，stack.peek()只是取出栈顶元素，要和stack.pop()弹出栈顶元素区分开来；\n\n第二，变量last用于保存当前栈顶所弹出的元素，判断 curr.right == last 是为了避免重复访问同一个元素而陷入死循环当中\n\n\n# Java代码(递归)\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    List<Integer> res = new ArrayList<>();\n    public List<Integer> postorderTraversal(TreeNode root) {\n        if(root==null) return res;\n        helper(root);\n        return res;\n    }\n    public void helper(TreeNode root){\n        if(root==null) return;\n        helper(root.left);\n        helper(root.right);\n        res.add(root.val);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# Java代码(迭代Stack)\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<Integer> postorderTraversal(TreeNode root) {\n        LinkedList<Integer> res = new LinkedList<>();\n        Stack<TreeNode> stack = new Stack<>(); // Stack实现根右左\n        if(root==null) return res;\n        stack.add(root);\n        while(!stack.isEmpty()){\n            TreeNode temp = stack.pop();\n            res.addFirst(temp.val); // 添加到头部，实现倒序\n            if(temp.left!=null)\n                stack.add(temp.left);\n            if(temp.right!=null)\n                stack.add(temp.right);\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# Java代码(迭代模拟)\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<Integer> postorderTraversal(TreeNode root) {\n        List<Integer> res = new LinkedList<>();\n        Stack<TreeNode> stack = new Stack<>();\n        TreeNode curr = root;\n        TreeNode last = null;\n        while (curr != null || !stack.isEmpty()) {\n            while (curr != null) {\n                stack.push(curr);\n                curr = curr.left;\n            }\n            curr = stack.peek();\n            if (curr.right == null || curr.right == last) {\n                res.add(curr.val);\n                stack.pop();\n                last = curr;\n                curr = null;\n            } else {\n                curr = curr.right;\n            }\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n",normalizedContent:"# leetcode-145-二叉树的后序遍历\n\n给定一个二叉树，返回它的 后序 遍历。\n\n相关链接：\n\n 1. leetcode-144-二叉树的前序遍历\n 2. leetcode-94-二叉树的中序遍历\n 3. leetcode-145-二叉树的后序遍历\n\n示例 1:\n\n输入: [1,null,2,3]  \n   1\n    \\\n     2\n    /\n   3 \n\n输出: [3,2,1]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 解题思路\n\n二叉树的遍历问题都有2种解法，一种是递归，一种是迭代\n\n递归：开启左子树递归，开启右子树递归，添加根节点\n\n迭代：后序遍历的方式是左右根，前序遍历是根左右，如果用stack来实现根左右，那么左边先加入就会后出，右边后加入会先出，于是看似是add(left)之后add(right)，实际上会先访问到right再访问left，从而实现前序遍历得到根右左，即后序遍历的倒序，之后将列表倒序就是后序遍历的结果\n\n迭代模拟：严格按照后序遍历的左右根访问，代码整体与中序遍历很相似，但需要注意其中两个点。\n\n思想来源于这里\n\n第一，stack.peek()只是取出栈顶元素，要和stack.pop()弹出栈顶元素区分开来；\n\n第二，变量last用于保存当前栈顶所弹出的元素，判断 curr.right == last 是为了避免重复访问同一个元素而陷入死循环当中\n\n\n# java代码(递归)\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    list<integer> res = new arraylist<>();\n    public list<integer> postordertraversal(treenode root) {\n        if(root==null) return res;\n        helper(root);\n        return res;\n    }\n    public void helper(treenode root){\n        if(root==null) return;\n        helper(root.left);\n        helper(root.right);\n        res.add(root.val);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# java代码(迭代stack)\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public list<integer> postordertraversal(treenode root) {\n        linkedlist<integer> res = new linkedlist<>();\n        stack<treenode> stack = new stack<>(); // stack实现根右左\n        if(root==null) return res;\n        stack.add(root);\n        while(!stack.isempty()){\n            treenode temp = stack.pop();\n            res.addfirst(temp.val); // 添加到头部，实现倒序\n            if(temp.left!=null)\n                stack.add(temp.left);\n            if(temp.right!=null)\n                stack.add(temp.right);\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# java代码(迭代模拟)\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public list<integer> postordertraversal(treenode root) {\n        list<integer> res = new linkedlist<>();\n        stack<treenode> stack = new stack<>();\n        treenode curr = root;\n        treenode last = null;\n        while (curr != null || !stack.isempty()) {\n            while (curr != null) {\n                stack.push(curr);\n                curr = curr.left;\n            }\n            curr = stack.peek();\n            if (curr.right == null || curr.right == last) {\n                res.add(curr.val);\n                stack.pop();\n                last = curr;\n                curr = null;\n            } else {\n                curr = curr.right;\n            }\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-53-最大子序和",frontmatter:{title:"LeetCode-53-最大子序和",date:"2020-05-30T10:28:18.000Z",description:"最大子序和",tags:["DP","贪心算法","Java","Python","Easy","LeetCode"],keywords:"DP,贪心算法,Java,Python,Easy,LeetCode",permalink:"/pages/1ac9e8/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/13.LeetCode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.html",relativePath:"06.算法/02.LeetCode/13.LeetCode-53-最大子序和.md",key:"v-7062dffd",path:"/pages/1ac9e8/",headers:[{level:2,title:"LeetCode-53-最大子序和",slug:"leetcode-53-最大子序和",normalizedTitle:"leetcode-53-最大子序和",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:210},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:415},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:863},{level:3,title:"Java代码",slug:"java代码-2",normalizedTitle:"java代码",charIndex:415}],headersStr:"LeetCode-53-最大子序和 解题思路 Java代码 Python代码 Java代码",content:"# LeetCode-53-最大子序和\n\n给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n\n示例 1:\n\n输入: [-2,1,-3,4,-1,2,1,-5,4],\n输出: 6\n解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n进阶:\n\n如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。\n\n\n# 解题思路\n\n方法1、DP：\n\n当前元素存储前一个元素和当前元素之和与当前元素之间的最大值，每个位置均可以由此规则计算得出，最后返回数组的最大值即可\n\n方法2、贪心：\n\n如果当前元素之前的和小于0，就丢弃之前的数列，即dp[i] = num[i]，如果大于0就累加\n\n方法3、更清楚的版本：\n\n实际上是一样的，只是代码看得清楚点\n\n当前和小于0，就把nums[i]赋值，如果当前值>最大值\n\n交换最大值\n\n\n# Java代码\n\nclass Solution {\n    public int maxSubArray(int[] nums) {\n        if(nums==null||nums.length==0) return 0;\n        int[] dp = new int[nums.length];\n        dp[0] = nums[0];\n        int max = nums[0];\n        for(int i=1;i<nums.length;i++){\n            dp[i] = Math.max(nums[i],dp[i-1]+nums[i]);\n            max = Math.max(max,dp[i]);\n        }\n        return max;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# Python代码\n\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        if not nums or len(nums)==0: return 0\n        for i in range(1,len(nums)):\n            nums[i] = nums[i]+max(nums[i-1],0)\n        return max(nums)\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n\n# Java代码\n\nclass Solution {\n    public int maxSubArray(int[] nums) {\n        if(nums.length==0||nums==null)\n            return 0;\n        int maxSum = Integer.MIN_VALUE;\n        int curSum = 0;\n        for(int i = 0;i< nums.length;i++){\n            if(curSum<=0)\n                curSum = nums[i];\n            else\n                curSum+=nums[i];\n            if(curSum>maxSum){\n                maxSum = curSum;\n            }\n        }\n        return maxSum;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n",normalizedContent:"# leetcode-53-最大子序和\n\n给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n\n示例 1:\n\n输入: [-2,1,-3,4,-1,2,1,-5,4],\n输出: 6\n解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n进阶:\n\n如果你已经实现复杂度为 o(n) 的解法，尝试使用更为精妙的分治法求解。\n\n\n# 解题思路\n\n方法1、dp：\n\n当前元素存储前一个元素和当前元素之和与当前元素之间的最大值，每个位置均可以由此规则计算得出，最后返回数组的最大值即可\n\n方法2、贪心：\n\n如果当前元素之前的和小于0，就丢弃之前的数列，即dp[i] = num[i]，如果大于0就累加\n\n方法3、更清楚的版本：\n\n实际上是一样的，只是代码看得清楚点\n\n当前和小于0，就把nums[i]赋值，如果当前值>最大值\n\n交换最大值\n\n\n# java代码\n\nclass solution {\n    public int maxsubarray(int[] nums) {\n        if(nums==null||nums.length==0) return 0;\n        int[] dp = new int[nums.length];\n        dp[0] = nums[0];\n        int max = nums[0];\n        for(int i=1;i<nums.length;i++){\n            dp[i] = math.max(nums[i],dp[i-1]+nums[i]);\n            max = math.max(max,dp[i]);\n        }\n        return max;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# python代码\n\nclass solution:\n    def maxsubarray(self, nums: list[int]) -> int:\n        if not nums or len(nums)==0: return 0\n        for i in range(1,len(nums)):\n            nums[i] = nums[i]+max(nums[i-1],0)\n        return max(nums)\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n\n# java代码\n\nclass solution {\n    public int maxsubarray(int[] nums) {\n        if(nums.length==0||nums==null)\n            return 0;\n        int maxsum = integer.min_value;\n        int cursum = 0;\n        for(int i = 0;i< nums.length;i++){\n            if(cursum<=0)\n                cursum = nums[i];\n            else\n                cursum+=nums[i];\n            if(cursum>maxsum){\n                maxsum = cursum;\n            }\n        }\n        return maxsum;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-392-判断子序列",frontmatter:{title:"LeetCode-392-判断子序列",date:"2020-05-30T13:13:39.000Z",description:"判断子序列",tags:["DP","字符串","Java","Easy","LeetCode"],keywords:"DP,字符串,Java,Easy,LeetCode",permalink:"/pages/20a5df/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/14.LeetCode-392-%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97.html",relativePath:"06.算法/02.LeetCode/14.LeetCode-392-判断子序列.md",key:"v-5e007e9e",path:"/pages/20a5df/",headers:[{level:2,title:"LeetCode-392-判断子序列",slug:"leetcode-392-判断子序列",normalizedTitle:"leetcode-392-判断子序列",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:381},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:846},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:1535}],headersStr:"LeetCode-392-判断子序列 解题思路 Java代码 Java代码2",content:'# LeetCode-392-判断子序列\n\n给定字符串 s 和 t ，判断 s 是否为 t 的子序列。\n\n你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 <=100）。\n\n字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。\n\n示例 1:\n\ns = "abc", t = "ahbgdc"\n\n\n1\n\n1\n\n\n示例2：\n\ns = "axc", t = "ahbgdc"\n\n\n1\n\n1\n\n\n后续挑战 :\n\n如果有大量输入的 S，称作S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？\n\n\n# 解题思路\n\n方法1、顺序遍历：\n\n固定s的第一位找t中有没有这一位，有就移动s指针，并让len++，当len达到slen的时候说明匹配上了\n\n方法2、DP：\n\nDP不是很快，主要是为了练手该怎么做，出处来源于这里\n\n状态dp[i][j]为s从头开始到i的子字符串是否是t从头开始到j的子字符串的子序列\n\n状态转移公式：\n\n * 当char[i]==char[j]时，则字符i一定是j的子序列，如果0i-1子字符串是0j-1子字符串的子序列，则dp[i][j]=true，也就是说当前的字符匹配上了，前面的也匹配上了，才是子序列，所以dp[i][j]=dp[i-1][j-1]\n * 当char[i]!=char[j]时，即判断当前0i子字符串是否是0j-1的子字符串的子序列，即dp[i][j]=d[i][j-1]。如ab，eabc，虽然s的最后一个字符串和t中的最后一个字符不相等，但是ab是eab的子序列，所以ab也是eabc的子序列\n * 初始化：空字符串一定是t的子字符串的子序列，所以dp[0][j]=true\n\n\n# Java代码\n\nclass Solution {\n    public boolean isSubsequence(String s, String t) {\n        if (s.length() != 0 &&t.length() == 0) return false;\n        if (s.length()==0&&t.length()!=0) return true;\n        if (s.length()==0&&t.length()==0) return true;\n        int index = 0;\n        int slen = s.length();\n        int len = 0;\n        for (int i = 0; i < t.length(); i++) {\n            if (s.charAt(index) == (t.charAt(i))) {\n                index++;\n                len++;\n            }\n            if (len == slen)\n                return true;\n        }\n        return false;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# Java代码2\n\nclass Solution {\n    public boolean isSubsequence(String s, String t) {\n        int slen = s.length(),tlen = t.length();\n        if(slen>tlen) return false;\n        if(slen==0) return true;\n        boolean[][] dp = new boolean[slen+1][tlen+1];\n        for(int j = 0;j<tlen;j++){\n            dp[0][j] = true;\n        }\n        for(int i =1;i<=slen;i++){\n            for(int j =1;j<=tlen;j++){\n                if(s.charAt(i-1)==t.charAt(j-1)){\n                    dp[i][j] = dp[i-1][j-1];\n                }else{\n                    dp[i][j] = dp[i][j-1];\n                }\n            }\n        }\n        return dp[slen][tlen];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n',normalizedContent:'# leetcode-392-判断子序列\n\n给定字符串 s 和 t ，判断 s 是否为 t 的子序列。\n\n你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 <=100）。\n\n字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。\n\n示例 1:\n\ns = "abc", t = "ahbgdc"\n\n\n1\n\n1\n\n\n示例2：\n\ns = "axc", t = "ahbgdc"\n\n\n1\n\n1\n\n\n后续挑战 :\n\n如果有大量输入的 s，称作s1, s2, ... , sk 其中 k >= 10亿，你需要依次检查它们是否为 t 的子序列。在这种情况下，你会怎样改变代码？\n\n\n# 解题思路\n\n方法1、顺序遍历：\n\n固定s的第一位找t中有没有这一位，有就移动s指针，并让len++，当len达到slen的时候说明匹配上了\n\n方法2、dp：\n\ndp不是很快，主要是为了练手该怎么做，出处来源于这里\n\n状态dp[i][j]为s从头开始到i的子字符串是否是t从头开始到j的子字符串的子序列\n\n状态转移公式：\n\n * 当char[i]==char[j]时，则字符i一定是j的子序列，如果0i-1子字符串是0j-1子字符串的子序列，则dp[i][j]=true，也就是说当前的字符匹配上了，前面的也匹配上了，才是子序列，所以dp[i][j]=dp[i-1][j-1]\n * 当char[i]!=char[j]时，即判断当前0i子字符串是否是0j-1的子字符串的子序列，即dp[i][j]=d[i][j-1]。如ab，eabc，虽然s的最后一个字符串和t中的最后一个字符不相等，但是ab是eab的子序列，所以ab也是eabc的子序列\n * 初始化：空字符串一定是t的子字符串的子序列，所以dp[0][j]=true\n\n\n# java代码\n\nclass solution {\n    public boolean issubsequence(string s, string t) {\n        if (s.length() != 0 &&t.length() == 0) return false;\n        if (s.length()==0&&t.length()!=0) return true;\n        if (s.length()==0&&t.length()==0) return true;\n        int index = 0;\n        int slen = s.length();\n        int len = 0;\n        for (int i = 0; i < t.length(); i++) {\n            if (s.charat(index) == (t.charat(i))) {\n                index++;\n                len++;\n            }\n            if (len == slen)\n                return true;\n        }\n        return false;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# java代码2\n\nclass solution {\n    public boolean issubsequence(string s, string t) {\n        int slen = s.length(),tlen = t.length();\n        if(slen>tlen) return false;\n        if(slen==0) return true;\n        boolean[][] dp = new boolean[slen+1][tlen+1];\n        for(int j = 0;j<tlen;j++){\n            dp[0][j] = true;\n        }\n        for(int i =1;i<=slen;i++){\n            for(int j =1;j<=tlen;j++){\n                if(s.charat(i-1)==t.charat(j-1)){\n                    dp[i][j] = dp[i-1][j-1];\n                }else{\n                    dp[i][j] = dp[i][j-1];\n                }\n            }\n        }\n        return dp[slen][tlen];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-303-区域和检索-数组不可变",frontmatter:{title:"LeetCode-303-区域和检索-数组不可变",date:"2020-05-31T10:12:38.000Z",description:"区域和检索-数组不可变",tags:["DP","数组","Java","Easy","LeetCode"],keywords:"DP,数组,Java,Easy,LeetCode",permalink:"/pages/d42c3d/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/15.LeetCode-303-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E5%8F%98.html",relativePath:"06.算法/02.LeetCode/15.LeetCode-303-区域和检索-数组不可变.md",key:"v-766367b0",path:"/pages/d42c3d/",headers:[{level:2,title:"LeetCode-303-区域和检索-数组不可变",slug:"leetcode-303-区域和检索-数组不可变",normalizedTitle:"leetcode-303-区域和检索-数组不可变",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:278},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:672},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:1445}],headersStr:"LeetCode-303-区域和检索-数组不可变 解题思路 Java代码 Java代码2",content:"# LeetCode-303-区域和检索-数组不可变\n\n给定一个整数数组 nums，求出数组从索引 i 到 j (i ≤ j) 范围内元素的总和，包含 i, j 两点。\n\n示例 1:\n\n给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()\n\nsumRange(0, 2) -> 1\nsumRange(2, 5) -> -1\nsumRange(0, 5) -> -3\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n说明:\n\n 1. 你可以假设数组不可变。\n 2. 会多次调用 sumRange 方法。\n\n\n# 解题思路\n\n方法1、DP暴力破解：\n\n显然这个方法可以用一维DP解决\n\n状态：dp[in]代表从i开始到当前位置的元素和\n\n状态转移方程：\n\n * 当是第一个元素时，直接赋值\n * 当是元素i，且i！=0时，dp[i]由dp[i-1]个元素和决定\n\n需要一个dp数组指针in，线性遍历一次数组，dp数组的最后位置就是元素和\n\n这个方法勉强能通过，但是每次调用都要计算[i,j]范围的和，速度很慢\n\n方法2、缓存：\n\n提前计算出所有范围的累和，能不能计算出第i个元素的和\n\nsum[k]定义为nums[0...k-1]的累和，sum[0]=0\n\n对于上述示例数组sum数组为[0，-2，-2，1，-4，-2，-3]\n\nsumrange(i,j)=sum[j+1]-sum[i]，也就是把后面部分的和前去并集部分即可\n\n这种方法只需要计算一次和，之后仅需要从数组取值相减即可得到结果\n\n\n# Java代码\n\nclass NumArray {\n    private int[] nums;\n    public NumArray(int[] nums) {\n        this.nums = nums;\n    }\n    \n    public int sumRange(int i, int j) {\n        if(nums==null||nums.length==0) return 0;\n        int[] dp = new int[j-i+1];\n        int in = 0;\n        for(int k=i;k<=j;k++){\n            if(k==i)\n                dp[in] = this.nums[k];\n            else\n                dp[in]=dp[in-1]+this.nums[k];\n            in++;\n        }\n        return dp[in-1];\n    }\n}\n\n/**\n * Your NumArray object will be instantiated and called as such:\n * NumArray obj = new NumArray(nums);\n * int param_1 = obj.sumRange(i,j);\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# Java代码2\n\nclass NumArray {\n    private int[] sum;\n\n    public NumArray(int[] nums) {\n        sum = new int[nums.length + 1];\n        for (int i = 0; i < nums.length; i++) {\n            sum[i + 1] = sum[i] + nums[i];\n        }\n    }\n\n    public int sumRange(int i, int j) {\n        return sum[j + 1] - sum[i];\n    }\n}\n\n/**\n * Your NumArray object will be instantiated and called as such:\n * NumArray obj = new NumArray(nums);\n * int param_1 = obj.sumRange(i,j);\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n",normalizedContent:"# leetcode-303-区域和检索-数组不可变\n\n给定一个整数数组 nums，求出数组从索引 i 到 j (i ≤ j) 范围内元素的总和，包含 i, j 两点。\n\n示例 1:\n\n给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumrange()\n\nsumrange(0, 2) -> 1\nsumrange(2, 5) -> -1\nsumrange(0, 5) -> -3\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n说明:\n\n 1. 你可以假设数组不可变。\n 2. 会多次调用 sumrange 方法。\n\n\n# 解题思路\n\n方法1、dp暴力破解：\n\n显然这个方法可以用一维dp解决\n\n状态：dp[in]代表从i开始到当前位置的元素和\n\n状态转移方程：\n\n * 当是第一个元素时，直接赋值\n * 当是元素i，且i！=0时，dp[i]由dp[i-1]个元素和决定\n\n需要一个dp数组指针in，线性遍历一次数组，dp数组的最后位置就是元素和\n\n这个方法勉强能通过，但是每次调用都要计算[i,j]范围的和，速度很慢\n\n方法2、缓存：\n\n提前计算出所有范围的累和，能不能计算出第i个元素的和\n\nsum[k]定义为nums[0...k-1]的累和，sum[0]=0\n\n对于上述示例数组sum数组为[0，-2，-2，1，-4，-2，-3]\n\nsumrange(i,j)=sum[j+1]-sum[i]，也就是把后面部分的和前去并集部分即可\n\n这种方法只需要计算一次和，之后仅需要从数组取值相减即可得到结果\n\n\n# java代码\n\nclass numarray {\n    private int[] nums;\n    public numarray(int[] nums) {\n        this.nums = nums;\n    }\n    \n    public int sumrange(int i, int j) {\n        if(nums==null||nums.length==0) return 0;\n        int[] dp = new int[j-i+1];\n        int in = 0;\n        for(int k=i;k<=j;k++){\n            if(k==i)\n                dp[in] = this.nums[k];\n            else\n                dp[in]=dp[in-1]+this.nums[k];\n            in++;\n        }\n        return dp[in-1];\n    }\n}\n\n/**\n * your numarray object will be instantiated and called as such:\n * numarray obj = new numarray(nums);\n * int param_1 = obj.sumrange(i,j);\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# java代码2\n\nclass numarray {\n    private int[] sum;\n\n    public numarray(int[] nums) {\n        sum = new int[nums.length + 1];\n        for (int i = 0; i < nums.length; i++) {\n            sum[i + 1] = sum[i] + nums[i];\n        }\n    }\n\n    public int sumrange(int i, int j) {\n        return sum[j + 1] - sum[i];\n    }\n}\n\n/**\n * your numarray object will be instantiated and called as such:\n * numarray obj = new numarray(nums);\n * int param_1 = obj.sumrange(i,j);\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-2-两数相加",frontmatter:{title:"LeetCode-2-两数相加",date:"2020-06-16T10:02:43.000Z",description:"两数相加",tags:["链表","Java","Medium","LeetCode"],keywords:"链表,Java,Medium,LeetCode",permalink:"/pages/95fe08/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/16.LeetCode-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0.html",relativePath:"06.算法/02.LeetCode/16.LeetCode-2-两数相加.md",key:"v-3ac3c5bf",path:"/pages/95fe08/",headers:[{level:2,title:"LeetCode-2-两数相加",slug:"leetcode-2-两数相加",normalizedTitle:"leetcode-2-两数相加",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:248},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:953}],headersStr:"LeetCode-2-两数相加 解题思路 Java代码",content:"# LeetCode-2-两数相加\n\n给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。\n\n如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。\n\n您可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n\n示例 1:\n\n输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)\n输出：7 -> 0 -> 8\n原因：342 + 465 = 807\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n\n# 解题思路\n\n顺序推进+哑结点：\n\n对于本题的测试用例，不难知道有以下三种情况：\n\n 1. 两个链表长度一致\n 2. 两个链表长度一长一短\n 3. 两个链表在相加过程中产生进位，进位需要加在下一位\n\n特例判断，当l1为空，直接返回l2；当l2为空，直接返回l1\n\n新增l1，l2的指针t1，t2，方便链表的遍历；新增l3哑结点和对应指针t3，用于存储相加之后的链表\n\n相加流程：\n\n当两个链表其中一个不为空的时候，说明还没有加完；\n\n由于相加的过程中，链表会出现一长一短的情况，所以在其中一个链表遍历完成之后，他的next就为空了，没有val值\n\n我们可以将后续空的链表的值默认为0，这样在相加的时候就不会对后续没有遍历完的链表产生影响\n\n所以对于t1，t2两个链表而言，他们的当前节点值是多少，可以由如下判断：\n\nint x = (t1!=null)?t1.val:0;\nint y = (t2!=null)?t2.val:0;\n\n\n1\n2\n\n1\n2\n\n\n之后当前的和为sum = (x+y+carry);\n\n判断进位：进位是多少可以由sum/10得到\n\n存储节点：每个节点只能存储1位数字，多出的部分成为进位，所以sum=sum%10，利用哑结点的后一位建立一个新的节点t3.next = new ListNode(sum);\n\n顺序移动t1，t2，t3，其中当t1，t2为空的时候就不再需要移动了，只需要下次用0相加即可\n\n新增进位节点：如果最后遍历完毕仍然有进位，那么尾节点就是最后以进位为值的节点t3.next = new ListNode(carry)\n\n最后返回哑结点的next就是头节点\n\n\n# Java代码\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        if(l1==null) return l2;\n        if(l2==null) return l1;\n        int carry = 0;\n        int sum = 0;\n        ListNode t1 = l1;\n        ListNode t2 = l2;\n        ListNode l3 = new ListNode(0);\n        ListNode t3 = l3;\n        while(t1!=null||t2!=null){\n            int x = (t1!=null)?t1.val:0;\n            int y = (t2!=null)?t2.val:0;\n            sum = (x+y+carry);\n            carry = sum/10;\n            sum = sum%10;\n            t3.next = new ListNode(sum);\n            if(t1!=null) t1 = t1.next;\n            if(t2!=null) t2 = t2.next;\n            t3 = t3.next;\n        }\n        if(carry>0) t3.next = new ListNode(carry);\n        return l3.next;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n",normalizedContent:"# leetcode-2-两数相加\n\n给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。\n\n如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。\n\n您可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n\n示例 1:\n\n输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)\n输出：7 -> 0 -> 8\n原因：342 + 465 = 807\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n\n# 解题思路\n\n顺序推进+哑结点：\n\n对于本题的测试用例，不难知道有以下三种情况：\n\n 1. 两个链表长度一致\n 2. 两个链表长度一长一短\n 3. 两个链表在相加过程中产生进位，进位需要加在下一位\n\n特例判断，当l1为空，直接返回l2；当l2为空，直接返回l1\n\n新增l1，l2的指针t1，t2，方便链表的遍历；新增l3哑结点和对应指针t3，用于存储相加之后的链表\n\n相加流程：\n\n当两个链表其中一个不为空的时候，说明还没有加完；\n\n由于相加的过程中，链表会出现一长一短的情况，所以在其中一个链表遍历完成之后，他的next就为空了，没有val值\n\n我们可以将后续空的链表的值默认为0，这样在相加的时候就不会对后续没有遍历完的链表产生影响\n\n所以对于t1，t2两个链表而言，他们的当前节点值是多少，可以由如下判断：\n\nint x = (t1!=null)?t1.val:0;\nint y = (t2!=null)?t2.val:0;\n\n\n1\n2\n\n1\n2\n\n\n之后当前的和为sum = (x+y+carry);\n\n判断进位：进位是多少可以由sum/10得到\n\n存储节点：每个节点只能存储1位数字，多出的部分成为进位，所以sum=sum%10，利用哑结点的后一位建立一个新的节点t3.next = new listnode(sum);\n\n顺序移动t1，t2，t3，其中当t1，t2为空的时候就不再需要移动了，只需要下次用0相加即可\n\n新增进位节点：如果最后遍历完毕仍然有进位，那么尾节点就是最后以进位为值的节点t3.next = new listnode(carry)\n\n最后返回哑结点的next就是头节点\n\n\n# java代码\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode(int x) { val = x; }\n * }\n */\nclass solution {\n    public listnode addtwonumbers(listnode l1, listnode l2) {\n        if(l1==null) return l2;\n        if(l2==null) return l1;\n        int carry = 0;\n        int sum = 0;\n        listnode t1 = l1;\n        listnode t2 = l2;\n        listnode l3 = new listnode(0);\n        listnode t3 = l3;\n        while(t1!=null||t2!=null){\n            int x = (t1!=null)?t1.val:0;\n            int y = (t2!=null)?t2.val:0;\n            sum = (x+y+carry);\n            carry = sum/10;\n            sum = sum%10;\n            t3.next = new listnode(sum);\n            if(t1!=null) t1 = t1.next;\n            if(t2!=null) t2 = t2.next;\n            t3 = t3.next;\n        }\n        if(carry>0) t3.next = new listnode(carry);\n        return l3.next;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-3-无重复字符的最长字串",frontmatter:{title:"LeetCode-3-无重复字符的最长字串",date:"2020-06-16T14:56:12.000Z",description:"无重复字符的最长字串",tags:["字符串","Java","滑动窗口","Medium","LeetCode"],keywords:"字符串,Java,滑动窗口,Medium,LeetCode",permalink:"/pages/30e6dd/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/17.LeetCode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2.html",relativePath:"06.算法/02.LeetCode/17.LeetCode-3-无重复字符的最长字串.md",key:"v-6419c4d5",path:"/pages/30e6dd/",headers:[{level:2,title:"LeetCode-3-无重复字符的最长字串",slug:"leetcode-3-无重复字符的最长字串",normalizedTitle:"leetcode-3-无重复字符的最长字串",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:339},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:733},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:1323},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:1873}],headersStr:"LeetCode-3-无重复字符的最长字串 解题思路 Java代码 Python代码 Java代码2",content:'# LeetCode-3-无重复字符的最长字串\n\n给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。\n\n示例 1:\n\n输入: "abcabcbb"\n输出: 3 \n解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2：\n\n输入: "bbbbb"\n输出: 1\n解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例3：\n\n输入: "pwwkew"\n输出: 3\n解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n\n# 解题思路\n\n方法1、哈希表：\n\n首先挨个比较i个字符和i+1结合哈希的方法是失败的，这样求的不适用于dvdf这样的测试用例\n\n我们可以通过记录无重复字符的初始位置start，以及结尾位置end，算出最长的字串是多大\n\n顺序遍历整个字符数组，判断当前的元素是否在hash表内，如果在则将当前元素作为key值，获取不重复元素对应位置，并更新start，此时，start到end不存在重复字符\n\n进入下一步，计算区间内字符长度\n\n如果当前元素不在hash表内，则添加当前字符位置+1，+1表示从当前字符位置后面一个开始不重复\n\n方法2、滑动窗口：\n\n窗口的最大值就是最长字串，比如dvdf这样的用例\n\n当窗口为dv的时候，满足题目要求，当窗口为dvd时，不满足要求，此时需要向右边滑动\n\n将左边重复的元素d移除，同时在右边新增，直到满足要求为止\n\n当窗口变化的时候记录当前窗口的最大值\n\n\n# Java代码\n\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        char[] c = s.toCharArray();\n        int max = 0;\n        int start = 0;\n        for (int end = 0; end < c.length; end++) {\n            if (map.containsKey(c[end])) {\n                start = Math.max(map.get(c[end]), start);\n            }\n            max = Math.max(max, end - start + 1);\n            map.put(c[end], end + 1);\n        }\n        return max;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# Python代码\n\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        if not s: return 0\n        left = 0\n        Max,curMax = 0,0\n        n = len(s)\n        hashset = set()\n        for i in range(n):\n            curMax += 1\n            while s[i] in hashset:\n                hashset.remove(s[left])\n                left += 1\n                curMax -= 1\n            if curMax > Max: Max = curMax\n            hashset.add(s[i])\n        return Max\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# Java代码2\n\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        if(s==null){\n            return 0;\n        }\n        int len = s.length();\n        HashSet<Character> set = new HashSet<>();\n        int left = 0;\n        int right = 0;\n        int res = 0;\n        while(right<len){\n            char now = s.charAt(right);\n            right++;\n            while(set.contains(now)){\n                set.remove(s.charAt(left));\n                left++;\n            }\n            res = Math.max(res,right-left);\n            set.add(now);\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n',normalizedContent:'# leetcode-3-无重复字符的最长字串\n\n给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。\n\n示例 1:\n\n输入: "abcabcbb"\n输出: 3 \n解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2：\n\n输入: "bbbbb"\n输出: 1\n解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例3：\n\n输入: "pwwkew"\n输出: 3\n解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n\n# 解题思路\n\n方法1、哈希表：\n\n首先挨个比较i个字符和i+1结合哈希的方法是失败的，这样求的不适用于dvdf这样的测试用例\n\n我们可以通过记录无重复字符的初始位置start，以及结尾位置end，算出最长的字串是多大\n\n顺序遍历整个字符数组，判断当前的元素是否在hash表内，如果在则将当前元素作为key值，获取不重复元素对应位置，并更新start，此时，start到end不存在重复字符\n\n进入下一步，计算区间内字符长度\n\n如果当前元素不在hash表内，则添加当前字符位置+1，+1表示从当前字符位置后面一个开始不重复\n\n方法2、滑动窗口：\n\n窗口的最大值就是最长字串，比如dvdf这样的用例\n\n当窗口为dv的时候，满足题目要求，当窗口为dvd时，不满足要求，此时需要向右边滑动\n\n将左边重复的元素d移除，同时在右边新增，直到满足要求为止\n\n当窗口变化的时候记录当前窗口的最大值\n\n\n# java代码\n\nclass solution {\n    public int lengthoflongestsubstring(string s) {\n        map<character, integer> map = new hashmap<>();\n        char[] c = s.tochararray();\n        int max = 0;\n        int start = 0;\n        for (int end = 0; end < c.length; end++) {\n            if (map.containskey(c[end])) {\n                start = math.max(map.get(c[end]), start);\n            }\n            max = math.max(max, end - start + 1);\n            map.put(c[end], end + 1);\n        }\n        return max;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# python代码\n\nclass solution:\n    def lengthoflongestsubstring(self, s: str) -> int:\n        if not s: return 0\n        left = 0\n        max,curmax = 0,0\n        n = len(s)\n        hashset = set()\n        for i in range(n):\n            curmax += 1\n            while s[i] in hashset:\n                hashset.remove(s[left])\n                left += 1\n                curmax -= 1\n            if curmax > max: max = curmax\n            hashset.add(s[i])\n        return max\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# java代码2\n\nclass solution {\n    public int lengthoflongestsubstring(string s) {\n        if(s==null){\n            return 0;\n        }\n        int len = s.length();\n        hashset<character> set = new hashset<>();\n        int left = 0;\n        int right = 0;\n        int res = 0;\n        while(right<len){\n            char now = s.charat(right);\n            right++;\n            while(set.contains(now)){\n                set.remove(s.charat(left));\n                left++;\n            }\n            res = math.max(res,right-left);\n            set.add(now);\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-4-寻找两个正序数组的中位数",frontmatter:{title:"LeetCode-4-寻找两个正序数组的中位数",date:"2020-06-19T13:52:54.000Z",description:"寻找两个正序数组的中位数",tags:["数组","Java","Hard","LeetCode"],keywords:"数组,Java,Hard,LeetCode",permalink:"/pages/e945ea/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/18.LeetCode-4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0.html",relativePath:"06.算法/02.LeetCode/18.LeetCode-4-寻找两个正序数组的中位数.md",key:"v-74022466",path:"/pages/e945ea/",headers:[{level:2,title:"LeetCode-4-寻找两个正序数组的中位数",slug:"leetcode-4-寻找两个正序数组的中位数",normalizedTitle:"leetcode-4-寻找两个正序数组的中位数",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:293},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:450},{level:3,title:"Java代码",slug:"java代码-2",normalizedTitle:"java代码",charIndex:450}],headersStr:"LeetCode-4-寻找两个正序数组的中位数 解题思路 Java代码 Java代码",content:"# LeetCode-4-寻找两个正序数组的中位数\n\n给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。\n\n请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。\n\n你可以假设 nums1 和 nums2 不会同时为空。\n\n示例 1:\n\nnums1 = [1, 3]\nnums2 = [2]\n\n则中位数是 2.0\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n示例2：\n\nnums1 = [1, 2]\nnums2 = [3, 4]\n\n则中位数是 (2 + 3)/2 = 2.5\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n\n# 解题思路\n\n方法1、归并排序思想：\n\n这种方法的复杂度不符合题意，属于备用解法\n\n对于两个有序的数组，想要找到对应的中位数，最简单的方法就是将两个数组合并为1个，之后找中位数就很简单\n\n只需要知道中间位置即可，奇数情况是一个数，偶数情况是两个数\n\n方法2、二分查找思想：\n\n不会做....答案出自官方题解\n\n\n# Java代码\n\nclass Solution {\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        int[] merge = new int[nums1.length + nums2.length];\n        int i = 0;\n        int j = 0;\n        int m = 0;\n        while (i < nums1.length && j < nums2.length) {\n            if (nums1[i] <= nums2[j]) {\n                merge[m++] = nums1[i++];\n            } else {\n                merge[m++] = nums2[j++];\n            }\n        }\n\n        while (i < nums1.length) {\n            merge[m++] = nums1[i++];\n        }\n        while (j < nums2.length) {\n            merge[m++] = nums2[j++];\n        }\n        return (m % 2 == 0) ? ((double) merge[m / 2] + (double) merge[m / 2 - 1]) / 2 : (double) merge[m / 2];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# Java代码\n\nclass Solution {\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        int leftLength = nums1.length;\n        int rightLength = nums2.length;\n        // 为了保证第一个数组比第二个数组小(或者相等)\n        if (leftLength > rightLength) {\n            return findMedianSortedArrays(nums2, nums1);\n        }\n        // 分割线左边的所有元素需要满足的个数 m + (n - m + 1) / 2;\n        // 两个数组长度之和为偶数时，当在长度之和上+1时，由于整除是向下取整，所以不会改变结果\n        // 两个数组长度之和为奇数时，按照分割线的左边比右边多一个元素的要求，此时在长度之和上+1，就会被2整除，会在原来的数\n        //的基础上+1，于是多出来的那个1就是左边比右边多出来的一个元素\n        int totalLeft = (leftLength + rightLength + 1) / 2;\n        // 在 nums1 的区间 [0, leftLength] 里查找恰当的分割线，\n        // 使得 nums1[i - 1] <= nums2[j] && nums2[j - 1] <= nums1[i]\n        int left = 0;\n        int right = leftLength;\n        // nums1[i - 1] <= nums2[j]\n        //  此处要求第一个数组中分割线的左边的值 不大于(小于等于) 第二个数组中分割线的右边的值\n        // nums2[j - 1] <= nums1[i]\n        //  此处要求第二个数组中分割线的左边的值 不大于(小于等于) 第一个数组中分割线的右边的值\n        // 循环条件结束的条件为指针重合，即分割线已找到\n        while (left < right) {\n            // 二分查找，此处为取第一个数组中左右指针下标的中位数，决定起始位置\n            // 此处+1首先是为了不出现死循环，即left永远小于right的情况\n            // left和right最小差距是1，此时下面的计算结果如果不加1会出现i一直=left的情况，而+1之后i才会=right\n            // 于是在left=i的时候可以破坏循环条件，其次下标+1还会保证下标不会越界，因为+1之后向上取整，保证了\n            // i不会取到0值，即i-1不会小于0\n            // 此时i也代表着在一个数组中左边的元素的个数\n            int i = left + (right - left + 1) / 2;\n            // 第一个数组中左边的元素个数确定后，用左边元素的总和-第一个数组中元素的总和=第二个元素中左边的元素的总和\n            // 此时j就是第二个元素中左边的元素的个数\n            int j = totalLeft - i;\n            // 此处用了nums1[i - 1] <= nums2[j]的取反，当第一个数组中分割线的左边的值大于第二个数组中分割线的右边的值\n            // 说明又指针应该左移，即-1\n            if (nums1[i - 1] > nums2[j]) {\n                // 下一轮搜索的区间 [left, i - 1]\n                right = i - 1;\n                // 此时说明条件满足，应当将左指针右移到i的位置，至于为什么是右移，请看i的定义\n            } else {\n                // 下一轮搜索的区间 [i, right]\n                left = i;\n            }\n        }\n        // 退出循环时left一定等于right，所以此时等于left和right都可以\n        // 为什么left一定不会大于right?因为left=i。\n        // 此时i代表分割线在第一个数组中所在的位置\n        // nums1[i]为第一个数组中分割线右边的第一个值\n        // nums[i-1]即第一个数组中分割线左边的第一个值\n        int i = left;\n        // 此时j代表分割线在第二个数组中的位置\n        // nums2[j]为第一个数组中分割线右边的第一个值\n        // nums2[j-1]即第一个数组中分割线左边的第一个值\n        int j = totalLeft - i;\n        // 当i=0时，说明第一个数组分割线左边没有值，为了不影响\n        // nums1[i - 1] <= nums2[j] 和 Math.max(nums1LeftMax, nums2LeftMax)\n        // 的判断，所以将它设置为int的最小值\n        int nums1LeftMax = i == 0 ? Integer.MIN_VALUE : nums1[i - 1];\n        // 等i=第一个数组的长度时，说明第一个数组分割线右边没有值，为了不影响\n        // nums2[j - 1] <= nums1[i] 和 Math.min(nums1RightMin, nums2RightMin)\n        // 的判断，所以将它设置为int的最大值\n        int nums1RightMin = i == leftLength ? Integer.MAX_VALUE : nums1[i];\n        // 当j=0时，说明第二个数组分割线左边没有值，为了不影响\n        // nums2[j - 1] <= nums1[i] 和 Math.max(nums1LeftMax, nums2LeftMax)\n        // 的判断，所以将它设置为int的最小值\n        int nums2LeftMax = j == 0 ? Integer.MIN_VALUE : nums2[j - 1];\n        // 等j=第二个数组的长度时，说明第二个数组分割线右边没有值，为了不影响\n        // nums1[i - 1] <= nums2[j] 和 Math.min(nums1RightMin, nums2RightMin)\n        // 的判断，所以将它设置为int的最大值\n        int nums2RightMin = j == rightLength ? Integer.MAX_VALUE : nums2[j];\n        // 如果两个数组的长度之和为奇数，直接返回两个数组在分割线左边的最大值即可\n        if (((leftLength + rightLength) % 2) == 1) {\n            return Math.max(nums1LeftMax, nums2LeftMax);\n        } else {\n            // 如果两个数组的长度之和为偶数，返回的是两个数组在左边的最大值和两个数组在右边的最小值的和的二分之一\n            // 此处不能被向下取整，所以要强制转换为double类型\n            return (double) ((Math.max(nums1LeftMax, nums2LeftMax) + Math.min(nums1RightMin, nums2RightMin))) / 2;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n",normalizedContent:"# leetcode-4-寻找两个正序数组的中位数\n\n给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。\n\n请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 o(log(m + n))。\n\n你可以假设 nums1 和 nums2 不会同时为空。\n\n示例 1:\n\nnums1 = [1, 3]\nnums2 = [2]\n\n则中位数是 2.0\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n示例2：\n\nnums1 = [1, 2]\nnums2 = [3, 4]\n\n则中位数是 (2 + 3)/2 = 2.5\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n\n# 解题思路\n\n方法1、归并排序思想：\n\n这种方法的复杂度不符合题意，属于备用解法\n\n对于两个有序的数组，想要找到对应的中位数，最简单的方法就是将两个数组合并为1个，之后找中位数就很简单\n\n只需要知道中间位置即可，奇数情况是一个数，偶数情况是两个数\n\n方法2、二分查找思想：\n\n不会做....答案出自官方题解\n\n\n# java代码\n\nclass solution {\n    public double findmediansortedarrays(int[] nums1, int[] nums2) {\n        int[] merge = new int[nums1.length + nums2.length];\n        int i = 0;\n        int j = 0;\n        int m = 0;\n        while (i < nums1.length && j < nums2.length) {\n            if (nums1[i] <= nums2[j]) {\n                merge[m++] = nums1[i++];\n            } else {\n                merge[m++] = nums2[j++];\n            }\n        }\n\n        while (i < nums1.length) {\n            merge[m++] = nums1[i++];\n        }\n        while (j < nums2.length) {\n            merge[m++] = nums2[j++];\n        }\n        return (m % 2 == 0) ? ((double) merge[m / 2] + (double) merge[m / 2 - 1]) / 2 : (double) merge[m / 2];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# java代码\n\nclass solution {\n    public double findmediansortedarrays(int[] nums1, int[] nums2) {\n        int leftlength = nums1.length;\n        int rightlength = nums2.length;\n        // 为了保证第一个数组比第二个数组小(或者相等)\n        if (leftlength > rightlength) {\n            return findmediansortedarrays(nums2, nums1);\n        }\n        // 分割线左边的所有元素需要满足的个数 m + (n - m + 1) / 2;\n        // 两个数组长度之和为偶数时，当在长度之和上+1时，由于整除是向下取整，所以不会改变结果\n        // 两个数组长度之和为奇数时，按照分割线的左边比右边多一个元素的要求，此时在长度之和上+1，就会被2整除，会在原来的数\n        //的基础上+1，于是多出来的那个1就是左边比右边多出来的一个元素\n        int totalleft = (leftlength + rightlength + 1) / 2;\n        // 在 nums1 的区间 [0, leftlength] 里查找恰当的分割线，\n        // 使得 nums1[i - 1] <= nums2[j] && nums2[j - 1] <= nums1[i]\n        int left = 0;\n        int right = leftlength;\n        // nums1[i - 1] <= nums2[j]\n        //  此处要求第一个数组中分割线的左边的值 不大于(小于等于) 第二个数组中分割线的右边的值\n        // nums2[j - 1] <= nums1[i]\n        //  此处要求第二个数组中分割线的左边的值 不大于(小于等于) 第一个数组中分割线的右边的值\n        // 循环条件结束的条件为指针重合，即分割线已找到\n        while (left < right) {\n            // 二分查找，此处为取第一个数组中左右指针下标的中位数，决定起始位置\n            // 此处+1首先是为了不出现死循环，即left永远小于right的情况\n            // left和right最小差距是1，此时下面的计算结果如果不加1会出现i一直=left的情况，而+1之后i才会=right\n            // 于是在left=i的时候可以破坏循环条件，其次下标+1还会保证下标不会越界，因为+1之后向上取整，保证了\n            // i不会取到0值，即i-1不会小于0\n            // 此时i也代表着在一个数组中左边的元素的个数\n            int i = left + (right - left + 1) / 2;\n            // 第一个数组中左边的元素个数确定后，用左边元素的总和-第一个数组中元素的总和=第二个元素中左边的元素的总和\n            // 此时j就是第二个元素中左边的元素的个数\n            int j = totalleft - i;\n            // 此处用了nums1[i - 1] <= nums2[j]的取反，当第一个数组中分割线的左边的值大于第二个数组中分割线的右边的值\n            // 说明又指针应该左移，即-1\n            if (nums1[i - 1] > nums2[j]) {\n                // 下一轮搜索的区间 [left, i - 1]\n                right = i - 1;\n                // 此时说明条件满足，应当将左指针右移到i的位置，至于为什么是右移，请看i的定义\n            } else {\n                // 下一轮搜索的区间 [i, right]\n                left = i;\n            }\n        }\n        // 退出循环时left一定等于right，所以此时等于left和right都可以\n        // 为什么left一定不会大于right?因为left=i。\n        // 此时i代表分割线在第一个数组中所在的位置\n        // nums1[i]为第一个数组中分割线右边的第一个值\n        // nums[i-1]即第一个数组中分割线左边的第一个值\n        int i = left;\n        // 此时j代表分割线在第二个数组中的位置\n        // nums2[j]为第一个数组中分割线右边的第一个值\n        // nums2[j-1]即第一个数组中分割线左边的第一个值\n        int j = totalleft - i;\n        // 当i=0时，说明第一个数组分割线左边没有值，为了不影响\n        // nums1[i - 1] <= nums2[j] 和 math.max(nums1leftmax, nums2leftmax)\n        // 的判断，所以将它设置为int的最小值\n        int nums1leftmax = i == 0 ? integer.min_value : nums1[i - 1];\n        // 等i=第一个数组的长度时，说明第一个数组分割线右边没有值，为了不影响\n        // nums2[j - 1] <= nums1[i] 和 math.min(nums1rightmin, nums2rightmin)\n        // 的判断，所以将它设置为int的最大值\n        int nums1rightmin = i == leftlength ? integer.max_value : nums1[i];\n        // 当j=0时，说明第二个数组分割线左边没有值，为了不影响\n        // nums2[j - 1] <= nums1[i] 和 math.max(nums1leftmax, nums2leftmax)\n        // 的判断，所以将它设置为int的最小值\n        int nums2leftmax = j == 0 ? integer.min_value : nums2[j - 1];\n        // 等j=第二个数组的长度时，说明第二个数组分割线右边没有值，为了不影响\n        // nums1[i - 1] <= nums2[j] 和 math.min(nums1rightmin, nums2rightmin)\n        // 的判断，所以将它设置为int的最大值\n        int nums2rightmin = j == rightlength ? integer.max_value : nums2[j];\n        // 如果两个数组的长度之和为奇数，直接返回两个数组在分割线左边的最大值即可\n        if (((leftlength + rightlength) % 2) == 1) {\n            return math.max(nums1leftmax, nums2leftmax);\n        } else {\n            // 如果两个数组的长度之和为偶数，返回的是两个数组在左边的最大值和两个数组在右边的最小值的和的二分之一\n            // 此处不能被向下取整，所以要强制转换为double类型\n            return (double) ((math.max(nums1leftmax, nums2leftmax) + math.min(nums1rightmin, nums2rightmin))) / 2;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-5-最长回文字串",frontmatter:{title:"LeetCode-5-最长回文字串",date:"2020-06-18T14:31:14.000Z",description:"最长回文字串",tags:["字符串","DP","Java","Medium","LeetCode"],keywords:"DP,字符串,Java,Medium,LeetCode",permalink:"/pages/c3c526/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/19.LeetCode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%97%E4%B8%B2.html",relativePath:"06.算法/02.LeetCode/19.LeetCode-5-最长回文字串.md",key:"v-281e7683",path:"/pages/c3c526/",headers:[{level:2,title:"LeetCode-5-最长回文字串",slug:"leetcode-5-最长回文字串",normalizedTitle:"leetcode-5-最长回文字串",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:175},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:862},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:1825},{level:3,title:"Java代码3",slug:"java代码3",normalizedTitle:"java代码3",charIndex:3420}],headersStr:"LeetCode-5-最长回文字串 解题思路 Java代码 Java代码2 Java代码3",content:'# LeetCode-5-最长回文字串\n\n给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。\n\n示例 1:\n\n输入: "babad"\n输出: "bab"\n注意: "aba" 也是一个有效答案。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2：\n\n输入: "cbbd"\n输出: "bb"\n\n\n1\n2\n\n1\n2\n\n\n\n# 解题思路\n\n方法1、暴力破解：\n\n暴力破解法，判断每个串开头的所有子串中，大于最长子串的串是否是回文子串\n\n判断回文字串的方法为，首尾往内遍历，如果首尾不相等则不是回文字串，移动左指针+1，右指针-1；\n\n否则就是回文子串\n\n方法2、动态规划：\n\n参考地址1\n\n参考地址2\n\n方法3、中心扩散法：\n\n枚举所有的回文中心位置，回文中心位置需要按照字符串长度分为奇数和偶数的情况\n\n奇数情况时，回文中心仅有1个字符\n\n偶数情况时，回文中心有2个字符\n\n从回文中心出发进行扩散，尽可能的使得子串长度达到最大，不满足时跳出，返回扩散之后回文子串的长度j-i+1-2\n\n判断奇数情况和偶数情况下回文子串的最大长度\n\n之后按照最大长度找到回文子串开始的位置，截取子串返回\n\n比如\n奇数回文串                             偶数回文串\nA   A   B   C   B   A                A   A   B   C   C   B   A\n0   1   2   3   4   5                0   1   2   3   4   5   6\n  begin     i                          begin     i  i+1\n          len=5                                  len=6\n                   bengin = i-(len-1)/2\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# Java代码\n\nclass Solution {\n    public String longestPalindrome(String s) {\n        int len = s.length();\n        if(len<2) return s;\n        int maxlen = 1;\n        int begin = 0;\n        char[] charAarray = s.toCharArray();\n        for(int i=0;i<len-1;i++){\n            for(int j=1;j<len;j++){\n                if(j-i+1>maxlen&&validateSubString(charAarray,i,j)){\n                    begin = i;\n                    maxlen = j-i+1;\n                }\n            }\n        }\n        return s.substring(begin,begin+maxlen);\n    }\n    public boolean validateSubString(char[] charAarray,int left,int right){\n        while(left<right){\n            if(charAarray[left]!=charAarray[right]){\n                return false;\n            }\n            left++;\n            right--;\n        }\n        return true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# Java代码2\n\npublic class Solution {\n\n    public String longestPalindrome(String s) {\n        int len = s.length();\n        if (len < 2) {\n            return s;\n        }\n\n        int maxLen = 1;\n        int begin = 0;\n\n        // dp[i][j] 表示 s[i, j] 是否是回文串\n        // i是子串的左边界，j是子串的右边界\n        boolean[][] dp = new boolean[len][len];\n        char[] charArray = s.toCharArray();\n\t\t// 对角线恒为true\n        for (int i = 0; i < len; i++) {\n            dp[i][i] = true;\n        }\n        // 由于dp[i+1][j-1]是行+1，列减1，dp[i][j]依赖于左下方的值，这样不好计算\n        // 所以先升序填列，再升序填行，按列遍历\n        for (int j = 1; j < len; j++) { // 列\n            for (int i = 0; i < j; i++) {// 行\n                if (charArray[i] != charArray[j]) { // 头尾字符不相等时\n                    dp[i][j] = false;\n                } else {\n                    // j-1-(i+1)+1<2\n                    if (j - i < 3) { // 如果头尾没有字符，或者只剩一个字符\n                        dp[i][j] = true;\n                    } else {\n                        dp[i][j] = dp[i + 1][j - 1];\n                    }\n                }\n\n                // 只要 dp[i][j] == true 成立，就表示子串 s[i..j] 是回文，此时记录回文长度和起始位置\n                if (dp[i][j] && j - i + 1 > maxLen) {\n                    maxLen = j - i + 1;\n                    begin = i;\n                }\n            }\n        }\n        return s.substring(begin, begin + maxLen);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# Java代码3\n\npublic class Solution {\n\n    public String longestPalindrome(String s) {\n        int len = s.length();\n        if (len < 2) {\n            return s;\n        }\n        int maxLen = 1;\n        int begin = 0;\n        char[] charArray = s.toCharArray();\n        // 枚举所有回文中心\n        for(int i=0;i<len-1;i++){\n            int oddLen = expandAroudCenter(charArray,i,i); // 以下标i作为回文中心\n            int evenLen = expandAroudCenter(charArray,i,i+1); //以下标i和i+1作为回文中心\n            \n            int curMaxLen = Math.max(oddLen,evenLen);\n            if(curMaxLen>maxLen){\n                maxLen = curMaxLen;\n                // 画图找规律\n                begin = i-(maxLen-1)/2;\n            }\n        }\n        return s.substring(begin,begin+maxLen);\n\t}\n    \n    public int expandAroudCenter(char[] charArray,int left,int right){\n        // 当left=right的时候，回文中心是一个字符，回文串的长度是奇数\n        // 当right=left+1的时候，此时回文中心两个字符，回文串的长度是偶数\n        int len = charArray.length;\n        int i = left;\n        int j = right;\n        // 从回文中心向两边扩散\n        while(i>=0&&j<len){\n            if(charArray[i]==charArray[j]){\n                i--;\n                j++;\n            }else{\n                break;\n            }\n        }\n        // 跳出while循环时，恰好满足 s.charAt(i)!=s.charAt(j)\n        // 回文串的长度 j-i+1-2=j-i-1 ，减2是因为不包括回文中心字符\n        return j-i-1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n',normalizedContent:'# leetcode-5-最长回文字串\n\n给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。\n\n示例 1:\n\n输入: "babad"\n输出: "bab"\n注意: "aba" 也是一个有效答案。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2：\n\n输入: "cbbd"\n输出: "bb"\n\n\n1\n2\n\n1\n2\n\n\n\n# 解题思路\n\n方法1、暴力破解：\n\n暴力破解法，判断每个串开头的所有子串中，大于最长子串的串是否是回文子串\n\n判断回文字串的方法为，首尾往内遍历，如果首尾不相等则不是回文字串，移动左指针+1，右指针-1；\n\n否则就是回文子串\n\n方法2、动态规划：\n\n参考地址1\n\n参考地址2\n\n方法3、中心扩散法：\n\n枚举所有的回文中心位置，回文中心位置需要按照字符串长度分为奇数和偶数的情况\n\n奇数情况时，回文中心仅有1个字符\n\n偶数情况时，回文中心有2个字符\n\n从回文中心出发进行扩散，尽可能的使得子串长度达到最大，不满足时跳出，返回扩散之后回文子串的长度j-i+1-2\n\n判断奇数情况和偶数情况下回文子串的最大长度\n\n之后按照最大长度找到回文子串开始的位置，截取子串返回\n\n比如\n奇数回文串                             偶数回文串\na   a   b   c   b   a                a   a   b   c   c   b   a\n0   1   2   3   4   5                0   1   2   3   4   5   6\n  begin     i                          begin     i  i+1\n          len=5                                  len=6\n                   bengin = i-(len-1)/2\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# java代码\n\nclass solution {\n    public string longestpalindrome(string s) {\n        int len = s.length();\n        if(len<2) return s;\n        int maxlen = 1;\n        int begin = 0;\n        char[] charaarray = s.tochararray();\n        for(int i=0;i<len-1;i++){\n            for(int j=1;j<len;j++){\n                if(j-i+1>maxlen&&validatesubstring(charaarray,i,j)){\n                    begin = i;\n                    maxlen = j-i+1;\n                }\n            }\n        }\n        return s.substring(begin,begin+maxlen);\n    }\n    public boolean validatesubstring(char[] charaarray,int left,int right){\n        while(left<right){\n            if(charaarray[left]!=charaarray[right]){\n                return false;\n            }\n            left++;\n            right--;\n        }\n        return true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# java代码2\n\npublic class solution {\n\n    public string longestpalindrome(string s) {\n        int len = s.length();\n        if (len < 2) {\n            return s;\n        }\n\n        int maxlen = 1;\n        int begin = 0;\n\n        // dp[i][j] 表示 s[i, j] 是否是回文串\n        // i是子串的左边界，j是子串的右边界\n        boolean[][] dp = new boolean[len][len];\n        char[] chararray = s.tochararray();\n\t\t// 对角线恒为true\n        for (int i = 0; i < len; i++) {\n            dp[i][i] = true;\n        }\n        // 由于dp[i+1][j-1]是行+1，列减1，dp[i][j]依赖于左下方的值，这样不好计算\n        // 所以先升序填列，再升序填行，按列遍历\n        for (int j = 1; j < len; j++) { // 列\n            for (int i = 0; i < j; i++) {// 行\n                if (chararray[i] != chararray[j]) { // 头尾字符不相等时\n                    dp[i][j] = false;\n                } else {\n                    // j-1-(i+1)+1<2\n                    if (j - i < 3) { // 如果头尾没有字符，或者只剩一个字符\n                        dp[i][j] = true;\n                    } else {\n                        dp[i][j] = dp[i + 1][j - 1];\n                    }\n                }\n\n                // 只要 dp[i][j] == true 成立，就表示子串 s[i..j] 是回文，此时记录回文长度和起始位置\n                if (dp[i][j] && j - i + 1 > maxlen) {\n                    maxlen = j - i + 1;\n                    begin = i;\n                }\n            }\n        }\n        return s.substring(begin, begin + maxlen);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# java代码3\n\npublic class solution {\n\n    public string longestpalindrome(string s) {\n        int len = s.length();\n        if (len < 2) {\n            return s;\n        }\n        int maxlen = 1;\n        int begin = 0;\n        char[] chararray = s.tochararray();\n        // 枚举所有回文中心\n        for(int i=0;i<len-1;i++){\n            int oddlen = expandaroudcenter(chararray,i,i); // 以下标i作为回文中心\n            int evenlen = expandaroudcenter(chararray,i,i+1); //以下标i和i+1作为回文中心\n            \n            int curmaxlen = math.max(oddlen,evenlen);\n            if(curmaxlen>maxlen){\n                maxlen = curmaxlen;\n                // 画图找规律\n                begin = i-(maxlen-1)/2;\n            }\n        }\n        return s.substring(begin,begin+maxlen);\n\t}\n    \n    public int expandaroudcenter(char[] chararray,int left,int right){\n        // 当left=right的时候，回文中心是一个字符，回文串的长度是奇数\n        // 当right=left+1的时候，此时回文中心两个字符，回文串的长度是偶数\n        int len = chararray.length;\n        int i = left;\n        int j = right;\n        // 从回文中心向两边扩散\n        while(i>=0&&j<len){\n            if(chararray[i]==chararray[j]){\n                i--;\n                j++;\n            }else{\n                break;\n            }\n        }\n        // 跳出while循环时，恰好满足 s.charat(i)!=s.charat(j)\n        // 回文串的长度 j-i+1-2=j-i-1 ，减2是因为不包括回文中心字符\n        return j-i-1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-11-盛最多水的容器",frontmatter:{title:"LeetCode-11-盛最多水的容器",date:"2020-06-19T14:57:16.000Z",description:"盛最多水的容器",tags:["数组","Java","Medium","LeetCode"],keywords:"数组,Java,Medium,LeetCode",permalink:"/pages/1104ba/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/20.LeetCode-11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8.html",relativePath:"06.算法/02.LeetCode/20.LeetCode-11-盛最多水的容器.md",key:"v-04405839",path:"/pages/1104ba/",headers:[{level:2,title:"LeetCode-11-盛最多水的容器",slug:"leetcode-11-盛最多水的容器",normalizedTitle:"leetcode-11-盛最多水的容器",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:227},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:487}],headersStr:"LeetCode-11-盛最多水的容器 解题思路 Java代码",content:"# LeetCode-11-盛最多水的容器\n\n给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\n\n说明：你不能倾斜容器，且 n 的值至少为 2。\n\n示例 1:\n\n输入：[1,8,6,2,5,4,8,3,7]\n输出：49\n\n\n1\n2\n\n1\n2\n\n\n\n# 解题思路\n\n方法1、双指针：\n\n根据题目的意思，最大面积=左右两个内板较低的一个高度*左右两个内板的间隔\n\n利用双指针解决，初始化首尾指针，现在的问题是怎么样去移动首尾指针，才能够使得面积最大\n\n想象一下，无论首尾指针谁大，我们都需要移动一次首尾指针，依次判断面积谁更大，此时无论是移动首还是尾指针，底部长度的变化都是1。于是我们只需要知道，移动哪个指针能让面积增大就行了。经过思考，移动值较小的那个指针，保留值较大的指针，可以使得面积更大的概率更大。所以当其中一个指针的值小于另外一个的时候，移动那个指针即可\n\n\n# Java代码\n\nclass Solution {\n    public int maxArea(int[] height) {\n        int left = 0;\n        int right = height.length-1;\n        int max = 0;\n        while(left<right){\n            max = Math.max(max,(right-left)*Math.min(height[left],height[right]));\n            if(height[left]<height[right]) left++;\n            else right--;\n        }\n        return max;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n",normalizedContent:"# leetcode-11-盛最多水的容器\n\n给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\n\n说明：你不能倾斜容器，且 n 的值至少为 2。\n\n示例 1:\n\n输入：[1,8,6,2,5,4,8,3,7]\n输出：49\n\n\n1\n2\n\n1\n2\n\n\n\n# 解题思路\n\n方法1、双指针：\n\n根据题目的意思，最大面积=左右两个内板较低的一个高度*左右两个内板的间隔\n\n利用双指针解决，初始化首尾指针，现在的问题是怎么样去移动首尾指针，才能够使得面积最大\n\n想象一下，无论首尾指针谁大，我们都需要移动一次首尾指针，依次判断面积谁更大，此时无论是移动首还是尾指针，底部长度的变化都是1。于是我们只需要知道，移动哪个指针能让面积增大就行了。经过思考，移动值较小的那个指针，保留值较大的指针，可以使得面积更大的概率更大。所以当其中一个指针的值小于另外一个的时候，移动那个指针即可\n\n\n# java代码\n\nclass solution {\n    public int maxarea(int[] height) {\n        int left = 0;\n        int right = height.length-1;\n        int max = 0;\n        while(left<right){\n            max = math.max(max,(right-left)*math.min(height[left],height[right]));\n            if(height[left]<height[right]) left++;\n            else right--;\n        }\n        return max;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-15-三数之和",frontmatter:{title:"LeetCode-15-三数之和",date:"2020-06-23T17:01:45.000Z",description:"三数之和",tags:["数组","Java","Medium","LeetCode"],keywords:"数组,Java,Medium,LeetCode",permalink:"/pages/5a4da3/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/21.LeetCode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html",relativePath:"06.算法/02.LeetCode/21.LeetCode-15-三数之和.md",key:"v-49ca2b1c",path:"/pages/5a4da3/",headers:[{level:2,title:"LeetCode-15-三数之和",slug:"leetcode-15-三数之和",normalizedTitle:"leetcode-15-三数之和",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:249},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:678}],headersStr:"LeetCode-15-三数之和 解题思路 Java代码",content:"# LeetCode-15-三数之和\n\n给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。\n\n注意：答案中不可以包含重复的三元组。\n\n示例 1:\n\n给定数组 nums = [-1, 0, 1, 2, -1, -4]，\n\n满足要求的三元组集合为：\n[\n  [-1, 0, 1],\n  [-1, -1, 2]\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 解题思路\n\n方法1、双指针：\n\n不重复问题首先一步是要对数组进行排序\n\n排序之后固定一个数nums[i]，之后利用左右指针找nums[left]+nums[right]+nums[i]==0 (sum)的数，就可以添加进入结果集合\n\n但过程中需要考虑数据重复的问题\n\n如果nums[i]>0，则说明三数之和必然无法等于0，直接跳出循环\n\n如果nums[i]==nums[i-1]，则说明该数字重复，会导致重复的结果，所以直接跳过\n\n之后当left<right的时候，且\n\nsum==0，nums[left]==nums[left+1]会导致重复的结果，应该跳过，所以left++\n\nsum==0，nums[right]==nums[right-1]时，会导致重复的，应该跳过，所以right--\n\n当sum>0的时候说明区间数太大了，由于此时是排序是所以，右移指针可以减小sum的值\n\n当sum<0的时候说明区间数太小了，左移指针可以增大sum的值\n\n\n# Java代码\n\nclass Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        int len = nums.length;\n        List<List<Integer>> res = new ArrayList<>();\n        if(len<3) return res;\n        Arrays.sort(nums);\n        for(int i=0;i<len-2;i++){\n            if(nums[i]>0) break;\n            if(i>0&&nums[i]==nums[i-1]) continue;\n            int left = i+1;\n            int right = len-1;\n            while(left<right){\n                if(nums[i]+nums[left]+nums[right]==0){\n                    res.add(Arrays.asList(nums[i],nums[left],nums[right]));\n                    while(left<right&&nums[left]==nums[left+1]) left++;\n                    while(left<right&&nums[right]==nums[right-1]) right--;\n                    left++;\n                    right--;\n                }else if(nums[i]+nums[left]+nums[right]>0){\n                    right--;\n                }else{\n                    left++;\n                }\n            }\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n",normalizedContent:"# leetcode-15-三数之和\n\n给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。\n\n注意：答案中不可以包含重复的三元组。\n\n示例 1:\n\n给定数组 nums = [-1, 0, 1, 2, -1, -4]，\n\n满足要求的三元组集合为：\n[\n  [-1, 0, 1],\n  [-1, -1, 2]\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 解题思路\n\n方法1、双指针：\n\n不重复问题首先一步是要对数组进行排序\n\n排序之后固定一个数nums[i]，之后利用左右指针找nums[left]+nums[right]+nums[i]==0 (sum)的数，就可以添加进入结果集合\n\n但过程中需要考虑数据重复的问题\n\n如果nums[i]>0，则说明三数之和必然无法等于0，直接跳出循环\n\n如果nums[i]==nums[i-1]，则说明该数字重复，会导致重复的结果，所以直接跳过\n\n之后当left<right的时候，且\n\nsum==0，nums[left]==nums[left+1]会导致重复的结果，应该跳过，所以left++\n\nsum==0，nums[right]==nums[right-1]时，会导致重复的，应该跳过，所以right--\n\n当sum>0的时候说明区间数太大了，由于此时是排序是所以，右移指针可以减小sum的值\n\n当sum<0的时候说明区间数太小了，左移指针可以增大sum的值\n\n\n# java代码\n\nclass solution {\n    public list<list<integer>> threesum(int[] nums) {\n        int len = nums.length;\n        list<list<integer>> res = new arraylist<>();\n        if(len<3) return res;\n        arrays.sort(nums);\n        for(int i=0;i<len-2;i++){\n            if(nums[i]>0) break;\n            if(i>0&&nums[i]==nums[i-1]) continue;\n            int left = i+1;\n            int right = len-1;\n            while(left<right){\n                if(nums[i]+nums[left]+nums[right]==0){\n                    res.add(arrays.aslist(nums[i],nums[left],nums[right]));\n                    while(left<right&&nums[left]==nums[left+1]) left++;\n                    while(left<right&&nums[right]==nums[right-1]) right--;\n                    left++;\n                    right--;\n                }else if(nums[i]+nums[left]+nums[right]>0){\n                    right--;\n                }else{\n                    left++;\n                }\n            }\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-17-电话号码的字母组合",frontmatter:{title:"LeetCode-17-电话号码的字母组合",date:"2020-06-24T15:51:32.000Z",description:"电话号码的字母组合",tags:["字符串","Java","Medium","LeetCode"],keywords:"字符串,Java,Medium,LeetCode",permalink:"/pages/23ca91/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/22.LeetCode-17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html",relativePath:"06.算法/02.LeetCode/22.LeetCode-17-电话号码的字母组合.md",key:"v-3d73a434",path:"/pages/23ca91/",headers:[{level:2,title:"LeetCode-17-电话号码的字母组合",slug:"leetcode-17-电话号码的字母组合",normalizedTitle:"leetcode-17-电话号码的字母组合",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:226},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:429}],headersStr:"LeetCode-17-电话号码的字母组合 解题思路 Java代码",content:'# LeetCode-17-电话号码的字母组合\n\n给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。\n\n给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。\n\n示例 1:\n\n输入："23"\n输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].\n\n\n1\n2\n\n1\n2\n\n\n说明: 尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。\n\n\n# 解题思路\n\n方法1、回溯：\n\n首先需要建立一个map，存储数字到字符串的映射\n\n排列组合问题一般想象成树形问题，可以进行回溯选择\n\n本题中回溯的停止条件是当深度达到输入字符长度的时候\n\n回溯流程：\n\n * 选择第一个输入的数字\n * 找到这个数字对应的字母列表，并选择第一个字母加入到tmp中\n * 开启下一层递归\n * 当加入过一个答案之后，进行回溯，即删除刚选择的最后一个字符，选择另外的路走\n\n\n# Java代码\n\nclass Solution {\n    Map<String, String> map = new HashMap<String, String>() {{\n            put("2", "abc");\n            put("3", "def");\n            put("4", "ghi");\n            put("5", "jkl");\n            put("6", "mno");\n            put("7", "pqrs");\n            put("8", "tuv");\n            put("9", "wxyz");\n        }};\n    List<String> res = new ArrayList<String>();\n    StringBuilder tmp = new StringBuilder();\n\n    public List<String> letterCombinations(String digits) {\n        if(digits==null||digits.length()==0) return res;\n        backtrack(digits,0);\n        return res;\n    }\n\n    public void backtrack(String digits,int index){\n        if(index>=digits.length()){\n            res.add(tmp.toString());\n            return;\n        }\n        String letter = map.get(digits.substring(index,index+1));\n        for(int i=0;i<letter.length();i++){\n            tmp.append(letter.charAt(i));\n            backtrack(digits,index+1);\n            tmp.deleteCharAt(tmp.length()-1);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n',normalizedContent:'# leetcode-17-电话号码的字母组合\n\n给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。\n\n给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。\n\n示例 1:\n\n输入："23"\n输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].\n\n\n1\n2\n\n1\n2\n\n\n说明: 尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。\n\n\n# 解题思路\n\n方法1、回溯：\n\n首先需要建立一个map，存储数字到字符串的映射\n\n排列组合问题一般想象成树形问题，可以进行回溯选择\n\n本题中回溯的停止条件是当深度达到输入字符长度的时候\n\n回溯流程：\n\n * 选择第一个输入的数字\n * 找到这个数字对应的字母列表，并选择第一个字母加入到tmp中\n * 开启下一层递归\n * 当加入过一个答案之后，进行回溯，即删除刚选择的最后一个字符，选择另外的路走\n\n\n# java代码\n\nclass solution {\n    map<string, string> map = new hashmap<string, string>() {{\n            put("2", "abc");\n            put("3", "def");\n            put("4", "ghi");\n            put("5", "jkl");\n            put("6", "mno");\n            put("7", "pqrs");\n            put("8", "tuv");\n            put("9", "wxyz");\n        }};\n    list<string> res = new arraylist<string>();\n    stringbuilder tmp = new stringbuilder();\n\n    public list<string> lettercombinations(string digits) {\n        if(digits==null||digits.length()==0) return res;\n        backtrack(digits,0);\n        return res;\n    }\n\n    public void backtrack(string digits,int index){\n        if(index>=digits.length()){\n            res.add(tmp.tostring());\n            return;\n        }\n        string letter = map.get(digits.substring(index,index+1));\n        for(int i=0;i<letter.length();i++){\n            tmp.append(letter.charat(i));\n            backtrack(digits,index+1);\n            tmp.deletecharat(tmp.length()-1);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-19-删除链表的倒数第N个节点",frontmatter:{title:"LeetCode-19-删除链表的倒数第N个节点",date:"2020-06-26T16:38:24.000Z",description:"删除链表的倒数第N个节点",tags:["链表","Java","Medium"],keywords:"链表,Java,Medium,LeetCode",permalink:"/pages/2b5a76/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/23.LeetCode-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.html",relativePath:"06.算法/02.LeetCode/23.LeetCode-19-删除链表的倒数第N个节点.md",key:"v-5766fcc4",path:"/pages/2b5a76/",headers:[{level:2,title:"LeetCode-19-删除链表的倒数第N个节点",slug:"leetcode-19-删除链表的倒数第n个节点",normalizedTitle:"leetcode-19-删除链表的倒数第n个节点",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:194},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:414}],headersStr:"LeetCode-19-删除链表的倒数第N个节点 解题思路 Java代码",content:"# LeetCode-19-删除链表的倒数第N个节点\n\n给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。\n\n示例 1:\n\n给定一个链表: 1->2->3->4->5, 和 n = 2.\n\n当删除了倒数第二个节点后，链表变为 1->2->3->5.\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n说明：\n\n给定的 n 保证是有效的。\n\n进阶：\n\n你能尝试使用一趟扫描实现吗？\n\n\n# 解题思路\n\n方法1、双指针：\n\n两次遍历是一定能找到的，但是这样复杂度比较高，所以直接能想到的是使用双指针来进行操作，一次遍历即可完成\n\n快指针先走n+1步，之后慢指针和快指针一起走\n\n当快指针走到末尾时，慢指针刚好指向要删除节点的前一个节点，改变指向就可以完成节点删除。\n\n其中需要初始化1个哑结点作为辅助，该节点位于列表头部，用来简化某些特例，比如列表中只含有一个节点，或者需要删除列表的头部。\n\n快指针和慢指针的间隔始终是n\n\n\n# Java代码\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode cur = dummy;\n        ListNode pre = dummy;\n        for (int i = 0; i <n+1; i++) {\n            cur = cur.next;\n        }\n        while (cur != null) {\n            cur = cur.next;\n            pre = pre.next;\n        }\n        pre.next = pre.next.next;\n        return dummy.next;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n",normalizedContent:"# leetcode-19-删除链表的倒数第n个节点\n\n给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。\n\n示例 1:\n\n给定一个链表: 1->2->3->4->5, 和 n = 2.\n\n当删除了倒数第二个节点后，链表变为 1->2->3->5.\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n说明：\n\n给定的 n 保证是有效的。\n\n进阶：\n\n你能尝试使用一趟扫描实现吗？\n\n\n# 解题思路\n\n方法1、双指针：\n\n两次遍历是一定能找到的，但是这样复杂度比较高，所以直接能想到的是使用双指针来进行操作，一次遍历即可完成\n\n快指针先走n+1步，之后慢指针和快指针一起走\n\n当快指针走到末尾时，慢指针刚好指向要删除节点的前一个节点，改变指向就可以完成节点删除。\n\n其中需要初始化1个哑结点作为辅助，该节点位于列表头部，用来简化某些特例，比如列表中只含有一个节点，或者需要删除列表的头部。\n\n快指针和慢指针的间隔始终是n\n\n\n# java代码\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode(int x) { val = x; }\n * }\n */\nclass solution {\n    public listnode removenthfromend(listnode head, int n) {\n        listnode dummy = new listnode(0);\n        dummy.next = head;\n        listnode cur = dummy;\n        listnode pre = dummy;\n        for (int i = 0; i <n+1; i++) {\n            cur = cur.next;\n        }\n        while (cur != null) {\n            cur = cur.next;\n            pre = pre.next;\n        }\n        pre.next = pre.next.next;\n        return dummy.next;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-20-有效的括号",frontmatter:{title:"LeetCode-20-有效的括号",date:"2020-06-24T09:37:20.000Z",description:"有效的括号",tags:["字符串","Java","Python","Easy"],keywords:"字符串,Java,Python,Easy,LeetCode",permalink:"/pages/b7ac0a/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/24.LeetCode-20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.html",relativePath:"06.算法/02.LeetCode/24.LeetCode-20-有效的括号.md",key:"v-2c1431df",path:"/pages/b7ac0a/",headers:[{level:2,title:"LeetCode-20-有效的括号",slug:"leetcode-20-有效的括号",normalizedTitle:"leetcode-20-有效的括号",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:341},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:672}],headersStr:"LeetCode-20-有效的括号 解题思路 Java代码",content:"# LeetCode-20-有效的括号\n\n给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。\n\n有效字符串需满足：\n\n 1. 左括号必须用相同类型的右括号闭合。\n 2. 左括号必须以正确的顺序闭合。\n\n注意空字符串可被认为是有效字符串。\n\n示例 1:\n\n输入: \"()\"\n输出: true\n\n\n1\n2\n\n1\n2\n\n\n示例2：\n\n输入: \"()[]{}\"\n输出: true\n\n\n1\n2\n\n1\n2\n\n\n示例3：\n\n输入: \"(]\"\n输出: false\n\n\n1\n2\n\n1\n2\n\n\n示例4：\n\n输入: \"([)]\"\n输出: false\n\n\n1\n2\n\n1\n2\n\n\n示例5：\n\n输入: \"{[]}\"\n输出: true\n\n\n1\n2\n\n1\n2\n\n\n\n# 解题思路\n\n方法1、栈：\n\n观察题目可知，要想构成有效的括号，最开始加入的(括号的反)必须是最后加入\n\n这种规律符合栈的先进后出的方式，于是可以用栈来模拟\n\n当扫描到前括号(、{、[的时候，在栈中加入对应的反括号),},]\n\n当全部匹配时，栈为空等于true\n\n特例处理当输入的字符为null的时候，直接返回true\n\n当输入的字符为[的时候，栈中会加入反括号]，此时栈不为空，返回false\n\n当输入的字符为]的时候，栈中不会加入反括号，此时如果直接返回栈是否为空，会返回true，但这是一个错误的结果\n\n所以新增一个新的判断，else if(stack.isEmpty()||c!=stack.pop())联合判别反括号和栈空的情况，都是false\n\n\n# Java代码\n\nclass Solution {\n    public boolean isValid(String s) {\n        if(s==null||s.length()==0) return true;\n        Stack<Character> stack = new Stack<>();\n        char[] cs = s.toCharArray();\n        for(char c:cs){\n            if(c=='('){\n                stack.push(')');\n            }else if(c=='{'){\n                stack.push('}');\n            }else if(c=='['){\n                stack.push(']');\n            }else if(stack.isEmpty()||c!=stack.pop()){\n                return false;\n            }\n        }\n        return stack.isEmpty();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n",normalizedContent:"# leetcode-20-有效的括号\n\n给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。\n\n有效字符串需满足：\n\n 1. 左括号必须用相同类型的右括号闭合。\n 2. 左括号必须以正确的顺序闭合。\n\n注意空字符串可被认为是有效字符串。\n\n示例 1:\n\n输入: \"()\"\n输出: true\n\n\n1\n2\n\n1\n2\n\n\n示例2：\n\n输入: \"()[]{}\"\n输出: true\n\n\n1\n2\n\n1\n2\n\n\n示例3：\n\n输入: \"(]\"\n输出: false\n\n\n1\n2\n\n1\n2\n\n\n示例4：\n\n输入: \"([)]\"\n输出: false\n\n\n1\n2\n\n1\n2\n\n\n示例5：\n\n输入: \"{[]}\"\n输出: true\n\n\n1\n2\n\n1\n2\n\n\n\n# 解题思路\n\n方法1、栈：\n\n观察题目可知，要想构成有效的括号，最开始加入的(括号的反)必须是最后加入\n\n这种规律符合栈的先进后出的方式，于是可以用栈来模拟\n\n当扫描到前括号(、{、[的时候，在栈中加入对应的反括号),},]\n\n当全部匹配时，栈为空等于true\n\n特例处理当输入的字符为null的时候，直接返回true\n\n当输入的字符为[的时候，栈中会加入反括号]，此时栈不为空，返回false\n\n当输入的字符为]的时候，栈中不会加入反括号，此时如果直接返回栈是否为空，会返回true，但这是一个错误的结果\n\n所以新增一个新的判断，else if(stack.isempty()||c!=stack.pop())联合判别反括号和栈空的情况，都是false\n\n\n# java代码\n\nclass solution {\n    public boolean isvalid(string s) {\n        if(s==null||s.length()==0) return true;\n        stack<character> stack = new stack<>();\n        char[] cs = s.tochararray();\n        for(char c:cs){\n            if(c=='('){\n                stack.push(')');\n            }else if(c=='{'){\n                stack.push('}');\n            }else if(c=='['){\n                stack.push(']');\n            }else if(stack.isempty()||c!=stack.pop()){\n                return false;\n            }\n        }\n        return stack.isempty();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-21-合并两个有序链表",frontmatter:{title:"LeetCode-21-合并两个有序链表",date:"2020-06-07T19:00:23.000Z",description:"合并两个有序链表",tags:["链表","Java","Python","Easy"],keywords:"链表,Java,Python,Easy,LeetCode",permalink:"/pages/d0dd86/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/25.LeetCode-21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8.html",relativePath:"06.算法/02.LeetCode/25.LeetCode-21-合并两个有序链表.md",key:"v-eace5c7c",path:"/pages/d0dd86/",headers:[{level:2,title:"LeetCode-21-合并两个有序链表",slug:"leetcode-21-合并两个有序链表",normalizedTitle:"leetcode-21-合并两个有序链表",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:137},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:661},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:1501},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:2130}],headersStr:"LeetCode-21-合并两个有序链表 解题思路 Java代码 Python代码 Java代码2",content:"# LeetCode-21-合并两个有序链表\n\n将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。\n\n示例 1:\n\n输入：1->2->4, 1->3->4\n输出：1->1->2->3->4->4\n\n\n1\n2\n\n1\n2\n\n\n\n# 解题思路\n\n方法一、递归：\n\n首先，两个链表存在长短不一致的情况\n\n递归终止条件：当链表1为空时，合并的链表为链表2；当链表2为空时，合并的链表为链表1\n\n之后，链表需要从小到大的有序合并\n\n新增一个合并后链表的头部指针，判断l1和l2的链表的当前位置值谁更小，小的加入到合并链表中，之后合并链表的next就是剩下的两个链表中的最小值。\n\n最后返回合并链表头部\n\n方法二、迭代：\n\n迭代的思路大致和递归一样，但需要一个新的指针，pre记录当前位置的前一个元素，并不断调整他的next指向构建整个合并链表，phead负责合并链表的头部。\n\n如果l1.val<l2.val则，把l1接在pre的后面，同时l1指针向后移动1位。否则就对l2做相同操作\n\n不管将l1和l2中的哪个元素接在了pre后面，pre指针始终需要向后移动1位，因为接了之后next就不为空了，需要移动到下一位继续构建链表\n\n在循环终止的时候，l1和l2可能出现长短不一的情况，至多会有一个是非空的，由于输入的链表都是有序的，所以不管是哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的元素要大，此时只需要将剩下的链表接在pre.next，之后返回合并链表的头部即可\n\n\n# Java代码\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        if(l1==null) return l2;\n        if(l2==null) return l1;\n        ListNode mergehead = null;\n        if(l1.val<l2.val){\n            mergehead = l1;\n            mergehead.next = mergeTwoLists(l1.next,l2);\n        }else{\n            mergehead = l2;\n            mergehead.next = mergeTwoLists(l1,l2.next);\n        }\n        return mergehead;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# Python代码\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:\n        if not l1: return l2\n        if not l2: return l1\n        if l1.val<l2.val:\n            mergeHead = l1\n            mergeHead.next = self.mergeTwoLists(l1.next,l2)\n        else:\n            mergeHead = l2\n            mergeHead.next = self.mergeTwoLists(l1,l2.next)\n        return mergeHead\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# Java代码2\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        if(l1==null) return l2;\n        if(l2==null) return l1;\n        ListNode phead = new ListNode(0);\n        ListNode pre = phead;\n        while(l1!=null&&l2!=null){\n            if(l1.val<l2.val){\n                pre.next = l1;\n                l1 = l1.next;\n            }else{\n                pre.next = l2;\n                l2 = l2.next;\n            }\n            pre = pre.next;\n        }\n        if(l1==null) pre.next = l2;\n        if(l2==null) pre.next = l1;\n        return phead.next;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n",normalizedContent:"# leetcode-21-合并两个有序链表\n\n将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。\n\n示例 1:\n\n输入：1->2->4, 1->3->4\n输出：1->1->2->3->4->4\n\n\n1\n2\n\n1\n2\n\n\n\n# 解题思路\n\n方法一、递归：\n\n首先，两个链表存在长短不一致的情况\n\n递归终止条件：当链表1为空时，合并的链表为链表2；当链表2为空时，合并的链表为链表1\n\n之后，链表需要从小到大的有序合并\n\n新增一个合并后链表的头部指针，判断l1和l2的链表的当前位置值谁更小，小的加入到合并链表中，之后合并链表的next就是剩下的两个链表中的最小值。\n\n最后返回合并链表头部\n\n方法二、迭代：\n\n迭代的思路大致和递归一样，但需要一个新的指针，pre记录当前位置的前一个元素，并不断调整他的next指向构建整个合并链表，phead负责合并链表的头部。\n\n如果l1.val<l2.val则，把l1接在pre的后面，同时l1指针向后移动1位。否则就对l2做相同操作\n\n不管将l1和l2中的哪个元素接在了pre后面，pre指针始终需要向后移动1位，因为接了之后next就不为空了，需要移动到下一位继续构建链表\n\n在循环终止的时候，l1和l2可能出现长短不一的情况，至多会有一个是非空的，由于输入的链表都是有序的，所以不管是哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的元素要大，此时只需要将剩下的链表接在pre.next，之后返回合并链表的头部即可\n\n\n# java代码\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode() {}\n *     listnode(int val) { this.val = val; }\n *     listnode(int val, listnode next) { this.val = val; this.next = next; }\n * }\n */\nclass solution {\n    public listnode mergetwolists(listnode l1, listnode l2) {\n        if(l1==null) return l2;\n        if(l2==null) return l1;\n        listnode mergehead = null;\n        if(l1.val<l2.val){\n            mergehead = l1;\n            mergehead.next = mergetwolists(l1.next,l2);\n        }else{\n            mergehead = l2;\n            mergehead.next = mergetwolists(l1,l2.next);\n        }\n        return mergehead;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# python代码\n\n# definition for singly-linked list.\n# class listnode:\n#     def __init__(self, val=0, next=none):\n#         self.val = val\n#         self.next = next\nclass solution:\n    def mergetwolists(self, l1: listnode, l2: listnode) -> listnode:\n        if not l1: return l2\n        if not l2: return l1\n        if l1.val<l2.val:\n            mergehead = l1\n            mergehead.next = self.mergetwolists(l1.next,l2)\n        else:\n            mergehead = l2\n            mergehead.next = self.mergetwolists(l1,l2.next)\n        return mergehead\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# java代码2\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode() {}\n *     listnode(int val) { this.val = val; }\n *     listnode(int val, listnode next) { this.val = val; this.next = next; }\n * }\n */\nclass solution {\n    public listnode mergetwolists(listnode l1, listnode l2) {\n        if(l1==null) return l2;\n        if(l2==null) return l1;\n        listnode phead = new listnode(0);\n        listnode pre = phead;\n        while(l1!=null&&l2!=null){\n            if(l1.val<l2.val){\n                pre.next = l1;\n                l1 = l1.next;\n            }else{\n                pre.next = l2;\n                l2 = l2.next;\n            }\n            pre = pre.next;\n        }\n        if(l1==null) pre.next = l2;\n        if(l2==null) pre.next = l1;\n        return phead.next;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-22-括号生成",frontmatter:{title:"LeetCode-22-括号生成",date:"2020-06-26T18:52:11.000Z",description:"括号生成",tags:["字符串","回溯","DFS","Java","Medium"],keywords:"字符串,回溯,DFS,Java,Medium,LeetCode",permalink:"/pages/a6eaf0/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/26.LeetCode-22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90.html",relativePath:"06.算法/02.LeetCode/26.LeetCode-22-括号生成.md",key:"v-77d9d1bd",path:"/pages/a6eaf0/",headers:[{level:2,title:"LeetCode-22-括号生成",slug:"leetcode-22-括号生成",normalizedTitle:"leetcode-22-括号生成",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:221},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:564},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:1185}],headersStr:"LeetCode-22-括号生成 解题思路 Java代码 Java代码2",content:'# LeetCode-22-括号生成\n\n数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。\n\n示例 1:\n\n输入：n = 3\n输出：[\n       "((()))",\n       "(()())",\n       "(())()",\n       "()(())",\n       "()()()"\n     ]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 解题思路\n\n方法1、DFS：\n\n深度优先遍历选择左括号和右括号，由于String拼接每次会产生一个新的String对象，所以传入的字符串不会影响其他结果，当左括号>0时，左括号-1进入下一次拼接。只有当左右括号数目相等为n的时候，拼接的括号才是合法的，此时加入到最终结果，返回上一层。当左括号用完了的时候进行右括号的拼接\n\n方法2、回溯：\n\n回溯法基本上和DFS一致，只是这里的回溯需要手动回溯，由于String每次生成一个新的String对象耗时比较多，所以可以用StringBuilder，然而StringBuilder拼接的时候会把上一次的字符记录着，所以在DFS之后需要手动回溯，即删除上一层拼接的字符cur.deleteCharAt(cur.length()-1);\n\n\n# Java代码\n\nclass Solution {\n    List<String> res = new ArrayList<>();\n    public List<String> generateParenthesis(int n) {\n        if(n==0) return res;\n        dfs(n,n,"");\n        return res;\n    }\n\n    public void dfs(int left,int right,String curStr){\n        if(left==0&&right==0){\n            res.add(curStr);\n            return;\n        }\n\n        if(left>0){\n            dfs(left-1,right,curStr+"(");\n        }\n        if(right>left){\n            dfs(left,right-1,curStr+")");\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# Java代码2\n\nclass Solution {\n    public List<String> generateParenthesis(int n) {\n        List<String> res = new ArrayList();\n        backtrack(res, new StringBuilder(), 0, 0, n);\n        return res;\n    }\n\n    public void backtrack(List<String> res,StringBuilder cur,int left,int right,int max){\n        if(cur.length()==max*2){\n            res.add(cur.toString());\n            return;\n        }\n        if(left<max){\n            cur.append(\'(\');\n            backtrack(res,cur,left+1,right,max);\n            cur.deleteCharAt(cur.length()-1);\n        }\n        if(right<left){\n            cur.append(\')\');\n            backtrack(res,cur,left,right+1,max);\n            cur.deleteCharAt(cur.length()-1);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n',normalizedContent:'# leetcode-22-括号生成\n\n数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。\n\n示例 1:\n\n输入：n = 3\n输出：[\n       "((()))",\n       "(()())",\n       "(())()",\n       "()(())",\n       "()()()"\n     ]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 解题思路\n\n方法1、dfs：\n\n深度优先遍历选择左括号和右括号，由于string拼接每次会产生一个新的string对象，所以传入的字符串不会影响其他结果，当左括号>0时，左括号-1进入下一次拼接。只有当左右括号数目相等为n的时候，拼接的括号才是合法的，此时加入到最终结果，返回上一层。当左括号用完了的时候进行右括号的拼接\n\n方法2、回溯：\n\n回溯法基本上和dfs一致，只是这里的回溯需要手动回溯，由于string每次生成一个新的string对象耗时比较多，所以可以用stringbuilder，然而stringbuilder拼接的时候会把上一次的字符记录着，所以在dfs之后需要手动回溯，即删除上一层拼接的字符cur.deletecharat(cur.length()-1);\n\n\n# java代码\n\nclass solution {\n    list<string> res = new arraylist<>();\n    public list<string> generateparenthesis(int n) {\n        if(n==0) return res;\n        dfs(n,n,"");\n        return res;\n    }\n\n    public void dfs(int left,int right,string curstr){\n        if(left==0&&right==0){\n            res.add(curstr);\n            return;\n        }\n\n        if(left>0){\n            dfs(left-1,right,curstr+"(");\n        }\n        if(right>left){\n            dfs(left,right-1,curstr+")");\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# java代码2\n\nclass solution {\n    public list<string> generateparenthesis(int n) {\n        list<string> res = new arraylist();\n        backtrack(res, new stringbuilder(), 0, 0, n);\n        return res;\n    }\n\n    public void backtrack(list<string> res,stringbuilder cur,int left,int right,int max){\n        if(cur.length()==max*2){\n            res.add(cur.tostring());\n            return;\n        }\n        if(left<max){\n            cur.append(\'(\');\n            backtrack(res,cur,left+1,right,max);\n            cur.deletecharat(cur.length()-1);\n        }\n        if(right<left){\n            cur.append(\')\');\n            backtrack(res,cur,left,right+1,max);\n            cur.deletecharat(cur.length()-1);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-23-合并K个排序链表",frontmatter:{title:"LeetCode-23-合并K个排序链表",date:"2020-06-07T20:09:48.000Z",description:"合并K个排序链表",tags:["链表","分治","Java","Hard"],keywords:"链表,分治,Java,Hard,LeetCode",permalink:"/pages/e24301/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/27.LeetCode-23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8.html",relativePath:"06.算法/02.LeetCode/27.LeetCode-23-合并K个排序链表.md",key:"v-7543bffe",path:"/pages/e24301/",headers:[{level:2,title:"LeetCode-23-合并K个排序链表",slug:"leetcode-23-合并k个排序链表",normalizedTitle:"leetcode-23-合并k个排序链表",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:168},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:1071},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:2466},{level:3,title:"Java代码3",slug:"java代码3",normalizedTitle:"java代码3",charIndex:3441}],headersStr:"LeetCode-23-合并K个排序链表 解题思路 Java代码 Java代码2 Java代码3",content:"# LeetCode-23-合并K个排序链表\n\n合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。\n\n示例 1:\n\n输入:\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\n输出: 1->1->2->3->4->4->5->6\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 解题思路\n\n相关链接：\n\n * {% post_link LeetCode-21-合并两个有序链表 %}\n\n方法1、分治+递归+自底向上：\n\n利用了归并排序分治的思想，对于一组链表，如果能够将每个链表两两拆分，那么问题就会简化为对两个链表的合并，合并之后的两两链表变为一个链表，再和另外一组已经合并成一个的链表合并，这个是自底向上的过程。\n\n两个链表的合并过程与LeetCode21一致，所以本题只需要研究如何进行链表划分，并判断返回条件\n\n * 返回条件：\n   \n   当链表长度为空，返回null；\n   \n   当链表长度为1，返回list[0];\n   \n   当链表长度为2，需要返回两个链表的合并\n\n * 链表划分：\n   \n   直接进行二分即可，mid左边的给l1数组，用于存储左边的一组链表；mid右边的给l2数组，用于存储右边的一组链表\n\n * 开启递归：\n   \n   拆分左边的多组链表，并进行合并；\n   \n   拆分右边的多组链表，并进行合并；\n   \n   返回：最后的左右链表的合并\n\n方法2、顺序遍历：\n\n这种方法就是暴力破解，一个一个遍历链表组中的链表，然后进行合并即可，最终返回的就是顺序排序的合并链表\n\n方法3、优先队列：\n\n前提知识：\n\n优先队列本身由最小堆实现，对于基础类型不需要重写Comparator接口，就可以实现默认加入数据之后队列是从小到大排序。在本题中，需要将链表从小到大的放入优先队列中，链表不是基础类型，所以需要重写Comparator接口将原本的v1.compareTo(v2)比较转化为v1.val和v2.val分别代表链表中的头结点值。这里采用匿名函数的实现方式\n\n在Comparator接口中，排序的判断依据如下：\n\n * 如果v1>v2，return 1\n * 如果v1<v2，return -1\n * 如果v1==v2，return 0\n\n题目思路：\n\n将所有链表的头结点放进去，由于是最小堆，所以每次就让队列中最小的出队，操作为pq.poll()，之后让出队的节点的下一个节点入队，再出队优先队列中的最小值，直到队列为空\n\n\n# Java代码\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        if(lists.length == 0) return null;\n        if(lists.length == 1) return lists[0];\n        if(lists.length == 2) return mergeTwoLists(lists[0],lists[1]);\n        int mid = lists.length/2;\n        ListNode[] l1 = new ListNode[mid];\n        for(int i=0;i<mid;i++){\n            l1[i] = lists[i];\n        }\n        ListNode[] l2 = new ListNode[lists.length-mid];\n        for(int i=mid,j=0;i<lists.length;i++,j++){\n            l2[j] = lists[i];\n        }\n        return mergeTwoLists(mergeKLists(l1),mergeKLists(l2));\n    }\n\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        if(l1==null) return l2;\n        if(l2==null) return l1;\n        ListNode mergehead = null;\n        if(l1.val<l2.val){\n            mergehead = l1;\n            mergehead.next = mergeTwoLists(l1.next,l2);\n        }else{\n            mergehead = l2;\n            mergehead.next = mergeTwoLists(l1,l2.next);\n        }\n        return mergehead;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# Java代码2\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        ListNode res = null;\n        for(int i=0;i<lists.length;i++){\n            res = mergeTwoLists(res,lists[i]);\n        }\n        return res;\n    }\n\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        if(l1==null) return l2;\n        if(l2==null) return l1;\n        ListNode mergehead = null;\n        if(l1.val<l2.val){\n            mergehead = l1;\n            mergehead.next = mergeTwoLists(l1.next,l2);\n        }else{\n            mergehead = l2;\n            mergehead.next = mergeTwoLists(l1,l2.next);\n        }\n        return mergehead;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# Java代码3\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        if(lists.length==0) return null;\n        Queue<ListNode> pq = new PriorityQueue<>((v1, v2) -> v1.val - v2.val);\n        ListNode head = new ListNode(0);\n        ListNode cur = head;\n        for(ListNode list:lists){\n            if(list!=null)\n                pq.offer(list);\n        }\n        while(!pq.isEmpty()){\n            ListNode minNode = pq.poll();\n            cur.next = minNode;\n            cur = cur.next;\n            if(minNode.next!=null){\n                pq.offer(minNode.next);\n            }\n        }\n        return head.next;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n",normalizedContent:"# leetcode-23-合并k个排序链表\n\n合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。\n\n示例 1:\n\n输入:\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\n输出: 1->1->2->3->4->4->5->6\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 解题思路\n\n相关链接：\n\n * {% post_link leetcode-21-合并两个有序链表 %}\n\n方法1、分治+递归+自底向上：\n\n利用了归并排序分治的思想，对于一组链表，如果能够将每个链表两两拆分，那么问题就会简化为对两个链表的合并，合并之后的两两链表变为一个链表，再和另外一组已经合并成一个的链表合并，这个是自底向上的过程。\n\n两个链表的合并过程与leetcode21一致，所以本题只需要研究如何进行链表划分，并判断返回条件\n\n * 返回条件：\n   \n   当链表长度为空，返回null；\n   \n   当链表长度为1，返回list[0];\n   \n   当链表长度为2，需要返回两个链表的合并\n\n * 链表划分：\n   \n   直接进行二分即可，mid左边的给l1数组，用于存储左边的一组链表；mid右边的给l2数组，用于存储右边的一组链表\n\n * 开启递归：\n   \n   拆分左边的多组链表，并进行合并；\n   \n   拆分右边的多组链表，并进行合并；\n   \n   返回：最后的左右链表的合并\n\n方法2、顺序遍历：\n\n这种方法就是暴力破解，一个一个遍历链表组中的链表，然后进行合并即可，最终返回的就是顺序排序的合并链表\n\n方法3、优先队列：\n\n前提知识：\n\n优先队列本身由最小堆实现，对于基础类型不需要重写comparator接口，就可以实现默认加入数据之后队列是从小到大排序。在本题中，需要将链表从小到大的放入优先队列中，链表不是基础类型，所以需要重写comparator接口将原本的v1.compareto(v2)比较转化为v1.val和v2.val分别代表链表中的头结点值。这里采用匿名函数的实现方式\n\n在comparator接口中，排序的判断依据如下：\n\n * 如果v1>v2，return 1\n * 如果v1<v2，return -1\n * 如果v1==v2，return 0\n\n题目思路：\n\n将所有链表的头结点放进去，由于是最小堆，所以每次就让队列中最小的出队，操作为pq.poll()，之后让出队的节点的下一个节点入队，再出队优先队列中的最小值，直到队列为空\n\n\n# java代码\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode(int x) { val = x; }\n * }\n */\nclass solution {\n    public listnode mergeklists(listnode[] lists) {\n        if(lists.length == 0) return null;\n        if(lists.length == 1) return lists[0];\n        if(lists.length == 2) return mergetwolists(lists[0],lists[1]);\n        int mid = lists.length/2;\n        listnode[] l1 = new listnode[mid];\n        for(int i=0;i<mid;i++){\n            l1[i] = lists[i];\n        }\n        listnode[] l2 = new listnode[lists.length-mid];\n        for(int i=mid,j=0;i<lists.length;i++,j++){\n            l2[j] = lists[i];\n        }\n        return mergetwolists(mergeklists(l1),mergeklists(l2));\n    }\n\n    public listnode mergetwolists(listnode l1, listnode l2) {\n        if(l1==null) return l2;\n        if(l2==null) return l1;\n        listnode mergehead = null;\n        if(l1.val<l2.val){\n            mergehead = l1;\n            mergehead.next = mergetwolists(l1.next,l2);\n        }else{\n            mergehead = l2;\n            mergehead.next = mergetwolists(l1,l2.next);\n        }\n        return mergehead;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# java代码2\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode(int x) { val = x; }\n * }\n */\nclass solution {\n    public listnode mergeklists(listnode[] lists) {\n        listnode res = null;\n        for(int i=0;i<lists.length;i++){\n            res = mergetwolists(res,lists[i]);\n        }\n        return res;\n    }\n\n    public listnode mergetwolists(listnode l1, listnode l2) {\n        if(l1==null) return l2;\n        if(l2==null) return l1;\n        listnode mergehead = null;\n        if(l1.val<l2.val){\n            mergehead = l1;\n            mergehead.next = mergetwolists(l1.next,l2);\n        }else{\n            mergehead = l2;\n            mergehead.next = mergetwolists(l1,l2.next);\n        }\n        return mergehead;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# java代码3\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode(int x) { val = x; }\n * }\n */\nclass solution {\n    public listnode mergeklists(listnode[] lists) {\n        if(lists.length==0) return null;\n        queue<listnode> pq = new priorityqueue<>((v1, v2) -> v1.val - v2.val);\n        listnode head = new listnode(0);\n        listnode cur = head;\n        for(listnode list:lists){\n            if(list!=null)\n                pq.offer(list);\n        }\n        while(!pq.isempty()){\n            listnode minnode = pq.poll();\n            cur.next = minnode;\n            cur = cur.next;\n            if(minnode.next!=null){\n                pq.offer(minnode.next);\n            }\n        }\n        return head.next;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-31-下一个排列",frontmatter:{title:"LeetCode-31-下一个排列",date:"2020-07-05T09:46:12.000Z",description:"下一个排列",tags:["数组","Java","Medium"],keywords:"数组,Java,Medium,LeetCode",permalink:"/pages/d9a097/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/28.LeetCode-31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97.html",relativePath:"06.算法/02.LeetCode/28.LeetCode-31-下一个排列.md",key:"v-61f87bf8",path:"/pages/d9a097/",headers:[{level:2,title:"LeetCode-31-下一个排列",slug:"leetcode-31-下一个排列",normalizedTitle:"leetcode-31-下一个排列",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:198},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:1016}],headersStr:"LeetCode-31-下一个排列 解题思路 Java代码",content:"# LeetCode-31-下一个排列\n\n实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。\n\n如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。\n\n必须原地修改，只允许使用额外常数空间。\n\n以下是一些例子，输入位于左侧列，其相应输出位于右侧列。 1,2,3 → 1,3,2 3,2,1 → 1,2,3 1,1,5 → 1,5,1\n\n\n# 解题思路\n\n思路出处\n\n推导：\n\n如何得到这样的排列顺序？这是本文的重点。我们可以这样来分析：\n\n 1. 我们希望下一个数比当前数大，这样才满足“下一个排列”的定义。因此只需要将后面的「大数」与前面的「小数」交换，就能得到一个更大的数。比如 123456，将 5 和 6 交换就能得到一个更大的数 123465。\n\n 2. 我们还希望下一个数增加的幅度尽可能的小，这样才满足“下一个排列与当前排列紧邻“的要求。为了满足这个要求，我们需要：\n    \n    1. 在尽可能靠右的低位进行交换，需要从后向前查找\n    \n    2. 将一个 尽可能小的「大数」 与前面的「小数」交换。比如 123465，下一个排列应该把 5 和 4 交换而不是把 6 和 4 交换\n    \n    3. 将「大数」换到前面后，需要将「大数」后面的所有数重置为升序，升序排列就是最小的排列。以 123465 为例：首先按照上一步，交换 5 和 4，得到 123564；然后需要将 5 之后的数重置为升序，得到 123546。显然 123546 比 123564 更小，123546 就是 123465 的下一个排列\n       \n       以上就是求“下一个排列”的分析过程。\n\n算法流程：\n\n标准的“下一个排列”算法可以描述为：\n\n 1. 从后向前查找第一个相邻升序的元素对 (i,j)，满足 A[i] < A[j]。此时 [j,end) 必然是降序\n 2. 在 [j,end) 从后向前查找第一个满足 A[i] < A[k] 的 k。A[i]、A[k] 分别就是上文所说的「小数」、「大数」\n 3. 将 A[i] 与 A[k] 交换\n 4. 可以断定这时 [j,end) 必然是降序，逆置 [j,end)，使其升序\n 5. 如果在步骤 1 找不到符合的相邻元素对，说明当前 [begin,end) 为一个降序顺序，则直接跳到步骤 4\n\n\n# Java代码\n\nclass Solution {\n    public void nextPermutation(int[] nums) {\n        int len = nums.length;\n        if (len < 2) return;\n        int i = len - 2;\n        int j = len - 1;\n        int k = len - 1;\n        // 从后向前找第一个正序，这里最后i指向的是逆序起始位置\n        while (i >= 0 && nums[i] >= nums[j]) {\n            i--;\n            j--;\n        }\n        if (i >= 0) {\n            // 从后向前找第一个比nums[j]大的元素，进行交换\n            while (nums[i] >= nums[k]) {\n                k--;\n            }\n            swap(nums, i, k);\n        }\n        // 翻转交换点后的数组，使后面的数组升序，保证整个数组是下一个最大数组\n        reverse(nums, j, len - 1);\n    }\n\n    public void swap(int[] nums, int i, int j) {\n        int temp = nums[j];\n        nums[j] = nums[i];\n        nums[i] = temp;\n    }\n\n    public void reverse(int[] nums, int start, int end) {\n        while (start < end) {\n            int temp = nums[end];\n            nums[end] = nums[start];\n            nums[start] = temp;\n            start++;\n            end--;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n",normalizedContent:"# leetcode-31-下一个排列\n\n实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。\n\n如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。\n\n必须原地修改，只允许使用额外常数空间。\n\n以下是一些例子，输入位于左侧列，其相应输出位于右侧列。 1,2,3 → 1,3,2 3,2,1 → 1,2,3 1,1,5 → 1,5,1\n\n\n# 解题思路\n\n思路出处\n\n推导：\n\n如何得到这样的排列顺序？这是本文的重点。我们可以这样来分析：\n\n 1. 我们希望下一个数比当前数大，这样才满足“下一个排列”的定义。因此只需要将后面的「大数」与前面的「小数」交换，就能得到一个更大的数。比如 123456，将 5 和 6 交换就能得到一个更大的数 123465。\n\n 2. 我们还希望下一个数增加的幅度尽可能的小，这样才满足“下一个排列与当前排列紧邻“的要求。为了满足这个要求，我们需要：\n    \n    1. 在尽可能靠右的低位进行交换，需要从后向前查找\n    \n    2. 将一个 尽可能小的「大数」 与前面的「小数」交换。比如 123465，下一个排列应该把 5 和 4 交换而不是把 6 和 4 交换\n    \n    3. 将「大数」换到前面后，需要将「大数」后面的所有数重置为升序，升序排列就是最小的排列。以 123465 为例：首先按照上一步，交换 5 和 4，得到 123564；然后需要将 5 之后的数重置为升序，得到 123546。显然 123546 比 123564 更小，123546 就是 123465 的下一个排列\n       \n       以上就是求“下一个排列”的分析过程。\n\n算法流程：\n\n标准的“下一个排列”算法可以描述为：\n\n 1. 从后向前查找第一个相邻升序的元素对 (i,j)，满足 a[i] < a[j]。此时 [j,end) 必然是降序\n 2. 在 [j,end) 从后向前查找第一个满足 a[i] < a[k] 的 k。a[i]、a[k] 分别就是上文所说的「小数」、「大数」\n 3. 将 a[i] 与 a[k] 交换\n 4. 可以断定这时 [j,end) 必然是降序，逆置 [j,end)，使其升序\n 5. 如果在步骤 1 找不到符合的相邻元素对，说明当前 [begin,end) 为一个降序顺序，则直接跳到步骤 4\n\n\n# java代码\n\nclass solution {\n    public void nextpermutation(int[] nums) {\n        int len = nums.length;\n        if (len < 2) return;\n        int i = len - 2;\n        int j = len - 1;\n        int k = len - 1;\n        // 从后向前找第一个正序，这里最后i指向的是逆序起始位置\n        while (i >= 0 && nums[i] >= nums[j]) {\n            i--;\n            j--;\n        }\n        if (i >= 0) {\n            // 从后向前找第一个比nums[j]大的元素，进行交换\n            while (nums[i] >= nums[k]) {\n                k--;\n            }\n            swap(nums, i, k);\n        }\n        // 翻转交换点后的数组，使后面的数组升序，保证整个数组是下一个最大数组\n        reverse(nums, j, len - 1);\n    }\n\n    public void swap(int[] nums, int i, int j) {\n        int temp = nums[j];\n        nums[j] = nums[i];\n        nums[i] = temp;\n    }\n\n    public void reverse(int[] nums, int start, int end) {\n        while (start < end) {\n            int temp = nums[end];\n            nums[end] = nums[start];\n            nums[start] = temp;\n            start++;\n            end--;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-32-最长有效括号",frontmatter:{title:"LeetCode-32-最长有效括号",date:"2020-07-17T09:43:11.000Z",description:"最长有效括号",tags:["字符串","DP","Java","Hard"],keywords:"字符串,Java,Hard,LeetCode",permalink:"/pages/bcf8b4/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/29.LeetCode-32-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.html",relativePath:"06.算法/02.LeetCode/29.LeetCode-32-最长有效括号.md",key:"v-50a84ff8",path:"/pages/bcf8b4/",headers:[{level:2,title:"LeetCode-32-最长有效括号",slug:"leetcode-32-最长有效括号",normalizedTitle:"leetcode-32-最长有效括号",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:189},{level:3,title:"Java代码1",slug:"java代码1",normalizedTitle:"java代码1",charIndex:1256},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:1983},{level:3,title:"Java代码3",slug:"java代码3",normalizedTitle:"java代码3",charIndex:2634}],headersStr:"LeetCode-32-最长有效括号 解题思路 Java代码1 Java代码2 Java代码3",content:"# LeetCode-32-最长有效括号\n\n给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。\n\n示例1：\n\n输入: \"(()\"\n输出: 2\n解释: 最长有效括号子串为 \"()\"\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2：\n\n输入: \")()())\"\n输出: 4\n解释: 最长有效括号子串为 \"()()\"\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n\n# 解题思路\n\n方法1、动态规划：\n\n详见链接：https://leetcode-cn.com/problems/longest-valid-parentheses/solution/zui-chang-you-xiao-gua-hao-by-leetcode-solution/\n\n方法2、栈：\n\n具体做法是我们始终保持栈底元素为当前已经遍历过的元素中「最后一个没有被匹配的右括号的下标」，这样的做法主要是考虑了边界条件的处理，栈里其他元素维护左括号的下标：\n\n * 对于遇到的每个‘(’ ，我们将它的下标放入栈中\n * 对于遇到的每个 ‘)’ ，我们先弹出栈顶元素表示匹配了当前右括号：\n   * 如果栈为空，说明当前的右括号为没有被匹配的右括号，我们将其下标放入栈中来更新我们之前提到的「最后一个没有被匹配的右括号的下标」\n   * 如果栈不为空，当前右括号的下标减去栈顶元素即为「以该右括号为结尾的最长有效括号的长度」\n\n我们从前往后遍历字符串并更新答案即可。\n\n需要注意的是，如果一开始栈为空，第一个字符为左括号的时候我们会将其放入栈中，这样就不满足提及的「最后一个没有被匹配的右括号的下标」，为了保持统一，我们在一开始的时候往栈中放入一个值为 −1 的元素。\n\n方法3、双指针：\n\n在此方法中，我们利用两个计数器 left 和right 。首先，我们从左到右遍历字符串，对于遇到的每个‘(’，我们增加 left 计数器，对于遇到的每个‘)’ ，我们增加 right 计数器。每当 left 计数器与 right 计数器相等时，我们计算当前有效字符串的长度，并且记录目前为止找到的最长子字符串。当 right 计数器比 left 计数器大时，我们将 left 和 right 计数器同时变回 0。\n\n这样的做法贪心地考虑了以当前字符下标结尾的有效括号长度，每次当右括号数量多于左括号数量的时候之前的字符我们都扔掉不再考虑，重新从下一个字符开始计算，但这样会漏掉一种情况，就是遍历的时候左括号的数量始终大于右括号的数量，即 (() ，这种时候最长有效括号是求不出来的。\n\n解决的方法也很简单，我们只需要从右往左遍历用类似的方法计算即可，只是这个时候判断条件反了过来：\n\n当left 计数器比right 计数器大时，我们将left 和right 计数器同时变回 0 当 left 计数器与 right 计数器相等时，我们计算当前有效字符串的长度，并且记录目前为止找到的最长子字符串 这样我们就能涵盖所有情况从而求解出答案。\n\n\n# Java代码1\n\nclass Solution {\n    public int longestValidParentheses(String s) {\n        int maxans = 0;\n        int dp[] = new int[s.length()];\n        for (int i = 1; i < s.length(); i++) {\n            if (s.charAt(i) == ')') {\n                if (s.charAt(i - 1) == '(') {\n                    dp[i] = (i >= 2 ? dp[i - 2] : 0) + 2;\n                } else if (i - dp[i - 1] > 0 && s.charAt(i - dp[i - 1] - 1) == '(') {\n                    dp[i] = dp[i - 1] + ((i - dp[i - 1]) >= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2;\n                }\n                maxans = Math.max(maxans, dp[i]);\n            }\n        }\n        return maxans;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# Java代码2\n\nclass Solution {\n    public int longestValidParentheses(String s) {\n        int max = 0;\n        Stack<Integer> stack = new Stack<>();\n        stack.push(-1);\n        for(int i=0;i<s.length();i++){\n            if(s.charAt(i)=='('){\n                stack.push(i);\n            }else{\n                stack.pop();\n                if(stack.isEmpty()){\n                    stack.push(i);\n                }else{\n                    max = Math.max(max,i-stack.peek());\n                }\n            }\n        }\n        return max;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# Java代码3\n\nclass Solution {\n    public int longestValidParentheses(String s) {\n        int left = 0, right = 0, maxlength = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '(') {\n                left++;\n            } else {\n                right++;\n            }\n            if (left == right) {\n                maxlength = Math.max(maxlength, 2 * right);\n            } else if (right > left) {\n                left = 0;\n                right = 0;\n            }\n        }\n        left = 0;\n        right = 0;\n        for (int i = s.length() - 1; i >= 0; i--) {\n            if (s.charAt(i) == '(') {\n                left++;\n            } else {\n                right++;\n            }\n            if (left == right) {\n                maxlength = Math.max(maxlength, 2 * left);\n            } else if (left > right) {\n                left = 0;\n                right = 0;\n            }\n        }\n        return maxlength;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n",normalizedContent:"# leetcode-32-最长有效括号\n\n给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。\n\n示例1：\n\n输入: \"(()\"\n输出: 2\n解释: 最长有效括号子串为 \"()\"\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2：\n\n输入: \")()())\"\n输出: 4\n解释: 最长有效括号子串为 \"()()\"\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n\n# 解题思路\n\n方法1、动态规划：\n\n详见链接：https://leetcode-cn.com/problems/longest-valid-parentheses/solution/zui-chang-you-xiao-gua-hao-by-leetcode-solution/\n\n方法2、栈：\n\n具体做法是我们始终保持栈底元素为当前已经遍历过的元素中「最后一个没有被匹配的右括号的下标」，这样的做法主要是考虑了边界条件的处理，栈里其他元素维护左括号的下标：\n\n * 对于遇到的每个‘(’ ，我们将它的下标放入栈中\n * 对于遇到的每个 ‘)’ ，我们先弹出栈顶元素表示匹配了当前右括号：\n   * 如果栈为空，说明当前的右括号为没有被匹配的右括号，我们将其下标放入栈中来更新我们之前提到的「最后一个没有被匹配的右括号的下标」\n   * 如果栈不为空，当前右括号的下标减去栈顶元素即为「以该右括号为结尾的最长有效括号的长度」\n\n我们从前往后遍历字符串并更新答案即可。\n\n需要注意的是，如果一开始栈为空，第一个字符为左括号的时候我们会将其放入栈中，这样就不满足提及的「最后一个没有被匹配的右括号的下标」，为了保持统一，我们在一开始的时候往栈中放入一个值为 −1 的元素。\n\n方法3、双指针：\n\n在此方法中，我们利用两个计数器 left 和right 。首先，我们从左到右遍历字符串，对于遇到的每个‘(’，我们增加 left 计数器，对于遇到的每个‘)’ ，我们增加 right 计数器。每当 left 计数器与 right 计数器相等时，我们计算当前有效字符串的长度，并且记录目前为止找到的最长子字符串。当 right 计数器比 left 计数器大时，我们将 left 和 right 计数器同时变回 0。\n\n这样的做法贪心地考虑了以当前字符下标结尾的有效括号长度，每次当右括号数量多于左括号数量的时候之前的字符我们都扔掉不再考虑，重新从下一个字符开始计算，但这样会漏掉一种情况，就是遍历的时候左括号的数量始终大于右括号的数量，即 (() ，这种时候最长有效括号是求不出来的。\n\n解决的方法也很简单，我们只需要从右往左遍历用类似的方法计算即可，只是这个时候判断条件反了过来：\n\n当left 计数器比right 计数器大时，我们将left 和right 计数器同时变回 0 当 left 计数器与 right 计数器相等时，我们计算当前有效字符串的长度，并且记录目前为止找到的最长子字符串 这样我们就能涵盖所有情况从而求解出答案。\n\n\n# java代码1\n\nclass solution {\n    public int longestvalidparentheses(string s) {\n        int maxans = 0;\n        int dp[] = new int[s.length()];\n        for (int i = 1; i < s.length(); i++) {\n            if (s.charat(i) == ')') {\n                if (s.charat(i - 1) == '(') {\n                    dp[i] = (i >= 2 ? dp[i - 2] : 0) + 2;\n                } else if (i - dp[i - 1] > 0 && s.charat(i - dp[i - 1] - 1) == '(') {\n                    dp[i] = dp[i - 1] + ((i - dp[i - 1]) >= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2;\n                }\n                maxans = math.max(maxans, dp[i]);\n            }\n        }\n        return maxans;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# java代码2\n\nclass solution {\n    public int longestvalidparentheses(string s) {\n        int max = 0;\n        stack<integer> stack = new stack<>();\n        stack.push(-1);\n        for(int i=0;i<s.length();i++){\n            if(s.charat(i)=='('){\n                stack.push(i);\n            }else{\n                stack.pop();\n                if(stack.isempty()){\n                    stack.push(i);\n                }else{\n                    max = math.max(max,i-stack.peek());\n                }\n            }\n        }\n        return max;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# java代码3\n\nclass solution {\n    public int longestvalidparentheses(string s) {\n        int left = 0, right = 0, maxlength = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charat(i) == '(') {\n                left++;\n            } else {\n                right++;\n            }\n            if (left == right) {\n                maxlength = math.max(maxlength, 2 * right);\n            } else if (right > left) {\n                left = 0;\n                right = 0;\n            }\n        }\n        left = 0;\n        right = 0;\n        for (int i = s.length() - 1; i >= 0; i--) {\n            if (s.charat(i) == '(') {\n                left++;\n            } else {\n                right++;\n            }\n            if (left == right) {\n                maxlength = math.max(maxlength, 2 * left);\n            } else if (left > right) {\n                left = 0;\n                right = 0;\n            }\n        }\n        return maxlength;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-33-搜索旋转排序数组",frontmatter:{title:"LeetCode-33-搜索旋转排序数组",date:"2020-07-10T09:30:50.000Z",description:"搜索旋转排序数组",tags:["Java","数组","Medium"],keywords:"Java,数组,Medium,LeetCode",permalink:"/pages/1b9196/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/30.LeetCode-33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84.html",relativePath:"06.算法/02.LeetCode/30.LeetCode-33-搜索旋转排序数组.md",key:"v-7691670a",path:"/pages/1b9196/",headers:[{level:2,title:"LeetCode-33-搜索旋转排序数组",slug:"leetcode-33-搜索旋转排序数组",normalizedTitle:"leetcode-33-搜索旋转排序数组",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:323},{level:3,title:"Java代码1",slug:"java代码1",normalizedTitle:"java代码1",charIndex:1068},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:2401}],headersStr:"LeetCode-33-搜索旋转排序数组 解题思路 Java代码1 Java代码2",content:"# LeetCode-33-搜索旋转排序数组\n\n假设按照升序排序的数组在预先未知的某个点上进行了旋转。\n\n( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。\n\n搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。\n\n你可以假设数组中不存在重复的元素。\n\n你的算法时间复杂度必须是 O(log n) 级别。\n\n示例1：\n\n输入: nums = [4,5,6,7,0,1,2], target = 0\n输出: 4\n\n\n1\n2\n\n1\n2\n\n\n示例2：\n\n输入: nums = [4,5,6,7,0,1,2], target = 3\n输出: -1\n\n\n1\n2\n\n1\n2\n\n\n\n# 解题思路\n\n方法1、双指针+根据规则的if-else：\n\n这种方法应该是不符合本题的时间复杂度，但又不同于直接顺序遍历\n\n用于铺垫二分查找解法。\n\n根据旋转的规则，旋转点可能出现在数组中间，也可能出现旋转后数组不变的情况\n\n假设旋转点出现在数组中间：\n\n * 数组分成2部分有序，可以通过判断target和low、high之间的大小来确定target可能在哪一半数组中\n\n * 其次，定义旋转边界，左半边数组升序排列，右半边数组从右向左降序排列\n   \n   如果从low开始向右遍历，则满足nums[i]-num[i-1]>0，当小于0时，则为旋转边界。如果到达边界都没有找到，说明查找的数不在数组中，此时返回-1，如果查找过程中找到target则返回数组下标。\n   \n   从high开始向左遍历情况类似。\n\n假设旋转点出现在数组之外：\n\n * 则数组直接有序，这时候线性遍历或者进行二分查找均可，这里简单写了线性遍历\n\n特例判断：\n\n * 当target等于low和high的时候，返回对应下标\n * 当target>low时，进行左子数组遍历\n * 当target<high时，进行右子数组遍历\n * 如果数组为空或者数组长度为0，返回-1\n * 如果数组长度为1，比较数组值是否等于target，等于则返回该值，不等于则返回-1\n\n方法2、二分查找：\n\n在上面一个方法中，虽然划分了数组，但比较过程仍然只是线性遍历\n\n我们可以进一步利用二分查找来进行搜索\n\n * 如果中间的数小于最右边的数，则右半段是有序的\n\n * 如果中间的数大于最右边的数，则左半段是有序的\n\n * 我们只需要在有序的半段里用首尾两个数来判断目标值是否在这个区域中，就可以确定保留哪半边数组\n\n\n * # Java代码1\n\nclass Solution {\n    public int search(int[] nums, int target) {\n        int len = nums.length;\n        if(nums==null||len==0) return -1;\n        int low = nums[0];\n        int high = nums[len-1];\n        if(target==low) return 0;\n        if(target==high) return len-1;\n        if(len==1) return nums[0]==target?nums[0]:-1;\n        if(low<high){\n            for(int i=0;i<len-1;i++){\n                if(target==nums[i]) return i;\n            }\n        }else{\n            if(target>low){\n                for(int i=1;i<len-1;i++){\n                    if(target==nums[i]) return i;\n                    if(nums[i]-nums[i-1]>0){\n                        continue;\n                    }else{\n                        break;\n                    }\n                }\n            }else if(target<high){\n                for(int i=len-1;i>=0;i--){\n                    if(target==nums[i]) return i;\n                    if(nums[i]-nums[i-1]>0){\n                        continue;\n                    }else{\n                        break;\n                    }\n                }\n            }\n        }\n        return -1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# Java代码2\n\nclass Solution {\n    public int search(int[] nums, int target) {\n        int len = nums.length;\n        int left = 0, right = len-1;\n        while(left<=right){\n            int mid = (left+right)/2;\n            if(nums[mid]==target)\n                return mid;\n            else if(nums[mid]<nums[right]){ // 如果中间数小于右边，说明右边有序\n                if(nums[mid]<target && target<=nums[right])\n                    left = mid+1; // 缩小左边查找区间\n                else\n                    right = mid-1;\n            }\n            else{// 如果中间数大于右边，说明左边有序\n                if(nums[left]<=target && target<nums[mid]) \n                    right = mid-1; // 缩小右边查找区间\n                else\n                    left = mid+1;\n            }\n        }\n        return -1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n",normalizedContent:"# leetcode-33-搜索旋转排序数组\n\n假设按照升序排序的数组在预先未知的某个点上进行了旋转。\n\n( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。\n\n搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。\n\n你可以假设数组中不存在重复的元素。\n\n你的算法时间复杂度必须是 o(log n) 级别。\n\n示例1：\n\n输入: nums = [4,5,6,7,0,1,2], target = 0\n输出: 4\n\n\n1\n2\n\n1\n2\n\n\n示例2：\n\n输入: nums = [4,5,6,7,0,1,2], target = 3\n输出: -1\n\n\n1\n2\n\n1\n2\n\n\n\n# 解题思路\n\n方法1、双指针+根据规则的if-else：\n\n这种方法应该是不符合本题的时间复杂度，但又不同于直接顺序遍历\n\n用于铺垫二分查找解法。\n\n根据旋转的规则，旋转点可能出现在数组中间，也可能出现旋转后数组不变的情况\n\n假设旋转点出现在数组中间：\n\n * 数组分成2部分有序，可以通过判断target和low、high之间的大小来确定target可能在哪一半数组中\n\n * 其次，定义旋转边界，左半边数组升序排列，右半边数组从右向左降序排列\n   \n   如果从low开始向右遍历，则满足nums[i]-num[i-1]>0，当小于0时，则为旋转边界。如果到达边界都没有找到，说明查找的数不在数组中，此时返回-1，如果查找过程中找到target则返回数组下标。\n   \n   从high开始向左遍历情况类似。\n\n假设旋转点出现在数组之外：\n\n * 则数组直接有序，这时候线性遍历或者进行二分查找均可，这里简单写了线性遍历\n\n特例判断：\n\n * 当target等于low和high的时候，返回对应下标\n * 当target>low时，进行左子数组遍历\n * 当target<high时，进行右子数组遍历\n * 如果数组为空或者数组长度为0，返回-1\n * 如果数组长度为1，比较数组值是否等于target，等于则返回该值，不等于则返回-1\n\n方法2、二分查找：\n\n在上面一个方法中，虽然划分了数组，但比较过程仍然只是线性遍历\n\n我们可以进一步利用二分查找来进行搜索\n\n * 如果中间的数小于最右边的数，则右半段是有序的\n\n * 如果中间的数大于最右边的数，则左半段是有序的\n\n * 我们只需要在有序的半段里用首尾两个数来判断目标值是否在这个区域中，就可以确定保留哪半边数组\n\n\n * # java代码1\n\nclass solution {\n    public int search(int[] nums, int target) {\n        int len = nums.length;\n        if(nums==null||len==0) return -1;\n        int low = nums[0];\n        int high = nums[len-1];\n        if(target==low) return 0;\n        if(target==high) return len-1;\n        if(len==1) return nums[0]==target?nums[0]:-1;\n        if(low<high){\n            for(int i=0;i<len-1;i++){\n                if(target==nums[i]) return i;\n            }\n        }else{\n            if(target>low){\n                for(int i=1;i<len-1;i++){\n                    if(target==nums[i]) return i;\n                    if(nums[i]-nums[i-1]>0){\n                        continue;\n                    }else{\n                        break;\n                    }\n                }\n            }else if(target<high){\n                for(int i=len-1;i>=0;i--){\n                    if(target==nums[i]) return i;\n                    if(nums[i]-nums[i-1]>0){\n                        continue;\n                    }else{\n                        break;\n                    }\n                }\n            }\n        }\n        return -1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# java代码2\n\nclass solution {\n    public int search(int[] nums, int target) {\n        int len = nums.length;\n        int left = 0, right = len-1;\n        while(left<=right){\n            int mid = (left+right)/2;\n            if(nums[mid]==target)\n                return mid;\n            else if(nums[mid]<nums[right]){ // 如果中间数小于右边，说明右边有序\n                if(nums[mid]<target && target<=nums[right])\n                    left = mid+1; // 缩小左边查找区间\n                else\n                    right = mid-1;\n            }\n            else{// 如果中间数大于右边，说明左边有序\n                if(nums[left]<=target && target<nums[mid]) \n                    right = mid-1; // 缩小右边查找区间\n                else\n                    left = mid+1;\n            }\n        }\n        return -1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-39-组合总数",frontmatter:{title:"LeetCode-39-组合总数",date:"2020-07-05T11:01:10.000Z",description:"组合总数",tags:["数组","DFS","Java","Medium"],keywords:"数组,DFS,Java,Medium,LeetCode",permalink:"/pages/731f67/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/32.LeetCode-39-%E7%BB%84%E5%90%88%E6%80%BB%E6%95%B0.html",relativePath:"06.算法/02.LeetCode/32.LeetCode-39-组合总数.md",key:"v-55238b17",path:"/pages/731f67/",headers:[{level:2,title:"LeetCode-39-组合总数",slug:"leetcode-39-组合总数",normalizedTitle:"leetcode-39-组合总数",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:398},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:781}],headersStr:"LeetCode-39-组合总数 解题思路 Java代码",content:"# LeetCode-39-组合总数\n\n给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。\n\ncandidates 中的数字可以无限制重复被选取。\n\n说明：\n\n * 所有数字（包括 target）都是正整数。\n * 解集不能包含重复的组合。\n\n示例1：\n\n输入: candidates = [2,3,6,7], target = 7,\n所求解集为:\n[\n  [7],\n  [2,2,3]\n]\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n示例2：\n\n输入: candidates = [2,3,5], target = 8,\n所求解集为:\n[\n  [2,2,2,2],\n  [2,3,3],\n  [3,5]\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 解题思路\n\n方法1、DFS+回溯：\n\n排列组合的问题，一般也是全排列问题\n\n这类问题可以使用回溯法+递归解决\n\n基本思路：\n\n * 当target=7时，为根节点，进行分支选择\n * 当减到0或者负数的时候，就是到了叶子节点，进行返回\n * 当减到0时，进行结果集的保存，从根节点到叶子节点(0)的路径就是答案其中一个组合\n\n刚开始一定要在纸上画一棵递归树，写出示例的整个树结构，在明白最基本的算法怎么实现之后，根据题意需要考虑结果不重复的问题，于是就需要对这个树进行剪枝操作\n\n比如示例1中，可能的路径有[[2,2,3],[2,3,2],[3,2,2],[7]]\n\n而答案中只有[[7],[2,2,3]]，显然，重复的原因是在较深层的节点值考虑了之前选择过的元素\n\n剪枝流程：\n\n * 在搜索的时候，需要设置起点的下标start，避免选择之前选择过的节点\n\n\n# Java代码\n\nclass Solution {\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> res = new ArrayList<>();\n        int len = candidates.length;\n        if(len==0) return res;\n        List<Integer> arr = new ArrayList<>();\n        Arrays.sort(candidates);\n        backtrack(candidates,target,res,0,arr);\n        return res;\n    }\n\n    public void backtrack(int[] candidates,int target,List<List<Integer>> res,int i,List<Integer> tmp_list){\n        if(target<0) return;\n        if(target==0){\n            res.add(new ArrayList<>(tmp_list));\n            return;\n        }\n        // 如果start从0开始，则会遍历全部数组，选择重复的，记录start避免重复\n        for(int start=i;start<candidates.length;start++){\n            if(target<0) break;\n            tmp_list.add(candidates[start]);\n            backtrack(candidates,target-candidates[start],res,start,tmp_list);\n            tmp_list.remove(tmp_list.size()-1);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n",normalizedContent:"# leetcode-39-组合总数\n\n给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。\n\ncandidates 中的数字可以无限制重复被选取。\n\n说明：\n\n * 所有数字（包括 target）都是正整数。\n * 解集不能包含重复的组合。\n\n示例1：\n\n输入: candidates = [2,3,6,7], target = 7,\n所求解集为:\n[\n  [7],\n  [2,2,3]\n]\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n示例2：\n\n输入: candidates = [2,3,5], target = 8,\n所求解集为:\n[\n  [2,2,2,2],\n  [2,3,3],\n  [3,5]\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 解题思路\n\n方法1、dfs+回溯：\n\n排列组合的问题，一般也是全排列问题\n\n这类问题可以使用回溯法+递归解决\n\n基本思路：\n\n * 当target=7时，为根节点，进行分支选择\n * 当减到0或者负数的时候，就是到了叶子节点，进行返回\n * 当减到0时，进行结果集的保存，从根节点到叶子节点(0)的路径就是答案其中一个组合\n\n刚开始一定要在纸上画一棵递归树，写出示例的整个树结构，在明白最基本的算法怎么实现之后，根据题意需要考虑结果不重复的问题，于是就需要对这个树进行剪枝操作\n\n比如示例1中，可能的路径有[[2,2,3],[2,3,2],[3,2,2],[7]]\n\n而答案中只有[[7],[2,2,3]]，显然，重复的原因是在较深层的节点值考虑了之前选择过的元素\n\n剪枝流程：\n\n * 在搜索的时候，需要设置起点的下标start，避免选择之前选择过的节点\n\n\n# java代码\n\nclass solution {\n    public list<list<integer>> combinationsum(int[] candidates, int target) {\n        list<list<integer>> res = new arraylist<>();\n        int len = candidates.length;\n        if(len==0) return res;\n        list<integer> arr = new arraylist<>();\n        arrays.sort(candidates);\n        backtrack(candidates,target,res,0,arr);\n        return res;\n    }\n\n    public void backtrack(int[] candidates,int target,list<list<integer>> res,int i,list<integer> tmp_list){\n        if(target<0) return;\n        if(target==0){\n            res.add(new arraylist<>(tmp_list));\n            return;\n        }\n        // 如果start从0开始，则会遍历全部数组，选择重复的，记录start避免重复\n        for(int start=i;start<candidates.length;start++){\n            if(target<0) break;\n            tmp_list.add(candidates[start]);\n            backtrack(candidates,target-candidates[start],res,start,tmp_list);\n            tmp_list.remove(tmp_list.size()-1);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-34-在排序数组中查找元素的第一个和最后一个位置",frontmatter:{title:"LeetCode-34-在排序数组中查找元素的第一个和最后一个位置",date:"2020-07-25T15:33:38.000Z",description:"在排序数组中查找元素的第一个和最后一个位置",tags:["数组","Java","Medium"],keywords:"数组,Java,Medium,LeetCode",permalink:"/pages/1f0b71/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/31.LeetCode-34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE.html",relativePath:"06.算法/02.LeetCode/31.LeetCode-34-在排序数组中查找元素的第一个和最后一个位置.md",key:"v-715b54f6",path:"/pages/1f0b71/",headers:[{level:2,title:"LeetCode-34-在排序数组中查找元素的第一个和最后一个位置",slug:"leetcode-34-在排序数组中查找元素的第一个和最后一个位置",normalizedTitle:"leetcode-34-在排序数组中查找元素的第一个和最后一个位置",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:288},{level:3,title:"Java代码1",slug:"java代码1",normalizedTitle:"java代码1",charIndex:986},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:1806},{level:3,title:"Java代码3",slug:"java代码3",normalizedTitle:"java代码3",charIndex:2654},{level:3,title:"Java代码4",slug:"java代码4",normalizedTitle:"java代码4",charIndex:3564}],headersStr:"LeetCode-34-在排序数组中查找元素的第一个和最后一个位置 解题思路 Java代码1 Java代码2 Java代码3 Java代码4",content:"# LeetCode-34-在排序数组中查找元素的第一个和最后一个位置\n\n给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。\n\n你的算法时间复杂度必须是 O(log n) 级别。\n\n如果数组中不存在目标值，返回 [-1, -1]。\n\n示例1：\n\n输入: nums = [5,7,7,8,8,10], target = 8\n输出: [3,4]\n\n\n1\n2\n\n1\n2\n\n\n示例2：\n\n输入: nums = [5,7,7,8,8,10], target = 6\n输出: [-1,-1]\n\n\n1\n2\n\n1\n2\n\n\n\n# 解题思路\n\n方法1、双指针暴力法(low)：\n\n特例判断：\n\n * 当数组为空或数组长度为0时，直接返回[-1,1]\n * 当数组长度为1时，判断第一个数字是否等于target，等于则返回[0,0]，否则返回[-1,-1]\n\n初始化头尾指针\n\n移动头指针，直到找到第一个等于target的位置，如果找完了都没有找到，返回[-1,-1]\n\n移动尾指针，直到找到最后一个等于target的位置，如果找完了都没有找到，返回[-1,-1]\n\n当头尾指针相同时，说明只有一个target，返回当前位置[start,start]或[end,end]\n\n反之，返回头尾指针区间[start,end]\n\n方法2、二分查找(fast)：\n\n通过判断mid位置的数值，决定左右边界的移动\n\n当nums[mid]<target时，说明target在mid右方，start = mid+1\n\n当nums[mid]>target时，说明target在mid左方，end = mid-1\n\n当nums[mid]==target时，说明左右边界有一个地方等于target，这时候只需要查找另外一个边界等于target的即可，可以进行循环移动查找，最后返回[start,end]即可\n\n如果没有找到，返回[-1,-1]\n\n方法3、递归分治(low)：\n\n通过二分查找切分数组寻找左右子数组的target位置，迭代到只有一个，判断是否是目标值，返回一个都是当前index的数组，然后进行合并即可\n\n方法4、二次二分找左右边界(fast)：\n\n第一次二分找左边界，第二次二分找右边界，找左边界时向右逼近，找右边界时向左逼近\n\n\n# Java代码1\n\nclass Solution {\n    public int[] searchRange(int[] nums, int target) {\n        int len = nums.length;\n        if(nums==null||len==0) return new int[]{-1,-1};\n        if(len==1) return nums[0]==target? new int[]{0,0}: new int[]{-1,-1};\n        int start = 0;\n        int end = len-1;\n        while(nums[start]!=target){\n            if((start+1)>len-1){\n                return new int[]{-1,-1};\n            }\n            start++;\n        }\n        while(nums[end]!=target){\n            if((end-1)<0){\n                return new int[]{-1,-1};\n            }\n            end--;\n        }\n        if(start==end) return new int[]{start,start};\n        return new int[]{start,end};\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# Java代码2\n\nclass Solution {\n    public int[] searchRange(int[] nums, int target) {\n        int len = nums.length;\n        if(nums==null||len==0) return new int[]{-1,-1};\n        if(len==1) return nums[0]==target? new int[]{0,0}: new int[]{-1,-1};\n        int start = 0;\n        int end = len-1;\n        while(start<=end){\n            int mid = start+(end-start)/2;\n            if(nums[mid]<target){\n                start = mid+1;\n            }else if(nums[mid]>target){\n                end = mid-1;\n            }else{\n                while(nums[start]!=target) start++;\n                while(nums[end]!=target) end--;\n                return new int[]{start,end};\n            }\n        }\n        return new int[]{-1,-1};\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# Java代码3\n\nclass Solution {\n    public int[] searchRange(int[] nums, int target) {\n        if(nums.length == 0) return new int[]{-1,-1};\n        return subSearch(nums,target,0,nums.length-1);\n    }\n\n    public int[] subSearch(int[] nums,int target,int left, int right){\n        if(nums[left]>target || nums[right]<target) return new int[]{-1,-1};\n        if(left==right){\n            if(nums[left] == target) return new int[]{left,left};\n            else return new int[]{-1,-1};\n        }\n        int mid = (left+right)/2;\n        int[] leftRe = subSearch(nums,target,left,mid);\n        int[] rightRe = subSearch(nums,target,mid+1,right);\n        if(leftRe[0] >=0 && rightRe[0] >=0) return new int[]{leftRe[0],rightRe[1]};\n        if(leftRe[0] >=0) return leftRe;\n        else return rightRe;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# Java代码4\n\nclass Solution {\n    public int[] searchRange(int[] nums, int target) {\n        int[] result = new int[2];\n        result[0] = binarySearchLeftBound(nums, target);\n        result[1] = binarySearchRightBound(nums, target);\n        return result;\n        \n    }\n    public int binarySearchLeftBound(int[] nums, int target) {\n        int l = 0, r = nums.length - 1;\n        while (l <= r) {\n            int mid = l + ((r - l) >> 1);\n            if (nums[mid] < target)  {\n                l = mid + 1;\n            } else if (nums[mid] > target) {\n                r = mid - 1;\n            } else if (nums[mid] == target) {\n                r = mid - 1;\n            }\n        }        \n        if (l >= nums.length || nums[l] != target) return -1;\n        return l;\n    }\n    public int binarySearchRightBound(int[] nums, int target) {\n        int l = 0, r = nums.length - 1;\n        while (l <= r) {\n            int mid = l + ((r - l) >> 1);\n            if (nums[mid] < target)  {\n                l = mid + 1;\n            } else if (nums[mid] > target) {\n                r = mid - 1;\n            } else if (nums[mid] == target) {\n                l = mid + 1;\n            }\n        }\n        if (r < 0 || nums[r] != target) return -1;\n        return r;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n",normalizedContent:"# leetcode-34-在排序数组中查找元素的第一个和最后一个位置\n\n给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。\n\n你的算法时间复杂度必须是 o(log n) 级别。\n\n如果数组中不存在目标值，返回 [-1, -1]。\n\n示例1：\n\n输入: nums = [5,7,7,8,8,10], target = 8\n输出: [3,4]\n\n\n1\n2\n\n1\n2\n\n\n示例2：\n\n输入: nums = [5,7,7,8,8,10], target = 6\n输出: [-1,-1]\n\n\n1\n2\n\n1\n2\n\n\n\n# 解题思路\n\n方法1、双指针暴力法(low)：\n\n特例判断：\n\n * 当数组为空或数组长度为0时，直接返回[-1,1]\n * 当数组长度为1时，判断第一个数字是否等于target，等于则返回[0,0]，否则返回[-1,-1]\n\n初始化头尾指针\n\n移动头指针，直到找到第一个等于target的位置，如果找完了都没有找到，返回[-1,-1]\n\n移动尾指针，直到找到最后一个等于target的位置，如果找完了都没有找到，返回[-1,-1]\n\n当头尾指针相同时，说明只有一个target，返回当前位置[start,start]或[end,end]\n\n反之，返回头尾指针区间[start,end]\n\n方法2、二分查找(fast)：\n\n通过判断mid位置的数值，决定左右边界的移动\n\n当nums[mid]<target时，说明target在mid右方，start = mid+1\n\n当nums[mid]>target时，说明target在mid左方，end = mid-1\n\n当nums[mid]==target时，说明左右边界有一个地方等于target，这时候只需要查找另外一个边界等于target的即可，可以进行循环移动查找，最后返回[start,end]即可\n\n如果没有找到，返回[-1,-1]\n\n方法3、递归分治(low)：\n\n通过二分查找切分数组寻找左右子数组的target位置，迭代到只有一个，判断是否是目标值，返回一个都是当前index的数组，然后进行合并即可\n\n方法4、二次二分找左右边界(fast)：\n\n第一次二分找左边界，第二次二分找右边界，找左边界时向右逼近，找右边界时向左逼近\n\n\n# java代码1\n\nclass solution {\n    public int[] searchrange(int[] nums, int target) {\n        int len = nums.length;\n        if(nums==null||len==0) return new int[]{-1,-1};\n        if(len==1) return nums[0]==target? new int[]{0,0}: new int[]{-1,-1};\n        int start = 0;\n        int end = len-1;\n        while(nums[start]!=target){\n            if((start+1)>len-1){\n                return new int[]{-1,-1};\n            }\n            start++;\n        }\n        while(nums[end]!=target){\n            if((end-1)<0){\n                return new int[]{-1,-1};\n            }\n            end--;\n        }\n        if(start==end) return new int[]{start,start};\n        return new int[]{start,end};\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# java代码2\n\nclass solution {\n    public int[] searchrange(int[] nums, int target) {\n        int len = nums.length;\n        if(nums==null||len==0) return new int[]{-1,-1};\n        if(len==1) return nums[0]==target? new int[]{0,0}: new int[]{-1,-1};\n        int start = 0;\n        int end = len-1;\n        while(start<=end){\n            int mid = start+(end-start)/2;\n            if(nums[mid]<target){\n                start = mid+1;\n            }else if(nums[mid]>target){\n                end = mid-1;\n            }else{\n                while(nums[start]!=target) start++;\n                while(nums[end]!=target) end--;\n                return new int[]{start,end};\n            }\n        }\n        return new int[]{-1,-1};\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# java代码3\n\nclass solution {\n    public int[] searchrange(int[] nums, int target) {\n        if(nums.length == 0) return new int[]{-1,-1};\n        return subsearch(nums,target,0,nums.length-1);\n    }\n\n    public int[] subsearch(int[] nums,int target,int left, int right){\n        if(nums[left]>target || nums[right]<target) return new int[]{-1,-1};\n        if(left==right){\n            if(nums[left] == target) return new int[]{left,left};\n            else return new int[]{-1,-1};\n        }\n        int mid = (left+right)/2;\n        int[] leftre = subsearch(nums,target,left,mid);\n        int[] rightre = subsearch(nums,target,mid+1,right);\n        if(leftre[0] >=0 && rightre[0] >=0) return new int[]{leftre[0],rightre[1]};\n        if(leftre[0] >=0) return leftre;\n        else return rightre;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# java代码4\n\nclass solution {\n    public int[] searchrange(int[] nums, int target) {\n        int[] result = new int[2];\n        result[0] = binarysearchleftbound(nums, target);\n        result[1] = binarysearchrightbound(nums, target);\n        return result;\n        \n    }\n    public int binarysearchleftbound(int[] nums, int target) {\n        int l = 0, r = nums.length - 1;\n        while (l <= r) {\n            int mid = l + ((r - l) >> 1);\n            if (nums[mid] < target)  {\n                l = mid + 1;\n            } else if (nums[mid] > target) {\n                r = mid - 1;\n            } else if (nums[mid] == target) {\n                r = mid - 1;\n            }\n        }        \n        if (l >= nums.length || nums[l] != target) return -1;\n        return l;\n    }\n    public int binarysearchrightbound(int[] nums, int target) {\n        int l = 0, r = nums.length - 1;\n        while (l <= r) {\n            int mid = l + ((r - l) >> 1);\n            if (nums[mid] < target)  {\n                l = mid + 1;\n            } else if (nums[mid] > target) {\n                r = mid - 1;\n            } else if (nums[mid] == target) {\n                l = mid + 1;\n            }\n        }\n        if (r < 0 || nums[r] != target) return -1;\n        return r;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-46-全排列",frontmatter:{title:"LeetCode-46-全排列",date:"2020-06-08T22:18:43.000Z",description:"全排列",tags:["回溯","数组","Java","Medium","LeetCode"],keywords:"回溯,数组,Java,Medium,LeetCode",permalink:"/pages/292c69/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/33.LeetCode-46-%E5%85%A8%E6%8E%92%E5%88%97.html",relativePath:"06.算法/02.LeetCode/33.LeetCode-46-全排列.md",key:"v-8edc01ec",path:"/pages/292c69/",headers:[{level:2,title:"LeetCode-46-全排列",slug:"leetcode-46-全排列",normalizedTitle:"leetcode-46-全排列",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:191},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:415}],headersStr:"LeetCode-46-全排列 解题思路 Java代码",content:"# LeetCode-46-全排列\n\n给定一个 没有重复 数字的序列，返回其所有可能的全排列。\n\n示例 1:\n\n输入: [1,2,3]\n输出:\n[\n  [1,2,3],\n  [1,3,2],\n  [2,1,3],\n  [2,3,1],\n  [3,1,2],\n  [3,2,1]\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 解题思路\n\n方法1、回溯：\n\n回溯问题经常会涉及到一个状态数组\n\n基本的思路想象成一个树的问题，是从一个数字(外层循环分别固定1，2，3数字)出发，往树的更深处遍历\n\n * 如果当前位置没有访问过，就将这个数加入到路径中，之后开启更深一层的遍历\n * 如果路径的长度等于了初始的数组长度，说明找到了一个可能的排列\n * 如果走到最后没有找到这样的排列路径，则说明此路不同进行回溯操作，将访问的位置状态还原，并同时移除还原路上已经添加的数字\n\n\n# Java代码\n\nclass Solution {\n    public List<List<Integer>> permute(int[] nums) {\n        int len = nums.length;\n        List<List<Integer>> res = new ArrayList<>();\n        if(len==0) return res;\n        boolean[] visited = new boolean[len];\n        List<Integer> path = new ArrayList<>();\n        dfs(nums,len,0,path,visited,res);\n        return res;\n    }\n\n    public void dfs(int[] nums, int len, int depth,\n                     List<Integer> path, boolean[] visited,\n                     List<List<Integer>> res){\n        if(len==depth){\n            res.add(new ArrayList<>(path));\n            return;\n        }\n        for(int i=0;i<len;i++){\n            if(!visited[i]){\n                path.add(nums[i]);\n                visited[i] = true;\n                dfs(nums,len,depth+1,path,visited,res);\n                visited[i] = false;\n                path.remove(path.size()-1);\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n",normalizedContent:"# leetcode-46-全排列\n\n给定一个 没有重复 数字的序列，返回其所有可能的全排列。\n\n示例 1:\n\n输入: [1,2,3]\n输出:\n[\n  [1,2,3],\n  [1,3,2],\n  [2,1,3],\n  [2,3,1],\n  [3,1,2],\n  [3,2,1]\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 解题思路\n\n方法1、回溯：\n\n回溯问题经常会涉及到一个状态数组\n\n基本的思路想象成一个树的问题，是从一个数字(外层循环分别固定1，2，3数字)出发，往树的更深处遍历\n\n * 如果当前位置没有访问过，就将这个数加入到路径中，之后开启更深一层的遍历\n * 如果路径的长度等于了初始的数组长度，说明找到了一个可能的排列\n * 如果走到最后没有找到这样的排列路径，则说明此路不同进行回溯操作，将访问的位置状态还原，并同时移除还原路上已经添加的数字\n\n\n# java代码\n\nclass solution {\n    public list<list<integer>> permute(int[] nums) {\n        int len = nums.length;\n        list<list<integer>> res = new arraylist<>();\n        if(len==0) return res;\n        boolean[] visited = new boolean[len];\n        list<integer> path = new arraylist<>();\n        dfs(nums,len,0,path,visited,res);\n        return res;\n    }\n\n    public void dfs(int[] nums, int len, int depth,\n                     list<integer> path, boolean[] visited,\n                     list<list<integer>> res){\n        if(len==depth){\n            res.add(new arraylist<>(path));\n            return;\n        }\n        for(int i=0;i<len;i++){\n            if(!visited[i]){\n                path.add(nums[i]);\n                visited[i] = true;\n                dfs(nums,len,depth+1,path,visited,res);\n                visited[i] = false;\n                path.remove(path.size()-1);\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-47-全排列2",frontmatter:{title:"LeetCode-47-全排列2",date:"2020-06-09T18:33:18.000Z",description:"全排列2",tags:["回溯","数组","Java","Medium","LeetCode"],keywords:"回溯,数组,Java,Medium,LeetCode",permalink:"/pages/ed20fe/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/34.LeetCode-47-%E5%85%A8%E6%8E%92%E5%88%972.html",relativePath:"06.算法/02.LeetCode/34.LeetCode-47-全排列2.md",key:"v-6eba0db4",path:"/pages/ed20fe/",headers:[{level:2,title:"LeetCode-47-全排列2",slug:"leetcode-47-全排列2",normalizedTitle:"leetcode-47-全排列2",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:144},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:495}],headersStr:"LeetCode-47-全排列2 解题思路 Java代码",content:"# LeetCode-47-全排列2\n\n给定一个可包含重复数字的序列，返回所有不重复的全排列。\n\n示例 1:\n\n输入: [1,1,2]\n输出:\n[\n  [1,1,2],\n  [1,2,1],\n  [2,1,1]\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 解题思路\n\n回溯+剪枝：\n\n基于46题{% post_link LeetCode-46-全排列 %}\n\n对于刚开始就有重复的数字序列，首先先对数组排序，保证数据有序\n\n之后构建递归树，因为返回的结果中不能包含重复的排列，所以在如数组1、1、2的排列过程中\n\n选择第一个1开头和选择第二个1开头的序列将会重复，所以说需要对第二个1开头的所有序列进行剪枝\n\n对应条件为nums[i]==num[i-1]，即第二个1等于第一个1时\n\n同时需要考虑仅在第一个1的排列选择完毕之后回退到空path的时候，才进行第二个1的剪枝。此时判断的依据是上一个nums[i-1]刚刚在回溯的过程中被撤销选择。\n\n对于其他可能重复的位置，如2，1，1。开头2、1都相同于是后续的排列也是重复的，上述的剪枝方法同样适用\n\n\n# Java代码\n\nclass Solution {\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        int len = nums.length;\n        List<List<Integer>> res = new ArrayList<>();\n        if (len == 0) return res;\n        Arrays.sort(nums);\n        boolean[] visited = new boolean[len];\n        List<Integer> path = new ArrayList<>();\n        dfs(nums, len, 0, path, visited, res);\n        return res;\n    }\n\n    public void dfs(int[] nums,int len,int depth,List<Integer> path,boolean[] visited,List<List<Integer>> res){\n        if(len==depth){\n            res.add(new ArrayList<>(path));\n            return;\n        }\n        for(int i=0;i<len;i++){\n            if(!visited[i]){\n                // visited[i-1]是因为nums[i-1]在回退的过程中刚刚被撤销选择\n                if(i>0&&nums[i]==nums[i-1]&&visited[i-1]==false) continue;\n                visited[i] = true;\n                path.add(nums[i]);\n                dfs(nums,len,depth+1,path,visited,res);\n                visited[i] = false;\n                path.remove(path.size()-1);\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n",normalizedContent:"# leetcode-47-全排列2\n\n给定一个可包含重复数字的序列，返回所有不重复的全排列。\n\n示例 1:\n\n输入: [1,1,2]\n输出:\n[\n  [1,1,2],\n  [1,2,1],\n  [2,1,1]\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 解题思路\n\n回溯+剪枝：\n\n基于46题{% post_link leetcode-46-全排列 %}\n\n对于刚开始就有重复的数字序列，首先先对数组排序，保证数据有序\n\n之后构建递归树，因为返回的结果中不能包含重复的排列，所以在如数组1、1、2的排列过程中\n\n选择第一个1开头和选择第二个1开头的序列将会重复，所以说需要对第二个1开头的所有序列进行剪枝\n\n对应条件为nums[i]==num[i-1]，即第二个1等于第一个1时\n\n同时需要考虑仅在第一个1的排列选择完毕之后回退到空path的时候，才进行第二个1的剪枝。此时判断的依据是上一个nums[i-1]刚刚在回溯的过程中被撤销选择。\n\n对于其他可能重复的位置，如2，1，1。开头2、1都相同于是后续的排列也是重复的，上述的剪枝方法同样适用\n\n\n# java代码\n\nclass solution {\n    public list<list<integer>> permuteunique(int[] nums) {\n        int len = nums.length;\n        list<list<integer>> res = new arraylist<>();\n        if (len == 0) return res;\n        arrays.sort(nums);\n        boolean[] visited = new boolean[len];\n        list<integer> path = new arraylist<>();\n        dfs(nums, len, 0, path, visited, res);\n        return res;\n    }\n\n    public void dfs(int[] nums,int len,int depth,list<integer> path,boolean[] visited,list<list<integer>> res){\n        if(len==depth){\n            res.add(new arraylist<>(path));\n            return;\n        }\n        for(int i=0;i<len;i++){\n            if(!visited[i]){\n                // visited[i-1]是因为nums[i-1]在回退的过程中刚刚被撤销选择\n                if(i>0&&nums[i]==nums[i-1]&&visited[i-1]==false) continue;\n                visited[i] = true;\n                path.add(nums[i]);\n                dfs(nums,len,depth+1,path,visited,res);\n                visited[i] = false;\n                path.remove(path.size()-1);\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-51-N皇后",frontmatter:{title:"LeetCode-51-N皇后",date:"2020-06-08T19:55:16.000Z",description:"N皇后",tags:["二维数组","矩阵","回溯","Java","Hard"],keywords:"二维数组,矩阵,回溯,Java,Hard",permalink:"/pages/cd98da/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/35.LeetCode-51-N%E7%9A%87%E5%90%8E.html",relativePath:"06.算法/02.LeetCode/35.LeetCode-51-N皇后.md",key:"v-ae62b842",path:"/pages/cd98da/",headers:[{level:2,title:"LeetCode-51-N皇后",slug:"leetcode-51-n皇后",normalizedTitle:"leetcode-51-n皇后",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:474},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:1077}],headersStr:"LeetCode-51-N皇后 解题思路 Java代码",content:'# LeetCode-51-N皇后\n\nn 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。\n\n给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。\n\n每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 \'Q\' 和 \'.\' 分别代表了皇后和空位。\n\n示例 1:\n\n输入: 4\n输出: [\n [".Q..",  // 解法 1\n  "...Q",\n  "Q...",\n  "..Q."],\n\n ["..Q.",  // 解法 2\n  "Q...",\n  "...Q",\n  ".Q.."]\n]\n解释: 4 皇后问题存在两个不同的解法。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n提示：\n\n * 皇后，是国际象棋中的棋子，意味着国王的妻子。皇后只做一件事，那就是“吃子”。当她遇见可以吃的棋子时，就迅速冲上去吃掉棋子。当然，她横、竖、斜都可走一到七步，可进可退。（引用自 百度百科 - 皇后 ）\n\n\n# 解题思路\n\n回溯方法引用与LeetCode官方\n\n**方法1、**回溯：\n\n在建立算法之前，我们来考虑两个有用的细节。\n\n一行只可能有一个皇后且一列也只可能有一个皇后。\n\n这意味着没有必要再棋盘上考虑所有的方格。只需要按列循环即可。\n\n对于所有的主对角线有 行号 + 列号 = 常数，对于所有的次对角线有 行号 - 列号 = 常数.\n\n这可以让我们标记已经在攻击范围下的对角线并且检查一个方格 (行号, 列号) 是否处在攻击位置。\n\n1、一行一个皇后\n2、每个皇后的左上方向没有其他皇后，每个皇后的上方没有其他皇后，每个皇后的右上方向没有皇后\n\n\n1\n2\n\n1\n2\n\n\n现在已经可以写回溯函数 backtrack(row = 0).\n\n * 从第一个 row = 0 开始.\n\n * 循环列并且试图在每个 column 中放置皇后.\n   \n   * 如果方格 (row, column) 不在攻击范围内\n     * 在 (row, column) 方格上放置皇后。\n     * 排除对应行，列和两个对角线的位置。\n     * If 所有的行被考虑过，row == N\n       * 意味着我们找到了一个解\n     * Else\n       * 继续考虑接下来的皇后放置 backtrack(row + 1).\n     * 回溯：将在 (row, column) 方格的皇后移除.\n\n\n# Java代码\n\nclass Solution {\n    private List<List<String>> output = new ArrayList<>();\n\n    // 用于标记是否被列方向的皇后攻击\n    int[] rows;\n    // 用于标记是否被主对角线方向的皇后攻击\n    int[] mains;\n    // 用于标记是否被次对角线方向的皇后攻击\n    int[] secondary;\n    // 用于存储皇后放置的位置\n    int[] queens;\n\n    int n;\n\n    public List<List<String>> solveNQueens(int n) {\n        // 初始化\n        rows = new int[n];\n        mains = new int[2*n-1];\n        secondary = new int[2*n-1];\n        queens = new int[n];\n        this.n = n;\n        // 从第一行开始回溯求解N皇后\n        backtrack(0);\n        return output;\n    }\n\n    // 在一行中放置一个皇后\n    private void backtrack(int row){\n        if(row>=n) return;\n        // 分别尝试在row行中的每一列都放置一个皇后\n        for(int col=0;col<n;col++){\n            // 判断当前放置的皇后不被其他皇后攻击\n            if(isNotUnderAttack(row,col)){\n                // 选择，在当前的位置上放置皇后\n                placeQueen(row,col);\n                // 当前行是最后一行，则找到了一个解决方案\n                if(row==n-1) addSolution();\n                // 在下一行中放置皇后\n                backtrack(row+1);\n                // 回溯，将当前位置的皇后去掉\n                removeQueen(row,col);\n            }\n        }\n    }\n\n    // 判断row行，col列这个位置有没有被其他方向的皇后攻击\n    private boolean isNotUnderAttack(int row,int col){\n        // 判断的逻辑是：\n        //      1. 当前位置的这一列方向没有皇后攻击\n        //      2. 当前位置的主对角线方向没有皇后攻击\n        //      3. 当前位置的次对角线方向没有皇后攻击\n        int res = rows[col]+mains[row-col+n-1]+secondary[row+col];\n        // 如果三个方向都没有攻击的话，则res=0\n        return res == 0;\n    }\n\n    // 在指定的位置上放置皇后\n    private void placeQueen(int row,int col){\n        // 在row行，col列放置皇后\n        queens[row] = col;\n        // 当前位置的列方向已经有皇后了\n        rows[col] = 1;\n        // 当前位置的主对角线方向已经有皇后了\n        mains[row-col+n-1] = 1;\n        // 当前位置的次对角线方向已经有皇后了\n        secondary[row+col] = 1;\n    }\n\n    // 移除指定位置上的皇后\n    private void removeQueen(int row,int col){\n        // 移除row行上的皇后\n        queens[row] = 0;\n        // 当前位置的列方向没有皇后了\n        rows[col] = 0;\n        // 当前位置的主对角线方向没有皇后了\n        mains[row-col+n-1] = 0;\n        // 当前位置的次对角线方向没有皇后了\n        secondary[row+col] = 0;\n    }\n\n    // 将满足条件的皇后位置放入output中\n    public void addSolution(){\n        List<String> Solution = new ArrayList<String>();\n        for(int i=0;i<n;i++){\n            int col = queens[i];\n            StringBuilder sb = new StringBuilder();\n            for(int j=0;j<col;j++) sb.append(".");\n            sb.append("Q");\n            for(int j=0;j<n-col-1;j++) sb.append(".");\n            Solution.add(sb.toString());\n        }\n        output.add(Solution);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n',normalizedContent:'# leetcode-51-n皇后\n\nn 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。\n\n给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。\n\n每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 \'q\' 和 \'.\' 分别代表了皇后和空位。\n\n示例 1:\n\n输入: 4\n输出: [\n [".q..",  // 解法 1\n  "...q",\n  "q...",\n  "..q."],\n\n ["..q.",  // 解法 2\n  "q...",\n  "...q",\n  ".q.."]\n]\n解释: 4 皇后问题存在两个不同的解法。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n提示：\n\n * 皇后，是国际象棋中的棋子，意味着国王的妻子。皇后只做一件事，那就是“吃子”。当她遇见可以吃的棋子时，就迅速冲上去吃掉棋子。当然，她横、竖、斜都可走一到七步，可进可退。（引用自 百度百科 - 皇后 ）\n\n\n# 解题思路\n\n回溯方法引用与leetcode官方\n\n**方法1、**回溯：\n\n在建立算法之前，我们来考虑两个有用的细节。\n\n一行只可能有一个皇后且一列也只可能有一个皇后。\n\n这意味着没有必要再棋盘上考虑所有的方格。只需要按列循环即可。\n\n对于所有的主对角线有 行号 + 列号 = 常数，对于所有的次对角线有 行号 - 列号 = 常数.\n\n这可以让我们标记已经在攻击范围下的对角线并且检查一个方格 (行号, 列号) 是否处在攻击位置。\n\n1、一行一个皇后\n2、每个皇后的左上方向没有其他皇后，每个皇后的上方没有其他皇后，每个皇后的右上方向没有皇后\n\n\n1\n2\n\n1\n2\n\n\n现在已经可以写回溯函数 backtrack(row = 0).\n\n * 从第一个 row = 0 开始.\n\n * 循环列并且试图在每个 column 中放置皇后.\n   \n   * 如果方格 (row, column) 不在攻击范围内\n     * 在 (row, column) 方格上放置皇后。\n     * 排除对应行，列和两个对角线的位置。\n     * if 所有的行被考虑过，row == n\n       * 意味着我们找到了一个解\n     * else\n       * 继续考虑接下来的皇后放置 backtrack(row + 1).\n     * 回溯：将在 (row, column) 方格的皇后移除.\n\n\n# java代码\n\nclass solution {\n    private list<list<string>> output = new arraylist<>();\n\n    // 用于标记是否被列方向的皇后攻击\n    int[] rows;\n    // 用于标记是否被主对角线方向的皇后攻击\n    int[] mains;\n    // 用于标记是否被次对角线方向的皇后攻击\n    int[] secondary;\n    // 用于存储皇后放置的位置\n    int[] queens;\n\n    int n;\n\n    public list<list<string>> solvenqueens(int n) {\n        // 初始化\n        rows = new int[n];\n        mains = new int[2*n-1];\n        secondary = new int[2*n-1];\n        queens = new int[n];\n        this.n = n;\n        // 从第一行开始回溯求解n皇后\n        backtrack(0);\n        return output;\n    }\n\n    // 在一行中放置一个皇后\n    private void backtrack(int row){\n        if(row>=n) return;\n        // 分别尝试在row行中的每一列都放置一个皇后\n        for(int col=0;col<n;col++){\n            // 判断当前放置的皇后不被其他皇后攻击\n            if(isnotunderattack(row,col)){\n                // 选择，在当前的位置上放置皇后\n                placequeen(row,col);\n                // 当前行是最后一行，则找到了一个解决方案\n                if(row==n-1) addsolution();\n                // 在下一行中放置皇后\n                backtrack(row+1);\n                // 回溯，将当前位置的皇后去掉\n                removequeen(row,col);\n            }\n        }\n    }\n\n    // 判断row行，col列这个位置有没有被其他方向的皇后攻击\n    private boolean isnotunderattack(int row,int col){\n        // 判断的逻辑是：\n        //      1. 当前位置的这一列方向没有皇后攻击\n        //      2. 当前位置的主对角线方向没有皇后攻击\n        //      3. 当前位置的次对角线方向没有皇后攻击\n        int res = rows[col]+mains[row-col+n-1]+secondary[row+col];\n        // 如果三个方向都没有攻击的话，则res=0\n        return res == 0;\n    }\n\n    // 在指定的位置上放置皇后\n    private void placequeen(int row,int col){\n        // 在row行，col列放置皇后\n        queens[row] = col;\n        // 当前位置的列方向已经有皇后了\n        rows[col] = 1;\n        // 当前位置的主对角线方向已经有皇后了\n        mains[row-col+n-1] = 1;\n        // 当前位置的次对角线方向已经有皇后了\n        secondary[row+col] = 1;\n    }\n\n    // 移除指定位置上的皇后\n    private void removequeen(int row,int col){\n        // 移除row行上的皇后\n        queens[row] = 0;\n        // 当前位置的列方向没有皇后了\n        rows[col] = 0;\n        // 当前位置的主对角线方向没有皇后了\n        mains[row-col+n-1] = 0;\n        // 当前位置的次对角线方向没有皇后了\n        secondary[row+col] = 0;\n    }\n\n    // 将满足条件的皇后位置放入output中\n    public void addsolution(){\n        list<string> solution = new arraylist<string>();\n        for(int i=0;i<n;i++){\n            int col = queens[i];\n            stringbuilder sb = new stringbuilder();\n            for(int j=0;j<col;j++) sb.append(".");\n            sb.append("q");\n            for(int j=0;j<n-col-1;j++) sb.append(".");\n            solution.add(sb.tostring());\n        }\n        output.add(solution);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-55-跳跃游戏",frontmatter:{title:"LeetCode-55-跳跃游戏",date:"2020-07-06T17:18:19.000Z",description:"跳跃游戏",tags:["数组","贪心算法","Java","Medium"],keywords:"数组,贪心算法,Java,Medium,LeetCode",permalink:"/pages/010874/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/36.LeetCode-55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F.html",relativePath:"06.算法/02.LeetCode/36.LeetCode-55-跳跃游戏.md",key:"v-b0357cfc",path:"/pages/010874/",headers:[{level:2,title:"LeetCode-55-跳跃游戏",slug:"leetcode-55-跳跃游戏",normalizedTitle:"leetcode-55-跳跃游戏",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:305},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:571}],headersStr:"LeetCode-55-跳跃游戏 解题思路 Java代码",content:"# LeetCode-55-跳跃游戏\n\n给定一个非负整数数组，你最初位于数组的第一个位置。\n\n数组中的每个元素代表你在该位置可以跳跃的最大长度。\n\n判断你是否能够到达最后一个位置。\n\n示例1：\n\n输入: [2,3,1,1,4]\n输出: true\n解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2：\n\n输入: [3,2,1,0,4]\n输出: false\n解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n\n# 解题思路\n\n方法1、贪心：\n\n对于数组中任意的一个位置y，如何判断是否可达\n\n根据题意，只要存在一个位置x，它本身可达，并且它跳跃的最大长度为x+nums[x]，这个值>=y，即x+nums[x]>=y，那么位置y也可达\n\n换句话说，对于每个可达的位置x，它使得x+1，x+2，......，x+nums[x]这些连续的位置都可以到达\n\n于是我们可以动态记录最远可以到达的位置，对于每一个起跳点，更新对应的最远可以到达的位置\n\n即把每个能起跳的点都试一次，使用max表示最远能够到达的点，超过max就不能跳了，直接进行返回\n\n\n# Java代码\n\nclass Solution {\n    public boolean canJump(int[] nums) {\n        boolean falg = true;\n        if(nums.length<2) return falg;\n        int max = 0;\n        for(int i=0;i<nums.length;i++){\n            if(i>max)\n                falg = false;\n            max = Math.max(max,i+nums[i]);\n        }\n        return falg;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n",normalizedContent:"# leetcode-55-跳跃游戏\n\n给定一个非负整数数组，你最初位于数组的第一个位置。\n\n数组中的每个元素代表你在该位置可以跳跃的最大长度。\n\n判断你是否能够到达最后一个位置。\n\n示例1：\n\n输入: [2,3,1,1,4]\n输出: true\n解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2：\n\n输入: [3,2,1,0,4]\n输出: false\n解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n\n# 解题思路\n\n方法1、贪心：\n\n对于数组中任意的一个位置y，如何判断是否可达\n\n根据题意，只要存在一个位置x，它本身可达，并且它跳跃的最大长度为x+nums[x]，这个值>=y，即x+nums[x]>=y，那么位置y也可达\n\n换句话说，对于每个可达的位置x，它使得x+1，x+2，......，x+nums[x]这些连续的位置都可以到达\n\n于是我们可以动态记录最远可以到达的位置，对于每一个起跳点，更新对应的最远可以到达的位置\n\n即把每个能起跳的点都试一次，使用max表示最远能够到达的点，超过max就不能跳了，直接进行返回\n\n\n# java代码\n\nclass solution {\n    public boolean canjump(int[] nums) {\n        boolean falg = true;\n        if(nums.length<2) return falg;\n        int max = 0;\n        for(int i=0;i<nums.length;i++){\n            if(i>max)\n                falg = false;\n            max = math.max(max,i+nums[i]);\n        }\n        return falg;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-56-合并区间",frontmatter:{title:"LeetCode-56-合并区间",date:"2020-08-02T16:28:08.000Z",description:"合并区间",tags:["数组","Java","Medium"],keywords:"数组,Java,Medium,LeetCode",permalink:"/pages/232d3c/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/37.LeetCode-56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4.html",relativePath:"06.算法/02.LeetCode/37.LeetCode-56-合并区间.md",key:"v-e6d11d7a",path:"/pages/232d3c/",headers:[{level:2,title:"LeetCode-56-合并区间",slug:"leetcode-56-合并区间",normalizedTitle:"leetcode-56-合并区间",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:252},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:640}],headersStr:"LeetCode-56-合并区间 解题思路 Java代码",content:"# LeetCode-56-合并区间\n\n给出一个区间的集合，请合并所有重叠的区间。\n\n示例1：\n\n输入: [[1,3],[2,6],[8,10],[15,18]]\n输出: [[1,6],[8,10],[15,18]]\n解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2：\n\n输入: [[1,4],[4,5]]\n输出: [[1,5]]\n解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n\n# 解题思路\n\n方法1、排序+双指针：\n\n虽然示例中没有给出需要排序的案例，但需要考虑数组不是按照首位数组顺序排列的情况，这样会让区间难以判断，所以先做一个排序。\n\n之后初始化双指针，指向第一个区间的start和end\n\n进入for循环判断，判断下一个区间的首位是否大于上个区间的末尾\n\n如果大于，则说明区间分离，加入新区间{start，end}，更新start\n\n当下一个区间不大于end，即<=end的时候，区间均要进行合并，此时区间为上一个区间的start，到当前区间和下一个区间end的最大值，所以end = Math.max(end,intervals[i][1])\n\n由于开始的start和end是上一个区间的结果，所以在最后一次时，暂时不会添加区间，res.add(new int[]{start,end});为最后一次添加之后转化为int[][]返回即可\n\n\n# Java代码\n\nclass Solution {\n    public int[][] merge(int[][] intervals) {\n        int len = intervals.length;\n        if (intervals == null || len <= 1) return intervals;\n        List<int[]> res = new ArrayList<>();\n        Arrays.sort(intervals, (x, y) -> x[0] - y[0]);\n        int start = intervals[0][0];\n        int end = intervals[0][1];\n        for (int i = 1; i < len; i++) {\n            if(intervals[i][0]>end){\n                res.add(new int[]{start,end});\n                start = intervals[i][0];\n            }\n            end = Math.max(end,intervals[i][1]);\n        }\n        // 最后一次添加\n        res.add(new int[]{start,end});\n        return res.toArray(new int[res.size()][2]);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n",normalizedContent:"# leetcode-56-合并区间\n\n给出一个区间的集合，请合并所有重叠的区间。\n\n示例1：\n\n输入: [[1,3],[2,6],[8,10],[15,18]]\n输出: [[1,6],[8,10],[15,18]]\n解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2：\n\n输入: [[1,4],[4,5]]\n输出: [[1,5]]\n解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n\n# 解题思路\n\n方法1、排序+双指针：\n\n虽然示例中没有给出需要排序的案例，但需要考虑数组不是按照首位数组顺序排列的情况，这样会让区间难以判断，所以先做一个排序。\n\n之后初始化双指针，指向第一个区间的start和end\n\n进入for循环判断，判断下一个区间的首位是否大于上个区间的末尾\n\n如果大于，则说明区间分离，加入新区间{start，end}，更新start\n\n当下一个区间不大于end，即<=end的时候，区间均要进行合并，此时区间为上一个区间的start，到当前区间和下一个区间end的最大值，所以end = math.max(end,intervals[i][1])\n\n由于开始的start和end是上一个区间的结果，所以在最后一次时，暂时不会添加区间，res.add(new int[]{start,end});为最后一次添加之后转化为int[][]返回即可\n\n\n# java代码\n\nclass solution {\n    public int[][] merge(int[][] intervals) {\n        int len = intervals.length;\n        if (intervals == null || len <= 1) return intervals;\n        list<int[]> res = new arraylist<>();\n        arrays.sort(intervals, (x, y) -> x[0] - y[0]);\n        int start = intervals[0][0];\n        int end = intervals[0][1];\n        for (int i = 1; i < len; i++) {\n            if(intervals[i][0]>end){\n                res.add(new int[]{start,end});\n                start = intervals[i][0];\n            }\n            end = math.max(end,intervals[i][1]);\n        }\n        // 最后一次添加\n        res.add(new int[]{start,end});\n        return res.toarray(new int[res.size()][2]);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-62-不同路径",frontmatter:{title:"LeetCode-62-不同路径",date:"2020-08-06T13:19:12.000Z",description:"不同路径",tags:["矩阵","DP","Java","Medium"],keywords:"矩阵,DP,Java,Medium,LeetCode",permalink:"/pages/193e4b/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/38.LeetCode-62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.html",relativePath:"06.算法/02.LeetCode/38.LeetCode-62-不同路径.md",key:"v-2ad7fa7c",path:"/pages/193e4b/",headers:[{level:2,title:"LeetCode-62-不同路径",slug:"leetcode-62-不同路径",normalizedTitle:"leetcode-62-不同路径",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:376},{level:3,title:"Java代码1",slug:"java代码1",normalizedTitle:"java代码1",charIndex:662},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:1169}],headersStr:"LeetCode-62-不同路径 解题思路 Java代码1 Java代码2",content:"# LeetCode-62-不同路径\n\n一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。\n\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。\n\n问总共有多少条不同的路径？\n\n示例1：\n\n输入: m = 3, n = 2\n输出: 3\n解释:\n从左上角开始，总共有 3 条路径可以到达右下角。\n1. 向右 -> 向右 -> 向下\n2. 向右 -> 向下 -> 向右\n3. 向下 -> 向右 -> 向右\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n示例2：\n\n输入: m = 7, n = 3\n输出: 28\n\n\n1\n2\n\n1\n2\n\n\n提示：\n\n * 1 <= m, n <= 100\n * 题目数据保证答案小于等于 2 * 10 ^ 9\n\n\n# 解题思路\n\n方法1、动态规划：\n\n这道题是个经典的动态规划问题，初始化矩阵大小的dp数组保存数字，由于只能往右或者往下走所以第1行和第1列都是1\n\ndp[i][j]状态定义为：有多少条路径到i，j这一格\n\n状态转移方程：\n\n * 当i==0或者j==0时，dp[i][j]=1\n * 其余位置，dp[i][j]的值依赖于左边位置的路径+上边位置的路径，即dp[i - 1][j] + dp[i][j - 1]\n\n最后返回右下角的值即可\n\n方法2、动态规划(空间优化)：\n\n由于每格的值仅与左侧和上方的值有关，所以只需要维护一行的值即可，空间复杂度可以降到O(N)\n\n\n# Java代码1\n\nclass Solution {\n    public int uniquePaths(int m, int n) {\n        int[][] dp = new int[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (i == 0 || j == 0) {\n                    dp[i][j] = 1;\n                } else {\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n                }\n            }\n        }\n        return dp[n - 1][m - 1];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# Java代码2\n\nclass Solution {\n    public int uniquePaths(int m, int n) {\n        int[] dp = new int[m];\n        Arrays.fill(dp, 1);\n        for (int i = 1; i < n; i++) {\n            for (int j = 1; j < m; j++) {\n                dp[j] += dp[j - 1];\n            }\n        }\n        return dp[m - 1];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n",normalizedContent:"# leetcode-62-不同路径\n\n一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“start” ）。\n\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“finish”）。\n\n问总共有多少条不同的路径？\n\n示例1：\n\n输入: m = 3, n = 2\n输出: 3\n解释:\n从左上角开始，总共有 3 条路径可以到达右下角。\n1. 向右 -> 向右 -> 向下\n2. 向右 -> 向下 -> 向右\n3. 向下 -> 向右 -> 向右\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n示例2：\n\n输入: m = 7, n = 3\n输出: 28\n\n\n1\n2\n\n1\n2\n\n\n提示：\n\n * 1 <= m, n <= 100\n * 题目数据保证答案小于等于 2 * 10 ^ 9\n\n\n# 解题思路\n\n方法1、动态规划：\n\n这道题是个经典的动态规划问题，初始化矩阵大小的dp数组保存数字，由于只能往右或者往下走所以第1行和第1列都是1\n\ndp[i][j]状态定义为：有多少条路径到i，j这一格\n\n状态转移方程：\n\n * 当i==0或者j==0时，dp[i][j]=1\n * 其余位置，dp[i][j]的值依赖于左边位置的路径+上边位置的路径，即dp[i - 1][j] + dp[i][j - 1]\n\n最后返回右下角的值即可\n\n方法2、动态规划(空间优化)：\n\n由于每格的值仅与左侧和上方的值有关，所以只需要维护一行的值即可，空间复杂度可以降到o(n)\n\n\n# java代码1\n\nclass solution {\n    public int uniquepaths(int m, int n) {\n        int[][] dp = new int[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (i == 0 || j == 0) {\n                    dp[i][j] = 1;\n                } else {\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n                }\n            }\n        }\n        return dp[n - 1][m - 1];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# java代码2\n\nclass solution {\n    public int uniquepaths(int m, int n) {\n        int[] dp = new int[m];\n        arrays.fill(dp, 1);\n        for (int i = 1; i < n; i++) {\n            for (int j = 1; j < m; j++) {\n                dp[j] += dp[j - 1];\n            }\n        }\n        return dp[m - 1];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-64-最小路径和",frontmatter:{title:"LeetCode-64-最小路径和",date:"2020-07-16T14:16:19.000Z",description:"最小路径和",tags:["数组","矩阵","DP","Java","Python","Medium"],keywords:"数组,矩阵,DP,Java,Python,Medium,LeetCode",permalink:"/pages/b04e8c/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/39.LeetCode-64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C.html",relativePath:"06.算法/02.LeetCode/39.LeetCode-64-最小路径和.md",key:"v-9a8f5e4a",path:"/pages/b04e8c/",headers:[{level:2,title:"LeetCode-64-最小路径和",slug:"leetcode-64-最小路径和",normalizedTitle:"leetcode-64-最小路径和",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:216},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:631},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:618}],headersStr:"LeetCode-64-最小路径和 解题思路 Java代码 Python代码",content:"# LeetCode-64-最小路径和\n\n给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。\n\n**说明：**每次只能向下或者向右移动一步。\n\n示例：\n\n输入:\n[\n  [1,3,1],\n  [1,5,1],\n  [4,2,1]\n]\n输出: 7\n解释: 因为路径 1→3→1→1→1 的总和最小。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 解题思路\n\n方法1、动态规划：\n\n特例判断：当行或者列为空，行列其中一个为0的时候，数组没有意义，直接返回0\n\n由于只能往下或者往右走，所以第一行和第一列的值始终是由单个方向移动得到\n\n这一部分的值可以先通过循环累加得到\n\n剩下的位置，以i=1，j=1的位置，数字5为例，数字5位置的最小值可以由，Min(上方位置的值+5，左方位置的值+5)计算得到\n\n所以当前的状态可以定义为：从左方和右方计算得到的当前位置的路径最小值\n\n不难看出，数值可以在原本的数组中原地改变且不影响结果。\n\n状态转移方程为：\n\ngrid[i][j] = Math.min(grid[i-1][j]+grid[i][j],grid[i][j-1]+grid[i][j]);\n\n由于当前位置始终存储到达该位置的路径最小值，则最后到达右下角时，就是该矩阵中到达右下角总和最小的路径和\n\n横向按顺序遍历的方法类似，这里不再重复介绍，详见Python代码\n\n\n# Java代码\n\nclass Solution {\n    public int minPathSum(int[][] grid) {\n        int rowlen = grid.length;\n        int collen = grid[0].length;\n        if(grid==null||rowlen==0||grid[0]==null||collen==0){\n            return 0;\n        }\n        for(int i=1;i<collen;i++){\n            grid[0][i] += grid[0][i-1];\n        }\n        for(int j=1;j<rowlen;j++){\n            grid[j][0] += grid[j-1][0];\n        }\n        for(int i=1;i<rowlen;i++){\n            for(int j=1;j<collen;j++){\n                grid[i][j] = Math.min(grid[i-1][j]+grid[i][j],grid[i][j-1]+grid[i][j]);\n            }\n        }\n        return grid[rowlen-1][collen-1];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# Python代码\n\nclass Solution:\n    def minPathSum(self, grid: [[int]]) -> int:\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if i == j == 0: continue\n                elif i == 0:  grid[i][j] = grid[i][j - 1] + grid[i][j]\n                elif j == 0:  grid[i][j] = grid[i - 1][j] + grid[i][j]\n                else: grid[i][j] = min(grid[i - 1][j], grid[i][j - 1]) + grid[i][j]\n        return grid[-1][-1]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n",normalizedContent:"# leetcode-64-最小路径和\n\n给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。\n\n**说明：**每次只能向下或者向右移动一步。\n\n示例：\n\n输入:\n[\n  [1,3,1],\n  [1,5,1],\n  [4,2,1]\n]\n输出: 7\n解释: 因为路径 1→3→1→1→1 的总和最小。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 解题思路\n\n方法1、动态规划：\n\n特例判断：当行或者列为空，行列其中一个为0的时候，数组没有意义，直接返回0\n\n由于只能往下或者往右走，所以第一行和第一列的值始终是由单个方向移动得到\n\n这一部分的值可以先通过循环累加得到\n\n剩下的位置，以i=1，j=1的位置，数字5为例，数字5位置的最小值可以由，min(上方位置的值+5，左方位置的值+5)计算得到\n\n所以当前的状态可以定义为：从左方和右方计算得到的当前位置的路径最小值\n\n不难看出，数值可以在原本的数组中原地改变且不影响结果。\n\n状态转移方程为：\n\ngrid[i][j] = math.min(grid[i-1][j]+grid[i][j],grid[i][j-1]+grid[i][j]);\n\n由于当前位置始终存储到达该位置的路径最小值，则最后到达右下角时，就是该矩阵中到达右下角总和最小的路径和\n\n横向按顺序遍历的方法类似，这里不再重复介绍，详见python代码\n\n\n# java代码\n\nclass solution {\n    public int minpathsum(int[][] grid) {\n        int rowlen = grid.length;\n        int collen = grid[0].length;\n        if(grid==null||rowlen==0||grid[0]==null||collen==0){\n            return 0;\n        }\n        for(int i=1;i<collen;i++){\n            grid[0][i] += grid[0][i-1];\n        }\n        for(int j=1;j<rowlen;j++){\n            grid[j][0] += grid[j-1][0];\n        }\n        for(int i=1;i<rowlen;i++){\n            for(int j=1;j<collen;j++){\n                grid[i][j] = math.min(grid[i-1][j]+grid[i][j],grid[i][j-1]+grid[i][j]);\n            }\n        }\n        return grid[rowlen-1][collen-1];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# python代码\n\nclass solution:\n    def minpathsum(self, grid: [[int]]) -> int:\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if i == j == 0: continue\n                elif i == 0:  grid[i][j] = grid[i][j - 1] + grid[i][j]\n                elif j == 0:  grid[i][j] = grid[i - 1][j] + grid[i][j]\n                else: grid[i][j] = min(grid[i - 1][j], grid[i][j - 1]) + grid[i][j]\n        return grid[-1][-1]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-70-爬楼梯",frontmatter:{title:"LeetCode-70-爬楼梯",date:"2020-06-20T20:58:35.000Z",description:"爬楼梯",tags:["数组","DP","Java","Easy"],keywords:"数组,DP,Java,Easy",permalink:"/pages/b9a49e/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/40.LeetCode-70-%E7%88%AC%E6%A5%BC%E6%A2%AF.html",relativePath:"06.算法/02.LeetCode/40.LeetCode-70-爬楼梯.md",key:"v-fc46af5c",path:"/pages/b9a49e/",headers:[{level:2,title:"LeetCode-70-爬楼梯",slug:"leetcode-70-爬楼梯",normalizedTitle:"leetcode-70-爬楼梯",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:301},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:613},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:979}],headersStr:"LeetCode-70-爬楼梯 解题思路 Java代码 Java代码2",content:"# LeetCode-70-爬楼梯\n\n假设你正在爬楼梯。需要 n 阶你才能到达楼顶。\n\n每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n\n**注意：**给定 n 是一个正整数。\n\n示例 1:\n\n输入： 2\n输出： 2\n解释： 有两种方法可以爬到楼顶。\n1.  1 阶 + 1 阶\n2.  2 阶\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n示例 2:\n\n输入： 3\n输出： 3\n解释： 有三种方法可以爬到楼顶。\n1.  1 阶 + 1 阶 + 1 阶\n2.  1 阶 + 2 阶\n3.  2 阶 + 1 阶\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 解题思路\n\n方法1、动态规划：\n\n当n等于1的时候，只需要跳一次即可，只有一种跳法，记f(1)=1\n\n当n等于2的时候，可以先跳一级再跳一级，或者直接跳二级，共有2种跳法，记f(2)=2\n\n当n等于3的时候，他可以从一级台阶上跳两步上来，也可以从二级台阶上跳一步上来，所以总共有f(3)=f(2)+f(1)；\n\n所以当等于n(n>2)的时候，总共有f(n)=f(n-1)+f(n-2)种跳法\n\n此时的状态: 为n的时候，可能的跳法有多少种\n\n状态转移方程：f(n)=f(n-1)+f(n-2)\n\n方法2、优化的动态规划：\n\n上一个方法需要开辟一个n的数组，其实可以直接用双指针完成状态的转移，不再需要开辟多余的空间\n\n\n# Java代码\n\nclass Solution {\n    public int climbStairs(int n) {\n        if (n <= 1)\n            return 1;\n        int[] dp = new int[n + 1];\n        dp[1] = 1;\n        dp[2] = 2;\n        for (int i = 3; i <= n; i++) {\n            dp[i] = dp[i - 1] + dp[i - 2];\n        }\n        return dp[n];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# Java代码2\n\nclass Solution {\n    public int climbStairs(int n) {\n        int[] result = new int[]{1, 1};\n        if (n < 2) {\n            return result[n];\n        }\n        int sum = 0;\n        int f1 = 1;\n        int f2 = 1;\n        for (int i = 2; i <= n; i++) {\n            sum = (f1 + f2);\n            f1 = f2;\n            f2 = sum;\n        }\n        return sum;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n",normalizedContent:"# leetcode-70-爬楼梯\n\n假设你正在爬楼梯。需要 n 阶你才能到达楼顶。\n\n每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n\n**注意：**给定 n 是一个正整数。\n\n示例 1:\n\n输入： 2\n输出： 2\n解释： 有两种方法可以爬到楼顶。\n1.  1 阶 + 1 阶\n2.  2 阶\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n示例 2:\n\n输入： 3\n输出： 3\n解释： 有三种方法可以爬到楼顶。\n1.  1 阶 + 1 阶 + 1 阶\n2.  1 阶 + 2 阶\n3.  2 阶 + 1 阶\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 解题思路\n\n方法1、动态规划：\n\n当n等于1的时候，只需要跳一次即可，只有一种跳法，记f(1)=1\n\n当n等于2的时候，可以先跳一级再跳一级，或者直接跳二级，共有2种跳法，记f(2)=2\n\n当n等于3的时候，他可以从一级台阶上跳两步上来，也可以从二级台阶上跳一步上来，所以总共有f(3)=f(2)+f(1)；\n\n所以当等于n(n>2)的时候，总共有f(n)=f(n-1)+f(n-2)种跳法\n\n此时的状态: 为n的时候，可能的跳法有多少种\n\n状态转移方程：f(n)=f(n-1)+f(n-2)\n\n方法2、优化的动态规划：\n\n上一个方法需要开辟一个n的数组，其实可以直接用双指针完成状态的转移，不再需要开辟多余的空间\n\n\n# java代码\n\nclass solution {\n    public int climbstairs(int n) {\n        if (n <= 1)\n            return 1;\n        int[] dp = new int[n + 1];\n        dp[1] = 1;\n        dp[2] = 2;\n        for (int i = 3; i <= n; i++) {\n            dp[i] = dp[i - 1] + dp[i - 2];\n        }\n        return dp[n];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# java代码2\n\nclass solution {\n    public int climbstairs(int n) {\n        int[] result = new int[]{1, 1};\n        if (n < 2) {\n            return result[n];\n        }\n        int sum = 0;\n        int f1 = 1;\n        int f2 = 1;\n        for (int i = 2; i <= n; i++) {\n            sum = (f1 + f2);\n            f1 = f2;\n            f2 = sum;\n        }\n        return sum;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-72-编辑距离",frontmatter:{title:"LeetCode-72-编辑距离",date:"2020-07-27T09:53:31.000Z",description:"编辑距离",tags:["字符串","Java","DP","Hard"],keywords:"字符串,Java,Hard,DP,LeetCode",permalink:"/pages/dfda01/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/41.LeetCode-72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB.html",relativePath:"06.算法/02.LeetCode/41.LeetCode-72-编辑距离.md",key:"v-695169c4",path:"/pages/dfda01/",headers:[{level:2,title:"LeetCode-72-编辑距离",slug:"leetcode-72-编辑距离",normalizedTitle:"leetcode-72-编辑距离",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:555},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:710}],headersStr:"LeetCode-72-编辑距离 解题思路 Java代码",content:"# LeetCode-72-编辑距离\n\n给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。\n\n你可以对一个单词进行如下三种操作：\n\n 1. 插入一个字符\n 2. 删除一个字符\n 3. 替换一个字符\n\n示例1：\n\n输入：word1 = \"horse\", word2 = \"ros\"\n输出：3\n解释：\nhorse -> rorse (将 'h' 替换为 'r')\nrorse -> rose (删除 'r')\nrose -> ros (删除 'e')\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n示例2：\n\n输入：word1 = \"intention\", word2 = \"execution\"\n输出：5\n解释：\nintention -> inention (删除 't')\ninention -> enention (将 'i' 替换为 'e')\nenention -> exention (将 'n' 替换为 'x')\nexention -> exection (将 'n' 替换为 'c')\nexection -> execution (插入 'u')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 解题思路\n\n方法1、动态规划：\n\n编辑距离是大厂面试的常考题目，是用作机器翻译和语音识别评价的基本算法\n\n详解见官方https://leetcode-cn.com/problems/edit-distance/solution/bian-ji-ju-chi-by-leetcode-solution/\n\n\n# Java代码\n\npublic int minDistance(String word1, String word2) {\n        int n1 = word1.length();\n        int n2 = word2.length();\n        int[][] dp = new int[n1 + 1][n2 + 1];\n        // 边界状态初始化\n        for (int i = 0; i < n1 + 1; i++) {\n            dp[i][0] = i;\n        }\n        for (int j = 0; j < n2 + 1; j++) {\n            dp[0][j] = j;\n        }\n        for (int i = 1; i < n1 + 1; i++) {\n            for (int j = 1; j < n2 + 1; j++) {\n                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1];\n                } else {\n                    dp[i][j] = 1 + Math.min(Math.min(dp[i - 1][j - 1], dp[i][j - 1]), dp[i - 1][j]);\n                }\n            }\n        }\n        return dp[n1][n2];\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n",normalizedContent:"# leetcode-72-编辑距离\n\n给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。\n\n你可以对一个单词进行如下三种操作：\n\n 1. 插入一个字符\n 2. 删除一个字符\n 3. 替换一个字符\n\n示例1：\n\n输入：word1 = \"horse\", word2 = \"ros\"\n输出：3\n解释：\nhorse -> rorse (将 'h' 替换为 'r')\nrorse -> rose (删除 'r')\nrose -> ros (删除 'e')\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n示例2：\n\n输入：word1 = \"intention\", word2 = \"execution\"\n输出：5\n解释：\nintention -> inention (删除 't')\ninention -> enention (将 'i' 替换为 'e')\nenention -> exention (将 'n' 替换为 'x')\nexention -> exection (将 'n' 替换为 'c')\nexection -> execution (插入 'u')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 解题思路\n\n方法1、动态规划：\n\n编辑距离是大厂面试的常考题目，是用作机器翻译和语音识别评价的基本算法\n\n详解见官方https://leetcode-cn.com/problems/edit-distance/solution/bian-ji-ju-chi-by-leetcode-solution/\n\n\n# java代码\n\npublic int mindistance(string word1, string word2) {\n        int n1 = word1.length();\n        int n2 = word2.length();\n        int[][] dp = new int[n1 + 1][n2 + 1];\n        // 边界状态初始化\n        for (int i = 0; i < n1 + 1; i++) {\n            dp[i][0] = i;\n        }\n        for (int j = 0; j < n2 + 1; j++) {\n            dp[0][j] = j;\n        }\n        for (int i = 1; i < n1 + 1; i++) {\n            for (int j = 1; j < n2 + 1; j++) {\n                if (word1.charat(i - 1) == word2.charat(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1];\n                } else {\n                    dp[i][j] = 1 + math.min(math.min(dp[i - 1][j - 1], dp[i][j - 1]), dp[i - 1][j]);\n                }\n            }\n        }\n        return dp[n1][n2];\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-75-颜色分类",frontmatter:{title:"LeetCode-75-颜色分类",date:"2020-08-06T09:47:45.000Z",description:"颜色分类",tags:["数组","Java","Medium"],keywords:"数组,Java,Medium,LeetCode",permalink:"/pages/a35d7b/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/42.LeetCode-75-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB.html",relativePath:"06.算法/02.LeetCode/42.LeetCode-75-颜色分类.md",key:"v-fe099c58",path:"/pages/a35d7b/",headers:[{level:2,title:"LeetCode-75-颜色分类",slug:"leetcode-75-颜色分类",normalizedTitle:"leetcode-75-颜色分类",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:309},{level:3,title:"Java代码1",slug:"java代码1",normalizedTitle:"java代码1",charIndex:923},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:1657}],headersStr:"LeetCode-75-颜色分类 解题思路 Java代码1 Java代码2",content:"# LeetCode-75-颜色分类\n\n给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。\n\n此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。\n\n注意: 不能使用代码库中的排序函数来解决这道题。\n\n示例1：\n\n输入: [2,0,2,1,1,0]\n输出: [0,0,1,1,2,2]\n\n\n1\n2\n\n1\n2\n\n\n进阶：\n\n * 一个直观的解决方案是使用计数排序的两趟扫描算法。 首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。\n * 你能想出一个仅使用常数空间的一趟扫描算法吗？\n\n\n# 解题思路\n\n方法1、计数排序：\n\n初始化max+1容量的桶，将数组值为下标的元素放入对应的桶内，并进行计数，如nums[2]=3，则bucket[3]+1。之后从每个桶中取出元素，重新放入原本的数组，实现原地修改。需要多次遍历数组。当然使用快排也可以，但题目要求使用一趟的扫描算法。\n\n方法2、三指针一次遍历(荷兰国旗问题)：\n\n我们用三个指针（p0, p2 和curr）来分别追踪0的最右边界，2的最左边界和当前考虑的元素。\n\n本解法的思路是沿着数组移动 curr 指针，若nums[curr] = 0，则将其与 nums[p0]互换；若 nums[curr] = 2 ，则与 nums[p2]互换。\n\n算法\n\n * 初始化0的最右边界：p0 = 0。在整个算法执行过程中 nums[idx < p0] = 0.\n\n * 初始化2的最左边界 ：p2 = n - 1。在整个算法执行过程中 nums[idx > p2] = 2.\n\n * 初始化当前考虑的元素序号 ：curr = 0.\n\n * While curr <= p2 :\n   \n   * 若 nums[curr] = 0 ：交换第 curr个 和 第p0个 元素，并将指针都向右移。\n   * 若 nums[curr] = 2 ：交换第 curr个和第 p2个元素，并将 p2指针左移 。\n   * 若 nums[curr] = 1 ：将指针curr右移。\n\n\n# Java代码1\n\nclass Solution {\n    public void sortColors(int[] nums) {\n        int len = nums.length;\n        int max = Integer.MIN_VALUE;\n        if (nums == null || len < 2) return;\n        for (int num : nums) {\n            max = Math.max(max, num);\n        }\n        int[] bucket = new int[max + 1];\n        for (int i = 0; i < len; i++) {\n            bucket[nums[i]]++;\n        }\n        int index = 0;\n        for (int j = 0; j < bucket.length; j++) {\n            while (bucket[j] > 0) {\n                nums[index] = j;\n                bucket[j] -= 1;\n                index++;\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# Java代码2\n\nclass Solution {\n    //只有三种数  0 1 2\n    // 直接冒泡排序  时间复杂度不符合\n    // 双指针  p_0 标注 0元素的最右边   p_2 标注 2元素的最最左边\n    // curr 指针，标注当前元素\n    public void sortColors(int[] nums) {\n        int p1 = 0;\n        int p2 = nums.length-1;\n        int curr = 0;\n        int temp;\n        while(curr<=p2){\n            //如果当前元素等于0，则与P_0互换位置\n            if(nums[curr]==0){\n                temp = nums[p1];\n                nums[p1] = nums[curr];\n                nums[curr] = temp;\n                curr++;\n                p1++;\n            }else if(nums[curr]==2){//如果当前元素等于2，则与P_2互换位置\n                temp = nums[p2];\n                nums[p2] = nums[curr];\n                nums[curr] = temp;\n                p2--;\n            //因为curr左边的值已经扫描过了，所以curr要++继续扫描下一位，而与p2交换的值，curr未扫描，要停下来扫描一下，所以curr不用++\n            }else{\n                curr++;\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n",normalizedContent:"# leetcode-75-颜色分类\n\n给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。\n\n此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。\n\n注意: 不能使用代码库中的排序函数来解决这道题。\n\n示例1：\n\n输入: [2,0,2,1,1,0]\n输出: [0,0,1,1,2,2]\n\n\n1\n2\n\n1\n2\n\n\n进阶：\n\n * 一个直观的解决方案是使用计数排序的两趟扫描算法。 首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。\n * 你能想出一个仅使用常数空间的一趟扫描算法吗？\n\n\n# 解题思路\n\n方法1、计数排序：\n\n初始化max+1容量的桶，将数组值为下标的元素放入对应的桶内，并进行计数，如nums[2]=3，则bucket[3]+1。之后从每个桶中取出元素，重新放入原本的数组，实现原地修改。需要多次遍历数组。当然使用快排也可以，但题目要求使用一趟的扫描算法。\n\n方法2、三指针一次遍历(荷兰国旗问题)：\n\n我们用三个指针（p0, p2 和curr）来分别追踪0的最右边界，2的最左边界和当前考虑的元素。\n\n本解法的思路是沿着数组移动 curr 指针，若nums[curr] = 0，则将其与 nums[p0]互换；若 nums[curr] = 2 ，则与 nums[p2]互换。\n\n算法\n\n * 初始化0的最右边界：p0 = 0。在整个算法执行过程中 nums[idx < p0] = 0.\n\n * 初始化2的最左边界 ：p2 = n - 1。在整个算法执行过程中 nums[idx > p2] = 2.\n\n * 初始化当前考虑的元素序号 ：curr = 0.\n\n * while curr <= p2 :\n   \n   * 若 nums[curr] = 0 ：交换第 curr个 和 第p0个 元素，并将指针都向右移。\n   * 若 nums[curr] = 2 ：交换第 curr个和第 p2个元素，并将 p2指针左移 。\n   * 若 nums[curr] = 1 ：将指针curr右移。\n\n\n# java代码1\n\nclass solution {\n    public void sortcolors(int[] nums) {\n        int len = nums.length;\n        int max = integer.min_value;\n        if (nums == null || len < 2) return;\n        for (int num : nums) {\n            max = math.max(max, num);\n        }\n        int[] bucket = new int[max + 1];\n        for (int i = 0; i < len; i++) {\n            bucket[nums[i]]++;\n        }\n        int index = 0;\n        for (int j = 0; j < bucket.length; j++) {\n            while (bucket[j] > 0) {\n                nums[index] = j;\n                bucket[j] -= 1;\n                index++;\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# java代码2\n\nclass solution {\n    //只有三种数  0 1 2\n    // 直接冒泡排序  时间复杂度不符合\n    // 双指针  p_0 标注 0元素的最右边   p_2 标注 2元素的最最左边\n    // curr 指针，标注当前元素\n    public void sortcolors(int[] nums) {\n        int p1 = 0;\n        int p2 = nums.length-1;\n        int curr = 0;\n        int temp;\n        while(curr<=p2){\n            //如果当前元素等于0，则与p_0互换位置\n            if(nums[curr]==0){\n                temp = nums[p1];\n                nums[p1] = nums[curr];\n                nums[curr] = temp;\n                curr++;\n                p1++;\n            }else if(nums[curr]==2){//如果当前元素等于2，则与p_2互换位置\n                temp = nums[p2];\n                nums[p2] = nums[curr];\n                nums[curr] = temp;\n                p2--;\n            //因为curr左边的值已经扫描过了，所以curr要++继续扫描下一位，而与p2交换的值，curr未扫描，要停下来扫描一下，所以curr不用++\n            }else{\n                curr++;\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-76-最小覆盖字串",frontmatter:{title:"LeetCode-76-最小覆盖字串",date:"2020-08-19T10:10:37.000Z",description:"最小覆盖字串",tags:["字符串","滑动窗口","Java","Hard"],keywords:"字符串,滑动窗口,Java,Hard,LeetCode",permalink:"/pages/a90162/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/43.LeetCode-76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%97%E4%B8%B2.html",relativePath:"06.算法/02.LeetCode/43.LeetCode-76-最小覆盖字串.md",key:"v-0f2f29d4",path:"/pages/a90162/",headers:[{level:2,title:"LeetCode-76-最小覆盖字串",slug:"leetcode-76-最小覆盖字串",normalizedTitle:"leetcode-76-最小覆盖字串",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:227},{level:3,title:"Java代码1",slug:"java代码1",normalizedTitle:"java代码1",charIndex:634},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:1936}],headersStr:"LeetCode-76-最小覆盖字串 解题思路 Java代码1 Java代码2",content:'# LeetCode-76-最小覆盖字串\n\n给你一个字符串 S、一个字符串 T 。请你设计一种算法，可以在 O(n) 的时间复杂度内，从字符串 S 里面找出：包含 T 所有字符的最小子串。\n\n示例1：\n\n输入：S = "ADOBECODEBANC", T = "ABC"\n输出："BANC"\n\n\n1\n2\n\n1\n2\n\n\n提示：\n\n * 如果 S 中不存这样的子串，则返回空字符串 ""。\n * 如果 S 中存在这样的子串，我们保证它是唯一的答案。\n\n\n# 解题思路\n\n方法1、滑动窗口(数组)：\n\n示例中只列出了大写字母，但实际测试中含有小写字母，且同一字母可能会出现多次\n\n用2个128长度的数组存储窗口window和实际需要的数组need\n\n 1. 先将两个字串转为char数组，用need数组存储对应字符的出现次数\n 2. 初始化滑动窗口指针，left、right、valid(记录匹配的长度)\n 3. 因为需要返回匹配的最短字串，所以使用start和end指针记录子串的首尾位置\n 4. 当右边界小于s的长度时，进行窗口滑动，直到包含t中所有字符为止\n 5. 当valid长度达到t子串长度时，停止增加右边界，记录当前匹配的串的start和end；之后不断减小左边界，直到窗口中的字符不符合要求\n 6. 重复4、5步，直到right达到s长度\n 7. 返回子串start,start+end\n\n方法2、滑动窗口(哈希表)：\n\n和上面类似，改为哈希表存储\n\n\n# Java代码1\n\nclass Solution {\n    public String minWindow(String s, String t) {\n        char[] arrs = s.toCharArray();\n        char[] arrt = t.toCharArray();\n        int[] window = new int[128];\n        int[] need = new int[128];\n        for (int i = 0; i < arrt.length; i++) {\n            need[arrt[i]]++;\n        }\n        int left = 0, right = 0, valid = 0;\n        int start = 0, end = Integer.MAX_VALUE;\n        while (right < arrs.length) {\n            char cright = arrs[right];\n            right++;\n            window[cright]++;\n            if (window[cright] <= need[cright]) {\n                valid++;\n            }\n            while (valid == arrt.length) {\n                if (right - left < end) {\n                    start = left;\n                    end = right - left;\n                }\n                char cleft = arrs[left];\n                left++;\n                if (window[cleft] == need[cleft]) {\n                    valid--;\n                }\n                window[cleft]--;\n            }\n        }\n        return end == Integer.MAX_VALUE ? "" : s.substring(start, start + end);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# Java代码2\n\nclass Solution {\n    public String minWindow(String s, String t) {\n        Map<Character,Integer> need = new HashMap<>();\n        Map<Character,Integer> window = new HashMap<>();\n        for(char c: t.toCharArray()){\n            need.put(c,need.getOrDefault(c,0)+1);\n        }\n        int left = 0,right = 0;\n        int valid = 0;\n        int start = 0,len = Integer.MAX_VALUE;\n        while(right<s.length()){\n            char cright = s.charAt(right);\n            right++;\n            if(need.containsKey(cright)){\n                window.put(cright,window.getOrDefault(cright,0)+1);\n                if((int)window.get(cright)==(int)need.get(cright)){\n                    valid++;\n                }\n            }\n            while(valid==need.size()){\n                if(right-left<len){\n                    start = left;\n                    len = right - left;\n                }\n                char dleft = s.charAt(left);\n                left++;\n                if(need.containsKey(dleft)){\n                    if((int)window.get(dleft)==(int)need.get(dleft)){\n                        valid--;\n                    }\n                    window.put(dleft,window.get(dleft)-1);\n                }\n            }\n        }\n        return len==Integer.MAX_VALUE? "" : s.substring(start,start+len);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n',normalizedContent:'# leetcode-76-最小覆盖字串\n\n给你一个字符串 s、一个字符串 t 。请你设计一种算法，可以在 o(n) 的时间复杂度内，从字符串 s 里面找出：包含 t 所有字符的最小子串。\n\n示例1：\n\n输入：s = "adobecodebanc", t = "abc"\n输出："banc"\n\n\n1\n2\n\n1\n2\n\n\n提示：\n\n * 如果 s 中不存这样的子串，则返回空字符串 ""。\n * 如果 s 中存在这样的子串，我们保证它是唯一的答案。\n\n\n# 解题思路\n\n方法1、滑动窗口(数组)：\n\n示例中只列出了大写字母，但实际测试中含有小写字母，且同一字母可能会出现多次\n\n用2个128长度的数组存储窗口window和实际需要的数组need\n\n 1. 先将两个字串转为char数组，用need数组存储对应字符的出现次数\n 2. 初始化滑动窗口指针，left、right、valid(记录匹配的长度)\n 3. 因为需要返回匹配的最短字串，所以使用start和end指针记录子串的首尾位置\n 4. 当右边界小于s的长度时，进行窗口滑动，直到包含t中所有字符为止\n 5. 当valid长度达到t子串长度时，停止增加右边界，记录当前匹配的串的start和end；之后不断减小左边界，直到窗口中的字符不符合要求\n 6. 重复4、5步，直到right达到s长度\n 7. 返回子串start,start+end\n\n方法2、滑动窗口(哈希表)：\n\n和上面类似，改为哈希表存储\n\n\n# java代码1\n\nclass solution {\n    public string minwindow(string s, string t) {\n        char[] arrs = s.tochararray();\n        char[] arrt = t.tochararray();\n        int[] window = new int[128];\n        int[] need = new int[128];\n        for (int i = 0; i < arrt.length; i++) {\n            need[arrt[i]]++;\n        }\n        int left = 0, right = 0, valid = 0;\n        int start = 0, end = integer.max_value;\n        while (right < arrs.length) {\n            char cright = arrs[right];\n            right++;\n            window[cright]++;\n            if (window[cright] <= need[cright]) {\n                valid++;\n            }\n            while (valid == arrt.length) {\n                if (right - left < end) {\n                    start = left;\n                    end = right - left;\n                }\n                char cleft = arrs[left];\n                left++;\n                if (window[cleft] == need[cleft]) {\n                    valid--;\n                }\n                window[cleft]--;\n            }\n        }\n        return end == integer.max_value ? "" : s.substring(start, start + end);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# java代码2\n\nclass solution {\n    public string minwindow(string s, string t) {\n        map<character,integer> need = new hashmap<>();\n        map<character,integer> window = new hashmap<>();\n        for(char c: t.tochararray()){\n            need.put(c,need.getordefault(c,0)+1);\n        }\n        int left = 0,right = 0;\n        int valid = 0;\n        int start = 0,len = integer.max_value;\n        while(right<s.length()){\n            char cright = s.charat(right);\n            right++;\n            if(need.containskey(cright)){\n                window.put(cright,window.getordefault(cright,0)+1);\n                if((int)window.get(cright)==(int)need.get(cright)){\n                    valid++;\n                }\n            }\n            while(valid==need.size()){\n                if(right-left<len){\n                    start = left;\n                    len = right - left;\n                }\n                char dleft = s.charat(left);\n                left++;\n                if(need.containskey(dleft)){\n                    if((int)window.get(dleft)==(int)need.get(dleft)){\n                        valid--;\n                    }\n                    window.put(dleft,window.get(dleft)-1);\n                }\n            }\n        }\n        return len==integer.max_value? "" : s.substring(start,start+len);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-77-组合",frontmatter:{title:"LeetCode-77-组合",date:"2020-07-28T09:30:45.000Z",description:"组合",tags:["数组","回溯","Java","Medium"],keywords:"数组,Java,回溯,Medium,LeetCode",permalink:"/pages/c30be8/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/44.LeetCode-77-%E7%BB%84%E5%90%88.html",relativePath:"06.算法/02.LeetCode/44.LeetCode-77-组合.md",key:"v-347e45ac",path:"/pages/c30be8/",headers:[{level:2,title:"LeetCode-77-组合",slug:"leetcode-77-组合",normalizedTitle:"leetcode-77-组合",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:194},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:419}],headersStr:"LeetCode-77-组合 解题思路 Java代码",content:"# LeetCode-77-组合\n\n给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。\n\n示例1：\n\n输入: n = 4, k = 2\n输出:\n[\n  [2,4],\n  [3,4],\n  [2,3],\n  [1,2],\n  [1,3],\n  [1,4],\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 解题思路\n\n方法1、回溯：\n\n典型的回溯题目，通过画一棵选择树不难看出，当有初始数组[1,2,3,4]，k=2时\n\n选择1之后，选择2，3，4能够组合成新的字串\n\n选择2之后，选择3，4，能够组合成新的字串\n\n可以归纳为，对于第i个选择的数，其和i+1开始到n的所有数进行组合，能够得到新的字串，且不会发生重复。\n\n递归的终止条件为，k==2时，将字串添加进res中\n\n当选择到达要求进行返回时，撤销上一次的选择，进行新的选择组合成新的字串\n\n\n# Java代码\n\nclass Solution {\n    public List<List<Integer>> combine(int n, int k) {\n        List<List<Integer>> res = new ArrayList<>();\n        backtrack(res, 1, n, k, new ArrayList<>());\n        return res;\n    }\n\n    private void backtrack(List<List<Integer>> res, int i, int n, int k, ArrayList<Integer> temp) {\n        if (k == temp.size()) {\n            res.add(new ArrayList<>(temp));\n            return;\n        }\n        for (int start = i; start < n + 1; start++) {\n            temp.add(start);\n            backtrack(res, start + 1, n, k, temp);\n            temp.remove(temp.size() - 1);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n",normalizedContent:"# leetcode-77-组合\n\n给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。\n\n示例1：\n\n输入: n = 4, k = 2\n输出:\n[\n  [2,4],\n  [3,4],\n  [2,3],\n  [1,2],\n  [1,3],\n  [1,4],\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 解题思路\n\n方法1、回溯：\n\n典型的回溯题目，通过画一棵选择树不难看出，当有初始数组[1,2,3,4]，k=2时\n\n选择1之后，选择2，3，4能够组合成新的字串\n\n选择2之后，选择3，4，能够组合成新的字串\n\n可以归纳为，对于第i个选择的数，其和i+1开始到n的所有数进行组合，能够得到新的字串，且不会发生重复。\n\n递归的终止条件为，k==2时，将字串添加进res中\n\n当选择到达要求进行返回时，撤销上一次的选择，进行新的选择组合成新的字串\n\n\n# java代码\n\nclass solution {\n    public list<list<integer>> combine(int n, int k) {\n        list<list<integer>> res = new arraylist<>();\n        backtrack(res, 1, n, k, new arraylist<>());\n        return res;\n    }\n\n    private void backtrack(list<list<integer>> res, int i, int n, int k, arraylist<integer> temp) {\n        if (k == temp.size()) {\n            res.add(new arraylist<>(temp));\n            return;\n        }\n        for (int start = i; start < n + 1; start++) {\n            temp.add(start);\n            backtrack(res, start + 1, n, k, temp);\n            temp.remove(temp.size() - 1);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-78-子集",frontmatter:{title:"LeetCode-78-子集",date:"2020-07-27T15:29:47.000Z",description:"子集",tags:["数组","Java","回溯","Medium"],keywords:"数组,Java,Medium,LeetCode",permalink:"/pages/60626a/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/45.LeetCode-78-%E5%AD%90%E9%9B%86.html",relativePath:"06.算法/02.LeetCode/45.LeetCode-78-子集.md",key:"v-bdb3b278",path:"/pages/60626a/",headers:[{level:2,title:"LeetCode-78-子集",slug:"leetcode-78-子集",normalizedTitle:"leetcode-78-子集",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:238},{level:3,title:"Java代码1",slug:"java代码1",normalizedTitle:"java代码1",charIndex:621},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:1157}],headersStr:"LeetCode-78-子集 解题思路 Java代码1 Java代码2",content:"# LeetCode-78-子集\n\n给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。\n\n**说明：**解集不能包含重复的子集。\n\n示例1：\n\n输入: nums = [1,2,3]\n输出:\n[\n  [3],\n  [1],\n  [2],\n  [1,2,3],\n  [1,3],\n  [2,3],\n  [1,2],\n  []\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 解题思路\n\n方法1、迭代：\n\n外层循环遍历原始数组\n\n内层循环遍历结果集，进行结果集的组合\n\n特例：空集是所有结果的子集\n\n当知道目前结果集有[[],[1]]时，想要得到[1,2]的所有子集，可以通过选择数字2和结果集进行组合得到；2与[]组合，得到[2]，2与1组合得到[1,2]。最终结果集为[[],[1],[2],[1,2]]满足数组[1,2]子集结果\n\n在代码上想要进行这类组合，只需要在选择下一个数字后，计算当前结果集的大小，内部循环到size，进行各个位置存的结果的获取，获取之后往尾部添加选择的数字即可。\n\n方法2、回溯：\n\n可以画递归树，看起来更为清晰\n\n回溯的框架：\n\n * 做出选择\n * 递归进入下一层，此时i+1，从原始数组下一个开始，避免重复选择，所以不需要剪枝\n * 当达到循环结束条件，即数组选完了，撤销上一次选择，走另外的路\n\n\n# Java代码1\n\nclass Solution {\n    public List<List<Integer>> subsets(int[] nums) {\n        List<List<Integer>> res = new ArrayList<>();\n        res.add(new ArrayList<>());\n        for (int num : nums) {\n            int size = res.size();\n            for (int i = 0; i < size; i++) {\n                List<Integer> tmp = new ArrayList<>(res.get(i));\n                tmp.add(num);\n                res.add(tmp);\n            }\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# Java代码2\n\nclass Solution {\n    public List<List<Integer>> subsets(int[] nums) {\n        int len = nums.length;\n        List<List<Integer>> res = new ArrayList<>();\n        if (len == 0) return res;\n        List<Integer> path = new ArrayList<>();\n        backtrack(nums, 0, path, res);\n        return res;\n    }\n\n    private void backtrack(int[] nums, int start, List<Integer> path, List<List<Integer>> res) {\n        res.add(new ArrayList<>(path));\n        for (int i = start; i < nums.length; i++) {\n            path.add(nums[i]);\n            backtrack(nums, i + 1, path, res);\n            path.remove(path.size() - 1);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n",normalizedContent:"# leetcode-78-子集\n\n给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。\n\n**说明：**解集不能包含重复的子集。\n\n示例1：\n\n输入: nums = [1,2,3]\n输出:\n[\n  [3],\n  [1],\n  [2],\n  [1,2,3],\n  [1,3],\n  [2,3],\n  [1,2],\n  []\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 解题思路\n\n方法1、迭代：\n\n外层循环遍历原始数组\n\n内层循环遍历结果集，进行结果集的组合\n\n特例：空集是所有结果的子集\n\n当知道目前结果集有[[],[1]]时，想要得到[1,2]的所有子集，可以通过选择数字2和结果集进行组合得到；2与[]组合，得到[2]，2与1组合得到[1,2]。最终结果集为[[],[1],[2],[1,2]]满足数组[1,2]子集结果\n\n在代码上想要进行这类组合，只需要在选择下一个数字后，计算当前结果集的大小，内部循环到size，进行各个位置存的结果的获取，获取之后往尾部添加选择的数字即可。\n\n方法2、回溯：\n\n可以画递归树，看起来更为清晰\n\n回溯的框架：\n\n * 做出选择\n * 递归进入下一层，此时i+1，从原始数组下一个开始，避免重复选择，所以不需要剪枝\n * 当达到循环结束条件，即数组选完了，撤销上一次选择，走另外的路\n\n\n# java代码1\n\nclass solution {\n    public list<list<integer>> subsets(int[] nums) {\n        list<list<integer>> res = new arraylist<>();\n        res.add(new arraylist<>());\n        for (int num : nums) {\n            int size = res.size();\n            for (int i = 0; i < size; i++) {\n                list<integer> tmp = new arraylist<>(res.get(i));\n                tmp.add(num);\n                res.add(tmp);\n            }\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# java代码2\n\nclass solution {\n    public list<list<integer>> subsets(int[] nums) {\n        int len = nums.length;\n        list<list<integer>> res = new arraylist<>();\n        if (len == 0) return res;\n        list<integer> path = new arraylist<>();\n        backtrack(nums, 0, path, res);\n        return res;\n    }\n\n    private void backtrack(int[] nums, int start, list<integer> path, list<list<integer>> res) {\n        res.add(new arraylist<>(path));\n        for (int i = start; i < nums.length; i++) {\n            path.add(nums[i]);\n            backtrack(nums, i + 1, path, res);\n            path.remove(path.size() - 1);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-84-柱状图中最大的矩形",frontmatter:{title:"LeetCode-84-柱状图中最大的矩形",date:"2020-08-07T10:13:52.000Z",description:"柱状图中最大的矩形",tags:["数组","Java","Hard"],keywords:"数组,Java,Hard,LeetCode",permalink:"/pages/16f784/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/46.LeetCode-84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.html",relativePath:"06.算法/02.LeetCode/46.LeetCode-84-柱状图中最大的矩形.md",key:"v-573934c0",path:"/pages/16f784/",headers:[{level:2,title:"LeetCode-84-柱状图中最大的矩形",slug:"leetcode-84-柱状图中最大的矩形",normalizedTitle:"leetcode-84-柱状图中最大的矩形",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:223},{level:3,title:"Java代码1",slug:"java代码1",normalizedTitle:"java代码1",charIndex:701},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:1344},{level:3,title:"Java代码3",slug:"java代码3",normalizedTitle:"java代码3",charIndex:2976}],headersStr:"LeetCode-84-柱状图中最大的矩形 解题思路 Java代码1 Java代码2 Java代码3",content:"# LeetCode-84-柱状图中最大的矩形\n\n给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。\n\n求在该柱状图中，能够勾勒出来的矩形的最大面积。\n\n以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。\n\n图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。\n\n示例1：\n\n输入: [2,1,5,6,2,3]\n输出: 10\n\n\n1\n2\n\n1\n2\n\n\n\n# 解题思路\n\n方法1、暴力破解：\n\n固定一个柱子的高度，往左和右寻找第一个高度小于当前柱子的柱体，向左和向右走的步数即是宽度\n\n对于每个柱子，都计算一次以当前柱子为高度，左右寻找位置为宽度围成的矩形面积，最后得到最大的面积即可\n\n方法2、单调栈：\n\n我们可以 O(1) 的获取柱体 i 左边第一个比它小的柱体吗？答案就是单调增栈，因为对于栈中的柱体来说，栈中下一个柱体就是左边第一个高度小于自身的柱体。\n\n视频详解https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/zhu-zhuang-tu-zhong-zui-da-de-ju-xing-by-leetcode-/\n\n方法3、单调栈+哨兵：\n\n视频详解https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/zhu-zhuang-tu-zhong-zui-da-de-ju-xing-by-leetcode-/\n\n\n# Java代码1\n\nclass Solution {\n    public int largestRectangleArea(int[] heights) {\n        int area = 0;\n        int len = heights.length;\n        for(int i=0;i<len;i++){\n            int width = 1;\n            int height = heights[i];\n            int j = i;\n            while(--j>=0&&heights[j]>=height){\n                width++;\n            }\n            j = i;\n            while(++j<len&&heights[j]>=height){\n                width++;\n            }\n            area = Math.max(area,width*height);\n        }\n        return area;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# Java代码2\n\nclass Solution {\n    public int largestRectangleArea(int[] heights) {\n        int area = 0;\n        int len = heights.length;\n        if (len == 0) {\n            return 0;\n        }\n        if (len == 1) {\n            return heights[0];\n        }\n        Deque<Integer> stack = new ArrayDeque<Integer>();\n        for (int i = 0; i < len; i++) {\n            while(!stack.isEmpty()&&heights[stack.peekLast()]>heights[i]){\n                int height = heights[stack.removeLast()];\n                while(!stack.isEmpty()&&heights[stack.peekLast()]==height){\n                    stack.removeLast();\n                }\n                int width;\n                if(stack.isEmpty()){\n                    width = i;\n                }else {\n                    width = i-stack.peekLast()-1;\n                }\n                area = Math.max(area,width*height);\n            }\n            stack.addLast(i);\n        }\n\n        while(!stack.isEmpty()){\n            int height = heights[stack.removeLast()];\n            while(!stack.isEmpty()&&heights[stack.peekLast()]==height){\n                stack.removeLast();\n            }\n            int width;\n            if(stack.isEmpty()){\n                width = len;\n            }else {\n                width = len-stack.peekLast()-1;\n            }\n            area = Math.max(area,width*height);\n        }\n        return area;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n\n# Java代码3\n\nclass Solution {\n    public int largestRectangleArea(int[] heights) {\n        int area = 0;\n        int len = heights.length;\n        if (len == 0) {\n            return 0;\n        }\n        if (len == 1) {\n            return heights[0];\n        }\n        int[] newHeights = new int[len + 2];\n        for (int i = 0; i < len; i++) {\n            newHeights[i + 1] = heights[i];\n        }\n        len += 2;\n        heights = newHeights;\n        Deque<Integer> stack = new ArrayDeque<Integer>();\n        stack.addLast(0);\n        for (int i = 0; i < len; i++) {\n            while (heights[stack.peekLast()] > heights[i]) {\n                int height = heights[stack.removeLast()];\n                int width = i - stack.peekLast() - 1;\n                area = Math.max(area, width * height);\n            }\n            stack.addLast(i);\n        }\n        return area;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n",normalizedContent:"# leetcode-84-柱状图中最大的矩形\n\n给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。\n\n求在该柱状图中，能够勾勒出来的矩形的最大面积。\n\n以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。\n\n图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。\n\n示例1：\n\n输入: [2,1,5,6,2,3]\n输出: 10\n\n\n1\n2\n\n1\n2\n\n\n\n# 解题思路\n\n方法1、暴力破解：\n\n固定一个柱子的高度，往左和右寻找第一个高度小于当前柱子的柱体，向左和向右走的步数即是宽度\n\n对于每个柱子，都计算一次以当前柱子为高度，左右寻找位置为宽度围成的矩形面积，最后得到最大的面积即可\n\n方法2、单调栈：\n\n我们可以 o(1) 的获取柱体 i 左边第一个比它小的柱体吗？答案就是单调增栈，因为对于栈中的柱体来说，栈中下一个柱体就是左边第一个高度小于自身的柱体。\n\n视频详解https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/zhu-zhuang-tu-zhong-zui-da-de-ju-xing-by-leetcode-/\n\n方法3、单调栈+哨兵：\n\n视频详解https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/zhu-zhuang-tu-zhong-zui-da-de-ju-xing-by-leetcode-/\n\n\n# java代码1\n\nclass solution {\n    public int largestrectanglearea(int[] heights) {\n        int area = 0;\n        int len = heights.length;\n        for(int i=0;i<len;i++){\n            int width = 1;\n            int height = heights[i];\n            int j = i;\n            while(--j>=0&&heights[j]>=height){\n                width++;\n            }\n            j = i;\n            while(++j<len&&heights[j]>=height){\n                width++;\n            }\n            area = math.max(area,width*height);\n        }\n        return area;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# java代码2\n\nclass solution {\n    public int largestrectanglearea(int[] heights) {\n        int area = 0;\n        int len = heights.length;\n        if (len == 0) {\n            return 0;\n        }\n        if (len == 1) {\n            return heights[0];\n        }\n        deque<integer> stack = new arraydeque<integer>();\n        for (int i = 0; i < len; i++) {\n            while(!stack.isempty()&&heights[stack.peeklast()]>heights[i]){\n                int height = heights[stack.removelast()];\n                while(!stack.isempty()&&heights[stack.peeklast()]==height){\n                    stack.removelast();\n                }\n                int width;\n                if(stack.isempty()){\n                    width = i;\n                }else {\n                    width = i-stack.peeklast()-1;\n                }\n                area = math.max(area,width*height);\n            }\n            stack.addlast(i);\n        }\n\n        while(!stack.isempty()){\n            int height = heights[stack.removelast()];\n            while(!stack.isempty()&&heights[stack.peeklast()]==height){\n                stack.removelast();\n            }\n            int width;\n            if(stack.isempty()){\n                width = len;\n            }else {\n                width = len-stack.peeklast()-1;\n            }\n            area = math.max(area,width*height);\n        }\n        return area;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n\n# java代码3\n\nclass solution {\n    public int largestrectanglearea(int[] heights) {\n        int area = 0;\n        int len = heights.length;\n        if (len == 0) {\n            return 0;\n        }\n        if (len == 1) {\n            return heights[0];\n        }\n        int[] newheights = new int[len + 2];\n        for (int i = 0; i < len; i++) {\n            newheights[i + 1] = heights[i];\n        }\n        len += 2;\n        heights = newheights;\n        deque<integer> stack = new arraydeque<integer>();\n        stack.addlast(0);\n        for (int i = 0; i < len; i++) {\n            while (heights[stack.peeklast()] > heights[i]) {\n                int height = heights[stack.removelast()];\n                int width = i - stack.peeklast() - 1;\n                area = math.max(area, width * height);\n            }\n            stack.addlast(i);\n        }\n        return area;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-102-二叉树的层序遍历",frontmatter:{title:"LeetCode-102-二叉树的层序遍历",date:"2020-07-15T14:14:24.000Z",description:"二叉树的层序遍历",tags:["树","Java","Medium"],keywords:"树,Java,Medium,LeetCode",permalink:"/pages/bcc13b/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/47.LeetCode-102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html",relativePath:"06.算法/02.LeetCode/47.LeetCode-102-二叉树的层序遍历.md",key:"v-8333bcc2",path:"/pages/bcc13b/",headers:[{level:2,title:"LeetCode-102-二叉树的层序遍历",slug:"leetcode-102-二叉树的层序遍历",normalizedTitle:"leetcode-102-二叉树的层序遍历",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:242},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:348}],headersStr:"LeetCode-102-二叉树的层序遍历 解题思路 Java代码",content:"# LeetCode-102-二叉树的层序遍历\n\n给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。\n\n示例： 二叉树：[3,9,20,null,null,15,7],\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n返回其层次遍历结果：\n\n[\n  [3],\n  [9,20],\n  [15,7]\n]\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n\n# 解题思路\n\n方法1、Queue迭代：\n\n利用一个Queue存储每层的节点，当一层没有遍历完时，持续poll出队列中的节点，并同时加入对应左右节点进入queue中，当一层遍历完成之后加入到结果集res中。\n\n\n# Java代码\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        List<List<Integer>> res = new LinkedList<>();\n        if(root==null) return res;\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.add(root);\n        while(!queue.isEmpty()){\n            List<Integer> row = new LinkedList<>();\n            int size = queue.size();\n            for(int i=0;i<size;i++){\n                TreeNode temp = queue.poll();\n                row.add(temp.val);\n                if(temp.left!=null)\n                    queue.add(temp.left);\n                if(temp.right!=null)\n                    queue.add(temp.right);\n            }\n            res.add(new LinkedList<>(row));\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n",normalizedContent:"# leetcode-102-二叉树的层序遍历\n\n给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。\n\n示例： 二叉树：[3,9,20,null,null,15,7],\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n返回其层次遍历结果：\n\n[\n  [3],\n  [9,20],\n  [15,7]\n]\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n\n# 解题思路\n\n方法1、queue迭代：\n\n利用一个queue存储每层的节点，当一层没有遍历完时，持续poll出队列中的节点，并同时加入对应左右节点进入queue中，当一层遍历完成之后加入到结果集res中。\n\n\n# java代码\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public list<list<integer>> levelorder(treenode root) {\n        list<list<integer>> res = new linkedlist<>();\n        if(root==null) return res;\n        queue<treenode> queue = new linkedlist<>();\n        queue.add(root);\n        while(!queue.isempty()){\n            list<integer> row = new linkedlist<>();\n            int size = queue.size();\n            for(int i=0;i<size;i++){\n                treenode temp = queue.poll();\n                row.add(temp.val);\n                if(temp.left!=null)\n                    queue.add(temp.left);\n                if(temp.right!=null)\n                    queue.add(temp.right);\n            }\n            res.add(new linkedlist<>(row));\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-104-二叉树的最大深度",frontmatter:{title:"LeetCode-104-二叉树的最大深度",date:"2020-06-11T19:38:36.000Z",description:"二叉树的最大深度",tags:["树","DFS","Java","Easy"],keywords:"树,DFS,Java,Easy",permalink:"/pages/95771c/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/48.LeetCode-104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html",relativePath:"06.算法/02.LeetCode/48.LeetCode-104-二叉树的最大深度.md",key:"v-7a4a3fcc",path:"/pages/95771c/",headers:[{level:2,title:"LeetCode-104-二叉树的最大深度",slug:"leetcode-104-二叉树的最大深度",normalizedTitle:"leetcode-104-二叉树的最大深度",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:214},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:488},{level:3,title:"Java代码2(迭代Queue)",slug:"java代码2-迭代queue",normalizedTitle:"java代码2(迭代queue)",charIndex:983}],headersStr:"LeetCode-104-二叉树的最大深度 解题思路 Java代码 Java代码2(迭代Queue)",content:"# LeetCode-104-二叉树的最大深度\n\n给定一个二叉树，找出其最大深度。\n\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n\n说明: 叶子节点是指没有子节点的节点。\n\n示例 1:\n\n给定二叉树 [3,9,20,null,null,15,7]\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n返回它的最大深度 3 。\n\n\n# 解题思路\n\n方法1、DFS递归：\n\n特例：root为空直接返回0\n\nDFS左子树深度，DFS右子树深度，树的深度=Max(左子树，右子树)+root节点\n\n方法2、Queue迭代：\n\n利用层序遍历的思想，一层一层遍历，每过一层深度+1\n\n利用一个先进先出的Queue队列，先将root节点加入其中，当queue不为空的时候开始遍历\n\n深度+1，弹出队列头部，判断头部的左右节点是否为空，不为空则加入其中\n\n对于一层的节点，节点数为queue.size()，对于queue中的每个节点都需要进行左右节点的判断\n\n当一层遍历完毕时，深度就+1\n\n\n# Java代码\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root==null) return 0;\n        int left = maxDepth(root.left);\n        int right = maxDepth(root.right);\n        return Math.max(left,right)+1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# Java代码2(迭代Queue)\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root==null) return 0;\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.add(root);\n        int depth=0;\n        while(!queue.isEmpty()){\n            depth++;\n            int size = queue.size();\n            for(int i=0;i<size;i++){\n                TreeNode temp = queue.poll();\n                if(temp.left!=null){\n                    queue.add(temp.left);\n                }\n                if(temp.right!=null){\n                    queue.add(temp.right);\n                }\n            }\n        }\n        return depth;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n",normalizedContent:"# leetcode-104-二叉树的最大深度\n\n给定一个二叉树，找出其最大深度。\n\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n\n说明: 叶子节点是指没有子节点的节点。\n\n示例 1:\n\n给定二叉树 [3,9,20,null,null,15,7]\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n返回它的最大深度 3 。\n\n\n# 解题思路\n\n方法1、dfs递归：\n\n特例：root为空直接返回0\n\ndfs左子树深度，dfs右子树深度，树的深度=max(左子树，右子树)+root节点\n\n方法2、queue迭代：\n\n利用层序遍历的思想，一层一层遍历，每过一层深度+1\n\n利用一个先进先出的queue队列，先将root节点加入其中，当queue不为空的时候开始遍历\n\n深度+1，弹出队列头部，判断头部的左右节点是否为空，不为空则加入其中\n\n对于一层的节点，节点数为queue.size()，对于queue中的每个节点都需要进行左右节点的判断\n\n当一层遍历完毕时，深度就+1\n\n\n# java代码\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public int maxdepth(treenode root) {\n        if(root==null) return 0;\n        int left = maxdepth(root.left);\n        int right = maxdepth(root.right);\n        return math.max(left,right)+1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# java代码2(迭代queue)\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public int maxdepth(treenode root) {\n        if(root==null) return 0;\n        queue<treenode> queue = new linkedlist<>();\n        queue.add(root);\n        int depth=0;\n        while(!queue.isempty()){\n            depth++;\n            int size = queue.size();\n            for(int i=0;i<size;i++){\n                treenode temp = queue.poll();\n                if(temp.left!=null){\n                    queue.add(temp.left);\n                }\n                if(temp.right!=null){\n                    queue.add(temp.right);\n                }\n            }\n        }\n        return depth;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-105-从前序与中序遍历构造二叉树",frontmatter:{title:"LeetCode-105-从前序与中序遍历构造二叉树",date:"2020-06-22T11:01:44.000Z",description:"从前序与中序遍历构造二叉树",tags:["树","Java","Medium"],keywords:"树,Java,Medium",permalink:"/pages/c5dd58/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/49.LeetCode-105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html",relativePath:"06.算法/02.LeetCode/49.LeetCode-105-从前序与中序遍历构造二叉树.md",key:"v-633b41b0",path:"/pages/c5dd58/",headers:[{level:2,title:"LeetCode-105-从前序与中序遍历构造二叉树",slug:"leetcode-105-从前序与中序遍历构造二叉树",normalizedTitle:"leetcode-105-从前序与中序遍历构造二叉树",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:239},{level:3,title:"Java代码1",slug:"java代码1",normalizedTitle:"java代码1",charIndex:830},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:2549}],headersStr:"LeetCode-105-从前序与中序遍历构造二叉树 解题思路 Java代码1 Java代码2",content:"# LeetCode-105-从前序与中序遍历构造二叉树\n\n根据一棵树的前序遍历与中序遍历构造二叉树。\n\n注意: 你可以假设树中没有重复的元素。\n\n示例 1:\n\n例如，给出\n\n前序遍历 preorder = [3,9,20,15,7]\n中序遍历 inorder = [9,3,15,20,7]\n\n\n1\n2\n\n1\n2\n\n\n返回如下的二叉树：\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n\n# 解题思路\n\n方法1、递归：\n\n前序遍历：根左右\n\n中序遍历：左根右\n\n对于任意一棵树而言，前序遍历的形式总是\n\n[根节点，[左子树的前序遍历结果],[右子树的前序遍历结果]]\n\n\n1\n\n1\n\n\n根节点总是，前序遍历中的第一个节点\n\n中序遍历的形式总是\n\n[[左子树的中序遍历结果],根节点,[右子树的中序遍历结果]]\n\n\n1\n\n1\n\n\n只要能够在中序遍历中定位到根节点，那么就可以得到对应的左右子树的节点数目\n\n由于前序遍历和中序遍历的长度是相同的，所以我们也能知道前序遍历的左右字数的区间范围\n\n之后进行递归，问题就变为了：\n\n知道左子树的前序和中序遍历，重建左子树；知道右子树的前序和中序遍历，重建右子树；\n\n定位优化：\n\n在中序遍历中需要根据前序遍历的根节点，定位到中序遍历中的根节点\n\n直接进行扫描匹配的耗时比较大，可以在一开始对中序遍历建立hash表，Key代表元素的值，value代表在中序遍历中出现的位置。之后寻找对应值就能够快速定位了\n\n方法2、迭代：\n\nhttps://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-9/\n\n\n# Java代码1\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        if(preorder==null||preorder.length==0){\n            return null;\n        }\n        Map<Integer,Integer> map = new HashMap<>();\n        for(int i=0;i<inorder.length;i++){\n            map.put(inorder[i],i);\n        }\n        int length = preorder.length-1;\n        TreeNode root = reconstrTree(preorder,0,length,inorder,0,length,map);\n        return root;\n    }\n\n    public TreeNode reconstrTree(int[] preorder,int postart,int poend,int[] inorder,int instart,int inend,Map<Integer,Integer> map){\n        if(postart>poend){\n            return null;\n        }\n        int rootNode = preorder[postart];\n        TreeNode root = new TreeNode(rootNode);\n        if(postart==poend){\n            return root;\n        }else{\n            int rootIndex = map.get(rootNode);\n            int leftRange = rootIndex - instart;\n            int rightRange = inend - rootIndex;\n            TreeNode leftTree = reconstrTree(preorder,postart+1,postart+leftRange,inorder,instart,rootIndex-1,map);\n            TreeNode rightTree = reconstrTree(preorder,poend-rightRange+1,poend,inorder,rootIndex+1,inend,map);\n            root.left = leftTree;\n            root.right = rightTree;\n            return root;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# Java代码2\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        if (preorder == null || preorder.length == 0) {\n            return null;\n        }\n        TreeNode root = new TreeNode(preorder[0]);\n        Stack<TreeNode> stack = new Stack<TreeNode>();\n        stack.push(root);\n        int inorderIndex = 0;\n        for (int i = 1; i < preorder.length; i++) {\n            int preorderVal = preorder[i];\n            TreeNode node = stack.peek();\n            if (node.val != inorder[inorderIndex]) {\n                node.left = new TreeNode(preorderVal);\n                stack.push(node.left);\n            } else {\n                while (!stack.isEmpty() && stack.peek().val == inorder[inorderIndex]) {\n                    node = stack.pop();\n                    inorderIndex++;\n                }\n                node.right = new TreeNode(preorderVal);\n                stack.push(node.right);\n            }\n        }\n        return root;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n",normalizedContent:"# leetcode-105-从前序与中序遍历构造二叉树\n\n根据一棵树的前序遍历与中序遍历构造二叉树。\n\n注意: 你可以假设树中没有重复的元素。\n\n示例 1:\n\n例如，给出\n\n前序遍历 preorder = [3,9,20,15,7]\n中序遍历 inorder = [9,3,15,20,7]\n\n\n1\n2\n\n1\n2\n\n\n返回如下的二叉树：\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n\n# 解题思路\n\n方法1、递归：\n\n前序遍历：根左右\n\n中序遍历：左根右\n\n对于任意一棵树而言，前序遍历的形式总是\n\n[根节点，[左子树的前序遍历结果],[右子树的前序遍历结果]]\n\n\n1\n\n1\n\n\n根节点总是，前序遍历中的第一个节点\n\n中序遍历的形式总是\n\n[[左子树的中序遍历结果],根节点,[右子树的中序遍历结果]]\n\n\n1\n\n1\n\n\n只要能够在中序遍历中定位到根节点，那么就可以得到对应的左右子树的节点数目\n\n由于前序遍历和中序遍历的长度是相同的，所以我们也能知道前序遍历的左右字数的区间范围\n\n之后进行递归，问题就变为了：\n\n知道左子树的前序和中序遍历，重建左子树；知道右子树的前序和中序遍历，重建右子树；\n\n定位优化：\n\n在中序遍历中需要根据前序遍历的根节点，定位到中序遍历中的根节点\n\n直接进行扫描匹配的耗时比较大，可以在一开始对中序遍历建立hash表，key代表元素的值，value代表在中序遍历中出现的位置。之后寻找对应值就能够快速定位了\n\n方法2、迭代：\n\nhttps://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-9/\n\n\n# java代码1\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public treenode buildtree(int[] preorder, int[] inorder) {\n        if(preorder==null||preorder.length==0){\n            return null;\n        }\n        map<integer,integer> map = new hashmap<>();\n        for(int i=0;i<inorder.length;i++){\n            map.put(inorder[i],i);\n        }\n        int length = preorder.length-1;\n        treenode root = reconstrtree(preorder,0,length,inorder,0,length,map);\n        return root;\n    }\n\n    public treenode reconstrtree(int[] preorder,int postart,int poend,int[] inorder,int instart,int inend,map<integer,integer> map){\n        if(postart>poend){\n            return null;\n        }\n        int rootnode = preorder[postart];\n        treenode root = new treenode(rootnode);\n        if(postart==poend){\n            return root;\n        }else{\n            int rootindex = map.get(rootnode);\n            int leftrange = rootindex - instart;\n            int rightrange = inend - rootindex;\n            treenode lefttree = reconstrtree(preorder,postart+1,postart+leftrange,inorder,instart,rootindex-1,map);\n            treenode righttree = reconstrtree(preorder,poend-rightrange+1,poend,inorder,rootindex+1,inend,map);\n            root.left = lefttree;\n            root.right = righttree;\n            return root;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# java代码2\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public treenode buildtree(int[] preorder, int[] inorder) {\n        if (preorder == null || preorder.length == 0) {\n            return null;\n        }\n        treenode root = new treenode(preorder[0]);\n        stack<treenode> stack = new stack<treenode>();\n        stack.push(root);\n        int inorderindex = 0;\n        for (int i = 1; i < preorder.length; i++) {\n            int preorderval = preorder[i];\n            treenode node = stack.peek();\n            if (node.val != inorder[inorderindex]) {\n                node.left = new treenode(preorderval);\n                stack.push(node.left);\n            } else {\n                while (!stack.isempty() && stack.peek().val == inorder[inorderindex]) {\n                    node = stack.pop();\n                    inorderindex++;\n                }\n                node.right = new treenode(preorderval);\n                stack.push(node.right);\n            }\n        }\n        return root;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-107-二叉树的层次遍历2",frontmatter:{title:"LeetCode-107-二叉树的层次遍历2",date:"2020-06-11T20:19:38.000Z",description:"二叉树的层次遍历2",tags:["树","BFS","Java","Easy"],keywords:"树,BFS,Java,Easy",permalink:"/pages/4d6c7d/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/50.LeetCode-107-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%862.html",relativePath:"06.算法/02.LeetCode/50.LeetCode-107-二叉树的层次遍历2.md",key:"v-7006d63d",path:"/pages/4d6c7d/",headers:[{level:2,title:"LeetCode-107-二叉树的层次遍历2",slug:"leetcode-107-二叉树的层次遍历2",normalizedTitle:"leetcode-107-二叉树的层次遍历2",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:259},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:400}],headersStr:"LeetCode-107-二叉树的层次遍历2 解题思路 Java代码",content:"# LeetCode-107-二叉树的层次遍历2\n\n给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）\n\n示例 1:\n\n给定二叉树 [3,9,20,null,null,15,7]\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n返回其自底向上的层次遍历为：\n\n[\n  [15,7],\n  [9,20],\n  [3]\n]\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n\n# 解题思路\n\nBFS层序遍历+头插法：\n\n涉及到要加入数值的，不太好用递归的方法，采用迭代的方法更容易一点\n\n使用queue队列进行层序遍历，每次弹出一个层的节点就将它加入到layer中，一层遍历完了之后\n\n再将一层的结果加入到res的头部，最后返回回来的就是按层倒序的结果\n\n\n# Java代码\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<List<Integer>> levelOrderBottom(TreeNode root) {\n        List<List<Integer>> res = new LinkedList<>();\n        if(root==null) return res;\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.add(root);\n        while(!queue.isEmpty()){\n            int size = queue.size();\n            List<Integer> layer = new LinkedList<>();\n            for(int i=0;i<size;i++){\n                TreeNode temp = queue.poll();\n                layer.add(temp.val);\n                if(temp.left!=null){\n                    queue.add(temp.left);\n                }\n                if(temp.right!=null){\n                    queue.add(temp.right);\n                }\n            }\n            res.add(0,layer);\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n",normalizedContent:"# leetcode-107-二叉树的层次遍历2\n\n给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）\n\n示例 1:\n\n给定二叉树 [3,9,20,null,null,15,7]\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n返回其自底向上的层次遍历为：\n\n[\n  [15,7],\n  [9,20],\n  [3]\n]\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n\n# 解题思路\n\nbfs层序遍历+头插法：\n\n涉及到要加入数值的，不太好用递归的方法，采用迭代的方法更容易一点\n\n使用queue队列进行层序遍历，每次弹出一个层的节点就将它加入到layer中，一层遍历完了之后\n\n再将一层的结果加入到res的头部，最后返回回来的就是按层倒序的结果\n\n\n# java代码\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public list<list<integer>> levelorderbottom(treenode root) {\n        list<list<integer>> res = new linkedlist<>();\n        if(root==null) return res;\n        queue<treenode> queue = new linkedlist<>();\n        queue.add(root);\n        while(!queue.isempty()){\n            int size = queue.size();\n            list<integer> layer = new linkedlist<>();\n            for(int i=0;i<size;i++){\n                treenode temp = queue.poll();\n                layer.add(temp.val);\n                if(temp.left!=null){\n                    queue.add(temp.left);\n                }\n                if(temp.right!=null){\n                    queue.add(temp.right);\n                }\n            }\n            res.add(0,layer);\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-114-二叉树展开为链表",frontmatter:{title:"LeetCode-114-二叉树展开为链表",date:"2020-07-14T13:55:35.000Z",description:"二叉树展开为链表",tags:["树","Java","Medium"],keywords:"树,Java,Medium,LeetCode",permalink:"/pages/f626bf/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/51.LeetCode-114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8.html",relativePath:"06.算法/02.LeetCode/51.LeetCode-114-二叉树展开为链表.md",key:"v-287ec08e",path:"/pages/f626bf/",headers:[{level:2,title:"LeetCode-114-二叉树展开为链表",slug:"leetcode-114-二叉树展开为链表",normalizedTitle:"leetcode-114-二叉树展开为链表",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:264},{level:3,title:"Java代码1",slug:"java代码1",normalizedTitle:"java代码1",charIndex:562},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:1173}],headersStr:"LeetCode-114-二叉树展开为链表 解题思路 Java代码1 Java代码2",content:"# LeetCode-114-二叉树展开为链表\n\n给定一个二叉树，原地将它展开为一个单链表。\n\n例如，给定二叉树\n\n    1\n   / \\\n  2   5\n / \\   \\\n3   4   6\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n将其展开为：\n\n1\n \\\n  2\n   \\\n    3\n     \\\n      4\n       \\\n        5\n         \\\n          6\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 解题思路\n\n方法1、递归：\n\n先将根节点的左子树变成链表，之后将根节点的右子树变成链表\n\n最后将变成链表的右子树放在变成链表的左子树的最右边\n\n方法2、迭代：\n\n从右至左的先序遍历，用一个栈来存储节点，先存储右节点后存储左节点，同时需要一个pre指针指向上一个节点，用于拼接前一个节点和当前节点\n\n当栈中弹出节点时，当前节点始终是拼接在前一个节点的右侧，于是pre.left=null、pre.right=temp,当当前节点temp右子节点不为空时，右子节点入栈，当左子节点不为空时，左子节点入栈。完成当前节点的左右子节点遍历，前一个节点变为链表中当前节点即pre=pre.right\n\n\n# Java代码1\n\nclass Solution {\n    public void flatten(TreeNode root) {\n        if(root == null){\n            return ;\n        }\n        //将根节点的左子树变成链表\n        flatten(root.left);\n        //将根节点的右子树变成链表\n        flatten(root.right);\n        TreeNode temp = root.right;\n        //把树的右边换成左边的链表\n        root.right = root.left;\n        //记得要将左边置空\n        root.left = null;\n        //找到树的最右边的节点\n        while(root.right != null) root = root.right;\n        //把右边的链表接到刚才树的最右边的节点\n        root.right = temp;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# Java代码2\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public void flatten(TreeNode root) {\n        if(root==null) return;\n        Stack<TreeNode> stack = new Stack<>();\n        stack.add(root);\n        TreeNode pre = new TreeNode(-1);\n        while(!stack.isEmpty()){\n            TreeNode temp = stack.pop();\n            pre.left = null;\n            pre.right = temp;\n            if(temp.right!=null){\n                stack.add(temp.right);\n            }\n            if(temp.left!=null){\n                stack.add(temp.left);\n            }\n            pre = pre.right;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n",normalizedContent:"# leetcode-114-二叉树展开为链表\n\n给定一个二叉树，原地将它展开为一个单链表。\n\n例如，给定二叉树\n\n    1\n   / \\\n  2   5\n / \\   \\\n3   4   6\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n将其展开为：\n\n1\n \\\n  2\n   \\\n    3\n     \\\n      4\n       \\\n        5\n         \\\n          6\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 解题思路\n\n方法1、递归：\n\n先将根节点的左子树变成链表，之后将根节点的右子树变成链表\n\n最后将变成链表的右子树放在变成链表的左子树的最右边\n\n方法2、迭代：\n\n从右至左的先序遍历，用一个栈来存储节点，先存储右节点后存储左节点，同时需要一个pre指针指向上一个节点，用于拼接前一个节点和当前节点\n\n当栈中弹出节点时，当前节点始终是拼接在前一个节点的右侧，于是pre.left=null、pre.right=temp,当当前节点temp右子节点不为空时，右子节点入栈，当左子节点不为空时，左子节点入栈。完成当前节点的左右子节点遍历，前一个节点变为链表中当前节点即pre=pre.right\n\n\n# java代码1\n\nclass solution {\n    public void flatten(treenode root) {\n        if(root == null){\n            return ;\n        }\n        //将根节点的左子树变成链表\n        flatten(root.left);\n        //将根节点的右子树变成链表\n        flatten(root.right);\n        treenode temp = root.right;\n        //把树的右边换成左边的链表\n        root.right = root.left;\n        //记得要将左边置空\n        root.left = null;\n        //找到树的最右边的节点\n        while(root.right != null) root = root.right;\n        //把右边的链表接到刚才树的最右边的节点\n        root.right = temp;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# java代码2\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode() {}\n *     treenode(int val) { this.val = val; }\n *     treenode(int val, treenode left, treenode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass solution {\n    public void flatten(treenode root) {\n        if(root==null) return;\n        stack<treenode> stack = new stack<>();\n        stack.add(root);\n        treenode pre = new treenode(-1);\n        while(!stack.isempty()){\n            treenode temp = stack.pop();\n            pre.left = null;\n            pre.right = temp;\n            if(temp.right!=null){\n                stack.add(temp.right);\n            }\n            if(temp.left!=null){\n                stack.add(temp.left);\n            }\n            pre = pre.right;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-121-买卖股票的最佳时机",frontmatter:{title:"LeetCode-121-买卖股票的最佳时机",date:"2020-06-05T20:28:28.000Z",description:"买卖股票的最佳时机",tags:["DP","数组","Java","Easy","LeetCode"],keywords:"DP,数组,Java,Easy,LeetCode",permalink:"/pages/6f907a/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/52.LeetCode-121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html",relativePath:"06.算法/02.LeetCode/52.LeetCode-121-买卖股票的最佳时机.md",key:"v-f4f24202",path:"/pages/6f907a/",headers:[{level:2,title:"LeetCode-121-买卖股票的最佳时机",slug:"leetcode-121-买卖股票的最佳时机",normalizedTitle:"leetcode-121-买卖股票的最佳时机",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:379},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:501}],headersStr:"LeetCode-121-买卖股票的最佳时机 解题思路 Java代码",content:"# LeetCode-121-买卖股票的最佳时机\n\n给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。\n\n如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。\n\n注意：你不能在买入股票前卖出股票。\n\n示例 1:\n\n输入: [7,1,5,3,6,4]\n输出: 5\n解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。\n     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n示例2：\n\n输入: [7,6,4,3,1]\n输出: 0\n解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n\n# 解题思路\n\n方法一、线性遍历(DP思想)：\n\n当利润是负数时，最小数应该变化为当前值，当利润为正数时，max最大利润保存，最后返回最大利润即可\n\n前i天的最大收益= max(前i-1天的最大收益，第i天的价格-前i-1天中的最小价格)\n\n\n# Java代码\n\nclass Solution {\n    public int maxProfit(int[] prices) {\n        if(prices==null||prices.length==0) return 0;\n        int low = prices[0];\n        int temp = 0;\n        for(int i=1;i<prices.length;i++){\n            if(prices[i]-low<0){\n                low = prices[i];\n            }else{\n                temp = Math.max(temp,prices[i]-low);\n            }\n        }\n        return temp;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n",normalizedContent:"# leetcode-121-买卖股票的最佳时机\n\n给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。\n\n如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。\n\n注意：你不能在买入股票前卖出股票。\n\n示例 1:\n\n输入: [7,1,5,3,6,4]\n输出: 5\n解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。\n     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n示例2：\n\n输入: [7,6,4,3,1]\n输出: 0\n解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n\n# 解题思路\n\n方法一、线性遍历(dp思想)：\n\n当利润是负数时，最小数应该变化为当前值，当利润为正数时，max最大利润保存，最后返回最大利润即可\n\n前i天的最大收益= max(前i-1天的最大收益，第i天的价格-前i-1天中的最小价格)\n\n\n# java代码\n\nclass solution {\n    public int maxprofit(int[] prices) {\n        if(prices==null||prices.length==0) return 0;\n        int low = prices[0];\n        int temp = 0;\n        for(int i=1;i<prices.length;i++){\n            if(prices[i]-low<0){\n                low = prices[i];\n            }else{\n                temp = math.max(temp,prices[i]-low);\n            }\n        }\n        return temp;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-128-最长连续序列",frontmatter:{title:"LeetCode-128-最长连续序列",date:"2020-07-11T09:49:26.000Z",description:"最长连续序列",tags:["Java","数组","Hard"],keywords:"Java,数组,Hard,LeetCode",permalink:"/pages/1c92f0/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/53.LeetCode-128-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97.html",relativePath:"06.算法/02.LeetCode/53.LeetCode-128-最长连续序列.md",key:"v-9a3b1246",path:"/pages/1c92f0/",headers:[{level:2,title:"LeetCode-128-最长连续序列",slug:"leetcode-128-最长连续序列",normalizedTitle:"leetcode-128-最长连续序列",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:162},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:844}],headersStr:"LeetCode-128-最长连续序列 解题思路 Java代码",content:"# LeetCode-128-最长连续序列\n\n给定一个未排序的整数数组，找出最长连续序列的长度。\n\n要求算法的时间复杂度为 O(n)。\n\n示例1：\n\n输入: [100, 4, 200, 1, 3, 2]\n输出: 4\n解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n\n# 解题思路\n\n方法1、哈希表：\n\n题解转自LeetCode：https://leetcode-cn.com/problems/longest-consecutive-sequence/solution/zui-chang-lian-xu-xu-lie-by-leetcode-solution/\n\n我们考虑枚举数组中的每个数 x，考虑以其为起点，不断尝试匹配 x+1, x+2,⋯ 是否存在，假设最长匹配到了 x+y，那么以 x为起点的最长连续序列即为 x, x+1, x+2, ⋯,x+y，其长度为 y+1，我们不断枚举并更新答案即可。\n\n对于匹配的过程，暴力的方法是 O(n)遍历数组去看是否存在这个数，但其实更高效的方法是用一个哈希表存储数组中的数，这样查看一个数是否存在即能优化至 O(1) 的时间复杂度。\n\n仅仅是这样我们的算法时间复杂度最坏情况下还是会达到 O(n^2)（即外层需要枚举 O(n)个数，内层需要暴力匹配 O(n)次），无法满足题目的要求。但仔细分析这个过程，我们会发现其中执行了很多不必要的枚举，如果已知有一个 x, x+1, x+2, ⋯,x+y 的连续序列，而我们却重新从 x+1，x+2 或者是 x+y处开始尝试匹配，那么得到的结果肯定不会优于枚举 x 为起点的答案，因此我们在外层循环的时候碰到这种情况跳过即可。\n\n那么怎么判断是否跳过呢？由于我们要枚举的数 x 一定是在数组中不存在前驱数 x-1 的，不然按照上面的分析我们会从 x-1 开始尝试匹配，因此我们每次在哈希表中检查是否存在 x-1即能判断是否需要跳过了。\n\n\n# Java代码\n\nclass Solution {\n    public int longestConsecutive(int[] nums) {\n        Set<Integer> num_set = new HashSet<Integer>();\n        for(int num:nums){\n            num_set.add(num);\n        }\n        int longest = 0;\n        for(int num: num_set){\n            if(!num_set.contains(num-1)){\n                int curNum = num;\n                int curStreak = 1;\n                while(num_set.contains(curNum+1)){\n                    curStreak+=1;\n                    curNum+=1;\n                }\n                longest = Math.max(curStreak,longest);\n            }\n        }\n        return longest;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n",normalizedContent:"# leetcode-128-最长连续序列\n\n给定一个未排序的整数数组，找出最长连续序列的长度。\n\n要求算法的时间复杂度为 o(n)。\n\n示例1：\n\n输入: [100, 4, 200, 1, 3, 2]\n输出: 4\n解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n\n# 解题思路\n\n方法1、哈希表：\n\n题解转自leetcode：https://leetcode-cn.com/problems/longest-consecutive-sequence/solution/zui-chang-lian-xu-xu-lie-by-leetcode-solution/\n\n我们考虑枚举数组中的每个数 x，考虑以其为起点，不断尝试匹配 x+1, x+2,⋯ 是否存在，假设最长匹配到了 x+y，那么以 x为起点的最长连续序列即为 x, x+1, x+2, ⋯,x+y，其长度为 y+1，我们不断枚举并更新答案即可。\n\n对于匹配的过程，暴力的方法是 o(n)遍历数组去看是否存在这个数，但其实更高效的方法是用一个哈希表存储数组中的数，这样查看一个数是否存在即能优化至 o(1) 的时间复杂度。\n\n仅仅是这样我们的算法时间复杂度最坏情况下还是会达到 o(n^2)（即外层需要枚举 o(n)个数，内层需要暴力匹配 o(n)次），无法满足题目的要求。但仔细分析这个过程，我们会发现其中执行了很多不必要的枚举，如果已知有一个 x, x+1, x+2, ⋯,x+y 的连续序列，而我们却重新从 x+1，x+2 或者是 x+y处开始尝试匹配，那么得到的结果肯定不会优于枚举 x 为起点的答案，因此我们在外层循环的时候碰到这种情况跳过即可。\n\n那么怎么判断是否跳过呢？由于我们要枚举的数 x 一定是在数组中不存在前驱数 x-1 的，不然按照上面的分析我们会从 x-1 开始尝试匹配，因此我们每次在哈希表中检查是否存在 x-1即能判断是否需要跳过了。\n\n\n# java代码\n\nclass solution {\n    public int longestconsecutive(int[] nums) {\n        set<integer> num_set = new hashset<integer>();\n        for(int num:nums){\n            num_set.add(num);\n        }\n        int longest = 0;\n        for(int num: num_set){\n            if(!num_set.contains(num-1)){\n                int curnum = num;\n                int curstreak = 1;\n                while(num_set.contains(curnum+1)){\n                    curstreak+=1;\n                    curnum+=1;\n                }\n                longest = math.max(curstreak,longest);\n            }\n        }\n        return longest;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-136-只出现一次的数字",frontmatter:{title:"LeetCode-136-只出现一次的数字",date:"2020-06-18T21:22:13.000Z",description:"只出现一次的数字",tags:["数组","Java","Python","Easy","LeetCode"],keywords:"数组,Java,Python,Easy,LeetCode",permalink:"/pages/7a9856/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/54.LeetCode-136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97.html",relativePath:"06.算法/02.LeetCode/54.LeetCode-136-只出现一次的数字.md",key:"v-5845d8e8",path:"/pages/7a9856/",headers:[{level:2,title:"LeetCode-136-只出现一次的数字",slug:"leetcode-136-只出现一次的数字",normalizedTitle:"leetcode-136-只出现一次的数字",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:199},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:400},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:634}],headersStr:"LeetCode-136-只出现一次的数字 解题思路 Java代码 Python代码",content:"# LeetCode-136-只出现一次的数字\n\n给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。\n\n说明：\n\n你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？\n\n示例 1:\n\n输入: [2,2,1]\n输出: 1\n\n\n1\n2\n\n1\n2\n\n\n示例2：\n\n输入: [4,1,2,1,2]\n输出: 4\n\n\n1\n2\n\n1\n2\n\n\n\n# 解题思路\n\n方法1、异或运算：\n\n异或运算的特点\n\n * 任何数和0做异或运算，结果是原来的数\n * 任何数和其自身做异或运算，结果是自身\n * 异或运算满足交换律和结合律，即a^b^a=b^a^a=b^(a^a)=b^0=b\n\n根据这个特点可以直接用异或运算得出出现一次的字符\n\n方法2、哈希表：\n\n这个解法不符合题意，用到了一个哈希表来存储数字出现的次数\n\n之后取出出现次数为1的数字即可\n\n\n# Java代码\n\nclass Solution {\n    public int singleNumber(int[] nums) {\n        int single = 0;\n        for (int num : nums) {\n            single ^= num;\n        }\n        return single;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# Python代码\n\nclass Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        dict1 = dict()\n        for i in nums:\n            if i in dict1:\n                dict1[i]+=1\n            else:\n                dict1[i]=1\n        return list(dict1.keys())[list(dict1.values()).index(1)]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n",normalizedContent:"# leetcode-136-只出现一次的数字\n\n给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。\n\n说明：\n\n你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？\n\n示例 1:\n\n输入: [2,2,1]\n输出: 1\n\n\n1\n2\n\n1\n2\n\n\n示例2：\n\n输入: [4,1,2,1,2]\n输出: 4\n\n\n1\n2\n\n1\n2\n\n\n\n# 解题思路\n\n方法1、异或运算：\n\n异或运算的特点\n\n * 任何数和0做异或运算，结果是原来的数\n * 任何数和其自身做异或运算，结果是自身\n * 异或运算满足交换律和结合律，即a^b^a=b^a^a=b^(a^a)=b^0=b\n\n根据这个特点可以直接用异或运算得出出现一次的字符\n\n方法2、哈希表：\n\n这个解法不符合题意，用到了一个哈希表来存储数字出现的次数\n\n之后取出出现次数为1的数字即可\n\n\n# java代码\n\nclass solution {\n    public int singlenumber(int[] nums) {\n        int single = 0;\n        for (int num : nums) {\n            single ^= num;\n        }\n        return single;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# python代码\n\nclass solution:\n    def singlenumber(self, nums: list[int]) -> int:\n        dict1 = dict()\n        for i in nums:\n            if i in dict1:\n                dict1[i]+=1\n            else:\n                dict1[i]=1\n        return list(dict1.keys())[list(dict1.values()).index(1)]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-142-环形链表2",frontmatter:{title:"LeetCode-142-环形链表2",date:"2020-06-10T16:43:09.000Z",description:"环形链表2",tags:["链表","Java","Medium","LeetCode"],keywords:"链表,Java,Medium,LeetCode",permalink:"/pages/21e57b/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/55.LeetCode-142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A82.html",relativePath:"06.算法/02.LeetCode/55.LeetCode-142-环形链表2.md",key:"v-364bea08",path:"/pages/21e57b/",headers:[{level:2,title:"LeetCode-142-环形链表2",slug:"leetcode-142-环形链表2",normalizedTitle:"leetcode-142-环形链表2",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:463},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:919},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:2399}],headersStr:"LeetCode-142-环形链表2 解题思路 Java代码 Java代码2",content:"# LeetCode-142-环形链表2\n\n给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\n\n为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。\n\n说明：不允许修改给定的链表。\n\n示例1：\n\n输入：head = [3,2,0,-4], pos = 1\n输出：tail connects to node index 1\n解释：链表中有一个环，其尾部连接到第二个节点。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2：\n\n输入：head = [1,2], pos = 0\n输出：tail connects to node index 0\n解释：链表中有一个环，其尾部连接到第一个节点。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例3：\n\n输入：head = [1], pos = -1\n输出：no cycle\n解释：链表中没有环。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n进阶： 你是否可以不用额外空间解决此题？\n\n\n# 解题思路\n\n相关链接：\n\n 1. LeetCode-141-环形链表\n 2. LeetCode-面试题02.02-返回倒数第k个节点\n\n快慢指针+双指针：\n\n想要在环形链表中找到入环的第一个节点，首先要判断是否有环\n\n在有环的前提下，如果能够计算出环内的节点有多少个，那么问题就变为同返回倒数第k个节点相似的问题\n\n让其中一个指针先走n步，之后一个指针第一个指针走完n步之后开始走\n\n两个指针继续移动1步，当第二个指针指向环的入口节点时，第一个指针已经绕了一圈回来到达了入口节点，此时第二个指针的位置就是入口\n\n快慢指针：\n\n我们使用两个指针，fast 与 slow。它们起始都位于链表的头部。随后，slow 指针每次向后移动一个位置，而 fast 指针向后移动两个位置。如果链表中存在环，则 fast 指针最终将再次与 slow 指针在环中相遇。当发现 slow 与 fast 相遇时，我们再使slow变成head，指向链表头部；随后，它和 slow 每次向后移动一个位置。最终，它们会在入环点相遇。\n\n\n# Java代码\n\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode meetingNode = hasCycle(head);\n        if(meetingNode==null) return null;\n        int n = 1;\n        ListNode temp = meetingNode;\n        while(temp.next!=meetingNode){\n            temp = temp.next;\n            n++;\n        }\n        ListNode start = head;\n        temp = head;\n        for(int i=0;i<n;i++){\n            temp = temp.next;\n        }\n        while(temp!=start){\n            temp = temp.next;\n            start = start.next;\n        }\n        return start;\n    }\n    public ListNode hasCycle(ListNode head) {\n        if(head==null) return null;\n        ListNode slow = head.next;\n        if(slow==null) return null;\n        ListNode fast = slow.next;\n        while(fast!=null&&slow!=null){\n            if(fast==slow) return fast;\n            slow = slow.next;\n            fast = fast.next;\n            if(fast!=null){\n                fast = fast.next;\n            }\n        }\n        return null;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n# Java代码2\n\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if(head==null||head.next==null){\n            return null;\n        }\n        ListNode slow = head;\n        ListNode fast = head;\n        while(fast!=null&&fast.next!=null){\n            slow = slow.next;\n            fast = fast.next.next;\n            if(slow==fast){\n                break;\n            }\n        }\n        if(fast==null||fast.next==null){\n            return null;\n        }\n        slow = head;\n        while(slow!=fast){\n            slow = slow.next;\n            fast = fast.next;\n        }\n        return slow;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n",normalizedContent:"# leetcode-142-环形链表2\n\n给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\n\n为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。\n\n说明：不允许修改给定的链表。\n\n示例1：\n\n输入：head = [3,2,0,-4], pos = 1\n输出：tail connects to node index 1\n解释：链表中有一个环，其尾部连接到第二个节点。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2：\n\n输入：head = [1,2], pos = 0\n输出：tail connects to node index 0\n解释：链表中有一个环，其尾部连接到第一个节点。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例3：\n\n输入：head = [1], pos = -1\n输出：no cycle\n解释：链表中没有环。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n进阶： 你是否可以不用额外空间解决此题？\n\n\n# 解题思路\n\n相关链接：\n\n 1. leetcode-141-环形链表\n 2. leetcode-面试题02.02-返回倒数第k个节点\n\n快慢指针+双指针：\n\n想要在环形链表中找到入环的第一个节点，首先要判断是否有环\n\n在有环的前提下，如果能够计算出环内的节点有多少个，那么问题就变为同返回倒数第k个节点相似的问题\n\n让其中一个指针先走n步，之后一个指针第一个指针走完n步之后开始走\n\n两个指针继续移动1步，当第二个指针指向环的入口节点时，第一个指针已经绕了一圈回来到达了入口节点，此时第二个指针的位置就是入口\n\n快慢指针：\n\n我们使用两个指针，fast 与 slow。它们起始都位于链表的头部。随后，slow 指针每次向后移动一个位置，而 fast 指针向后移动两个位置。如果链表中存在环，则 fast 指针最终将再次与 slow 指针在环中相遇。当发现 slow 与 fast 相遇时，我们再使slow变成head，指向链表头部；随后，它和 slow 每次向后移动一个位置。最终，它们会在入环点相遇。\n\n\n# java代码\n\n/**\n * definition for singly-linked list.\n * class listnode {\n *     int val;\n *     listnode next;\n *     listnode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class solution {\n    public listnode detectcycle(listnode head) {\n        listnode meetingnode = hascycle(head);\n        if(meetingnode==null) return null;\n        int n = 1;\n        listnode temp = meetingnode;\n        while(temp.next!=meetingnode){\n            temp = temp.next;\n            n++;\n        }\n        listnode start = head;\n        temp = head;\n        for(int i=0;i<n;i++){\n            temp = temp.next;\n        }\n        while(temp!=start){\n            temp = temp.next;\n            start = start.next;\n        }\n        return start;\n    }\n    public listnode hascycle(listnode head) {\n        if(head==null) return null;\n        listnode slow = head.next;\n        if(slow==null) return null;\n        listnode fast = slow.next;\n        while(fast!=null&&slow!=null){\n            if(fast==slow) return fast;\n            slow = slow.next;\n            fast = fast.next;\n            if(fast!=null){\n                fast = fast.next;\n            }\n        }\n        return null;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n# java代码2\n\npublic class solution {\n    public listnode detectcycle(listnode head) {\n        if(head==null||head.next==null){\n            return null;\n        }\n        listnode slow = head;\n        listnode fast = head;\n        while(fast!=null&&fast.next!=null){\n            slow = slow.next;\n            fast = fast.next.next;\n            if(slow==fast){\n                break;\n            }\n        }\n        if(fast==null||fast.next==null){\n            return null;\n        }\n        slow = head;\n        while(slow!=fast){\n            slow = slow.next;\n            fast = fast.next;\n        }\n        return slow;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-143-重排链表",frontmatter:{title:"LeetCode-143-重排链表",date:"2020-06-10T20:33:33.000Z",description:"重排链表",tags:["链表","Java","Medium","LeetCode"],keywords:"链表,Java,Medium,LeetCode",permalink:"/pages/825806/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/56.LeetCode-143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8.html",relativePath:"06.算法/02.LeetCode/56.LeetCode-143-重排链表.md",key:"v-513eccc6",path:"/pages/825806/",headers:[{level:2,title:"LeetCode-143-重排链表",slug:"leetcode-143-重排链表",normalizedTitle:"leetcode-143-重排链表",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:227},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:1467},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:2579}],headersStr:"LeetCode-143-重排链表 解题思路 Java代码 Java代码2",content:"# LeetCode-143-重排链表\n\n给定一个单链表 L：L0→L1→…→Ln-1→Ln ， 将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…\n\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n\n示例1：\n\n给定链表 1->2->3->4, 重新排列为 1->4->2->3.\n\n\n1\n\n1\n\n\n示例2：\n\n给定链表 1->2->3->4->5, 重新排列为 1->5->2->4->3.\n\n\n1\n\n1\n\n\n\n# 解题思路\n\n方法1、存储+双指针：\n\n用一个线性表存储所有的链表元素，之后用2个指针，分别获得链表的头尾\n\n按照规律对于1，2，3，4这样的链表例子\n\n1之后是4，4之后是2，2之后是3\n\n初始化头尾指针，改变头部指针的指向到尾部，并使i指向下一位\n\n即list.get(i).next = list.get(j);和i++\n\n改变尾部指针指向到原本头部的下一位，由于上面已经i++，此时线性表的i就是上一次i的下一位\n\n所以list.get(j).next = list.get(i);，之后j--\n\n直到i==j时跳出循环，此时i仍然与原来的链表相连，将i.next=null完成链表构建\n\n方法2、拆分+翻转+拼接：\n\n这个解法复习的内容挺多的，按照题目规律，重排链表可以分为如下3个步骤\n\n1 -> 2 -> 3 -> 4 -> 5 -> 6\n第一步，将链表平均分成两半\n1 -> 2 -> 3\n4 -> 5 -> 6\n    \n第二步，将第二个链表逆序\n1 -> 2 -> 3\n6 -> 5 -> 4\n    \n第三步，依次连接两个链表\n1 -> 6 -> 2 -> 5 -> 3 -> 4\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n如何拆分链表，最重要的是找到拆分的中点\n\n对于偶数链表，拆分的中点在边界左边，对于奇数链表，中点就是中间的那个\n\n可以利用快慢指针来寻找中点，一个指针走2步，一个指针走1步，当快指针走到链表尾部的时候，慢指针的位置就是拆分的中点，由于奇数和偶数拆分点不一样，所以ListNode newHead = slow.next;和slow.next = null;在找到边界点之后，始终后移1位，这样保证了偶数情况下，拆分点始终是第二个链表的头部\n\n但是对于奇数情况，则会让第一个链表始终比第二个链表多一个数字，这种情况在合并的时候进行处理。\n\n链表的逆序思想和{% post_link LeetCode-面试题24-反转链表 %}相同\n\n链表的合并思想和{% post_link LeetCode-面试题25-合并两个排序的链表 %}大致相同\n\n稍微有点区别的地方是这里不是按照值进行合并\n\n对于\nslow  1 -> 2 -> 3\nfast  4 -> 5\n而言，应该先存储slow和fast的next节点\n之后将slow的next变为fast，即1 -> 4\nfast的next = 刚才存储的slow.next，即4 -> 2\n接下来移动1位slow和fast指针，即slow = 刚才存储的slow.next，fast = 刚才存储的fast.next\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n而此时的第一个链表由于始终比第二个链表长，所以判断空的条件为slow!=null&&fast!=null，当满足此条件时，才会进行V字型拼接\n\n\n# Java代码\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public void reorderList(ListNode head) {\n        if (head == null) {\n            return;\n        }\n        //存到 list 中去\n        List<ListNode> list = new ArrayList<>();\n        while (head != null) {\n            list.add(head);\n            head = head.next;\n        }\n        //头尾指针依次取元素\n        int i = 0, j = list.size() - 1;\n        while (i < j) {\n            list.get(i).next = list.get(j);\n            i++;\n            //偶数个节点的情况，会提前相遇\n            if (i == j) {\n                break;\n            }\n            list.get(j).next = list.get(i);\n            j--;\n        }\n        list.get(i).next = null;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# Java代码2\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public void reorderList(ListNode head) {\n        if (head == null || head.next == null || head.next.next == null) {\n            return;\n        }\n        ListNode slow = head;\n        ListNode fast = head;\n        while(fast!=null&&fast.next!=null){\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        ListNode newHead = slow.next;\n        slow.next = null;\n        fast = reversList(newHead);\n        slow = head;\n        while(slow!=null&&fast!=null){\n            ListNode stemp = slow.next;\n            ListNode ftemp = fast.next;\n            slow.next = fast;\n            fast.next = stemp;\n            slow = stemp;\n            fast = ftemp;\n        }\n    }\n\n    public ListNode reversList(ListNode head){\n        if(head==null||head.next==null) return head;\n        ListNode pre = null;\n        ListNode cur = head;\n        while(cur!=null){\n            ListNode temp = cur.next;\n            cur.next = pre;\n            pre = cur;\n            cur = temp;\n        }\n        return pre;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n",normalizedContent:"# leetcode-143-重排链表\n\n给定一个单链表 l：l0→l1→…→ln-1→ln ， 将其重新排列后变为： l0→ln→l1→ln-1→l2→ln-2→…\n\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n\n示例1：\n\n给定链表 1->2->3->4, 重新排列为 1->4->2->3.\n\n\n1\n\n1\n\n\n示例2：\n\n给定链表 1->2->3->4->5, 重新排列为 1->5->2->4->3.\n\n\n1\n\n1\n\n\n\n# 解题思路\n\n方法1、存储+双指针：\n\n用一个线性表存储所有的链表元素，之后用2个指针，分别获得链表的头尾\n\n按照规律对于1，2，3，4这样的链表例子\n\n1之后是4，4之后是2，2之后是3\n\n初始化头尾指针，改变头部指针的指向到尾部，并使i指向下一位\n\n即list.get(i).next = list.get(j);和i++\n\n改变尾部指针指向到原本头部的下一位，由于上面已经i++，此时线性表的i就是上一次i的下一位\n\n所以list.get(j).next = list.get(i);，之后j--\n\n直到i==j时跳出循环，此时i仍然与原来的链表相连，将i.next=null完成链表构建\n\n方法2、拆分+翻转+拼接：\n\n这个解法复习的内容挺多的，按照题目规律，重排链表可以分为如下3个步骤\n\n1 -> 2 -> 3 -> 4 -> 5 -> 6\n第一步，将链表平均分成两半\n1 -> 2 -> 3\n4 -> 5 -> 6\n    \n第二步，将第二个链表逆序\n1 -> 2 -> 3\n6 -> 5 -> 4\n    \n第三步，依次连接两个链表\n1 -> 6 -> 2 -> 5 -> 3 -> 4\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n如何拆分链表，最重要的是找到拆分的中点\n\n对于偶数链表，拆分的中点在边界左边，对于奇数链表，中点就是中间的那个\n\n可以利用快慢指针来寻找中点，一个指针走2步，一个指针走1步，当快指针走到链表尾部的时候，慢指针的位置就是拆分的中点，由于奇数和偶数拆分点不一样，所以listnode newhead = slow.next;和slow.next = null;在找到边界点之后，始终后移1位，这样保证了偶数情况下，拆分点始终是第二个链表的头部\n\n但是对于奇数情况，则会让第一个链表始终比第二个链表多一个数字，这种情况在合并的时候进行处理。\n\n链表的逆序思想和{% post_link leetcode-面试题24-反转链表 %}相同\n\n链表的合并思想和{% post_link leetcode-面试题25-合并两个排序的链表 %}大致相同\n\n稍微有点区别的地方是这里不是按照值进行合并\n\n对于\nslow  1 -> 2 -> 3\nfast  4 -> 5\n而言，应该先存储slow和fast的next节点\n之后将slow的next变为fast，即1 -> 4\nfast的next = 刚才存储的slow.next，即4 -> 2\n接下来移动1位slow和fast指针，即slow = 刚才存储的slow.next，fast = 刚才存储的fast.next\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n而此时的第一个链表由于始终比第二个链表长，所以判断空的条件为slow!=null&&fast!=null，当满足此条件时，才会进行v字型拼接\n\n\n# java代码\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode() {}\n *     listnode(int val) { this.val = val; }\n *     listnode(int val, listnode next) { this.val = val; this.next = next; }\n * }\n */\nclass solution {\n    public void reorderlist(listnode head) {\n        if (head == null) {\n            return;\n        }\n        //存到 list 中去\n        list<listnode> list = new arraylist<>();\n        while (head != null) {\n            list.add(head);\n            head = head.next;\n        }\n        //头尾指针依次取元素\n        int i = 0, j = list.size() - 1;\n        while (i < j) {\n            list.get(i).next = list.get(j);\n            i++;\n            //偶数个节点的情况，会提前相遇\n            if (i == j) {\n                break;\n            }\n            list.get(j).next = list.get(i);\n            j--;\n        }\n        list.get(i).next = null;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# java代码2\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode() {}\n *     listnode(int val) { this.val = val; }\n *     listnode(int val, listnode next) { this.val = val; this.next = next; }\n * }\n */\nclass solution {\n    public void reorderlist(listnode head) {\n        if (head == null || head.next == null || head.next.next == null) {\n            return;\n        }\n        listnode slow = head;\n        listnode fast = head;\n        while(fast!=null&&fast.next!=null){\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        listnode newhead = slow.next;\n        slow.next = null;\n        fast = reverslist(newhead);\n        slow = head;\n        while(slow!=null&&fast!=null){\n            listnode stemp = slow.next;\n            listnode ftemp = fast.next;\n            slow.next = fast;\n            fast.next = stemp;\n            slow = stemp;\n            fast = ftemp;\n        }\n    }\n\n    public listnode reverslist(listnode head){\n        if(head==null||head.next==null) return head;\n        listnode pre = null;\n        listnode cur = head;\n        while(cur!=null){\n            listnode temp = cur.next;\n            cur.next = pre;\n            pre = cur;\n            cur = temp;\n        }\n        return pre;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-146-LRU缓存机制",frontmatter:{title:"LeetCode-146-LRU缓存机制",date:"2020-08-04T09:32:57.000Z",description:"LRU缓存机制",tags:["数组","Java","Medium"],keywords:"数组,Java,Medium,LeetCode",permalink:"/pages/0d05d2/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/57.LeetCode-146-LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6.html",relativePath:"06.算法/02.LeetCode/57.LeetCode-146-LRU缓存机制.md",key:"v-39c91715",path:"/pages/0d05d2/",headers:[{level:2,title:"LeetCode-146-LRU缓存机制",slug:"leetcode-146-lru缓存机制",normalizedTitle:"leetcode-146-lru缓存机制",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:677},{level:3,title:"Java代码1",slug:"java代码1",normalizedTitle:"java代码1",charIndex:2422},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:3743},{level:3,title:"Java代码3",slug:"java代码3",normalizedTitle:"java代码3",charIndex:4576}],headersStr:"LeetCode-146-LRU缓存机制 解题思路 Java代码1 Java代码2 Java代码3",content:"# LeetCode-146-LRU缓存机制\n\n运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。\n\n获取数据 get(key) - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。 写入数据 put(key, value) - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。\n\n进阶:\n\n你是否可以在 O(1) 时间复杂度内完成这两种操作？\n\n示例1：\n\nLRUCache cache = new LRUCache( 2 /* 缓存容量 */ );\n\ncache.put(1, 1);\ncache.put(2, 2);\ncache.get(1);       // 返回  1\ncache.put(3, 3);    // 该操作会使得关键字 2 作废\ncache.get(2);       // 返回 -1 (未找到)\ncache.put(4, 4);    // 该操作会使得关键字 1 作废\ncache.get(1);       // 返回 -1 (未找到)\ncache.get(3);       // 返回  3\ncache.get(4);       // 返回  4\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 解题思路\n\n方法1、队列+哈希表：\n\n观察示例可知，当执行get(1)之后，后加入的key为2的数据会变为最久没有使用的\n\n不难知道，在get操作之后需要对数据进行重排。而put操作也将依赖与重排的逻辑进行操作\n\n这里选择先进先出的Queue作为重排的容器比较合适。\n\n首先需要记录初始化的容量capacity\n\n 1. 每进行一次put，队列中也会加入key，map中也会加入key，value，同时容量减1\n 2. 当容量为0时，需要删除map中最久没有使用的key，value，再添加新的key，value\n\n如果get的时候能够保证queue头部存储的最久没有使用的key，那么这一步操作就变得很简单。只需要如下操作即可。\n\nmap.remove(queue.poll());\nqueue.add(key);\nmap.put(key,value);\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n那么如何让get操作，保证queue的头部存储的最久没有使用的key呢？\n\n想要实现这样的queue，换一种思路，使用了(get)之后的key应该放在队列的最后\n\n那么当查找一个key的时候，通过判断queue是否有这个key来进行get操作\n\n * 当有这个key的时候，将这个key拿出来，然后放到queue末尾，之后返回map中获得key的结果即可。\n * 如果没有这个key，返回-1即可。\n\n回到put函数这里，除了put中的1、2两个操作之外，还需要考虑第3种情况\n\n 3. 如果put的过程中queue中有这个key，即put[1,2]之后又put[1,5]这种情况仅仅value不同，key相同，需要删除原本queue中的key，再添加新的key，因为put同一个key的操作或许不是连续的。同时需要更新map的key和value\n\n方法2、哈希表+双向链表：\n\n原文链接：https://leetcode-cn.com/problems/lru-cache/solution/lruhuan-cun-ji-zhi-by-leetcode-solution/\n\n利用LinkedHashMap，不利用LinkedHashMap两个版本\n\nLRU 缓存机制可以通过哈希表辅以双向链表实现，我们用一个哈希表和一个双向链表维护所有在缓存中的键值对。\n\n * 双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。\n\n * 哈希表即为普通的哈希映射（HashMap），通过缓存数据的键映射到其在双向链表中的位置。\n\n这样以来，我们首先使用哈希表进行定位，找出缓存项在双向链表中的位置，随后将其移动到双向链表的头部，即可在 O(1) 的时间内完成 get或者 put 操作。具体的方法如下：\n\n * 对于 get 操作，首先判断 key是否存在：\n   \n   * 如果 key 不存在，则返回−1；\n   * 如果 key存在，则 key对应的节点是最近被使用的节点。通过哈希表定位到该节点在双向链表中的位置，并将其移动到双向链表的头部，最后返回该节点的值。\n\n * 对于 put 操作，首先判断key是否存在：\n   \n   * 如果key 不存在，使用key和 value创建一个新的节点，在双向链表的头部添加该节点，并将 key和该节点添加进哈希表中。然后判断双向链表的节点数是否超出容量，如果超出容量，则删除双向链表的尾部节点，并删除哈希表中对应的项；\n   * 如果 key存在，则与 get操作类似，先通过哈希表定位，再将对应的节点的值更新为 value，并将该节点移到双向链表的头部。\n\n上述各项操作中，访问哈希表的时间复杂度为 O(1)，在双向链表的头部添加节点、在双向链表的尾部删除节点的复杂度也为 O(1)。而将一个节点移到双向链表的头部，可以分成「删除该节点」和「在双向链表的头部添加节点」两步操作，都可以在O(1) 时间内完成。\n\n小贴士\n\n在双向链表的实现中，使用一个伪头部（dummy head）和伪尾部（dummy tail）标记界限，这样在添加节点和删除节点的时候就不需要检查相邻的节点是否存在。\n\n\n# Java代码1\n\nclass LRUCache {\n    Queue<Integer> queue;\n    HashMap<Integer,Integer> map;\n    int capacity;\n    public LRUCache(int capacity) {\n        this.map = new HashMap<>();\n        this.queue = new LinkedList<>();\n        this.capacity = capacity;\n    }\n    \n    public int get(int key) {\n        if(queue.contains(key)){\n            queue.remove(key);\n            queue.add(key);\n            return map.get(key);\n        }else{\n            return -1;\n        }\n    }\n    \n    public void put(int key, int value) {\n        if(queue.contains(key)){\n            queue.remove(key);\n            queue.add(key);\n            map.put(key,value);\n        }\n        else if(capacity==0){\n            map.remove(queue.poll());\n            queue.add(key);\n            map.put(key,value);\n        }else{\n            queue.add(key);\n            map.put(key,value);\n            capacity--;\n        }\n    }\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n\n# Java代码2\n\nclass LRUCache {\n    private int cap;\n\tprivate Map<Integer, Integer> map = new LinkedHashMap<>();  // 保持插入顺序\n\n\tpublic LRUCache(int capacity) {\n\t\tthis.cap = capacity;\n\t}\n\n\tpublic int get(int key) {\n\t\tif (map.keySet().contains(key)) {\n\t\t\tint value = map.get(key);\n\t\t\tmap.remove(key);\n            // 保证每次查询后，都在末尾\n\t\t\tmap.put(key, value);\n\t\t\treturn value;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tpublic void put(int key, int value) {\n\t\tif (map.keySet().contains(key)) {\n\t\t\tmap.remove(key);\n\t\t} else if (map.size() == cap) {\n\t\t\tIterator<Map.Entry<Integer, Integer>> iterator = map.entrySet().iterator();\n\t\t\titerator.next();\n\t\t\titerator.remove();\n\t\t}\n\t\tmap.put(key, value);\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# Java代码3\n\n完全手动实现LinkedHashMap\n\npublic class LRUCache {\n    class DLinkedNode {\n        int key;\n        int value;\n        DLinkedNode prev;\n        DLinkedNode next;\n        public DLinkedNode() {}\n        public DLinkedNode(int _key, int _value) {key = _key; value = _value;}\n    }\n\n    private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();\n    private int size;\n    private int capacity;\n    private DLinkedNode head, tail;\n\n    public LRUCache(int capacity) {\n        this.size = 0;\n        this.capacity = capacity;\n        // 使用伪头部和伪尾部节点\n        head = new DLinkedNode();\n        tail = new DLinkedNode();\n        head.next = tail;\n        tail.prev = head;\n    }\n\n    public int get(int key) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) {\n            return -1;\n        }\n        // 如果 key 存在，先通过哈希表定位，再移到头部\n        moveToHead(node);\n        return node.value;\n    }\n\n    public void put(int key, int value) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) {\n            // 如果 key 不存在，创建一个新的节点\n            DLinkedNode newNode = new DLinkedNode(key, value);\n            // 添加进哈希表\n            cache.put(key, newNode);\n            // 添加至双向链表的头部\n            addToHead(newNode);\n            ++size;\n            if (size > capacity) {\n                // 如果超出容量，删除双向链表的尾部节点\n                DLinkedNode tail = removeTail();\n                // 删除哈希表中对应的项\n                cache.remove(tail.key);\n                --size;\n            }\n        }\n        else {\n            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部\n            node.value = value;\n            moveToHead(node);\n        }\n    }\n\n    private void addToHead(DLinkedNode node) {\n        node.prev = head;\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;\n    }\n\n    private void removeNode(DLinkedNode node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n\n    private void moveToHead(DLinkedNode node) {\n        removeNode(node);\n        addToHead(node);\n    }\n\n    private DLinkedNode removeTail() {\n        DLinkedNode res = tail.prev;\n        removeNode(res);\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n",normalizedContent:"# leetcode-146-lru缓存机制\n\n运用你所掌握的数据结构，设计和实现一个 lru (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。\n\n获取数据 get(key) - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。 写入数据 put(key, value) - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。\n\n进阶:\n\n你是否可以在 o(1) 时间复杂度内完成这两种操作？\n\n示例1：\n\nlrucache cache = new lrucache( 2 /* 缓存容量 */ );\n\ncache.put(1, 1);\ncache.put(2, 2);\ncache.get(1);       // 返回  1\ncache.put(3, 3);    // 该操作会使得关键字 2 作废\ncache.get(2);       // 返回 -1 (未找到)\ncache.put(4, 4);    // 该操作会使得关键字 1 作废\ncache.get(1);       // 返回 -1 (未找到)\ncache.get(3);       // 返回  3\ncache.get(4);       // 返回  4\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 解题思路\n\n方法1、队列+哈希表：\n\n观察示例可知，当执行get(1)之后，后加入的key为2的数据会变为最久没有使用的\n\n不难知道，在get操作之后需要对数据进行重排。而put操作也将依赖与重排的逻辑进行操作\n\n这里选择先进先出的queue作为重排的容器比较合适。\n\n首先需要记录初始化的容量capacity\n\n 1. 每进行一次put，队列中也会加入key，map中也会加入key，value，同时容量减1\n 2. 当容量为0时，需要删除map中最久没有使用的key，value，再添加新的key，value\n\n如果get的时候能够保证queue头部存储的最久没有使用的key，那么这一步操作就变得很简单。只需要如下操作即可。\n\nmap.remove(queue.poll());\nqueue.add(key);\nmap.put(key,value);\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n那么如何让get操作，保证queue的头部存储的最久没有使用的key呢？\n\n想要实现这样的queue，换一种思路，使用了(get)之后的key应该放在队列的最后\n\n那么当查找一个key的时候，通过判断queue是否有这个key来进行get操作\n\n * 当有这个key的时候，将这个key拿出来，然后放到queue末尾，之后返回map中获得key的结果即可。\n * 如果没有这个key，返回-1即可。\n\n回到put函数这里，除了put中的1、2两个操作之外，还需要考虑第3种情况\n\n 3. 如果put的过程中queue中有这个key，即put[1,2]之后又put[1,5]这种情况仅仅value不同，key相同，需要删除原本queue中的key，再添加新的key，因为put同一个key的操作或许不是连续的。同时需要更新map的key和value\n\n方法2、哈希表+双向链表：\n\n原文链接：https://leetcode-cn.com/problems/lru-cache/solution/lruhuan-cun-ji-zhi-by-leetcode-solution/\n\n利用linkedhashmap，不利用linkedhashmap两个版本\n\nlru 缓存机制可以通过哈希表辅以双向链表实现，我们用一个哈希表和一个双向链表维护所有在缓存中的键值对。\n\n * 双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。\n\n * 哈希表即为普通的哈希映射（hashmap），通过缓存数据的键映射到其在双向链表中的位置。\n\n这样以来，我们首先使用哈希表进行定位，找出缓存项在双向链表中的位置，随后将其移动到双向链表的头部，即可在 o(1) 的时间内完成 get或者 put 操作。具体的方法如下：\n\n * 对于 get 操作，首先判断 key是否存在：\n   \n   * 如果 key 不存在，则返回−1；\n   * 如果 key存在，则 key对应的节点是最近被使用的节点。通过哈希表定位到该节点在双向链表中的位置，并将其移动到双向链表的头部，最后返回该节点的值。\n\n * 对于 put 操作，首先判断key是否存在：\n   \n   * 如果key 不存在，使用key和 value创建一个新的节点，在双向链表的头部添加该节点，并将 key和该节点添加进哈希表中。然后判断双向链表的节点数是否超出容量，如果超出容量，则删除双向链表的尾部节点，并删除哈希表中对应的项；\n   * 如果 key存在，则与 get操作类似，先通过哈希表定位，再将对应的节点的值更新为 value，并将该节点移到双向链表的头部。\n\n上述各项操作中，访问哈希表的时间复杂度为 o(1)，在双向链表的头部添加节点、在双向链表的尾部删除节点的复杂度也为 o(1)。而将一个节点移到双向链表的头部，可以分成「删除该节点」和「在双向链表的头部添加节点」两步操作，都可以在o(1) 时间内完成。\n\n小贴士\n\n在双向链表的实现中，使用一个伪头部（dummy head）和伪尾部（dummy tail）标记界限，这样在添加节点和删除节点的时候就不需要检查相邻的节点是否存在。\n\n\n# java代码1\n\nclass lrucache {\n    queue<integer> queue;\n    hashmap<integer,integer> map;\n    int capacity;\n    public lrucache(int capacity) {\n        this.map = new hashmap<>();\n        this.queue = new linkedlist<>();\n        this.capacity = capacity;\n    }\n    \n    public int get(int key) {\n        if(queue.contains(key)){\n            queue.remove(key);\n            queue.add(key);\n            return map.get(key);\n        }else{\n            return -1;\n        }\n    }\n    \n    public void put(int key, int value) {\n        if(queue.contains(key)){\n            queue.remove(key);\n            queue.add(key);\n            map.put(key,value);\n        }\n        else if(capacity==0){\n            map.remove(queue.poll());\n            queue.add(key);\n            map.put(key,value);\n        }else{\n            queue.add(key);\n            map.put(key,value);\n            capacity--;\n        }\n    }\n}\n\n/**\n * your lrucache object will be instantiated and called as such:\n * lrucache obj = new lrucache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n\n# java代码2\n\nclass lrucache {\n    private int cap;\n\tprivate map<integer, integer> map = new linkedhashmap<>();  // 保持插入顺序\n\n\tpublic lrucache(int capacity) {\n\t\tthis.cap = capacity;\n\t}\n\n\tpublic int get(int key) {\n\t\tif (map.keyset().contains(key)) {\n\t\t\tint value = map.get(key);\n\t\t\tmap.remove(key);\n            // 保证每次查询后，都在末尾\n\t\t\tmap.put(key, value);\n\t\t\treturn value;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tpublic void put(int key, int value) {\n\t\tif (map.keyset().contains(key)) {\n\t\t\tmap.remove(key);\n\t\t} else if (map.size() == cap) {\n\t\t\titerator<map.entry<integer, integer>> iterator = map.entryset().iterator();\n\t\t\titerator.next();\n\t\t\titerator.remove();\n\t\t}\n\t\tmap.put(key, value);\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# java代码3\n\n完全手动实现linkedhashmap\n\npublic class lrucache {\n    class dlinkednode {\n        int key;\n        int value;\n        dlinkednode prev;\n        dlinkednode next;\n        public dlinkednode() {}\n        public dlinkednode(int _key, int _value) {key = _key; value = _value;}\n    }\n\n    private map<integer, dlinkednode> cache = new hashmap<integer, dlinkednode>();\n    private int size;\n    private int capacity;\n    private dlinkednode head, tail;\n\n    public lrucache(int capacity) {\n        this.size = 0;\n        this.capacity = capacity;\n        // 使用伪头部和伪尾部节点\n        head = new dlinkednode();\n        tail = new dlinkednode();\n        head.next = tail;\n        tail.prev = head;\n    }\n\n    public int get(int key) {\n        dlinkednode node = cache.get(key);\n        if (node == null) {\n            return -1;\n        }\n        // 如果 key 存在，先通过哈希表定位，再移到头部\n        movetohead(node);\n        return node.value;\n    }\n\n    public void put(int key, int value) {\n        dlinkednode node = cache.get(key);\n        if (node == null) {\n            // 如果 key 不存在，创建一个新的节点\n            dlinkednode newnode = new dlinkednode(key, value);\n            // 添加进哈希表\n            cache.put(key, newnode);\n            // 添加至双向链表的头部\n            addtohead(newnode);\n            ++size;\n            if (size > capacity) {\n                // 如果超出容量，删除双向链表的尾部节点\n                dlinkednode tail = removetail();\n                // 删除哈希表中对应的项\n                cache.remove(tail.key);\n                --size;\n            }\n        }\n        else {\n            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部\n            node.value = value;\n            movetohead(node);\n        }\n    }\n\n    private void addtohead(dlinkednode node) {\n        node.prev = head;\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;\n    }\n\n    private void removenode(dlinkednode node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n\n    private void movetohead(dlinkednode node) {\n        removenode(node);\n        addtohead(node);\n    }\n\n    private dlinkednode removetail() {\n        dlinkednode res = tail.prev;\n        removenode(res);\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-152-乘积最大子数组",frontmatter:{title:"LeetCode-152-乘积最大子数组",date:"2020-07-12T10:15:54.000Z",description:"乘积最大子数组",tags:["Java","数组","DP","Medium"],keywords:"Java,数组,DP,Medium,LeetCode",permalink:"/pages/87a481/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/58.LeetCode-152-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84.html",relativePath:"06.算法/02.LeetCode/58.LeetCode-152-乘积最大子数组.md",key:"v-bbbaa4fa",path:"/pages/87a481/",headers:[{level:2,title:"LeetCode-152-乘积最大子数组",slug:"leetcode-152-乘积最大子数组",normalizedTitle:"leetcode-152-乘积最大子数组",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:232},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:650},{level:3,title:"Java代码",slug:"java代码-2",normalizedTitle:"java代码",charIndex:650}],headersStr:"LeetCode-152-乘积最大子数组 解题思路 Java代码 Java代码",content:"# LeetCode-152-乘积最大子数组\n\n给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。\n\n示例1：\n\n输入: [2,3,-2,4]\n输出: 6\n解释: 子数组 [2,3] 有最大乘积 6。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2：\n\n输入: [-2,0,-1]\n输出: 0\n解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n\n# 解题思路\n\n方法1、动态规划：\n\n遍历数组的时候不断计算当前的最大值\n\n同时还需要记录之前的最小值，当遍历的到的nums[i]为负数的时候\n\n最大值*负数：会导致最大值变为最小\n\n最小值*负数：会导致最小值变为最大\n\n所以需要维护当前的最大值和当前的最小值\n\n最大值可由curMax = Math.max(curMax*nums[i],nums[i]);计算\n\n最小值可由curMin = Math.min(curMin*nums[i],nums[i]);计算\n\n最大值和最小值会发生互换，导致结果不对\n\n既然这样当遇到负数nums[i]的时候，提前将最大值和最小值互换，就可以维持原本的最大最小值\n\n一个更好的题解来自https://leetcode-cn.com/problems/maximum-product-subarray/solution/dpfang-fa-xiang-jie-by-yang-cong-12/\n\n\n# Java代码\n\nclass Solution {\n    public int maxProduct(int[] nums) {\n        int max = Integer.MIN_VALUE;\n        int curMax = 1;\n        int curMin = 1;\n        for(int i=0;i<nums.length;i++){\n            if(nums[i]<0){\n                int temp = curMax;\n                curMax = curMin;\n                curMin = temp;\n            }\n            curMax = Math.max(curMax*nums[i],nums[i]);\n            curMin = Math.min(curMin*nums[i],nums[i]);\n            max = Math.max(max,curMax);\n        }\n        return max;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\ndp数组版本\n\n\n# Java代码\n\nclass Solution {\n    public int maxProduct(int[] nums) {\n        int[] dp_max = new int[nums.length+1];\n        int[] dp_min = new int[nums.length+1];\n        if(nums.length == 0) return 0;\n        int max = Integer.MIN_VALUE;\n        // 由于存在负数，所以需要维护两个数组\n        // dp_max[i] 指的是以第 i 个数结尾的 乘积最大 的连续子序列\n        // dp_min[i] 指的是以第 i 个数结尾的 乘积最小 的连续子序列\n        dp_max[0] = 1;\n        dp_min[0] = 1;\n        for (int i = 1;i <= nums.length;i++){\n            // 如果数组的数是负数，那么会导致 max 变成 min，min 变成 max\n            // 故需要交换dp \n            if(nums[i-1] < 0){\n                int temp = dp_min[i-1];\n                dp_min[i-1] = dp_max[i-1];\n                dp_max[i-1] = temp;\n            }\n            dp_min[i] = Math.min(nums[i-1],dp_min[i-1]*nums[i-1]);\n            dp_max[i] = Math.max(nums[i-1],dp_max[i-1]*nums[i-1]);\n            max = Math.max(max,dp_max[i]);\n        }\n        return max;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n",normalizedContent:"# leetcode-152-乘积最大子数组\n\n给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。\n\n示例1：\n\n输入: [2,3,-2,4]\n输出: 6\n解释: 子数组 [2,3] 有最大乘积 6。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2：\n\n输入: [-2,0,-1]\n输出: 0\n解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n\n# 解题思路\n\n方法1、动态规划：\n\n遍历数组的时候不断计算当前的最大值\n\n同时还需要记录之前的最小值，当遍历的到的nums[i]为负数的时候\n\n最大值*负数：会导致最大值变为最小\n\n最小值*负数：会导致最小值变为最大\n\n所以需要维护当前的最大值和当前的最小值\n\n最大值可由curmax = math.max(curmax*nums[i],nums[i]);计算\n\n最小值可由curmin = math.min(curmin*nums[i],nums[i]);计算\n\n最大值和最小值会发生互换，导致结果不对\n\n既然这样当遇到负数nums[i]的时候，提前将最大值和最小值互换，就可以维持原本的最大最小值\n\n一个更好的题解来自https://leetcode-cn.com/problems/maximum-product-subarray/solution/dpfang-fa-xiang-jie-by-yang-cong-12/\n\n\n# java代码\n\nclass solution {\n    public int maxproduct(int[] nums) {\n        int max = integer.min_value;\n        int curmax = 1;\n        int curmin = 1;\n        for(int i=0;i<nums.length;i++){\n            if(nums[i]<0){\n                int temp = curmax;\n                curmax = curmin;\n                curmin = temp;\n            }\n            curmax = math.max(curmax*nums[i],nums[i]);\n            curmin = math.min(curmin*nums[i],nums[i]);\n            max = math.max(max,curmax);\n        }\n        return max;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\ndp数组版本\n\n\n# java代码\n\nclass solution {\n    public int maxproduct(int[] nums) {\n        int[] dp_max = new int[nums.length+1];\n        int[] dp_min = new int[nums.length+1];\n        if(nums.length == 0) return 0;\n        int max = integer.min_value;\n        // 由于存在负数，所以需要维护两个数组\n        // dp_max[i] 指的是以第 i 个数结尾的 乘积最大 的连续子序列\n        // dp_min[i] 指的是以第 i 个数结尾的 乘积最小 的连续子序列\n        dp_max[0] = 1;\n        dp_min[0] = 1;\n        for (int i = 1;i <= nums.length;i++){\n            // 如果数组的数是负数，那么会导致 max 变成 min，min 变成 max\n            // 故需要交换dp \n            if(nums[i-1] < 0){\n                int temp = dp_min[i-1];\n                dp_min[i-1] = dp_max[i-1];\n                dp_max[i-1] = temp;\n            }\n            dp_min[i] = math.min(nums[i-1],dp_min[i-1]*nums[i-1]);\n            dp_max[i] = math.max(nums[i-1],dp_max[i-1]*nums[i-1]);\n            max = math.max(max,dp_max[i]);\n        }\n        return max;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-198-打家劫舍",frontmatter:{title:"LeetCode-198-打家劫舍",date:"2020-06-06T15:03:23.000Z",description:"打家劫舍",tags:["DP","数组","Java","Python","Easy","LeetCode"],keywords:"DP,数组,Java,Python,Easy,LeetCode",permalink:"/pages/bd9776/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/59.LeetCode-198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D.html",relativePath:"06.算法/02.LeetCode/59.LeetCode-198-打家劫舍.md",key:"v-20c0614d",path:"/pages/bd9776/",headers:[{level:2,title:"LeetCode-198-打家劫舍",slug:"leetcode-198-打家劫舍",normalizedTitle:"leetcode-198-打家劫舍",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:489},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:804},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:1292}],headersStr:"LeetCode-198-打家劫舍 解题思路 Java代码 Python代码",content:"# LeetCode-198-打家劫舍\n\n你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\n\n给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。\n\n示例 1:\n\n输入：[1,2,3,1]\n输出：4\n解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。\n     偷窃到的最高金额 = 1 + 3 = 4 。\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n示例2：\n\n输入：[2,7,9,3,1]\n输出：12\n解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。\n     偷窃到的最高金额 = 2 + 9 + 1 = 12 。\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n提示：\n\n * 0 <= nums.length <= 100\n * 0 <= nums[i] <= 400\n\n\n# 解题思路\n\n动态规划：\n\n题目和{% post_link LeetCode-面试题17.16-按摩师 %}是基本上一样的\n\ndp数组的状态：当前位置前相隔数据的最大值\n\n初始化：dp[0] = nums[0] ,dp[1] = Math.max(nums[0],nums[1])\n\n转移方程：索引从2开始，由于dp[i-1]存储前面相隔数据的最大值，所以需要比较，当前位置的num[i]和前面间隔位置的数值最大值dp[i-2]之和，与dp[i-1]之间的大小关系，即dp[i] = Math.max(dp[i-1],dp[i-2]+nums[i])\n\n双指针：\n\n多加一间房子，这个解法是经过分析之后简化的，原文来源这里\n\n\n# Java代码\n\nclass Solution {\n    public int rob(int[] nums) {\n        int len = nums.length;\n        if(nums==null||len==0) return 0;\n        if(len<2)\n            return nums[0];\n        int[] dp = new int[len];\n        dp[0] = nums[0];\n        dp[1] = Math.max(nums[0],nums[1]);\n        for(int i=2;i<len;i++){\n            dp[i] = Math.max(dp[i-1],dp[i-2]+nums[i]);\n        }\n        return dp[len-1];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# Python代码\n\nclass Solution:\n    def rob(self, nums: List[int]) -> int:\n        cur , pre = 0,0\n        for i in nums:\n            cur,pre = max(pre+i,cur),cur\n        return cur;\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n",normalizedContent:"# leetcode-198-打家劫舍\n\n你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\n\n给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。\n\n示例 1:\n\n输入：[1,2,3,1]\n输出：4\n解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。\n     偷窃到的最高金额 = 1 + 3 = 4 。\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n示例2：\n\n输入：[2,7,9,3,1]\n输出：12\n解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。\n     偷窃到的最高金额 = 2 + 9 + 1 = 12 。\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n提示：\n\n * 0 <= nums.length <= 100\n * 0 <= nums[i] <= 400\n\n\n# 解题思路\n\n动态规划：\n\n题目和{% post_link leetcode-面试题17.16-按摩师 %}是基本上一样的\n\ndp数组的状态：当前位置前相隔数据的最大值\n\n初始化：dp[0] = nums[0] ,dp[1] = math.max(nums[0],nums[1])\n\n转移方程：索引从2开始，由于dp[i-1]存储前面相隔数据的最大值，所以需要比较，当前位置的num[i]和前面间隔位置的数值最大值dp[i-2]之和，与dp[i-1]之间的大小关系，即dp[i] = math.max(dp[i-1],dp[i-2]+nums[i])\n\n双指针：\n\n多加一间房子，这个解法是经过分析之后简化的，原文来源这里\n\n\n# java代码\n\nclass solution {\n    public int rob(int[] nums) {\n        int len = nums.length;\n        if(nums==null||len==0) return 0;\n        if(len<2)\n            return nums[0];\n        int[] dp = new int[len];\n        dp[0] = nums[0];\n        dp[1] = math.max(nums[0],nums[1]);\n        for(int i=2;i<len;i++){\n            dp[i] = math.max(dp[i-1],dp[i-2]+nums[i]);\n        }\n        return dp[len-1];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# python代码\n\nclass solution:\n    def rob(self, nums: list[int]) -> int:\n        cur , pre = 0,0\n        for i in nums:\n            cur,pre = max(pre+i,cur),cur\n        return cur;\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-199-二叉树的右视图",frontmatter:{title:"LeetCode-199-二叉树的右视图",date:"2020-07-08T11:14:52.000Z",description:"二叉树的右视图",tags:["树","Java","BFS","DFS","Medium"],keywords:"树,Java,BFS,DFS,Medium,LeetCode",permalink:"/pages/2aa937/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/60.LeetCode-199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE.html",relativePath:"06.算法/02.LeetCode/60.LeetCode-199-二叉树的右视图.md",key:"v-eab0bdca",path:"/pages/2aa937/",headers:[{level:2,title:"LeetCode-199-二叉树的右视图",slug:"leetcode-199-二叉树的右视图",normalizedTitle:"leetcode-199-二叉树的右视图",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:245},{level:3,title:"Java代码1",slug:"java代码1",normalizedTitle:"java代码1",charIndex:473},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:1569}],headersStr:"LeetCode-199-二叉树的右视图 解题思路 Java代码1 Java代码2",content:"# LeetCode-199-二叉树的右视图\n\n给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。\n\n示例1：\n\n输入: [1,2,3,null,5,null,4]\n输出: [1, 3, 4]\n解释:\n\n   1            <---\n /   \\\n2     3         <---\n \\     \\\n  5     4       <---\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 解题思路\n\n方法1、Queue迭代+BFS：\n\n按照层序遍历的思想，利用一个Queue进行迭代，在层序遍历的时候优先加入右节点，按根右左的顺序遍历二叉树\n\n从右边可见的节点始终是层序遍历时队列中第一个弹出的节点，即i==0时，将节点加入到res中\n\n方法2、DFS：\n\n我们对树进行深度优先搜索，在搜索过程中，我们总是先访问右子树。那么对于每一层来说，我们在这层见到的第一个结点一定是最右边的结点。这样一来，只需要存储每个深度访问的第一个节点即可\n\n\n# Java代码1\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<Integer> rightSideView(TreeNode root) {\n        List<Integer> res = new ArrayList<>();\n        if(root==null) return res;\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.add(root);\n        while(!queue.isEmpty()){\n            int size = queue.size();\n            for(int i=0;i<size;i++){\n                if(i==0){\n                    res.add(queue.peek().val);\n                }\n                TreeNode temp = queue.poll();\n                if(temp.right!=null){\n                    queue.add(temp.right);\n                }\n                if(temp.left!=null){\n                    queue.add(temp.left);\n                }\n            }\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# Java代码2\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    List<Integer> res = new ArrayList<>();\n    public List<Integer> rightSideView(TreeNode root) {\n        if(root==null) return res;\n        DFS(root,0);\n        return res;\n    }\n\n    public void DFS(TreeNode root,int depth){\n        if(root==null) return;\n        // 如果当前节点所在深度还没有出现在res里\n        // 说明在该深度下当前节点是第一个被访问的节点，因此将当前节点加入res中。\n        if(depth>=res.size()){\n            res.add(root.val);\n        }\n        DFS(root.right,depth+1);\n        DFS(root.left,depth+1);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n",normalizedContent:"# leetcode-199-二叉树的右视图\n\n给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。\n\n示例1：\n\n输入: [1,2,3,null,5,null,4]\n输出: [1, 3, 4]\n解释:\n\n   1            <---\n /   \\\n2     3         <---\n \\     \\\n  5     4       <---\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 解题思路\n\n方法1、queue迭代+bfs：\n\n按照层序遍历的思想，利用一个queue进行迭代，在层序遍历的时候优先加入右节点，按根右左的顺序遍历二叉树\n\n从右边可见的节点始终是层序遍历时队列中第一个弹出的节点，即i==0时，将节点加入到res中\n\n方法2、dfs：\n\n我们对树进行深度优先搜索，在搜索过程中，我们总是先访问右子树。那么对于每一层来说，我们在这层见到的第一个结点一定是最右边的结点。这样一来，只需要存储每个深度访问的第一个节点即可\n\n\n# java代码1\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public list<integer> rightsideview(treenode root) {\n        list<integer> res = new arraylist<>();\n        if(root==null) return res;\n        queue<treenode> queue = new linkedlist<>();\n        queue.add(root);\n        while(!queue.isempty()){\n            int size = queue.size();\n            for(int i=0;i<size;i++){\n                if(i==0){\n                    res.add(queue.peek().val);\n                }\n                treenode temp = queue.poll();\n                if(temp.right!=null){\n                    queue.add(temp.right);\n                }\n                if(temp.left!=null){\n                    queue.add(temp.left);\n                }\n            }\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# java代码2\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    list<integer> res = new arraylist<>();\n    public list<integer> rightsideview(treenode root) {\n        if(root==null) return res;\n        dfs(root,0);\n        return res;\n    }\n\n    public void dfs(treenode root,int depth){\n        if(root==null) return;\n        // 如果当前节点所在深度还没有出现在res里\n        // 说明在该深度下当前节点是第一个被访问的节点，因此将当前节点加入res中。\n        if(depth>=res.size()){\n            res.add(root.val);\n        }\n        dfs(root.right,depth+1);\n        dfs(root.left,depth+1);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-207-课程表",frontmatter:{title:"LeetCode-207-课程表",date:"2020-07-18T11:25:07.000Z",description:"课程表",tags:["数组","图论算法","拓扑排序","BFS","DFS","Java","Medium"],keywords:"数组,图论算法,拓扑排序,BFS,DFS,Java,Medium,LeetCode",permalink:"/pages/44df2f/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/62.LeetCode-207-%E8%AF%BE%E7%A8%8B%E8%A1%A8.html",relativePath:"06.算法/02.LeetCode/62.LeetCode-207-课程表.md",key:"v-2b11bb3a",path:"/pages/44df2f/",headers:[{level:2,title:"LeetCode-207-课程表",slug:"leetcode-207-课程表",normalizedTitle:"leetcode-207-课程表",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:487},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:1237}],headersStr:"LeetCode-207-课程表 解题思路 Java代码",content:"# LeetCode-207-课程表\n\n你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。\n\n在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1]\n\n给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？\n\n示例1：\n\n输入: 2, [[1,0]] \n输出: true\n解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2：\n\n输入: 2, [[1,0],[0,1]]\n输出: false\n解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n提示：\n\n 1. 输入的先决条件是由 边缘列表 表示的图形，而不是 邻接矩阵 。详情请参见图的表示法。\n 2. 你可以假定输入的先决条件中没有重复的边。\n 3. 1 <= numCourses <= 10^5\n\n\n# 解题思路\n\n转载自https://leetcode-cn.com/problems/course-schedule/solution/course-schedule-tuo-bu-pai-xu-bfsdfsliang-chong-fa/\n\n课程安排图问题，可以转化为通过拓扑排序判断这个图是否是有向无环图\n\n拓扑排序的原理：可见这篇文章\n\n方法1、入度表(BFS)：\n\n算法流程：\n\n 1. 统计课程安排图中每个节点的入度，生成 入度表 indegrees。\n 2. 借助一个队列 queue，将所有入度为 0 的节点入队。\n 3. 当 queue 非空时，依次将队首节点出队，在课程安排图中删除此节点pre：\n    1. 并不是真正从邻接表中删除此节点 pre，而是将此节点对应所有邻接节点cur的入度 -1，即indegrees[cur] -= 1。\n    2. 当入度 -1后邻接节点cur 的入度为 0，说明 cur所有的前驱节点已经被 “删除”，此时将 cur入队。\n 4. 在每次 pre出队时，执行 numCourses--；\n    1. 若整个课程安排图是有向无环图（即可以安排），则所有节点一定都入队并出队过，即完成拓扑排序。换个角度说，若课程安排图中存在环，一定有节点的入度始终不为 0。\n    2. 因此，拓扑排序出队次数等于课程个数，返回 numCourses == 0 判断课程是否可以成功安排。\n\n复杂度分析：\n\n * 时间复杂度 O(N + M)： 遍历一个图需要访问所有节点和所有临边，N 和 M 分别为节点数量和临边数量；\n * 空间复杂度 O(N + M)： 为建立邻接表所需额外空间，adjacency 长度为 N ，并存储 M 条临边的数据。\n\n\n# Java代码\n\nclass Solution {\n    public boolean canFinish(int numCourses, int[][] prerequisites) {\n        int[] indegrees = new int[numCourses];\n        List<List<Integer>> adjacency = new ArrayList<>();\n        Queue<Integer> queue = new LinkedList<>();\n        for(int i=0;i<numCourses;i++){\n            adjacency.add(new ArrayList<>());\n        }\n        // 获得每个课程入度和邻接表\n        for(int[] cp:prerequisites){\n            indegrees[cp[0]]++;\n            adjacency.get(cp[1]).add(cp[0]);\n        }\n        // 获得所有入度为0的课程\n        for(int i=0;i<numCourses;i++){\n            if(indegrees[i]==0) queue.add(i);\n        }\n        // BFS\n        while(!queue.isEmpty()){\n            int pre = queue.poll();\n            numCourses--;\n            for(int cur: adjacency.get(pre)){\n                if(--indegrees[cur]==0) queue.add(cur);\n            }\n        }\n        return numCourses == 0;\n    }\n} \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n",normalizedContent:"# leetcode-207-课程表\n\n你这个学期必须选修 numcourse 门课程，记为 0 到 numcourse-1 。\n\n在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1]\n\n给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？\n\n示例1：\n\n输入: 2, [[1,0]] \n输出: true\n解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2：\n\n输入: 2, [[1,0],[0,1]]\n输出: false\n解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n提示：\n\n 1. 输入的先决条件是由 边缘列表 表示的图形，而不是 邻接矩阵 。详情请参见图的表示法。\n 2. 你可以假定输入的先决条件中没有重复的边。\n 3. 1 <= numcourses <= 10^5\n\n\n# 解题思路\n\n转载自https://leetcode-cn.com/problems/course-schedule/solution/course-schedule-tuo-bu-pai-xu-bfsdfsliang-chong-fa/\n\n课程安排图问题，可以转化为通过拓扑排序判断这个图是否是有向无环图\n\n拓扑排序的原理：可见这篇文章\n\n方法1、入度表(bfs)：\n\n算法流程：\n\n 1. 统计课程安排图中每个节点的入度，生成 入度表 indegrees。\n 2. 借助一个队列 queue，将所有入度为 0 的节点入队。\n 3. 当 queue 非空时，依次将队首节点出队，在课程安排图中删除此节点pre：\n    1. 并不是真正从邻接表中删除此节点 pre，而是将此节点对应所有邻接节点cur的入度 -1，即indegrees[cur] -= 1。\n    2. 当入度 -1后邻接节点cur 的入度为 0，说明 cur所有的前驱节点已经被 “删除”，此时将 cur入队。\n 4. 在每次 pre出队时，执行 numcourses--；\n    1. 若整个课程安排图是有向无环图（即可以安排），则所有节点一定都入队并出队过，即完成拓扑排序。换个角度说，若课程安排图中存在环，一定有节点的入度始终不为 0。\n    2. 因此，拓扑排序出队次数等于课程个数，返回 numcourses == 0 判断课程是否可以成功安排。\n\n复杂度分析：\n\n * 时间复杂度 o(n + m)： 遍历一个图需要访问所有节点和所有临边，n 和 m 分别为节点数量和临边数量；\n * 空间复杂度 o(n + m)： 为建立邻接表所需额外空间，adjacency 长度为 n ，并存储 m 条临边的数据。\n\n\n# java代码\n\nclass solution {\n    public boolean canfinish(int numcourses, int[][] prerequisites) {\n        int[] indegrees = new int[numcourses];\n        list<list<integer>> adjacency = new arraylist<>();\n        queue<integer> queue = new linkedlist<>();\n        for(int i=0;i<numcourses;i++){\n            adjacency.add(new arraylist<>());\n        }\n        // 获得每个课程入度和邻接表\n        for(int[] cp:prerequisites){\n            indegrees[cp[0]]++;\n            adjacency.get(cp[1]).add(cp[0]);\n        }\n        // 获得所有入度为0的课程\n        for(int i=0;i<numcourses;i++){\n            if(indegrees[i]==0) queue.add(i);\n        }\n        // bfs\n        while(!queue.isempty()){\n            int pre = queue.poll();\n            numcourses--;\n            for(int cur: adjacency.get(pre)){\n                if(--indegrees[cur]==0) queue.add(cur);\n            }\n        }\n        return numcourses == 0;\n    }\n} \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-206-反转链表",frontmatter:{title:"LeetCode-206-反转链表",date:"2020-07-17T13:23:02.000Z",description:"反转链表",tags:["链表","Java","Easy"],keywords:"链表,Java,Easy,LeetCode",permalink:"/pages/7c576f/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/61.LeetCode-206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.html",relativePath:"06.算法/02.LeetCode/61.LeetCode-206-反转链表.md",key:"v-bc33ea14",path:"/pages/7c576f/",headers:[{level:2,title:"LeetCode-206-反转链表",slug:"leetcode-206-反转链表",normalizedTitle:"leetcode-206-反转链表",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:135},{level:3,title:"Java代码1",slug:"java代码1",normalizedTitle:"java代码1",charIndex:422},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:1059}],headersStr:"LeetCode-206-反转链表 解题思路 Java代码1 Java代码2",content:"# LeetCode-206-反转链表\n\n反转一个单链表。\n\n示例1：\n\n输入: 1->2->3->4->5->NULL\n输出: 5->4->3->2->1->NULL\n\n\n1\n2\n\n1\n2\n\n\n进阶: 你可以迭代或递归地反转链表。你能否用两种方法解决这道题？\n\n\n# 解题思路\n\n方法1、迭代：\n\n利用pre指针指向null，并利用cur指针存储head节点，当cur不为空的时候\n\n临时存储cur.next，因为要改变指向，将cur.next指向pre，将pre移动到cur的位置，将cur移动到cur.next即temp\n\n最后返回pre即可\n\n方法2、递归：\n\n递归方法不容易理解，详见https://leetcode-cn.com/problems/reverse-linked-list/solution/dong-hua-yan-shi-206-fan-zhuan-lian-biao-by-user74/中的幻灯片演示\n\n\n# Java代码1\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        if(head==null||head.next==null) return head;\n        ListNode pre = null;\n        ListNode cur = head;\n        while(cur!=null){\n            ListNode temp = cur.next;\n            cur.next = pre;\n            pre = cur;\n            cur = temp;\n        }\n        return pre;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# Java代码2\n\nclass Solution {\n\tpublic ListNode reverseList(ListNode head) {\n\t\t//递归终止条件是当前为空，或者下一个节点为空\n\t\tif(head==null || head.next==null) {\n\t\t\treturn head;\n\t\t}\n\t\t//这里的cur就是最后一个节点\n\t\tListNode cur = reverseList(head.next);\n\t\t//这里请配合动画演示理解\n\t\t//如果链表是 1->2->3->4->5，那么此时的cur就是5\n\t\t//而head是4，head的下一个是5，下下一个是空\n\t\t//所以head.next.next 就是5->4\n\t\thead.next.next = head;\n\t\t//防止链表循环，需要将head.next设置为空\n\t\thead.next = null;\n\t\t//每层递归函数都返回cur，也就是最后一个节点\n\t\treturn cur;\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n",normalizedContent:"# leetcode-206-反转链表\n\n反转一个单链表。\n\n示例1：\n\n输入: 1->2->3->4->5->null\n输出: 5->4->3->2->1->null\n\n\n1\n2\n\n1\n2\n\n\n进阶: 你可以迭代或递归地反转链表。你能否用两种方法解决这道题？\n\n\n# 解题思路\n\n方法1、迭代：\n\n利用pre指针指向null，并利用cur指针存储head节点，当cur不为空的时候\n\n临时存储cur.next，因为要改变指向，将cur.next指向pre，将pre移动到cur的位置，将cur移动到cur.next即temp\n\n最后返回pre即可\n\n方法2、递归：\n\n递归方法不容易理解，详见https://leetcode-cn.com/problems/reverse-linked-list/solution/dong-hua-yan-shi-206-fan-zhuan-lian-biao-by-user74/中的幻灯片演示\n\n\n# java代码1\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode(int x) { val = x; }\n * }\n */\nclass solution {\n    public listnode reverselist(listnode head) {\n        if(head==null||head.next==null) return head;\n        listnode pre = null;\n        listnode cur = head;\n        while(cur!=null){\n            listnode temp = cur.next;\n            cur.next = pre;\n            pre = cur;\n            cur = temp;\n        }\n        return pre;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# java代码2\n\nclass solution {\n\tpublic listnode reverselist(listnode head) {\n\t\t//递归终止条件是当前为空，或者下一个节点为空\n\t\tif(head==null || head.next==null) {\n\t\t\treturn head;\n\t\t}\n\t\t//这里的cur就是最后一个节点\n\t\tlistnode cur = reverselist(head.next);\n\t\t//这里请配合动画演示理解\n\t\t//如果链表是 1->2->3->4->5，那么此时的cur就是5\n\t\t//而head是4，head的下一个是5，下下一个是空\n\t\t//所以head.next.next 就是5->4\n\t\thead.next.next = head;\n\t\t//防止链表循环，需要将head.next设置为空\n\t\thead.next = null;\n\t\t//每层递归函数都返回cur，也就是最后一个节点\n\t\treturn cur;\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-215-数组中的第K个最大元素",frontmatter:{title:"LeetCode-215-数组中的第K个最大元素",date:"2020-06-24T10:18:17.000Z",description:"数组中的第K个最大元素",tags:["数组","Java","Python","Medium","LeetCode"],keywords:"数组,Java,Python,Medium,LeetCode",permalink:"/pages/f586d8/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/63.LeetCode-215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0.html",relativePath:"06.算法/02.LeetCode/63.LeetCode-215-数组中的第K个最大元素.md",key:"v-0f1d08a6",path:"/pages/f586d8/",headers:[{level:2,title:"LeetCode-215-数组中的第K个最大元素",slug:"leetcode-215-数组中的第k个最大元素",normalizedTitle:"leetcode-215-数组中的第k个最大元素",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:241},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:1004},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:1692},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:1861}],headersStr:"LeetCode-215-数组中的第K个最大元素 解题思路 Java代码 Python代码 Java代码2",content:"# LeetCode-215-数组中的第K个最大元素\n\n在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。\n\n示例 1:\n\n输入: [3,2,1,5,6,4] 和 k = 2\n输出: 5\n\n\n1\n2\n\n1\n2\n\n\n示例2：\n\n输入: [3,2,3,1,2,4,5,5,6] 和 k = 4\n输出: 4\n\n\n1\n2\n\n1\n2\n\n\n说明:\n\n你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。\n\n\n# 解题思路\n\n方法1、优先队列：\n\n首先想到的是给数组进行排序，排序之后就很容易找到第k个最大的元素\n\n那么有没有不排序的方法，自然就会想到建立堆来进行操作\n\n我们可以建立一个大顶堆，最大的数在建堆的过程中排最上面，一次遍历就能完成数组从大到小的构建\n\n寻找排序之后的第k个最大的元素，也就是寻找大顶堆的正序第k个元素\n\n之后一直弹出到k-1为止，下一个位置就是第k个最大的元素\n\n方法2、暴力破解：\n\n排序之后，倒置一下，第k-1个位置就是第k个最大的元素，不倒置就是nums.length-k个位置\n\n方法3、快速选择：\n\n摘自LeetCode官方题解\n\n就像快速排序那样，本算法也是 Tony Hoare 发明的，因此也被称为 Hoare选择算法。\n\n本方法大致上与快速排序相同。简便起见，注意到第 k 个最大元素也就是第 N - k 个最小元素，因此可以用第 k 小算法来解决本问题。\n\n首先，我们选择一个枢轴，并在线性时间内定义其在排序数组中的位置。这可以通过 划分算法 的帮助来完成。\n\n为了实现划分，沿着数组移动，将每个元素与枢轴进行比较，并将小于枢轴的所有元素移动到枢轴的左侧。\n\n这样，在输出的数组中，枢轴达到其合适位置。所有小于枢轴的元素都在其左侧，所有大于或等于的元素都在其右侧。\n\n这样，数组就被分成了两部分。如果是快速排序算法，会在这里递归地对两部分进行快速排序。\n\n而在这里，由于知道要找的第 N - k 小的元素在哪部分中，我们不需要对两部分都做处理。\n\n最终的算法十分直接了当 :\n\n * 随机选择一个枢轴。\n\n * 使用划分算法将枢轴放在数组中的合适位置 pos。将小于枢轴的元素移到左边，大于等于枢轴的元素移到右边。\n\n * 比较 pos 和 N - k 以决定在哪边继续递归处理。\n\n\n# Java代码\n\nclass Solution {\n    public int findKthLargest(int[] nums, int k) {\n        int len = nums.length;\n        if (len == 1) {\n            return nums[0];\n        }\n        if (len <= 2) {\n            Arrays.sort(nums);\n            return nums[len - k];\n        }\n        Queue<Integer> queue = new PriorityQueue<>((v1,v2)->v2-v1);\n        for (int i = 0; i < len; i++) {\n            queue.add(nums[i]);\n        }\n        int i=0;\n        while (!queue.isEmpty()&&i<k-1){\n            queue.poll();\n            i++;\n        }\n        return queue.poll();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# Python代码\n\nclass Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        nums.sort(reverse=True)\n        return nums[k-1]\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n\n# Java代码2\n\nclass Solution {\n    int[] nums;\n\n    public void swap(int a, int b) {\n        int tmp = this.nums[a];\n        this.nums[a] = this.nums[b];\n        this.nums[b] = tmp;\n    }\n\n\n    public int partition(int left, int right, int pivot_index) {\n        // 优化之后的快排，比枢轴元素大的理论应该放右边，但右边这部分甚至不需要排序\n        // 只需要找到N-k个位置就可以了\n        int pivot = this.nums[pivot_index];\n        // 1. 移动枢轴到最右\n        swap(pivot_index, right);\n        int store_index = left;\n\n        // 2. 移动所有小的元素到枢轴左边\n        for (int i = left; i <= right; i++) {\n            if (this.nums[i] < pivot) {\n                swap(store_index, i);\n                store_index++;\n            }\n        }\n\n        // 3. 还原枢轴到最终位置，左边的元素全部比他小\n        swap(store_index, right);\n\n        return store_index;\n    }\n\n    public int quickselect(int left, int right, int k_smallest) {\n        if (left == right) // 如果list只包含一个元素\n            return this.nums[left];  // 则返回这个元素\n\n        // 选择一个随机的枢轴\n        Random random_num = new Random();\n        int pivot_index = left + random_num.nextInt(right - left);\n\n        pivot_index = partition(left, right, pivot_index);\n\n        // 枢轴在N-k小的位置上，比较pos和N-k\n        if (k_smallest == pivot_index)\n            return this.nums[k_smallest];\n            // 左递归\n        else if (k_smallest < pivot_index)\n            return quickselect(left, pivot_index - 1, k_smallest);\n        // 右递归\n        return quickselect(pivot_index + 1, right, k_smallest);\n    }\n\n    public int findKthLargest(int[] nums, int k) {\n        this.nums = nums;\n        int size = nums.length;\n        // 第k个最大的元素，也就是第N-k个最小的元素\n        return quickselect(0, size - 1, size - k);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n",normalizedContent:"# leetcode-215-数组中的第k个最大元素\n\n在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。\n\n示例 1:\n\n输入: [3,2,1,5,6,4] 和 k = 2\n输出: 5\n\n\n1\n2\n\n1\n2\n\n\n示例2：\n\n输入: [3,2,3,1,2,4,5,5,6] 和 k = 4\n输出: 4\n\n\n1\n2\n\n1\n2\n\n\n说明:\n\n你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。\n\n\n# 解题思路\n\n方法1、优先队列：\n\n首先想到的是给数组进行排序，排序之后就很容易找到第k个最大的元素\n\n那么有没有不排序的方法，自然就会想到建立堆来进行操作\n\n我们可以建立一个大顶堆，最大的数在建堆的过程中排最上面，一次遍历就能完成数组从大到小的构建\n\n寻找排序之后的第k个最大的元素，也就是寻找大顶堆的正序第k个元素\n\n之后一直弹出到k-1为止，下一个位置就是第k个最大的元素\n\n方法2、暴力破解：\n\n排序之后，倒置一下，第k-1个位置就是第k个最大的元素，不倒置就是nums.length-k个位置\n\n方法3、快速选择：\n\n摘自leetcode官方题解\n\n就像快速排序那样，本算法也是 tony hoare 发明的，因此也被称为 hoare选择算法。\n\n本方法大致上与快速排序相同。简便起见，注意到第 k 个最大元素也就是第 n - k 个最小元素，因此可以用第 k 小算法来解决本问题。\n\n首先，我们选择一个枢轴，并在线性时间内定义其在排序数组中的位置。这可以通过 划分算法 的帮助来完成。\n\n为了实现划分，沿着数组移动，将每个元素与枢轴进行比较，并将小于枢轴的所有元素移动到枢轴的左侧。\n\n这样，在输出的数组中，枢轴达到其合适位置。所有小于枢轴的元素都在其左侧，所有大于或等于的元素都在其右侧。\n\n这样，数组就被分成了两部分。如果是快速排序算法，会在这里递归地对两部分进行快速排序。\n\n而在这里，由于知道要找的第 n - k 小的元素在哪部分中，我们不需要对两部分都做处理。\n\n最终的算法十分直接了当 :\n\n * 随机选择一个枢轴。\n\n * 使用划分算法将枢轴放在数组中的合适位置 pos。将小于枢轴的元素移到左边，大于等于枢轴的元素移到右边。\n\n * 比较 pos 和 n - k 以决定在哪边继续递归处理。\n\n\n# java代码\n\nclass solution {\n    public int findkthlargest(int[] nums, int k) {\n        int len = nums.length;\n        if (len == 1) {\n            return nums[0];\n        }\n        if (len <= 2) {\n            arrays.sort(nums);\n            return nums[len - k];\n        }\n        queue<integer> queue = new priorityqueue<>((v1,v2)->v2-v1);\n        for (int i = 0; i < len; i++) {\n            queue.add(nums[i]);\n        }\n        int i=0;\n        while (!queue.isempty()&&i<k-1){\n            queue.poll();\n            i++;\n        }\n        return queue.poll();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# python代码\n\nclass solution:\n    def findkthlargest(self, nums: list[int], k: int) -> int:\n        nums.sort(reverse=true)\n        return nums[k-1]\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n\n# java代码2\n\nclass solution {\n    int[] nums;\n\n    public void swap(int a, int b) {\n        int tmp = this.nums[a];\n        this.nums[a] = this.nums[b];\n        this.nums[b] = tmp;\n    }\n\n\n    public int partition(int left, int right, int pivot_index) {\n        // 优化之后的快排，比枢轴元素大的理论应该放右边，但右边这部分甚至不需要排序\n        // 只需要找到n-k个位置就可以了\n        int pivot = this.nums[pivot_index];\n        // 1. 移动枢轴到最右\n        swap(pivot_index, right);\n        int store_index = left;\n\n        // 2. 移动所有小的元素到枢轴左边\n        for (int i = left; i <= right; i++) {\n            if (this.nums[i] < pivot) {\n                swap(store_index, i);\n                store_index++;\n            }\n        }\n\n        // 3. 还原枢轴到最终位置，左边的元素全部比他小\n        swap(store_index, right);\n\n        return store_index;\n    }\n\n    public int quickselect(int left, int right, int k_smallest) {\n        if (left == right) // 如果list只包含一个元素\n            return this.nums[left];  // 则返回这个元素\n\n        // 选择一个随机的枢轴\n        random random_num = new random();\n        int pivot_index = left + random_num.nextint(right - left);\n\n        pivot_index = partition(left, right, pivot_index);\n\n        // 枢轴在n-k小的位置上，比较pos和n-k\n        if (k_smallest == pivot_index)\n            return this.nums[k_smallest];\n            // 左递归\n        else if (k_smallest < pivot_index)\n            return quickselect(left, pivot_index - 1, k_smallest);\n        // 右递归\n        return quickselect(pivot_index + 1, right, k_smallest);\n    }\n\n    public int findkthlargest(int[] nums, int k) {\n        this.nums = nums;\n        int size = nums.length;\n        // 第k个最大的元素，也就是第n-k个最小的元素\n        return quickselect(0, size - 1, size - k);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-221-最大正方形",frontmatter:{title:"LeetCode-221-最大正方形",date:"2020-08-11T11:22:30.000Z",description:"最大正方形",tags:["矩阵","DP","Java","Medium"],keywords:"矩阵,DP,Java,Medium,LeetCode",permalink:"/pages/3b7ec6/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/64.LeetCode-221-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2.html",relativePath:"06.算法/02.LeetCode/64.LeetCode-221-最大正方形.md",key:"v-5989d2b3",path:"/pages/3b7ec6/",headers:[{level:2,title:"LeetCode-221-最大正方形",slug:"leetcode-221-最大正方形",normalizedTitle:"leetcode-221-最大正方形",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:165},{level:3,title:"Java代码1",slug:"java代码1",normalizedTitle:"java代码1",charIndex:800},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:2588}],headersStr:"LeetCode-221-最大正方形 解题思路 Java代码1 Java代码2",content:"# LeetCode-221-最大正方形\n\n在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。\n\n示例1：\n\n输入: \n\n1 0 1 0 0\n1 0 1 1 1\n1 1 1 1 1\n1 0 0 1 0\n\n输出: 4\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 解题思路\n\n方法1、暴力破解：\n\n引用链接https://leetcode-cn.com/problems/maximal-square/solution/zui-da-zheng-fang-xing-by-leetcode-solution/\n\n暴力法是最简单直观的做法，具体做法如下：\n\n * 遍历矩阵中的每个元素，每次遇到 1，则将该元素作为正方形的左上角；\n\n * 确定正方形的左上角后，根据左上角所在的行和列计算可能的最大正方形的边长（正方形的范围不能超出矩阵的行数和列数），在该边长范围内寻找只包含 1 的最大正方形；\n\n * 每次在下方新增一行以及在右方新增一列，判断新增的行和列是否满足所有元素都是 1。\n\n方法2、动态规划：\n\n * 状态dp[i][j]表示以第i行第j列为右下角所能构成的最大正方形边长\n\n则当i==0或者j==0，最大正方形边长始终为1，则dp[i][j]=1\n\n右下角的正方形的最大边长，最多比它的上方，左方，左上方为右下角的正方形边长+1\n\n最好的情况是这三个方向的正方形大小都一样，这样加上右下角这个点就可以构成更大的正方形。但是如果其中某一个方向形成的正方形大小不一样，合起来就会缺少某个点，这时候的正方形大小只能取3个正方形中，最小的正方形边长+1了。\n\n * 状态转移方程为：dp[i][j] = Math.min(dp[i-1][j-1],Math.min(dp[i-1][j],dp[i][j-1]))+1\n\n\n# Java代码1\n\nint maxSide = 0;\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\n            return maxSide;\n        }\n        int rows = matrix.length, columns = matrix[0].length;\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < columns; j++) {\n                if (matrix[i][j] == '1') {\n                    // 遇到一个 1 作为正方形的左上角\n                    maxSide = Math.max(maxSide, 1);\n                    // 计算可能的最大正方形边长\n                    int currentMaxSide = Math.min(rows - i, columns - j);\n                    // 遍历可能的最大正方形内的每个元素\n                    for (int k = 1; k < currentMaxSide; k++) {\n                        // 判断新增的一行一列是否均为 1\n                        // 先判断对角线是否为0\n                        boolean flag = true;\n                        if (matrix[i + k][j + k] == '0') {\n                            break;\n                        }\n                        // 再判断左上角点的右边和下边是否为0\n                        for (int m = 0; m < k; m++) {\n                            if (matrix[i + k][j + m] == '0' || matrix[i + m][j + k] == '0') {\n                                flag = false;\n                                break;\n                            }\n                        }\n                        // 如果flag仍然为true则说明矩阵中全部是1，更新最大边长\n                        if (flag) {\n                            maxSide = Math.max(maxSide, k + 1);\n                        } else {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        return maxSide * maxSide;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# Java代码2\n\nclass Solution {\n    public int maximalSquare(char[][] matrix) {\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\n            return 0;\n        }\n        int row = matrix.length;\n        int col = matrix[0].length;\n        int matLen = 0;\n        int[][] dp = new int[row][col];\n        for(int i=0;i<row;i++){\n            for(int j=0;j<col;j++){\n                if (matrix[i][j] == '1') {\n                    if(i==0||j==0){\n                        dp[i][j] = 1;\n                    }else{\n                        dp[i][j] = Math.min(dp[i-1][j-1],Math.min(dp[i-1][j],dp[i][j-1]))+1;\n                    }\n                    matLen = Math.max(dp[i][j],matLen);\n                }\n            }\n        }\n        return matLen*matLen;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n",normalizedContent:"# leetcode-221-最大正方形\n\n在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。\n\n示例1：\n\n输入: \n\n1 0 1 0 0\n1 0 1 1 1\n1 1 1 1 1\n1 0 0 1 0\n\n输出: 4\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 解题思路\n\n方法1、暴力破解：\n\n引用链接https://leetcode-cn.com/problems/maximal-square/solution/zui-da-zheng-fang-xing-by-leetcode-solution/\n\n暴力法是最简单直观的做法，具体做法如下：\n\n * 遍历矩阵中的每个元素，每次遇到 1，则将该元素作为正方形的左上角；\n\n * 确定正方形的左上角后，根据左上角所在的行和列计算可能的最大正方形的边长（正方形的范围不能超出矩阵的行数和列数），在该边长范围内寻找只包含 1 的最大正方形；\n\n * 每次在下方新增一行以及在右方新增一列，判断新增的行和列是否满足所有元素都是 1。\n\n方法2、动态规划：\n\n * 状态dp[i][j]表示以第i行第j列为右下角所能构成的最大正方形边长\n\n则当i==0或者j==0，最大正方形边长始终为1，则dp[i][j]=1\n\n右下角的正方形的最大边长，最多比它的上方，左方，左上方为右下角的正方形边长+1\n\n最好的情况是这三个方向的正方形大小都一样，这样加上右下角这个点就可以构成更大的正方形。但是如果其中某一个方向形成的正方形大小不一样，合起来就会缺少某个点，这时候的正方形大小只能取3个正方形中，最小的正方形边长+1了。\n\n * 状态转移方程为：dp[i][j] = math.min(dp[i-1][j-1],math.min(dp[i-1][j],dp[i][j-1]))+1\n\n\n# java代码1\n\nint maxside = 0;\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\n            return maxside;\n        }\n        int rows = matrix.length, columns = matrix[0].length;\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < columns; j++) {\n                if (matrix[i][j] == '1') {\n                    // 遇到一个 1 作为正方形的左上角\n                    maxside = math.max(maxside, 1);\n                    // 计算可能的最大正方形边长\n                    int currentmaxside = math.min(rows - i, columns - j);\n                    // 遍历可能的最大正方形内的每个元素\n                    for (int k = 1; k < currentmaxside; k++) {\n                        // 判断新增的一行一列是否均为 1\n                        // 先判断对角线是否为0\n                        boolean flag = true;\n                        if (matrix[i + k][j + k] == '0') {\n                            break;\n                        }\n                        // 再判断左上角点的右边和下边是否为0\n                        for (int m = 0; m < k; m++) {\n                            if (matrix[i + k][j + m] == '0' || matrix[i + m][j + k] == '0') {\n                                flag = false;\n                                break;\n                            }\n                        }\n                        // 如果flag仍然为true则说明矩阵中全部是1，更新最大边长\n                        if (flag) {\n                            maxside = math.max(maxside, k + 1);\n                        } else {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        return maxside * maxside;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# java代码2\n\nclass solution {\n    public int maximalsquare(char[][] matrix) {\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\n            return 0;\n        }\n        int row = matrix.length;\n        int col = matrix[0].length;\n        int matlen = 0;\n        int[][] dp = new int[row][col];\n        for(int i=0;i<row;i++){\n            for(int j=0;j<col;j++){\n                if (matrix[i][j] == '1') {\n                    if(i==0||j==0){\n                        dp[i][j] = 1;\n                    }else{\n                        dp[i][j] = math.min(dp[i-1][j-1],math.min(dp[i-1][j],dp[i][j-1]))+1;\n                    }\n                    matlen = math.max(dp[i][j],matlen);\n                }\n            }\n        }\n        return matlen*matlen;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题24-反转链表",frontmatter:{title:"LeetCode-面试题24-反转链表",date:"2020-04-19T17:44:28.000Z",description:"反转链表",tags:["链表","Python","Java","Easy","剑指Offer"],keywords:"链表,Java,Python,Easy,剑指Offer",permalink:"/pages/2dfb9f/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/21.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9824-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.html",relativePath:"06.算法/01.剑指Offer/21.LeetCode-面试题24-反转链表.md",key:"v-1c9f13f8",path:"/pages/2dfb9f/",headers:[{level:2,title:"LeetCode-面试题24-反转链表",slug:"leetcode-面试题24-反转链表",normalizedTitle:"leetcode-面试题24-反转链表",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:154},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:262},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:916}],headersStr:"LeetCode-面试题24-反转链表 解题思路 Java代码 Python代码",content:"# LeetCode-面试题24-反转链表\n\n定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。\n\n示例：\n\n输入: 1->2->3->4->5->NULL\n输出: 5->4->3->2->1->NULL\n\n\n1\n2\n\n1\n2\n\n\n限制：\n\n0 <= 节点个数 <= 5000\n\n\n# 解题思路\n\n总共需要3个指针，一个指向当前节点，一个指向前一个节点，一个指向后一个节点\n\n局部反转，将当前节点的后一个节点保存在temp指针里，改变cur指向前一个位置pre，然后向后移动一位pre和cur\n\n\n# Java代码\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        if(head==null||head.next==null)\n            return head;\n        ListNode pre = null;\n        ListNode cur = head;\n        while(cur!=null){\n            ListNode temp = cur.next;\n            cur.next = pre;\n            pre = cur;\n            cur = temp;\n        }\n        return pre;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# Python代码\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def reverseList(self, head: ListNode) -> ListNode:\n        if not head or not head.next:\n            return head\n        pre , cur = None,head\n        while cur:\n            temp = cur.next\n            cur.next = pre\n            pre = cur\n            cur = temp\n        return pre\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n",normalizedContent:"# leetcode-面试题24-反转链表\n\n定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。\n\n示例：\n\n输入: 1->2->3->4->5->null\n输出: 5->4->3->2->1->null\n\n\n1\n2\n\n1\n2\n\n\n限制：\n\n0 <= 节点个数 <= 5000\n\n\n# 解题思路\n\n总共需要3个指针，一个指向当前节点，一个指向前一个节点，一个指向后一个节点\n\n局部反转，将当前节点的后一个节点保存在temp指针里，改变cur指向前一个位置pre，然后向后移动一位pre和cur\n\n\n# java代码\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode(int x) { val = x; }\n * }\n */\nclass solution {\n    public listnode reverselist(listnode head) {\n        if(head==null||head.next==null)\n            return head;\n        listnode pre = null;\n        listnode cur = head;\n        while(cur!=null){\n            listnode temp = cur.next;\n            cur.next = pre;\n            pre = cur;\n            cur = temp;\n        }\n        return pre;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# python代码\n\n# definition for singly-linked list.\n# class listnode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = none\n\nclass solution:\n    def reverselist(self, head: listnode) -> listnode:\n        if not head or not head.next:\n            return head\n        pre , cur = none,head\n        while cur:\n            temp = cur.next\n            cur.next = pre\n            pre = cur\n            cur = temp\n        return pre\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-226-翻转二叉树",frontmatter:{title:"LeetCode-226-翻转二叉树",date:"2020-07-10T11:11:30.000Z",description:"翻转二叉树",tags:["树","Java","DFS","Easy"],keywords:"树,Java,DFS,Easy,LeetCode",permalink:"/pages/2bee97/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/65.LeetCode-226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.html",relativePath:"06.算法/02.LeetCode/65.LeetCode-226-翻转二叉树.md",key:"v-34a7b1f8",path:"/pages/2bee97/",headers:[{level:2,title:"LeetCode-226-翻转二叉树",slug:"leetcode-226-翻转二叉树",normalizedTitle:"leetcode-226-翻转二叉树",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:299},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:615},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:1371}],headersStr:"LeetCode-226-翻转二叉树 解题思路 Java代码 Java代码2",content:"# LeetCode-226-翻转二叉树\n\n翻转一棵二叉树。\n\n示例1：\n\n输入：\n\n     4\n   /   \\\n  2     7\n / \\   / \\\n1   3 6   9\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n输出：\n\n     4\n   /   \\\n  7     2\n / \\   / \\\n9   6 3   1\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n备注: 这个问题是受到 Max Howell 的 原问题 启发的 ：\n\n谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。\n\n\n# 解题思路\n\n方法1、DFS递归：\n\n当根节点不为空的时候，交换他的左右子节点\n\n当左子节点不为空时，继续往左子树递归遍历，进行下一层的交换\n\n当右子节点不为空时，继续往右子树递归遍历，进行下一层的交换\n\n方法2、迭代：\n\n这个方法的思路就是，我们需要交换树中所有节点的左孩子和右孩子。\n\n因此可以创一个队列来存储所有左孩子和右孩子还没有被交换过的节点。\n\n开始的时候，只有根节点在这个队列里面。\n\n只要这个队列不空，就一直从队列中出队节点，然后互换这个节点的左右孩子节点，接着再把孩子节点入队到队列，对于其中的空节点不需要加入队列。\n\n最终队列一定会空，这时候所有节点的孩子节点都被互换过了，直接返回最初的根节点就可以了。\n\n\n# Java代码\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode invertTree(TreeNode root) {\n        if(root==null) return root;\n        if(root.left==null&&root.right==null) return root;\n        TreeNode temp = root.left;\n        root.left = root.right;\n        root.right = temp;\n        if(root.left!=null){\n            invertTree(root.left);\n        }\n        if(root.right!=null){\n            invertTree(root.right);\n        }\n        return root;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# Java代码2\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode invertTree(TreeNode root) {\n        if(root==null) return root;\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.add(root);\n        while(!queue.isEmpty()){\n            TreeNode node = queue.poll();\n            TreeNode temp = node.left;\n            node.left = node.right;\n            node.right = temp;\n            if(node.left!=null) queue.add(node.left);\n            if(node.right!=null) queue.add(node.right);\n        }\n        return root;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n",normalizedContent:"# leetcode-226-翻转二叉树\n\n翻转一棵二叉树。\n\n示例1：\n\n输入：\n\n     4\n   /   \\\n  2     7\n / \\   / \\\n1   3 6   9\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n输出：\n\n     4\n   /   \\\n  7     2\n / \\   / \\\n9   6 3   1\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n备注: 这个问题是受到 max howell 的 原问题 启发的 ：\n\n谷歌：我们90％的工程师使用您编写的软件(homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。\n\n\n# 解题思路\n\n方法1、dfs递归：\n\n当根节点不为空的时候，交换他的左右子节点\n\n当左子节点不为空时，继续往左子树递归遍历，进行下一层的交换\n\n当右子节点不为空时，继续往右子树递归遍历，进行下一层的交换\n\n方法2、迭代：\n\n这个方法的思路就是，我们需要交换树中所有节点的左孩子和右孩子。\n\n因此可以创一个队列来存储所有左孩子和右孩子还没有被交换过的节点。\n\n开始的时候，只有根节点在这个队列里面。\n\n只要这个队列不空，就一直从队列中出队节点，然后互换这个节点的左右孩子节点，接着再把孩子节点入队到队列，对于其中的空节点不需要加入队列。\n\n最终队列一定会空，这时候所有节点的孩子节点都被互换过了，直接返回最初的根节点就可以了。\n\n\n# java代码\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public treenode inverttree(treenode root) {\n        if(root==null) return root;\n        if(root.left==null&&root.right==null) return root;\n        treenode temp = root.left;\n        root.left = root.right;\n        root.right = temp;\n        if(root.left!=null){\n            inverttree(root.left);\n        }\n        if(root.right!=null){\n            inverttree(root.right);\n        }\n        return root;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# java代码2\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public treenode inverttree(treenode root) {\n        if(root==null) return root;\n        queue<treenode> queue = new linkedlist<>();\n        queue.add(root);\n        while(!queue.isempty()){\n            treenode node = queue.poll();\n            treenode temp = node.left;\n            node.left = node.right;\n            node.right = temp;\n            if(node.left!=null) queue.add(node.left);\n            if(node.right!=null) queue.add(node.right);\n        }\n        return root;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-279-完全平方数",frontmatter:{title:"LeetCode-279-完全平方数",date:"2020-08-14T13:38:52.000Z",description:"完全平方数",tags:["数组","DP","Java","Medium"],keywords:"数组,DP,Java,Medium,LeetCode",permalink:"/pages/aa9694/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/67.LeetCode-279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0.html",relativePath:"06.算法/02.LeetCode/67.LeetCode-279-完全平方数.md",key:"v-4177806d",path:"/pages/aa9694/",headers:[{level:2,title:"LeetCode-279-完全平方数",slug:"leetcode-279-完全平方数",normalizedTitle:"leetcode-279-完全平方数",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:213},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:514}],headersStr:"LeetCode-279-完全平方数 解题思路 Java代码",content:"# LeetCode-279-完全平方数\n\n给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。\n\n示例1：\n\n输入: n = 12\n输出: 3 \n解释: 12 = 4 + 4 + 4.\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2：\n\n输入: n = 13\n输出: 2\n解释: 13 = 4 + 9.\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n\n# 解题思路\n\n方法1、动态规划：\n\n详见https://leetcode-cn.com/problems/perfect-squares/solution/hua-jie-suan-fa-279-wan-quan-ping-fang-shu-by-guan/\n\n首先初始化长度为n+1的数组dp，每个位置都为0 如果n为0，则结果为0 对数组进行遍历，下标为i，每次都将当前数字先更新为最大的结果，即dp[i]=i，比如i=4，最坏结果为4=1+1+1+1即为4个数字 动态转移方程为：dp[i] = MIN(dp[i], dp[i - j * j] + 1)，i表示当前数字，j*j表示平方数\n\n\n# Java代码\n\nclass Solution {\n    public int numSquares(int n) {\n        int[] dp = new int[n + 1]; // 默认初始化值都为0\n        for (int i = 1; i <= n; i++) {\n            dp[i] = i; // 最坏的情况就是每次+1\n            for (int j = 1; i - j * j >= 0; j++) { \n                dp[i] = Math.min(dp[i], dp[i - j * j] + 1); // 动态转移方程\n            }\n        }\n        return dp[n];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n",normalizedContent:"# leetcode-279-完全平方数\n\n给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。\n\n示例1：\n\n输入: n = 12\n输出: 3 \n解释: 12 = 4 + 4 + 4.\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2：\n\n输入: n = 13\n输出: 2\n解释: 13 = 4 + 9.\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n\n# 解题思路\n\n方法1、动态规划：\n\n详见https://leetcode-cn.com/problems/perfect-squares/solution/hua-jie-suan-fa-279-wan-quan-ping-fang-shu-by-guan/\n\n首先初始化长度为n+1的数组dp，每个位置都为0 如果n为0，则结果为0 对数组进行遍历，下标为i，每次都将当前数字先更新为最大的结果，即dp[i]=i，比如i=4，最坏结果为4=1+1+1+1即为4个数字 动态转移方程为：dp[i] = min(dp[i], dp[i - j * j] + 1)，i表示当前数字，j*j表示平方数\n\n\n# java代码\n\nclass solution {\n    public int numsquares(int n) {\n        int[] dp = new int[n + 1]; // 默认初始化值都为0\n        for (int i = 1; i <= n; i++) {\n            dp[i] = i; // 最坏的情况就是每次+1\n            for (int j = 1; i - j * j >= 0; j++) { \n                dp[i] = math.min(dp[i], dp[i - j * j] + 1); // 动态转移方程\n            }\n        }\n        return dp[n];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-236-二叉树的最近公共祖先",frontmatter:{title:"LeetCode-236-二叉树的最近公共祖先",date:"2020-08-01T10:01:16.000Z",description:"二叉树的最近公共祖先",tags:["树","Java","Medium"],keywords:"树,Java,Medium,LeetCode",permalink:"/pages/ceb226/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/66.LeetCode-236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html",relativePath:"06.算法/02.LeetCode/66.LeetCode-236-二叉树的最近公共祖先.md",key:"v-97e09750",path:"/pages/ceb226/",headers:[{level:2,title:"LeetCode-236-二叉树的最近公共祖先",slug:"leetcode-236-二叉树的最近公共祖先",normalizedTitle:"leetcode-236-二叉树的最近公共祖先",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:502},{level:3,title:"Java代码1",slug:"java代码1",normalizedTitle:"java代码1",charIndex:1262},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:1930},{level:3,title:"Java代码3",slug:"java代码3",normalizedTitle:"java代码3",charIndex:2507}],headersStr:"LeetCode-236-二叉树的最近公共祖先 解题思路 Java代码1 Java代码2 Java代码3",content:"# LeetCode-236-二叉树的最近公共祖先\n\n给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\n\n百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n\n例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]\n\n示例1：\n\n输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n输出: 3\n解释: 节点 5 和节点 1 的最近公共祖先是节点 3。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2：\n\n输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n输出: 5\n解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n说明:\n\n * 所有节点的值都是唯一的。\n * p、q 为不同节点且均存在于给定的二叉树中。\n\n\n# 解题思路\n\n方法1、递归：\n\n参考链接https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/236-er-cha-shu-de-zui-jin-gong-gong-zu-xian-hou-xu/\n\n根据上述示例可以得知，如果root是p，q的最近公共祖先，则可能的情况有以下3种：\n\n 1. root节点的子树包含p和q两个节点，且p和q分别在root的左、右子树中；\n 2. p=root，且q在root的左/右子树中；\n 3. q=root，且p在root的左/右子树中；\n\n递归解析：\n\n1、终止条件：\n\n 1. 当越过叶节点，则直接返回null；\n 2. 当root等于p,q，则直接返回root；\n\n2、递推工作：\n\n 1. 开启递归左子节点，返回值记为left；\n 2. 开启递归右子节点，返回值记为right；\n\n**3、返回值：**根据left和right，可展开为四种情况；\n\n 1. 当left和right同时为空：说明root的左/右子树中都不包含p,q，返回null；\n 2. 当left和right同时不为空：说明p,q分列在root的左/右子树，因此root为最近公共祖先，返回root；\n 3. 当left为空，right不为空：p,q都不在root的左子树中，直接返回right。具体可分为两种情况：\n    1. p,q其中一个在root的右子树中，此时right指向p(假设为p)；\n    2. p,q两节点都在root的右子树中，此时right指向最近公共祖先节点；\n 4. 当left不为空，right为空：与情况3同理；\n\n观察发现，情况1可合并至3和4内\n\n\n# Java代码1\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if(root==null||root==p||root==q) return root;\n        TreeNode left = lowestCommonAncestor(root.left,p,q);\n        TreeNode right = lowestCommonAncestor(root.right,p,q);\n        if(left==null) return right;\n        if(right==null) return left;\n        return root;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# Java代码2\n\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if(root == null || root == p || root == q) return root;\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\n        if(left == null && right == null) return null; // 1.\n        if(left == null) return right; // 3.\n        if(right == null) return left; // 4.\n        return root; // 2. if(left != null and right != null)\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# Java代码3\n\n逻辑更清晰版本，出处https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/comments/\n\npublic class Solution {//所有的递归的返回值有4种可能性，null、p、q、公共祖先\n    public TreeNode LowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if (root == null) {//当遍历到叶结点后就会返回null\n            return root;\n        }\n        if (root == p || root == q) {//当找到p或者q的是时候就会返回pq\n            return root;/*当然，值得一提的是，如果公共祖先是自己（pq），并不需要寻找另外\n                     一个，我们在执行前序遍历会先找上面的，后找下面的，我们会直接返回公共祖先。*/\n        }\n        TreeNode left = LowestCommonAncestor(root.left, p, q);//返回的结点进行保存，可能是null\n        TreeNode right = LowestCommonAncestor(root.right, p, q);//也可能是pq，还可能是公共祖先\n        if (left != null && right != null) {\n            return root;//如果左右都存在，就说明pq都出现了，这就是，公共祖先，此时不用考虑公共祖先是自己的情况，因为上面已经做过判断了。\n        } else if (left != null) {//否则我们返回已经找到的那个值（存储在left，与right中），p或者q\n            return left;//还有一种可能就是，由下面返回的公共祖先，并将这个值一路返回到最表层\n        } else if (right != null) {\n            return right;\n        }\n        return null;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n",normalizedContent:"# leetcode-236-二叉树的最近公共祖先\n\n给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\n\n百度百科中最近公共祖先的定义为：“对于有根树 t 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n\n例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]\n\n示例1：\n\n输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n输出: 3\n解释: 节点 5 和节点 1 的最近公共祖先是节点 3。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2：\n\n输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n输出: 5\n解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n说明:\n\n * 所有节点的值都是唯一的。\n * p、q 为不同节点且均存在于给定的二叉树中。\n\n\n# 解题思路\n\n方法1、递归：\n\n参考链接https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/236-er-cha-shu-de-zui-jin-gong-gong-zu-xian-hou-xu/\n\n根据上述示例可以得知，如果root是p，q的最近公共祖先，则可能的情况有以下3种：\n\n 1. root节点的子树包含p和q两个节点，且p和q分别在root的左、右子树中；\n 2. p=root，且q在root的左/右子树中；\n 3. q=root，且p在root的左/右子树中；\n\n递归解析：\n\n1、终止条件：\n\n 1. 当越过叶节点，则直接返回null；\n 2. 当root等于p,q，则直接返回root；\n\n2、递推工作：\n\n 1. 开启递归左子节点，返回值记为left；\n 2. 开启递归右子节点，返回值记为right；\n\n**3、返回值：**根据left和right，可展开为四种情况；\n\n 1. 当left和right同时为空：说明root的左/右子树中都不包含p,q，返回null；\n 2. 当left和right同时不为空：说明p,q分列在root的左/右子树，因此root为最近公共祖先，返回root；\n 3. 当left为空，right不为空：p,q都不在root的左子树中，直接返回right。具体可分为两种情况：\n    1. p,q其中一个在root的右子树中，此时right指向p(假设为p)；\n    2. p,q两节点都在root的右子树中，此时right指向最近公共祖先节点；\n 4. 当left不为空，right为空：与情况3同理；\n\n观察发现，情况1可合并至3和4内\n\n\n# java代码1\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public treenode lowestcommonancestor(treenode root, treenode p, treenode q) {\n        if(root==null||root==p||root==q) return root;\n        treenode left = lowestcommonancestor(root.left,p,q);\n        treenode right = lowestcommonancestor(root.right,p,q);\n        if(left==null) return right;\n        if(right==null) return left;\n        return root;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# java代码2\n\nclass solution {\n    public treenode lowestcommonancestor(treenode root, treenode p, treenode q) {\n        if(root == null || root == p || root == q) return root;\n        treenode left = lowestcommonancestor(root.left, p, q);\n        treenode right = lowestcommonancestor(root.right, p, q);\n        if(left == null && right == null) return null; // 1.\n        if(left == null) return right; // 3.\n        if(right == null) return left; // 4.\n        return root; // 2. if(left != null and right != null)\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# java代码3\n\n逻辑更清晰版本，出处https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/comments/\n\npublic class solution {//所有的递归的返回值有4种可能性，null、p、q、公共祖先\n    public treenode lowestcommonancestor(treenode root, treenode p, treenode q) {\n        if (root == null) {//当遍历到叶结点后就会返回null\n            return root;\n        }\n        if (root == p || root == q) {//当找到p或者q的是时候就会返回pq\n            return root;/*当然，值得一提的是，如果公共祖先是自己（pq），并不需要寻找另外\n                     一个，我们在执行前序遍历会先找上面的，后找下面的，我们会直接返回公共祖先。*/\n        }\n        treenode left = lowestcommonancestor(root.left, p, q);//返回的结点进行保存，可能是null\n        treenode right = lowestcommonancestor(root.right, p, q);//也可能是pq，还可能是公共祖先\n        if (left != null && right != null) {\n            return root;//如果左右都存在，就说明pq都出现了，这就是，公共祖先，此时不用考虑公共祖先是自己的情况，因为上面已经做过判断了。\n        } else if (left != null) {//否则我们返回已经找到的那个值（存储在left，与right中），p或者q\n            return left;//还有一种可能就是，由下面返回的公共祖先，并将这个值一路返回到最表层\n        } else if (right != null) {\n            return right;\n        }\n        return null;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-287-寻找重复数",frontmatter:{title:"LeetCode-287-寻找重复数",date:"2020-07-13T11:02:55.000Z",description:"寻找重复数",tags:["Java","数组","Medium"],keywords:"Java,数组,Medium,LeetCode",permalink:"/pages/d6c0fb/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/68.LeetCode-287-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0.html",relativePath:"06.算法/02.LeetCode/68.LeetCode-287-寻找重复数.md",key:"v-03423148",path:"/pages/d6c0fb/",headers:[{level:2,title:"LeetCode-287-寻找重复数",slug:"leetcode-287-寻找重复数",normalizedTitle:"leetcode-287-寻找重复数",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:296},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:600}],headersStr:"LeetCode-287-寻找重复数 解题思路 Java代码",content:"# LeetCode-287-寻找重复数\n\n给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。\n\n示例1：\n\n输入: [1,3,4,2,2]\n输出: 2\n\n\n1\n2\n\n1\n2\n\n\n示例2：\n\n输入: [3,1,3,4,2]\n输出: 3\n\n\n1\n2\n\n1\n2\n\n\n说明：\n\n 1. 不能更改原数组（假设数组是只读的）。\n 2. 只能使用额外的 O(1) 的空间。\n 3. 时间复杂度小于 O(n2) 。\n 4. 数组中只有一个重复的数字，但它可能不止重复出现一次。\n\n\n# 解题思路\n\n方法1、二分查找：\n\n我们知道二分查找算法要求数组是有序的，而本题中数组不是有序的，但有数字都在1到n的这个条件。而1到n本身就是一个有序序列，于是可以使用二分查找进行判断。\n\nmid = (left+right)/2，判断答案是在[left,mid]中，还是在[mid+1,right]中\n\n我们只需要一次遍历数组，统计原数组中小于等于mid的个数，记为count\n\n当count<=mid时，说明[left,mid]范围中没有重复的数字，答案应该在[mid+1,right]中\n\n反之，当count>mid时，说明[left,mid]中有重复的数字，将right变为mid再进行查找\n\n\n# Java代码\n\nclass Solution {\n    public int findDuplicate(int[] nums) {\n        int left = 0;\n        int right = nums.length;\n        while(left<right){\n            int mid = (left+right)>>1;\n            int count = 0;\n            for(int num : nums){\n                if(num<=mid){\n                    count++;\n                }\n            }\n            if(count<=mid){\n                left = mid+1;\n            }else{\n                right = mid;\n            }\n        }\n        return right;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n",normalizedContent:"# leetcode-287-寻找重复数\n\n给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。\n\n示例1：\n\n输入: [1,3,4,2,2]\n输出: 2\n\n\n1\n2\n\n1\n2\n\n\n示例2：\n\n输入: [3,1,3,4,2]\n输出: 3\n\n\n1\n2\n\n1\n2\n\n\n说明：\n\n 1. 不能更改原数组（假设数组是只读的）。\n 2. 只能使用额外的 o(1) 的空间。\n 3. 时间复杂度小于 o(n2) 。\n 4. 数组中只有一个重复的数字，但它可能不止重复出现一次。\n\n\n# 解题思路\n\n方法1、二分查找：\n\n我们知道二分查找算法要求数组是有序的，而本题中数组不是有序的，但有数字都在1到n的这个条件。而1到n本身就是一个有序序列，于是可以使用二分查找进行判断。\n\nmid = (left+right)/2，判断答案是在[left,mid]中，还是在[mid+1,right]中\n\n我们只需要一次遍历数组，统计原数组中小于等于mid的个数，记为count\n\n当count<=mid时，说明[left,mid]范围中没有重复的数字，答案应该在[mid+1,right]中\n\n反之，当count>mid时，说明[left,mid]中有重复的数字，将right变为mid再进行查找\n\n\n# java代码\n\nclass solution {\n    public int findduplicate(int[] nums) {\n        int left = 0;\n        int right = nums.length;\n        while(left<right){\n            int mid = (left+right)>>1;\n            int count = 0;\n            for(int num : nums){\n                if(num<=mid){\n                    count++;\n                }\n            }\n            if(count<=mid){\n                left = mid+1;\n            }else{\n                right = mid;\n            }\n        }\n        return right;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-300-最长上升子序列",frontmatter:{title:"LeetCode-300-最长上升子序列",date:"2020-06-09T20:02:29.000Z",description:"最长上升子序列",tags:["DP","数组","Java","Medium","LeetCode"],keywords:"DP,数组,Java,Medium,LeetCode",permalink:"/pages/444ab2/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/69.LeetCode-300-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97.html",relativePath:"06.算法/02.LeetCode/69.LeetCode-300-最长上升子序列.md",key:"v-490137f5",path:"/pages/444ab2/",headers:[{level:2,title:"LeetCode-300-最长上升子序列",slug:"leetcode-300-最长上升子序列",normalizedTitle:"leetcode-300-最长上升子序列",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:240},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:622},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:1239}],headersStr:"LeetCode-300-最长上升子序列 解题思路 Java代码 Java代码2",content:"# LeetCode-300-最长上升子序列\n\n给定一个无序的整数数组，找到其中最长上升子序列的长度。\n\n示例 1:\n\n输入: [10,9,2,5,3,7,101,18]\n输出: 4 \n解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n说明:\n\n可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。 你算法的时间复杂度应该为 O(n2) 。 进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?\n\n\n# 解题思路\n\n动态规划：\n\n子序列严格上升，不存在中间数字相等的情况，且不要求序列连续\n\n状态定义为：第i个数字为结尾的最长上升子序列的长度，自身也需要统计在其中，每个位置的初始化长度为1\n\n状态转移方程：遍历到索引是i的数字的时候，需要看i前面的i-1个数字是否小于当前的nums[i]的值，如果小于则可以构成一个更长的子序列，但i-1个数字中比nums[i]小的数字有多个，所以dp[i]位置的子序列长度，应该是前面i-1个数字的最长的那个加上1，即dp[i] = Math.max(dp[j]+1,dp[i])\n\n外层循环到len，控制dp[i]每个位置的初始化为1\n\n内层循环到i，查看从数组开头到i-1个数，最长的子序列分别是多少\n\n最后dp数组中的最大值，就是最长上升子序列的长度\n\n贪心+二分查找：\n\n实在是想不到这种解法....原题题解出处\n\n\n# Java代码\n\nclass Solution {\n    public int lengthOfLIS(int[] nums) {\n        int len = nums.length;\n        if(len<2) return len;\n        int[] dp = new int[len];\n        int res = 1;\n        for(int i=0;i<len;i++){\n            dp[i]=1;\n            // 看前面i-1个数字\n            for(int j=0;j<i;j++){\n                if(nums[j]<nums[i]){ //可以构成更长的子序列，所以dp[j]+1\n                    dp[i] = Math.max(dp[j]+1,dp[i]);\n                }\n            }\n            if(res<dp[i]) res=dp[i];\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# Java代码2\n\nclass Solution {\n    public int lengthOfLIS(int[] nums) {\n        int len = nums.length;\n        if(len<2) return len;\n        int[] dp = new int[nums.length];\n        int maxL = 0;\n        for(int num:nums){\n            int low = 0;\n            int high = maxL;\n            while(low<high){\n                int mid = low+(high-low)/2;\n                if(dp[mid]<num){\n                    low = mid+1;\n                }\n                else{\n                    high = mid;\n                }\n            }\n            dp[low]=num;\n            if(low==maxL)\n                maxL++;\n        }\n        return maxL;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n",normalizedContent:"# leetcode-300-最长上升子序列\n\n给定一个无序的整数数组，找到其中最长上升子序列的长度。\n\n示例 1:\n\n输入: [10,9,2,5,3,7,101,18]\n输出: 4 \n解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n说明:\n\n可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。 你算法的时间复杂度应该为 o(n2) 。 进阶: 你能将算法的时间复杂度降低到 o(n log n) 吗?\n\n\n# 解题思路\n\n动态规划：\n\n子序列严格上升，不存在中间数字相等的情况，且不要求序列连续\n\n状态定义为：第i个数字为结尾的最长上升子序列的长度，自身也需要统计在其中，每个位置的初始化长度为1\n\n状态转移方程：遍历到索引是i的数字的时候，需要看i前面的i-1个数字是否小于当前的nums[i]的值，如果小于则可以构成一个更长的子序列，但i-1个数字中比nums[i]小的数字有多个，所以dp[i]位置的子序列长度，应该是前面i-1个数字的最长的那个加上1，即dp[i] = math.max(dp[j]+1,dp[i])\n\n外层循环到len，控制dp[i]每个位置的初始化为1\n\n内层循环到i，查看从数组开头到i-1个数，最长的子序列分别是多少\n\n最后dp数组中的最大值，就是最长上升子序列的长度\n\n贪心+二分查找：\n\n实在是想不到这种解法....原题题解出处\n\n\n# java代码\n\nclass solution {\n    public int lengthoflis(int[] nums) {\n        int len = nums.length;\n        if(len<2) return len;\n        int[] dp = new int[len];\n        int res = 1;\n        for(int i=0;i<len;i++){\n            dp[i]=1;\n            // 看前面i-1个数字\n            for(int j=0;j<i;j++){\n                if(nums[j]<nums[i]){ //可以构成更长的子序列，所以dp[j]+1\n                    dp[i] = math.max(dp[j]+1,dp[i]);\n                }\n            }\n            if(res<dp[i]) res=dp[i];\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# java代码2\n\nclass solution {\n    public int lengthoflis(int[] nums) {\n        int len = nums.length;\n        if(len<2) return len;\n        int[] dp = new int[nums.length];\n        int maxl = 0;\n        for(int num:nums){\n            int low = 0;\n            int high = maxl;\n            while(low<high){\n                int mid = low+(high-low)/2;\n                if(dp[mid]<num){\n                    low = mid+1;\n                }\n                else{\n                    high = mid;\n                }\n            }\n            dp[low]=num;\n            if(low==maxl)\n                maxl++;\n        }\n        return maxl;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-309-最佳买卖股票时机含冷冻期",frontmatter:{title:"LeetCode-309-最佳买卖股票时机含冷冻期",date:"2020-07-08T09:27:07.000Z",description:"最佳买卖股票时机含冷冻期",tags:["数组","Java","DP","Medium"],keywords:"数组,Java,DP,Medium,LeetCode",permalink:"/pages/3b3388/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/70.LeetCode-309-%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F.html",relativePath:"06.算法/02.LeetCode/70.LeetCode-309-最佳买卖股票时机含冷冻期.md",key:"v-6daed7c5",path:"/pages/3b3388/",headers:[{level:2,title:"LeetCode-309-最佳买卖股票时机含冷冻期",slug:"leetcode-309-最佳买卖股票时机含冷冻期",normalizedTitle:"leetcode-309-最佳买卖股票时机含冷冻期",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:265},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:419}],headersStr:"LeetCode-309-最佳买卖股票时机含冷冻期 解题思路 Java代码",content:"# LeetCode-309-最佳买卖股票时机含冷冻期\n\n给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。\n\n设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:\n\n你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。\n\n示例1：\n\n输入: [1,2,3,0,2]\n输出: 3 \n解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n\n# 解题思路\n\n详见链接https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-lab/\n\n\n# Java代码\n\nclass Solution {\n    public int maxProfit(int[] prices) {\n        if(prices == null || prices.length == 0){\n            return 0;\n        }\n        //状态转移图：\n        //       持股               不持股\n        //     ↙-----、   卖出    ↙-----、\n        //    持股-----↑--------→不持股---↑\n        //      |\n        //      |卖\n        //      |出\n        //      ↓\n        //    冷冻期(期间什么都不能干) \n        //\n        int[][] dp = new int[prices.length][3];\n        //dp[i][x]第i天进入x状态（0.不持股，1.持股，2.冷冻期）\n        //不持股\n        dp[0][0] = 0;\n        //持股\n        dp[0][1] = -prices[0];\n        //冷冻期\n        dp[0][2] = 0;\n        for(int i = 1;i < prices.length;i++){\n            //第i天不持股可以从两种状态转移而来，1.第i-1天不持股，今天仍不买股票，保持不持股状态。2.冷冻期结束了，但是今天不买股票。\n            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][2]);\n            //第i天持股可从两种状态转移而来，1.第i-1天不持股(包含昨天是冷冻期或者昨天本身就不持股)，今天买股票。2.第i-1天持股，今天不卖出，保持持股状态。\n            dp[i][1] = Math.max(dp[i - 1][0] - prices[i], dp[i - 1][1]);\n            //只有第i天卖出了股票，第i天才能进入冷冻期。\n            dp[i][2] = dp[i-1][1] + prices[i];\n        }\n        //只有最后一天不持股（不持股状态）或者前一天已经卖掉了（今天为冷冻期）这两种情况手里是拿着钱的，最大值在二者中产生。\n        return Math.max(dp[prices.length - 1][0], dp[prices.length - 1][2]);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n",normalizedContent:"# leetcode-309-最佳买卖股票时机含冷冻期\n\n给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。\n\n设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:\n\n你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。\n\n示例1：\n\n输入: [1,2,3,0,2]\n输出: 3 \n解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n\n# 解题思路\n\n详见链接https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-lab/\n\n\n# java代码\n\nclass solution {\n    public int maxprofit(int[] prices) {\n        if(prices == null || prices.length == 0){\n            return 0;\n        }\n        //状态转移图：\n        //       持股               不持股\n        //     ↙-----、   卖出    ↙-----、\n        //    持股-----↑--------→不持股---↑\n        //      |\n        //      |卖\n        //      |出\n        //      ↓\n        //    冷冻期(期间什么都不能干) \n        //\n        int[][] dp = new int[prices.length][3];\n        //dp[i][x]第i天进入x状态（0.不持股，1.持股，2.冷冻期）\n        //不持股\n        dp[0][0] = 0;\n        //持股\n        dp[0][1] = -prices[0];\n        //冷冻期\n        dp[0][2] = 0;\n        for(int i = 1;i < prices.length;i++){\n            //第i天不持股可以从两种状态转移而来，1.第i-1天不持股，今天仍不买股票，保持不持股状态。2.冷冻期结束了，但是今天不买股票。\n            dp[i][0] = math.max(dp[i-1][0], dp[i-1][2]);\n            //第i天持股可从两种状态转移而来，1.第i-1天不持股(包含昨天是冷冻期或者昨天本身就不持股)，今天买股票。2.第i-1天持股，今天不卖出，保持持股状态。\n            dp[i][1] = math.max(dp[i - 1][0] - prices[i], dp[i - 1][1]);\n            //只有第i天卖出了股票，第i天才能进入冷冻期。\n            dp[i][2] = dp[i-1][1] + prices[i];\n        }\n        //只有最后一天不持股（不持股状态）或者前一天已经卖掉了（今天为冷冻期）这两种情况手里是拿着钱的，最大值在二者中产生。\n        return math.max(dp[prices.length - 1][0], dp[prices.length - 1][2]);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-322-零钱兑换",frontmatter:{title:"LeetCode-322-零钱兑换",date:"2020-08-21T10:00:46.000Z",description:"零钱兑换",tags:["数组","DP","回溯","Java","Medium"],keywords:"数组,DP,回溯,Java,Medium,LeetCode",permalink:"/pages/9868ec/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/71.LeetCode-322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html",relativePath:"06.算法/02.LeetCode/71.LeetCode-322-零钱兑换.md",key:"v-b19b5dd2",path:"/pages/9868ec/",headers:[{level:2,title:"LeetCode-322-零钱兑换",slug:"leetcode-322-零钱兑换",normalizedTitle:"leetcode-322-零钱兑换",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:269},{level:3,title:"Java代码1",slug:"java代码1",normalizedTitle:"java代码1",charIndex:1843},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:3096},{level:3,title:"Java代码3",slug:"java代码3",normalizedTitle:"java代码3",charIndex:3938}],headersStr:"LeetCode-322-零钱兑换 解题思路 Java代码1 Java代码2 Java代码3",content:"# LeetCode-322-零钱兑换\n\n给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。\n\n示例1：\n\n输入: coins = [1, 2, 5], amount = 11\n输出: 3 \n解释: 11 = 5 + 5 + 1\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2：\n\n输入: coins = [2], amount = 3\n输出: -1\n\n\n1\n2\n\n1\n2\n\n\n说明: 你可以认为每种硬币的数量是无限的。\n\n\n# 解题思路\n\n摘自官方题解https://leetcode-cn.com/problems/coin-change/solution/322-ling-qian-dui-huan-by-leetcode-solution/\n\n方法1、回溯：\n\n用S代表总金额，ci是第i枚硬币的面值，xi是面值为ci的硬币数量，由于xi*ci不能超过S，可以得出xi的取值范围[0,S/xi]\n\n一个简单的解决方案是枚举每个硬币数量子集[x0,...,xn-1]。如果满足上述约束条件，计算硬币数量总和并返回所有子集中的最小值\n\nfor循环每一个硬币，选择0个1面值硬币，判断当前选择情况*面值是否小于等于总面值S，进入下层递归选择硬币应该固定1面值，选择2面值，idxCoin+1，总面值应该减去当前选择的硬币个数乘以面值数，即\n\namount - i * coins[idxCoin]，选择0个2面值硬币，进行判断...依次列推。固定某一面值选择数，深度优先穷举后续面值可能的选择数目，且硬币选择数目范围在[0,S/xi]\n\n由于有重复计算，所以回溯的效率并不是很高\n\n方法2、动态规划-自上而下：\n\n利用动态规划，改进上面的指数时间复杂度的解，定义\n\n * F(S)：组成金额S所需的最少硬币数量\n * [c0,...,cn-1]：可选的n枚硬币面额值\n\n这个问题有一个最优的子结构性质，这是解决动态规划问题的关键。最优解可以从其子问题的最优解构造出来。如何将问题分解成子问题？\n\n假设我们知道F(S)，即组成金额S最少的硬币数，最后一枚硬币的面值是C。那么由于问题的最优子结构，转移方程应为：\n\nF(S)=F(S-C)+1\n\n但我们不知道最后一枚硬币的面值是多少，所以我们需要枚举每个硬币面额值c0,c1,c2,...,cn-1并选择其中的最小值。下列递推关系成立：\n\n\n\n在上面的递归树中，可以发现有许多子问题被多次计算。例如，F(1)被计算了13次。为了避免重复的计算，我们将每个子问题的答案存在一个数组中进行记忆化，如果下次还要计算这个问题的值直接从数组中去除返回即可，这样能保证每个子问题最多只被计算一次。\n\n方法3、动态规划-自下而上：\n\n采用自下而上的方式进行思考，仍定义F(i)为组成金额i所需最少的硬币数量，假设在计算F(i)之前，我们已经计算出F(0)-F(i-1)的答案，则F(i)对应的转移方程为\n\n\n\n其中cj代表的是第j枚硬币的面值，即我们枚举最后一枚硬币面额是cj，那么需要从i-cj这个金额的状态F(i-cj)转移过来，再算上枚举的这个硬币数量1的贡献，由于要硬币数量最少，所以F(i)为：前面能转移过来的状态的最小值加上枚举的硬币数量1。\n\n例子1：假设\n\ncoins = [1,2,5],amount=11\n\n\n1\n\n1\n\n\n则，当i==0时无法用硬币组成，为0。当i<0时，忽略F(i)\n\nF(I)    最小硬币数量\nF(0)    0 //金额为0不能由硬币组成\nF(1)    1 //F(1)=min(F(1-1),F(1-2),F(1-5))+1=1\nF(2)    1 //F(2)=min(F(2-1),F(2-2),F(2-5))+1=1\nF(3)    2 //F(3)=min(F(3-1),F(3-2),F(3-5))+1=2\nF(4)    2 //F(4)=min(F(4-1),F(4-2),F(4-5))+1=2\n...     ...\nF(11)   3 //F(11)=min(F(11-1),F(11-2),F(11-5))+1=3\n\n我们可以看到问题的答案是通过子问题的最优解得到的\n\n例子2：假设\n\ncoins = [1,2,3],amount = 6\n\n\n1\n\n1\n\n\n\n\n\n# Java代码1\n\npublic class LeetCode322 {\n    public static void main(String[] args) {\n        int[] coins = new int[]{1, 2, 5};\n        int amount = 11;\n        System.out.println(coinChange(coins, amount));\n    }\n\n    public static int coinChange(int[] coins, int amount) {\n        return coinChanges(0, coins, amount);\n    }\n\n    private static int coinChanges(int idxCoin, int[] coins, int amount) {\n        if (amount == 0)\n            return 0;\n        if (idxCoin < coins.length && amount > 0) {\n            int maxVal = amount / coins[idxCoin];\n            int minCost = Integer.MAX_VALUE;\n            for (int i = 0; i <= maxVal; i++) {\n                if (i * coins[idxCoin] <= amount) {\n                    int res = coinChanges(idxCoin + 1, coins, amount - i * coins[idxCoin]);\n                    // 说明需要更新\n                    if (res != -1) {\n                        minCost = Math.min(minCost, res + i);\n                    }\n                }\n            }\n            return (minCost == Integer.MAX_VALUE) ? -1 : minCost;\n        }\n        return -1;\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# Java代码2\n\nclass Solution {\n    public int coinChange(int[] coins, int amount) {\n        if (amount < 1) return 0;\n        return coinChanges(amount, coins, new int[amount]);\n    }\n\n    private static int coinChanges(int amount, int[] coins, int[] count) {\n        if (amount < 0) return -1;\n        if (amount == 0) return 0;\n        if (count[amount - 1] != 0) return count[amount - 1];\n        int min = Integer.MAX_VALUE;\n        for (int coin : coins) {\n            int res = coinChanges(amount - coin, coins, count);\n            if (res >= 0 && res < min) {\n                min = 1 + res;\n            }\n        }\n        count[amount - 1] = (min == Integer.MAX_VALUE) ? -1 : min;\n        return count[amount - 1];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# Java代码3\n\nimport java.util.Arrays;\n\npublic class LeetCode322_DP {\n    public static void main(String[] args) {\n        int[] coins = new int[]{1, 2, 5};\n        int amount = 11;\n        System.out.println(coinChange(coins, amount));\n    }\n\n    public static int coinChange(int[] coins, int amount) {\n        int max = amount + 1;\n        int[] dp = new int[max];\n        // 因为需要比较最小，所以初始化数组为最大值\n        Arrays.fill(dp, max);\n        // 没有数值为0的硬币\n        dp[0] = 0;\n        // 自底向上\n        for (int i = 1; i <= amount; i++) {\n            // 遍历硬币面值cj\n            for (int j = 0; j < coins.length; j++) {\n                if (coins[j] <= i) {\n                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);\n                }\n            }\n        }\n        return dp[amount] > amount ? -1 : dp[amount];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n",normalizedContent:"# leetcode-322-零钱兑换\n\n给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。\n\n示例1：\n\n输入: coins = [1, 2, 5], amount = 11\n输出: 3 \n解释: 11 = 5 + 5 + 1\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2：\n\n输入: coins = [2], amount = 3\n输出: -1\n\n\n1\n2\n\n1\n2\n\n\n说明: 你可以认为每种硬币的数量是无限的。\n\n\n# 解题思路\n\n摘自官方题解https://leetcode-cn.com/problems/coin-change/solution/322-ling-qian-dui-huan-by-leetcode-solution/\n\n方法1、回溯：\n\n用s代表总金额，ci是第i枚硬币的面值，xi是面值为ci的硬币数量，由于xi*ci不能超过s，可以得出xi的取值范围[0,s/xi]\n\n一个简单的解决方案是枚举每个硬币数量子集[x0,...,xn-1]。如果满足上述约束条件，计算硬币数量总和并返回所有子集中的最小值\n\nfor循环每一个硬币，选择0个1面值硬币，判断当前选择情况*面值是否小于等于总面值s，进入下层递归选择硬币应该固定1面值，选择2面值，idxcoin+1，总面值应该减去当前选择的硬币个数乘以面值数，即\n\namount - i * coins[idxcoin]，选择0个2面值硬币，进行判断...依次列推。固定某一面值选择数，深度优先穷举后续面值可能的选择数目，且硬币选择数目范围在[0,s/xi]\n\n由于有重复计算，所以回溯的效率并不是很高\n\n方法2、动态规划-自上而下：\n\n利用动态规划，改进上面的指数时间复杂度的解，定义\n\n * f(s)：组成金额s所需的最少硬币数量\n * [c0,...,cn-1]：可选的n枚硬币面额值\n\n这个问题有一个最优的子结构性质，这是解决动态规划问题的关键。最优解可以从其子问题的最优解构造出来。如何将问题分解成子问题？\n\n假设我们知道f(s)，即组成金额s最少的硬币数，最后一枚硬币的面值是c。那么由于问题的最优子结构，转移方程应为：\n\nf(s)=f(s-c)+1\n\n但我们不知道最后一枚硬币的面值是多少，所以我们需要枚举每个硬币面额值c0,c1,c2,...,cn-1并选择其中的最小值。下列递推关系成立：\n\n\n\n在上面的递归树中，可以发现有许多子问题被多次计算。例如，f(1)被计算了13次。为了避免重复的计算，我们将每个子问题的答案存在一个数组中进行记忆化，如果下次还要计算这个问题的值直接从数组中去除返回即可，这样能保证每个子问题最多只被计算一次。\n\n方法3、动态规划-自下而上：\n\n采用自下而上的方式进行思考，仍定义f(i)为组成金额i所需最少的硬币数量，假设在计算f(i)之前，我们已经计算出f(0)-f(i-1)的答案，则f(i)对应的转移方程为\n\n\n\n其中cj代表的是第j枚硬币的面值，即我们枚举最后一枚硬币面额是cj，那么需要从i-cj这个金额的状态f(i-cj)转移过来，再算上枚举的这个硬币数量1的贡献，由于要硬币数量最少，所以f(i)为：前面能转移过来的状态的最小值加上枚举的硬币数量1。\n\n例子1：假设\n\ncoins = [1,2,5],amount=11\n\n\n1\n\n1\n\n\n则，当i==0时无法用硬币组成，为0。当i<0时，忽略f(i)\n\nf(i)    最小硬币数量\nf(0)    0 //金额为0不能由硬币组成\nf(1)    1 //f(1)=min(f(1-1),f(1-2),f(1-5))+1=1\nf(2)    1 //f(2)=min(f(2-1),f(2-2),f(2-5))+1=1\nf(3)    2 //f(3)=min(f(3-1),f(3-2),f(3-5))+1=2\nf(4)    2 //f(4)=min(f(4-1),f(4-2),f(4-5))+1=2\n...     ...\nf(11)   3 //f(11)=min(f(11-1),f(11-2),f(11-5))+1=3\n\n我们可以看到问题的答案是通过子问题的最优解得到的\n\n例子2：假设\n\ncoins = [1,2,3],amount = 6\n\n\n1\n\n1\n\n\n\n\n\n# java代码1\n\npublic class leetcode322 {\n    public static void main(string[] args) {\n        int[] coins = new int[]{1, 2, 5};\n        int amount = 11;\n        system.out.println(coinchange(coins, amount));\n    }\n\n    public static int coinchange(int[] coins, int amount) {\n        return coinchanges(0, coins, amount);\n    }\n\n    private static int coinchanges(int idxcoin, int[] coins, int amount) {\n        if (amount == 0)\n            return 0;\n        if (idxcoin < coins.length && amount > 0) {\n            int maxval = amount / coins[idxcoin];\n            int mincost = integer.max_value;\n            for (int i = 0; i <= maxval; i++) {\n                if (i * coins[idxcoin] <= amount) {\n                    int res = coinchanges(idxcoin + 1, coins, amount - i * coins[idxcoin]);\n                    // 说明需要更新\n                    if (res != -1) {\n                        mincost = math.min(mincost, res + i);\n                    }\n                }\n            }\n            return (mincost == integer.max_value) ? -1 : mincost;\n        }\n        return -1;\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# java代码2\n\nclass solution {\n    public int coinchange(int[] coins, int amount) {\n        if (amount < 1) return 0;\n        return coinchanges(amount, coins, new int[amount]);\n    }\n\n    private static int coinchanges(int amount, int[] coins, int[] count) {\n        if (amount < 0) return -1;\n        if (amount == 0) return 0;\n        if (count[amount - 1] != 0) return count[amount - 1];\n        int min = integer.max_value;\n        for (int coin : coins) {\n            int res = coinchanges(amount - coin, coins, count);\n            if (res >= 0 && res < min) {\n                min = 1 + res;\n            }\n        }\n        count[amount - 1] = (min == integer.max_value) ? -1 : min;\n        return count[amount - 1];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# java代码3\n\nimport java.util.arrays;\n\npublic class leetcode322_dp {\n    public static void main(string[] args) {\n        int[] coins = new int[]{1, 2, 5};\n        int amount = 11;\n        system.out.println(coinchange(coins, amount));\n    }\n\n    public static int coinchange(int[] coins, int amount) {\n        int max = amount + 1;\n        int[] dp = new int[max];\n        // 因为需要比较最小，所以初始化数组为最大值\n        arrays.fill(dp, max);\n        // 没有数值为0的硬币\n        dp[0] = 0;\n        // 自底向上\n        for (int i = 1; i <= amount; i++) {\n            // 遍历硬币面值cj\n            for (int j = 0; j < coins.length; j++) {\n                if (coins[j] <= i) {\n                    dp[i] = math.min(dp[i], dp[i - coins[j]] + 1);\n                }\n            }\n        }\n        return dp[amount] > amount ? -1 : dp[amount];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-328-奇偶链表",frontmatter:{title:"LeetCode-328-奇偶链表",date:"2020-06-10T15:14:20.000Z",description:"奇偶链表",tags:["链表","Java","Medium","LeetCode"],keywords:"链表,Java,Medium,LeetCode",permalink:"/pages/74a1b6/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/72.LeetCode-328-%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8.html",relativePath:"06.算法/02.LeetCode/72.LeetCode-328-奇偶链表.md",key:"v-86b57bc6",path:"/pages/74a1b6/",headers:[{level:2,title:"LeetCode-328-奇偶链表",slug:"leetcode-328-奇偶链表",normalizedTitle:"leetcode-328-奇偶链表",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:368},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:699}],headersStr:"LeetCode-328-奇偶链表 解题思路 Java代码",content:"# LeetCode-328-奇偶链表\n\n给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。\n\n请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。\n\n示例 1:\n\n输入: 1->2->3->4->5->NULL\n输出: 1->3->5->2->4->NULL\n\n\n1\n2\n\n1\n2\n\n\n示例2：\n\n输入: 2->1->3->5->6->4->7->NULL \n输出: 2->3->6->7->1->5->4->NULL\n\n\n1\n2\n\n1\n2\n\n\n说明:\n\n * 应当保持奇数节点和偶数节点的相对顺序。\n * 链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。\n\n\n# 解题思路\n\n双指针：\n\n一个指针指向奇数节点，一个指针指向偶数节点\n\n间隔遍历，奇数指针只能指向奇数节点，偶数指针只能指向偶数节点\n\n对于链表长度为奇数时，奇数指针one能够指向之后一个数字，此时偶数指针two==null，作为循环结束条件\n\n对于链表长度为偶数时，奇数指针one会在之前遍历完毕奇数位置，此时偶数指针two.next==null，作为循环结束条件\n\n最后进行奇偶链表拼接，one.next=tempTwo\n\n注意：间隔遍历很重要，如果按照顺序遍历，会出现one和two指针在奇偶长度的指向不一样，即one和two在快到链表末尾时候，可能指向的奇数链表也可能指向的偶数链表，这样就无法进行最后指针拼接的判断了，间隔遍历保证了指针的奇偶性\n\n\n# Java代码\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode oddEvenList(ListNode head) {\n        if(head==null) return head;\n        ListNode one = head;\n        ListNode two = head.next;\n        ListNode tempTwo = two;\n        while(two!=null&&two.next!=null){\n            one.next = two.next;\n            one = one.next;\n            two.next = one.next;\n            two = two.next;\n        }\n        one.next = tempTwo;\n        return head;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n",normalizedContent:"# leetcode-328-奇偶链表\n\n给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。\n\n请尝试使用原地算法完成。你的算法的空间复杂度应为 o(1)，时间复杂度应为 o(nodes)，nodes 为节点总数。\n\n示例 1:\n\n输入: 1->2->3->4->5->null\n输出: 1->3->5->2->4->null\n\n\n1\n2\n\n1\n2\n\n\n示例2：\n\n输入: 2->1->3->5->6->4->7->null \n输出: 2->3->6->7->1->5->4->null\n\n\n1\n2\n\n1\n2\n\n\n说明:\n\n * 应当保持奇数节点和偶数节点的相对顺序。\n * 链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。\n\n\n# 解题思路\n\n双指针：\n\n一个指针指向奇数节点，一个指针指向偶数节点\n\n间隔遍历，奇数指针只能指向奇数节点，偶数指针只能指向偶数节点\n\n对于链表长度为奇数时，奇数指针one能够指向之后一个数字，此时偶数指针two==null，作为循环结束条件\n\n对于链表长度为偶数时，奇数指针one会在之前遍历完毕奇数位置，此时偶数指针two.next==null，作为循环结束条件\n\n最后进行奇偶链表拼接，one.next=temptwo\n\n注意：间隔遍历很重要，如果按照顺序遍历，会出现one和two指针在奇偶长度的指向不一样，即one和two在快到链表末尾时候，可能指向的奇数链表也可能指向的偶数链表，这样就无法进行最后指针拼接的判断了，间隔遍历保证了指针的奇偶性\n\n\n# java代码\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode() {}\n *     listnode(int val) { this.val = val; }\n *     listnode(int val, listnode next) { this.val = val; this.next = next; }\n * }\n */\nclass solution {\n    public listnode oddevenlist(listnode head) {\n        if(head==null) return head;\n        listnode one = head;\n        listnode two = head.next;\n        listnode temptwo = two;\n        while(two!=null&&two.next!=null){\n            one.next = two.next;\n            one = one.next;\n            two.next = one.next;\n            two = two.next;\n        }\n        one.next = temptwo;\n        return head;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-347-前K个高频元素",frontmatter:{title:"LeetCode-347-前K个高频元素",date:"2020-07-15T09:14:34.000Z",description:"前K个高频元素",tags:["Java","数组","Medium"],keywords:"Java,数组,Medium,LeetCode",permalink:"/pages/5abc8f/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/73.LeetCode-347-%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0.html",relativePath:"06.算法/02.LeetCode/73.LeetCode-347-前K个高频元素.md",key:"v-726c37f8",path:"/pages/5abc8f/",headers:[{level:2,title:"LeetCode-347-前K个高频元素",slug:"leetcode-347-前k个高频元素",normalizedTitle:"leetcode-347-前k个高频元素",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:316},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:609}],headersStr:"LeetCode-347-前K个高频元素 解题思路 Java代码",content:"# LeetCode-347-前K个高频元素\n\n给定一个非空的整数数组，返回其中出现频率前 k 高的元素。\n\n示例1：\n\n输入: nums = [1,1,1,2,2,3], k = 2\n输出: [1,2]\n\n\n1\n2\n\n1\n2\n\n\n示例2：\n\n输入: nums = [1], k = 1\n输出: [1]\n\n\n1\n2\n\n1\n2\n\n\n提示：\n\n * 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。\n * 你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。\n * 题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。\n * 你可以按任意顺序返回答案。\n\n\n# 解题思路\n\n方法1、最小堆：\n\n首先利用Map来计算数组中数字出现的频率\n\n之后利用一个优先队列，在存储的过程中按照频率进行排序，且只存储频率最高的前K个数\n\n由于题目要求的顺序可以不同，所以最后一次弹出queue中的数字到list中就好了\n\n计算频率这个步骤需要 O(N)时间其中 N是列表中元素个数。\n\n第二步建立堆，堆中添加一个元素的复杂度是 O(log(k))，要进行 N 次复杂度是 O(N)。\n\n最后一步是输出结果，复杂度为 O(klog(k))。第二步和最后一步复杂度综合O(Nlog(k))。\n\n因此总复杂度为O(N+Nlog(k)) = O(Nlog(k))\n\n\n# Java代码\n\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> map = new HashMap<>();\n        List<Integer> list = new ArrayList<>();\n        for (int num : nums) {\n            map.put(num, map.getOrDefault(num, 0) + 1);\n        }\n        PriorityQueue<Map.Entry<Integer, Integer>> queue = new PriorityQueue<>((v1, v2) -> v1.getValue() - v2.getValue());\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\n            if (queue.size() < k) {\n                queue.add(entry);\n            } else {\n                if (entry.getValue() > queue.peek().getValue()) {\n                    queue.poll();\n                    queue.add(entry);\n                }\n            }\n        }\n        while (!queue.isEmpty()) {\n            list.add(queue.poll().getKey());\n        }\n        return list.stream().mapToInt(Integer::intValue).toArray();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n",normalizedContent:"# leetcode-347-前k个高频元素\n\n给定一个非空的整数数组，返回其中出现频率前 k 高的元素。\n\n示例1：\n\n输入: nums = [1,1,1,2,2,3], k = 2\n输出: [1,2]\n\n\n1\n2\n\n1\n2\n\n\n示例2：\n\n输入: nums = [1], k = 1\n输出: [1]\n\n\n1\n2\n\n1\n2\n\n\n提示：\n\n * 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。\n * 你的算法的时间复杂度必须优于 o(n log n) , n 是数组的大小。\n * 题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。\n * 你可以按任意顺序返回答案。\n\n\n# 解题思路\n\n方法1、最小堆：\n\n首先利用map来计算数组中数字出现的频率\n\n之后利用一个优先队列，在存储的过程中按照频率进行排序，且只存储频率最高的前k个数\n\n由于题目要求的顺序可以不同，所以最后一次弹出queue中的数字到list中就好了\n\n计算频率这个步骤需要 o(n)时间其中 n是列表中元素个数。\n\n第二步建立堆，堆中添加一个元素的复杂度是 o(log(k))，要进行 n 次复杂度是 o(n)。\n\n最后一步是输出结果，复杂度为 o(klog(k))。第二步和最后一步复杂度综合o(nlog(k))。\n\n因此总复杂度为o(n+nlog(k)) = o(nlog(k))\n\n\n# java代码\n\nclass solution {\n    public int[] topkfrequent(int[] nums, int k) {\n        map<integer, integer> map = new hashmap<>();\n        list<integer> list = new arraylist<>();\n        for (int num : nums) {\n            map.put(num, map.getordefault(num, 0) + 1);\n        }\n        priorityqueue<map.entry<integer, integer>> queue = new priorityqueue<>((v1, v2) -> v1.getvalue() - v2.getvalue());\n        for (map.entry<integer, integer> entry : map.entryset()) {\n            if (queue.size() < k) {\n                queue.add(entry);\n            } else {\n                if (entry.getvalue() > queue.peek().getvalue()) {\n                    queue.poll();\n                    queue.add(entry);\n                }\n            }\n        }\n        while (!queue.isempty()) {\n            list.add(queue.poll().getkey());\n        }\n        return list.stream().maptoint(integer::intvalue).toarray();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-394-字符串解码",frontmatter:{title:"LeetCode-394-字符串解码",date:"2020-08-03T11:11:29.000Z",description:"字符串解码",tags:["字符串","Java","Medium"],keywords:"字符串,Java,Medium,LeetCode",permalink:"/pages/0af455/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/74.LeetCode-394-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81.html",relativePath:"06.算法/02.LeetCode/74.LeetCode-394-字符串解码.md",key:"v-3e1194da",path:"/pages/0af455/",headers:[{level:2,title:"LeetCode-394-字符串解码",slug:"leetcode-394-字符串解码",normalizedTitle:"leetcode-394-字符串解码",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:456},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:1137}],headersStr:"LeetCode-394-字符串解码 解题思路 Java代码",content:"# LeetCode-394-字符串解码\n\n给定一个经过编码的字符串，返回它解码后的字符串。\n\n编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。\n\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\n\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。\n\n示例1：\n\n输入：s = \"3[a]2[bc]\"\n输出：\"aaabcbc\"\n\n\n1\n2\n\n1\n2\n\n\n示例2：\n\n输入：s = \"3[a2[c]]\"\n输出：\"accaccacc\"\n\n\n1\n2\n\n1\n2\n\n\n示例3：\n\n输入：s = \"2[abc]3[cd]ef\"\n输出：\"abcabccdcdcdef\"\n\n\n1\n2\n\n1\n2\n\n\n示例4：\n\n输入：s = \"abc3[cd]xyz\"\n输出：\"abccdcdcdxyz\"\n\n\n1\n2\n\n1\n2\n\n\n\n# 解题思路\n\n方法1、栈：\n\n观察示例可知，当出现括号时，需要考虑括号前的数字\n\n由于有时候括号不止1个，而且括号内的字符也不止1组，所以需要2个栈(或者队列)来进行存储，此外还需要一个res存储最终拼接的字符串。\n\n顺序进行遍历，情况分为以下4种：\n\n 1. 0<=当前字符<=9时，记录当前num，num=c[i]-'0'，但是num可能不止一个数字，当字符为100时，下一个也是num，如果直接覆盖会导致数字丢失，于是num=num * 10 + c[i] - '0'正是考虑这种情况。\n 2. 当前字符==[左括号时，记录括号前的num，并将num置0，方便下次记录。同时需要记录数字之前出现的所有英文字符，使用str的栈进行先前结果的存储，strStack.push(res.toString());，复用res准备记录括号内的英文字符。\n 3. 当前字符是a-z或者A-Z范围内时，直接进行字符串拼接res.append(c[i])\n 4. 当前字符==]右括号时，需要将括号内的字符重复，同时需要将之前保存的字符串和括号内的字符串进行拼接。首先弹出数字栈内的数字tempNum，利用一个临时的字符串tempStr保存之前的结果，从字符栈中弹出之前的字符串strStack.pop()，并转为StringBuilder类型赋值给tempStr，循环添加到tempStr中，此时的res保存的是括号内的字符，循环次数为tempNum。进行玩括号内字符添加后，将临时字符串赋值给res，继续进行循环判断。\n\n最后，返回res.toString()\n\n\n# Java代码\n\nclass Solution {\n    public String decodeString(String s) {\n        StringBuilder res = new StringBuilder();\n        Stack<Integer> numStack = new Stack<>();\n        Stack<String> strStack = new Stack<>();\n        char[] c = s.toCharArray();\n        int num = 0;\n        for (int i = 0; i < c.length; i++) {\n            if (c[i] >= '0' && c[i] <= '9') {\n                num = num * 10 + c[i] - '0';\n            } else if (c[i] == '[') {\n                numStack.push(num);\n                num = 0;\n                strStack.push(res.toString());\n                res = new StringBuilder();\n            } else if (('a' <= c[i] && c[i] <= 'z') || ('A' <= c[i] && c[i] <= 'Z')) {\n                res.append(c[i]);\n            } else if (c[i] == ']') {\n                int tempNum = numStack.pop();\n                StringBuilder tempStr = new StringBuilder(strStack.pop());\n                for (int j = 0; j < tempNum; j++) {\n                    tempStr.append(res);\n                }\n                res = tempStr;\n            }\n        }\n        return res.toString();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n",normalizedContent:"# leetcode-394-字符串解码\n\n给定一个经过编码的字符串，返回它解码后的字符串。\n\n编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。\n\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\n\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。\n\n示例1：\n\n输入：s = \"3[a]2[bc]\"\n输出：\"aaabcbc\"\n\n\n1\n2\n\n1\n2\n\n\n示例2：\n\n输入：s = \"3[a2[c]]\"\n输出：\"accaccacc\"\n\n\n1\n2\n\n1\n2\n\n\n示例3：\n\n输入：s = \"2[abc]3[cd]ef\"\n输出：\"abcabccdcdcdef\"\n\n\n1\n2\n\n1\n2\n\n\n示例4：\n\n输入：s = \"abc3[cd]xyz\"\n输出：\"abccdcdcdxyz\"\n\n\n1\n2\n\n1\n2\n\n\n\n# 解题思路\n\n方法1、栈：\n\n观察示例可知，当出现括号时，需要考虑括号前的数字\n\n由于有时候括号不止1个，而且括号内的字符也不止1组，所以需要2个栈(或者队列)来进行存储，此外还需要一个res存储最终拼接的字符串。\n\n顺序进行遍历，情况分为以下4种：\n\n 1. 0<=当前字符<=9时，记录当前num，num=c[i]-'0'，但是num可能不止一个数字，当字符为100时，下一个也是num，如果直接覆盖会导致数字丢失，于是num=num * 10 + c[i] - '0'正是考虑这种情况。\n 2. 当前字符==[左括号时，记录括号前的num，并将num置0，方便下次记录。同时需要记录数字之前出现的所有英文字符，使用str的栈进行先前结果的存储，strstack.push(res.tostring());，复用res准备记录括号内的英文字符。\n 3. 当前字符是a-z或者a-z范围内时，直接进行字符串拼接res.append(c[i])\n 4. 当前字符==]右括号时，需要将括号内的字符重复，同时需要将之前保存的字符串和括号内的字符串进行拼接。首先弹出数字栈内的数字tempnum，利用一个临时的字符串tempstr保存之前的结果，从字符栈中弹出之前的字符串strstack.pop()，并转为stringbuilder类型赋值给tempstr，循环添加到tempstr中，此时的res保存的是括号内的字符，循环次数为tempnum。进行玩括号内字符添加后，将临时字符串赋值给res，继续进行循环判断。\n\n最后，返回res.tostring()\n\n\n# java代码\n\nclass solution {\n    public string decodestring(string s) {\n        stringbuilder res = new stringbuilder();\n        stack<integer> numstack = new stack<>();\n        stack<string> strstack = new stack<>();\n        char[] c = s.tochararray();\n        int num = 0;\n        for (int i = 0; i < c.length; i++) {\n            if (c[i] >= '0' && c[i] <= '9') {\n                num = num * 10 + c[i] - '0';\n            } else if (c[i] == '[') {\n                numstack.push(num);\n                num = 0;\n                strstack.push(res.tostring());\n                res = new stringbuilder();\n            } else if (('a' <= c[i] && c[i] <= 'z') || ('a' <= c[i] && c[i] <= 'z')) {\n                res.append(c[i]);\n            } else if (c[i] == ']') {\n                int tempnum = numstack.pop();\n                stringbuilder tempstr = new stringbuilder(strstack.pop());\n                for (int j = 0; j < tempnum; j++) {\n                    tempstr.append(res);\n                }\n                res = tempstr;\n            }\n        }\n        return res.tostring();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-406-根据身高重建队列",frontmatter:{title:"LeetCode-406-根据身高重建队列",date:"2020-07-18T09:32:29.000Z",description:"根据身高重建队列",tags:["数组","Java","Medium"],keywords:"数组,Java,Medium,LeetCode",permalink:"/pages/8d243f/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/75.LeetCode-406-%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97.html",relativePath:"06.算法/02.LeetCode/75.LeetCode-406-根据身高重建队列.md",key:"v-3f1714d1",path:"/pages/8d243f/",headers:[{level:2,title:"LeetCode-406-根据身高重建队列",slug:"leetcode-406-根据身高重建队列",normalizedTitle:"leetcode-406-根据身高重建队列",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:257},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:506}],headersStr:"LeetCode-406-根据身高重建队列 解题思路 Java代码",content:"# LeetCode-406-根据身高重建队列\n\n假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。\n\n注意： 总人数少于1100人。\n\n示例：\n\n输入:\n[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]\n\n输出:\n[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n\n# 解题思路\n\n方法1、贪心算法(排序+插入):\n\n详见官方题解：https://leetcode-cn.com/problems/queue-reconstruction-by-height/solution/gen-ju-shen-gao-zhong-jian-dui-lie-by-leetcode/\n\n算法：\n\n * 排序：\n   * 按高度降序排列。\n   * 在同一高度的人中，按 k 值的升序排列。\n * 逐个地把它们放在输出队列中，索引等于它们的 k 值。\n * 返回输出队列\n\n\n# Java代码\n\nclass Solution {\n    public int[][] reconstructQueue(int[][] people) {\n        Arrays.sort(people, new Comparator<int[]>() {\n            // 如果两个人的身高相同，则需要按照k值进行升序排列\n            // 如果不同则按照身高降序排列\n            // 注意下面的数组下标是不同的\n            @Override\n            public int compare(int[] o1, int[] o2) {\n                return o1[0] == o2[0] ? o1[1] - o2[1] : o2[0] - o1[0];\n            }\n        });\n        List<int[]> output = new LinkedList<>();\n        for (int[] p : people) {\n            output.add(p[1], p);\n        }\n        int n = people.length;\n        return output.toArray(new int[n][2]);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n",normalizedContent:"# leetcode-406-根据身高重建队列\n\n假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。\n\n注意： 总人数少于1100人。\n\n示例：\n\n输入:\n[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]\n\n输出:\n[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n\n# 解题思路\n\n方法1、贪心算法(排序+插入):\n\n详见官方题解：https://leetcode-cn.com/problems/queue-reconstruction-by-height/solution/gen-ju-shen-gao-zhong-jian-dui-lie-by-leetcode/\n\n算法：\n\n * 排序：\n   * 按高度降序排列。\n   * 在同一高度的人中，按 k 值的升序排列。\n * 逐个地把它们放在输出队列中，索引等于它们的 k 值。\n * 返回输出队列\n\n\n# java代码\n\nclass solution {\n    public int[][] reconstructqueue(int[][] people) {\n        arrays.sort(people, new comparator<int[]>() {\n            // 如果两个人的身高相同，则需要按照k值进行升序排列\n            // 如果不同则按照身高降序排列\n            // 注意下面的数组下标是不同的\n            @override\n            public int compare(int[] o1, int[] o2) {\n                return o1[0] == o2[0] ? o1[1] - o2[1] : o2[0] - o1[0];\n            }\n        });\n        list<int[]> output = new linkedlist<>();\n        for (int[] p : people) {\n            output.add(p[1], p);\n        }\n        int n = people.length;\n        return output.toarray(new int[n][2]);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-413-等差数列划分",frontmatter:{title:"LeetCode-413-等差数列划分",date:"2020-06-18T20:13:57.000Z",description:"判断子序列",tags:["DP","数组","Java","Medium","LeetCode"],keywords:"DP,数组,Java,Medium,LeetCode",permalink:"/pages/cd66f6/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/76.LeetCode-413-%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%88%92%E5%88%86.html",relativePath:"06.算法/02.LeetCode/76.LeetCode-413-等差数列划分.md",key:"v-1456ec14",path:"/pages/cd66f6/",headers:[{level:2,title:"LeetCode-413-等差数列划分",slug:"leetcode-413-等差数列划分",normalizedTitle:"leetcode-413-等差数列划分",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:461},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:687},{level:3,title:"Java代码",slug:"java代码-2",normalizedTitle:"java代码",charIndex:687}],headersStr:"LeetCode-413-等差数列划分 解题思路 Java代码 Java代码",content:"# LeetCode-413-等差数列划分\n\n如果一个数列至少有三个元素，并且任意两个相邻元素之差相同，则称该数列为等差数列。\n\n例如，以下数列为等差数列:\n\n1, 3, 5, 7, 9\n7, 7, 7, 7\n3, -1, -5, -9\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n以下数列不是等差数列\n\n1, 1, 2, 5, 7\n\n\n1\n\n1\n\n\n数组 A 包含 N 个数，且索引从0开始。数组 A 的一个子数组划分为数组 (P, Q)，P 与 Q 是整数且满足 0<=P<Q<N 。\n\n如果满足以下条件，则称子数组(P, Q)为等差数组：\n\n元素 A[P], A[p + 1], ..., A[Q - 1], A[Q] 是等差的。并且 P + 1 < Q 。\n\n函数要返回数组 A 中所有为等差数组的子数组个数。\n\n示例 1:\n\nA = [1, 2, 3, 4]\n\n返回: 3, A 中有三个子等差数组: [1, 2, 3], [2, 3, 4] 以及自身 [1, 2, 3, 4]。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n\n# 解题思路\n\n方法1、动态规划：\n\n状态定义为：当前的等差数组数量\n\n如果前一个状态是等差数组，则只需要判断后一个数字前两个的差值是否满足等差数组，如果满足则+1\n\n如1，2，3是等差数组，指针后移到4时仍然满足等差数组的条件，此时不需要往前判断到1，只需要判断到前2位即可，2，3，4是等差数组，之前的1，2，3，4同样也是\n\n所以状态转移方程为：dp[i]=dp[i-1]+1\n\n之后返回dp数组的和就是等差数组的数量\n\n方法2、暴力破解：\n\n\n# Java代码\n\nclass Solution {\n    public int numberOfArithmeticSlices(int[] A) {\n        int len = A.length;\n        if(A==null||len==0) return 0;\n        int[] dp = new int[len];\n        int sum = 0;\n        for(int i=2;i<len;i++){\n            if(A[i-1]-A[i-2]==A[i]-A[i-1]){\n                dp[i]=dp[i-1]+1;\n                sum+=dp[i];\n            }\n        }\n        return sum;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# Java代码\n\nclass Solution {\n    public int numberOfArithmeticSlices(int[] A) {\n        int sum = 0;\n        int len = A.length;\n        for(int i=0;i<len-2;i++){\n            int distance = A[i+1]-A[i];\n            for(int j=i+2;j<len;j++){\n                if(A[j]-A[j-1]==distance){\n                    sum++;\n                }else{\n                    break;\n                }\n            }\n        }\n        return sum;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n",normalizedContent:"# leetcode-413-等差数列划分\n\n如果一个数列至少有三个元素，并且任意两个相邻元素之差相同，则称该数列为等差数列。\n\n例如，以下数列为等差数列:\n\n1, 3, 5, 7, 9\n7, 7, 7, 7\n3, -1, -5, -9\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n以下数列不是等差数列\n\n1, 1, 2, 5, 7\n\n\n1\n\n1\n\n\n数组 a 包含 n 个数，且索引从0开始。数组 a 的一个子数组划分为数组 (p, q)，p 与 q 是整数且满足 0<=p<q<n 。\n\n如果满足以下条件，则称子数组(p, q)为等差数组：\n\n元素 a[p], a[p + 1], ..., a[q - 1], a[q] 是等差的。并且 p + 1 < q 。\n\n函数要返回数组 a 中所有为等差数组的子数组个数。\n\n示例 1:\n\na = [1, 2, 3, 4]\n\n返回: 3, a 中有三个子等差数组: [1, 2, 3], [2, 3, 4] 以及自身 [1, 2, 3, 4]。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n\n# 解题思路\n\n方法1、动态规划：\n\n状态定义为：当前的等差数组数量\n\n如果前一个状态是等差数组，则只需要判断后一个数字前两个的差值是否满足等差数组，如果满足则+1\n\n如1，2，3是等差数组，指针后移到4时仍然满足等差数组的条件，此时不需要往前判断到1，只需要判断到前2位即可，2，3，4是等差数组，之前的1，2，3，4同样也是\n\n所以状态转移方程为：dp[i]=dp[i-1]+1\n\n之后返回dp数组的和就是等差数组的数量\n\n方法2、暴力破解：\n\n\n# java代码\n\nclass solution {\n    public int numberofarithmeticslices(int[] a) {\n        int len = a.length;\n        if(a==null||len==0) return 0;\n        int[] dp = new int[len];\n        int sum = 0;\n        for(int i=2;i<len;i++){\n            if(a[i-1]-a[i-2]==a[i]-a[i-1]){\n                dp[i]=dp[i-1]+1;\n                sum+=dp[i];\n            }\n        }\n        return sum;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# java代码\n\nclass solution {\n    public int numberofarithmeticslices(int[] a) {\n        int sum = 0;\n        int len = a.length;\n        for(int i=0;i<len-2;i++){\n            int distance = a[i+1]-a[i];\n            for(int j=i+2;j<len;j++){\n                if(a[j]-a[j-1]==distance){\n                    sum++;\n                }else{\n                    break;\n                }\n            }\n        }\n        return sum;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-416-分割等和子集",frontmatter:{title:"LeetCode-416-分割等和子集",date:"2020-08-05T09:46:41.000Z",description:"分割等和子集",tags:["数组","DP","Java","Medium"],keywords:"数组,DP,Java,Medium,LeetCode",permalink:"/pages/87a353/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/77.LeetCode-416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.html",relativePath:"06.算法/02.LeetCode/77.LeetCode-416-分割等和子集.md",key:"v-3b2f4a8c",path:"/pages/87a353/",headers:[{level:2,title:"LeetCode-416-分割等和子集",slug:"leetcode-416-分割等和子集",normalizedTitle:"leetcode-416-分割等和子集",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:292},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:549}],headersStr:"LeetCode-416-分割等和子集 解题思路 Java代码",content:"# LeetCode-416-分割等和子集\n\n给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。\n\n注意:\n\n 1. 每个数组中的元素不会超过 100\n 2. 数组的大小不会超过 200\n\n示例1：\n\n输入: [1, 5, 11, 5]\n\n输出: true\n\n解释: 数组可以分割成 [1, 5, 5] 和 [11].\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n示例2：\n\n输入: [1, 2, 3, 5]\n\n输出: false\n\n解释: 数组不能分割成两个元素和相等的子集.\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n\n# 解题思路\n\n**方法1、动态规划：**非常好的详解，0-1背包问题https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/0-1-bei-bao-wen-ti-xiang-jie-zhen-dui-ben-ti-de-yo/\n\n做这道题需要做这样一个等价转换：**是否可以从这个数组中挑选出一些正整数，使得这些数的和等于整个数组元素的和的一半。**前提条件是：数组的和一定得是偶数，即数组的和一定得被2整除，这一点是特判。\n\n\n# Java代码\n\npublic class Solution {\n\n    public boolean canPartition(int[] nums) {\n        int len = nums.length;\n        if (len == 0) {\n            return false;\n        }\n\n        int sum = 0;\n        for (int num : nums) {\n            sum += num;\n        }\n\n        // 特判：如果是奇数，就不符合要求\n        if ((sum & 1) == 1) {\n            return false;\n        }\n\n        int target = sum / 2;\n\n        // 创建二维状态数组，行：物品索引，列：容量（包括 0）\n        boolean[][] dp = new boolean[len][target + 1];\n\n        // 先填表格第 0 行，第 1 个数只能让容积为它自己的背包恰好装满\n        if (nums[0] <= target) {\n            dp[0][nums[0]] = true;\n        }\n\n        // 再填表格后面几行\n        for (int i = 1; i < len; i++) {\n            for (int j = 0; j <= target; j++) {\n                // 直接从上一行先把结果抄下来，然后再修正\n                dp[i][j] = dp[i - 1][j];\n\n                if (nums[i] == j) {\n                    dp[i][j] = true;\n                    continue;\n                }\n                if (nums[i] < j) {\n                    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]];\n                }\n            }\n        }\n        return dp[len - 1][target];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n",normalizedContent:"# leetcode-416-分割等和子集\n\n给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。\n\n注意:\n\n 1. 每个数组中的元素不会超过 100\n 2. 数组的大小不会超过 200\n\n示例1：\n\n输入: [1, 5, 11, 5]\n\n输出: true\n\n解释: 数组可以分割成 [1, 5, 5] 和 [11].\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n示例2：\n\n输入: [1, 2, 3, 5]\n\n输出: false\n\n解释: 数组不能分割成两个元素和相等的子集.\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n\n# 解题思路\n\n**方法1、动态规划：**非常好的详解，0-1背包问题https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/0-1-bei-bao-wen-ti-xiang-jie-zhen-dui-ben-ti-de-yo/\n\n做这道题需要做这样一个等价转换：**是否可以从这个数组中挑选出一些正整数，使得这些数的和等于整个数组元素的和的一半。**前提条件是：数组的和一定得是偶数，即数组的和一定得被2整除，这一点是特判。\n\n\n# java代码\n\npublic class solution {\n\n    public boolean canpartition(int[] nums) {\n        int len = nums.length;\n        if (len == 0) {\n            return false;\n        }\n\n        int sum = 0;\n        for (int num : nums) {\n            sum += num;\n        }\n\n        // 特判：如果是奇数，就不符合要求\n        if ((sum & 1) == 1) {\n            return false;\n        }\n\n        int target = sum / 2;\n\n        // 创建二维状态数组，行：物品索引，列：容量（包括 0）\n        boolean[][] dp = new boolean[len][target + 1];\n\n        // 先填表格第 0 行，第 1 个数只能让容积为它自己的背包恰好装满\n        if (nums[0] <= target) {\n            dp[0][nums[0]] = true;\n        }\n\n        // 再填表格后面几行\n        for (int i = 1; i < len; i++) {\n            for (int j = 0; j <= target; j++) {\n                // 直接从上一行先把结果抄下来，然后再修正\n                dp[i][j] = dp[i - 1][j];\n\n                if (nums[i] == j) {\n                    dp[i][j] = true;\n                    continue;\n                }\n                if (nums[i] < j) {\n                    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]];\n                }\n            }\n        }\n        return dp[len - 1][target];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-438-找到字符串中所有字母异位词",frontmatter:{title:"LeetCode-438-找到字符串中所有字母异位词",date:"2020-08-18T09:57:26.000Z",description:"找到字符串中所有字母异位词",tags:["字符串","滑动窗口","Java","Medium"],keywords:"字符串,Java,滑动窗口,Medium,LeetCode",permalink:"/pages/e8a730/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/78.LeetCode-438-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html",relativePath:"06.算法/02.LeetCode/78.LeetCode-438-找到字符串中所有字母异位词.md",key:"v-0a68e3d0",path:"/pages/e8a730/",headers:[{level:2,title:"LeetCode-438-找到字符串中所有字母异位词",slug:"leetcode-438-找到字符串中所有字母异位词",normalizedTitle:"leetcode-438-找到字符串中所有字母异位词",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:549},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:2562}],headersStr:"LeetCode-438-找到字符串中所有字母异位词 解题思路 Java代码2",content:'# LeetCode-438-找到字符串中所有字母异位词\n\n给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。\n\n字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。\n\n说明：\n\n * 字母异位词指字母相同，但排列不同的字符串。\n * 不考虑答案输出的顺序。\n\n示例1：\n\n输入:\ns: "cbaebabacd" p: "abc"\n\n输出:\n[0, 6]\n\n解释:\n起始索引等于 0 的子串是 "cba", 它是 "abc" 的字母异位词。\n起始索引等于 6 的子串是 "bac", 它是 "abc" 的字母异位词。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n示例2：\n\n输入:\ns: "abab" p: "ab"\n\n输出:\n[0, 1, 2]\n\n解释:\n起始索引等于 0 的子串是 "ab", 它是 "ab" 的字母异位词。\n起始索引等于 1 的子串是 "ba", 它是 "ab" 的字母异位词。\n起始索引等于 2 的子串是 "ab", 它是 "ab" 的字母异位词。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 解题思路\n\n方法1、哈希表+滑动窗口：\n\n详见注释\n\n方法2、数组+滑动窗口：\n\n详见https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/solution/20200321438median-by-jasion_han-r/\n\n * 一开始还是先将字符串转换为字符数组，定义一个ans来接收结果\n\n * 这里使用了两个数组needs和window来分别记录需要得到的元素和滑动窗口遍历到的元素\n\n * 首先把目标数组arrP中有的元素都放入needs中，然后通过不断移动滑动窗口将目标元素的个数保存到window中\n\n * 如果window数组中记录的元素个数超过了needs数组的元素个数，则开始移动左窗口慢慢减少多余的个数\n\n * 最后把整个遍历过程中所有符合要求的左窗口索引放到ans中并返回即可。\n\n###Java代码1\n\nclass Solution {\n    public List<Integer> findAnagrams(String s, String p) {\n        Map<Character, Integer> smap = new HashMap<>();\n        Map<Character, Integer> pmap = new HashMap<>();\n        for (char ch : p.toCharArray()) {\n            pmap.put(ch, pmap.getOrDefault(ch, 0) + 1);\n        }\n        List<Integer> res = new ArrayList<>();\n        int count = 0; // 候选字符的个数\n        int len = p.length();\n        int left = 0;\n        int right = 0;\n        while (right < s.length()) {\n            char ch = s.charAt(right);\n            smap.put(ch, smap.getOrDefault(ch, 0) + 1);\n            // 如果p中包含当前字符，且s的窗口中该字符出现次数不足，则该字符可以作为一个候选字符串，count++\n            if (pmap.containsKey(ch) && smap.get(ch) <= pmap.get(ch)) {\n                count++;\n            }\n            // 当候选字符个数等于p长度，此时left为起始索引\n            if (count == len) {\n                res.add(left);\n            }\n            // 当窗口大小大于等于p长度时，窗口左边需要收缩一个字符\n            if (right - left + 1 >= len) {\n                char leftChar = s.charAt(left);\n                // 判断收缩的这个字符是否是候选字符\n                if (pmap.containsKey(leftChar) && smap.get(leftChar) <= pmap.get(leftChar)) {\n                    count--;\n                }\n                // 窗口收缩一个字符\n                smap.put(leftChar, smap.getOrDefault(leftChar, 1) - 1);\n                left++;\n            }\n            right++;\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# Java代码2\n\nclass Solution {\n    public List<Integer> findAnagrams(String s, String p) {\n        char[] arrS = s.toCharArray();\n        char[] arrP = p.toCharArray();\n        \n        // 接收最后返回的结果\n        List<Integer> ans = new ArrayList<>();\n        \n        // 定义一个 needs 数组来看 arrP 中包含元素的个数\n        int[] needs = new int[26];\n        // 定义一个 window 数组来看滑动窗口中是否有 arrP 中的元素，并记录出现的个数\n        int[] window = new int[26]; \n        \n        // 先将 arrP 中的元素保存到 needs 数组中\n        for (int i = 0; i < arrP.length; i++) {\n            needs[arrP[i] - \'a\'] += 1;\n        }\n        \n        // 定义滑动窗口的两端\n        int left = 0;\n        int right = 0;\n        \n        // 右窗口开始不断向右移动\n        while (right < arrS.length) {\n            int curR = arrS[right] - \'a\';\n            right++;\n            // 将右窗口当前访问到的元素 curR 个数加 1 \n            window[curR] += 1;\n            \n            // 当 window 数组中 curR 比 needs 数组中对应元素的个数要多的时候就该移动左窗口指针 \n            while (window[curR] > needs[curR]) {\n                int curL = arrS[left] - \'a\';\n                left++;\n                // 将左窗口当前访问到的元素 curL 个数减 1 \n                window[curL] -= 1;            \n            }\n            \n            // 这里将所有符合要求的左窗口索引放入到了接收结果的 List 中\n            if (right - left == arrP.length) {\n                ans.add(left);\n            }\n        }\n        return ans;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n',normalizedContent:'# leetcode-438-找到字符串中所有字母异位词\n\n给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。\n\n字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。\n\n说明：\n\n * 字母异位词指字母相同，但排列不同的字符串。\n * 不考虑答案输出的顺序。\n\n示例1：\n\n输入:\ns: "cbaebabacd" p: "abc"\n\n输出:\n[0, 6]\n\n解释:\n起始索引等于 0 的子串是 "cba", 它是 "abc" 的字母异位词。\n起始索引等于 6 的子串是 "bac", 它是 "abc" 的字母异位词。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n示例2：\n\n输入:\ns: "abab" p: "ab"\n\n输出:\n[0, 1, 2]\n\n解释:\n起始索引等于 0 的子串是 "ab", 它是 "ab" 的字母异位词。\n起始索引等于 1 的子串是 "ba", 它是 "ab" 的字母异位词。\n起始索引等于 2 的子串是 "ab", 它是 "ab" 的字母异位词。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 解题思路\n\n方法1、哈希表+滑动窗口：\n\n详见注释\n\n方法2、数组+滑动窗口：\n\n详见https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/solution/20200321438median-by-jasion_han-r/\n\n * 一开始还是先将字符串转换为字符数组，定义一个ans来接收结果\n\n * 这里使用了两个数组needs和window来分别记录需要得到的元素和滑动窗口遍历到的元素\n\n * 首先把目标数组arrp中有的元素都放入needs中，然后通过不断移动滑动窗口将目标元素的个数保存到window中\n\n * 如果window数组中记录的元素个数超过了needs数组的元素个数，则开始移动左窗口慢慢减少多余的个数\n\n * 最后把整个遍历过程中所有符合要求的左窗口索引放到ans中并返回即可。\n\n###java代码1\n\nclass solution {\n    public list<integer> findanagrams(string s, string p) {\n        map<character, integer> smap = new hashmap<>();\n        map<character, integer> pmap = new hashmap<>();\n        for (char ch : p.tochararray()) {\n            pmap.put(ch, pmap.getordefault(ch, 0) + 1);\n        }\n        list<integer> res = new arraylist<>();\n        int count = 0; // 候选字符的个数\n        int len = p.length();\n        int left = 0;\n        int right = 0;\n        while (right < s.length()) {\n            char ch = s.charat(right);\n            smap.put(ch, smap.getordefault(ch, 0) + 1);\n            // 如果p中包含当前字符，且s的窗口中该字符出现次数不足，则该字符可以作为一个候选字符串，count++\n            if (pmap.containskey(ch) && smap.get(ch) <= pmap.get(ch)) {\n                count++;\n            }\n            // 当候选字符个数等于p长度，此时left为起始索引\n            if (count == len) {\n                res.add(left);\n            }\n            // 当窗口大小大于等于p长度时，窗口左边需要收缩一个字符\n            if (right - left + 1 >= len) {\n                char leftchar = s.charat(left);\n                // 判断收缩的这个字符是否是候选字符\n                if (pmap.containskey(leftchar) && smap.get(leftchar) <= pmap.get(leftchar)) {\n                    count--;\n                }\n                // 窗口收缩一个字符\n                smap.put(leftchar, smap.getordefault(leftchar, 1) - 1);\n                left++;\n            }\n            right++;\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# java代码2\n\nclass solution {\n    public list<integer> findanagrams(string s, string p) {\n        char[] arrs = s.tochararray();\n        char[] arrp = p.tochararray();\n        \n        // 接收最后返回的结果\n        list<integer> ans = new arraylist<>();\n        \n        // 定义一个 needs 数组来看 arrp 中包含元素的个数\n        int[] needs = new int[26];\n        // 定义一个 window 数组来看滑动窗口中是否有 arrp 中的元素，并记录出现的个数\n        int[] window = new int[26]; \n        \n        // 先将 arrp 中的元素保存到 needs 数组中\n        for (int i = 0; i < arrp.length; i++) {\n            needs[arrp[i] - \'a\'] += 1;\n        }\n        \n        // 定义滑动窗口的两端\n        int left = 0;\n        int right = 0;\n        \n        // 右窗口开始不断向右移动\n        while (right < arrs.length) {\n            int curr = arrs[right] - \'a\';\n            right++;\n            // 将右窗口当前访问到的元素 curr 个数加 1 \n            window[curr] += 1;\n            \n            // 当 window 数组中 curr 比 needs 数组中对应元素的个数要多的时候就该移动左窗口指针 \n            while (window[curr] > needs[curr]) {\n                int curl = arrs[left] - \'a\';\n                left++;\n                // 将左窗口当前访问到的元素 curl 个数减 1 \n                window[curl] -= 1;            \n            }\n            \n            // 这里将所有符合要求的左窗口索引放入到了接收结果的 list 中\n            if (right - left == arrp.length) {\n                ans.add(left);\n            }\n        }\n        return ans;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-461-汉明距离",frontmatter:{title:"LeetCode-461-汉明距离",date:"2020-07-20T09:22:22.000Z",description:"汉明距离",tags:["数组","Java","Easy"],keywords:"数组,Java,Easy,LeetCode",permalink:"/pages/ad566a/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/80.LeetCode-461-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB.html",relativePath:"06.算法/02.LeetCode/80.LeetCode-461-汉明距离.md",key:"v-1642c97c",path:"/pages/ad566a/",headers:[{level:2,title:"LeetCode-461-汉明距离",slug:"leetcode-461-汉明距离",normalizedTitle:"leetcode-461-汉明距离",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:254},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:471}],headersStr:"LeetCode-461-汉明距离 解题思路 Java代码",content:"# LeetCode-461-汉明距离\n\n两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。\n\n给出两个整数 x 和 y，计算它们之间的汉明距离。\n\n注意： 0 ≤ x, y < 2^31.\n\n示例1：\n\n输入: x = 1, y = 4\n\n输出: 2\n\n解释:\n1   (0 0 0 1)\n4   (0 1 0 0)\n       ↑   ↑\n\n上面的箭头指出了对应二进制位不同的位置。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 解题思路\n\n方法1、异或+移位：\n\n不难看出异或运算能够保留数据中不相同位置的1，之后我们只需要统计1的个数即可\n\n在Java中内置函数Integer.bitCount(x^y)可以快速计算出1的个数\n\n另外一种方式是将每个位逻辑位移，移动到最左侧，或者最右侧，检查该位是否为1\n\n这里采用移动到最右侧的方式，即右移运算\n\n使用取模%2运算或者AND运算&1，检查最右边的一位是否为1，这两个操作都会屏蔽最右位以外的其他位。\n\n\n# Java代码\n\nclass Solution {\n    public int hammingDistance(int x, int y) {\n        int xOry = x^y;\n        int distance = 0;\n        while(xOry!=0){\n            if((xOry%2)==1){ // 或者使用(xOry&1)也可以\n                distance++;\n            }\n            xOry=xOry>>1;\n        }\n        return distance;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n",normalizedContent:"# leetcode-461-汉明距离\n\n两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。\n\n给出两个整数 x 和 y，计算它们之间的汉明距离。\n\n注意： 0 ≤ x, y < 2^31.\n\n示例1：\n\n输入: x = 1, y = 4\n\n输出: 2\n\n解释:\n1   (0 0 0 1)\n4   (0 1 0 0)\n       ↑   ↑\n\n上面的箭头指出了对应二进制位不同的位置。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 解题思路\n\n方法1、异或+移位：\n\n不难看出异或运算能够保留数据中不相同位置的1，之后我们只需要统计1的个数即可\n\n在java中内置函数integer.bitcount(x^y)可以快速计算出1的个数\n\n另外一种方式是将每个位逻辑位移，移动到最左侧，或者最右侧，检查该位是否为1\n\n这里采用移动到最右侧的方式，即右移运算\n\n使用取模%2运算或者and运算&1，检查最右边的一位是否为1，这两个操作都会屏蔽最右位以外的其他位。\n\n\n# java代码\n\nclass solution {\n    public int hammingdistance(int x, int y) {\n        int xory = x^y;\n        int distance = 0;\n        while(xory!=0){\n            if((xory%2)==1){ // 或者使用(xory&1)也可以\n                distance++;\n            }\n            xory=xory>>1;\n        }\n        return distance;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-448-找到所有数组中消失的数字",frontmatter:{title:"LeetCode-448-找到所有数组中消失的数字",date:"2020-08-03T09:52:29.000Z",description:"找到所有数组中消失的数字",tags:["数组","Java","Easy"],keywords:"数组,Java,Easy,LeetCode",permalink:"/pages/d2f3f5/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/79.LeetCode-448-%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97.html",relativePath:"06.算法/02.LeetCode/79.LeetCode-448-找到所有数组中消失的数字.md",key:"v-4e381294",path:"/pages/d2f3f5/",headers:[{level:2,title:"LeetCode-448-找到所有数组中消失的数字",slug:"leetcode-448-找到所有数组中消失的数字",normalizedTitle:"leetcode-448-找到所有数组中消失的数字",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:248},{level:3,title:"Java代码1",slug:"java代码1",normalizedTitle:"java代码1",charIndex:517},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:1087}],headersStr:"LeetCode-448-找到所有数组中消失的数字 解题思路 Java代码1 Java代码2",content:"# LeetCode-448-找到所有数组中消失的数字\n\n给定一个范围在 1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。\n\n找到所有在 [1, n] 范围之间没有出现在数组中的数字。\n\n您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。\n\n示例1：\n\n输入:\n[4,3,2,7,8,2,3,1]\n\n输出:\n[5,6]\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n\n# 解题思路\n\n方法1、哈希表：\n\n排序后的复杂度不符合要求，写一个需要空间要求的。利用一个O(n)空间的哈希表进行数据存储，之后进行数组的遍历，判断是否有i这个值在哈希表内，如果不在则就是消失的数字。\n\n方法2、原地修改：\n\n原地修改具有技巧性，不容易想到，详见https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/solution/zhao-dao-suo-you-shu-zu-zhong-xiao-shi-de-shu-zi-2/\n\n\n# Java代码1\n\nclass Solution {\n    public List<Integer> findDisappearedNumbers(int[] nums) {\n        List<Integer> res = new ArrayList<>();\n        if (nums == null || nums.length == 0) return res;\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int num : nums) {\n            map.put(num, 1);\n        }\n        for (int i = 1; i <= nums.length; i++) {\n            if (!map.containsKey(i)) {\n                res.add(i);\n            }\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# Java代码2\n\n    /**\n     *\n     * 找出 1 - n 中没有出现的数字。不能使用额外的空间，两次循环时间复杂度为 2O(n)，即为 O(n)。\n     *\n     * 解题思路：使用数组的下标来标记数字的出现于否，通过一遍遍历即可标记出全部已经出现的数组\n     *\n     * [4,3,2,7,8,2,3,1] 初始数据\n     *\n     * [4,3,2,-7,8,2,3,1] 第一个数据 4 出现，将数组的第四个也就是下标 3 的数据修改为负数。-7 计算时，通过绝对值处理一下即可不影响数据的计算\n     * [4,3,-2,-7,8,2,3,1]\n     * [4,-3,-2,-7,8,2,3,1]\n     * [4,-3,-2,-7,8,2,-3,1]\n     * [4,-3,-2,-7,8,2,-3,-1]\n     * [4,-3,-2,-7,8,2,-3,-1]\n     * [4,-3,-2,-7,8,2,-3,-1]\n     * [-4,-3,-2,-7,8,2,-3,-1]\n     *\n     * 计算结束，数组的第五个，第六个依然为整数，证明 5,6 没有出现\n     *\n     * @param nums\n     * @return\n     */\nclass Solution {\n    public List<Integer> findDisappearedNumbers(int[] nums) {\n        List<Integer> results = new ArrayList<>();\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[Math.abs(nums[i]) - 1] > 0) {\n                nums[Math.abs(nums[i]) - 1] *= -1;\n            }\n        }\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] > 0) {\n                results.add(i + 1);\n            }\n        }\n        return results;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n",normalizedContent:"# leetcode-448-找到所有数组中消失的数字\n\n给定一个范围在 1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。\n\n找到所有在 [1, n] 范围之间没有出现在数组中的数字。\n\n您能在不使用额外空间且时间复杂度为o(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。\n\n示例1：\n\n输入:\n[4,3,2,7,8,2,3,1]\n\n输出:\n[5,6]\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n\n# 解题思路\n\n方法1、哈希表：\n\n排序后的复杂度不符合要求，写一个需要空间要求的。利用一个o(n)空间的哈希表进行数据存储，之后进行数组的遍历，判断是否有i这个值在哈希表内，如果不在则就是消失的数字。\n\n方法2、原地修改：\n\n原地修改具有技巧性，不容易想到，详见https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/solution/zhao-dao-suo-you-shu-zu-zhong-xiao-shi-de-shu-zi-2/\n\n\n# java代码1\n\nclass solution {\n    public list<integer> finddisappearednumbers(int[] nums) {\n        list<integer> res = new arraylist<>();\n        if (nums == null || nums.length == 0) return res;\n        map<integer, integer> map = new hashmap<>();\n        for (int num : nums) {\n            map.put(num, 1);\n        }\n        for (int i = 1; i <= nums.length; i++) {\n            if (!map.containskey(i)) {\n                res.add(i);\n            }\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# java代码2\n\n    /**\n     *\n     * 找出 1 - n 中没有出现的数字。不能使用额外的空间，两次循环时间复杂度为 2o(n)，即为 o(n)。\n     *\n     * 解题思路：使用数组的下标来标记数字的出现于否，通过一遍遍历即可标记出全部已经出现的数组\n     *\n     * [4,3,2,7,8,2,3,1] 初始数据\n     *\n     * [4,3,2,-7,8,2,3,1] 第一个数据 4 出现，将数组的第四个也就是下标 3 的数据修改为负数。-7 计算时，通过绝对值处理一下即可不影响数据的计算\n     * [4,3,-2,-7,8,2,3,1]\n     * [4,-3,-2,-7,8,2,3,1]\n     * [4,-3,-2,-7,8,2,-3,1]\n     * [4,-3,-2,-7,8,2,-3,-1]\n     * [4,-3,-2,-7,8,2,-3,-1]\n     * [4,-3,-2,-7,8,2,-3,-1]\n     * [-4,-3,-2,-7,8,2,-3,-1]\n     *\n     * 计算结束，数组的第五个，第六个依然为整数，证明 5,6 没有出现\n     *\n     * @param nums\n     * @return\n     */\nclass solution {\n    public list<integer> finddisappearednumbers(int[] nums) {\n        list<integer> results = new arraylist<>();\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[math.abs(nums[i]) - 1] > 0) {\n                nums[math.abs(nums[i]) - 1] *= -1;\n            }\n        }\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] > 0) {\n                results.add(i + 1);\n            }\n        }\n        return results;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-494-目标和",frontmatter:{title:"LeetCode-494-目标和",date:"2020-07-20T09:52:58.000Z",description:"目标和",tags:["数组","Java","回溯","DP","Medium"],keywords:"数组,Java,回溯,DP,Medium,LeetCode",permalink:"/pages/ed7689/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/81.LeetCode-494-%E7%9B%AE%E6%A0%87%E5%92%8C.html",relativePath:"06.算法/02.LeetCode/81.LeetCode-494-目标和.md",key:"v-104c0473",path:"/pages/ed7689/",headers:[{level:2,title:"LeetCode-494-目标和",slug:"leetcode-494-目标和",normalizedTitle:"leetcode-494-目标和",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:412},{level:3,title:"Java代码1",slug:"java代码1",normalizedTitle:"java代码1",charIndex:715},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:1499}],headersStr:"LeetCode-494-目标和 解题思路 Java代码1 Java代码2",content:"# LeetCode-494-目标和\n\n给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。\n\n返回可以使最终数组和为目标数 S 的所有添加符号的方法数。\n\n示例1：\n\n输入：nums: [1, 1, 1, 1, 1], S: 3\n输出：5\n解释：\n\n-1+1+1+1+1 = 3\n+1-1+1+1+1 = 3\n+1+1-1+1+1 = 3\n+1+1+1-1+1 = 3\n+1+1+1+1-1 = 3\n\n一共有5种方法让最终目标和为3。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n提示：\n\n * 数组非空，且长度不会超过 20 。\n * 初始的数组的和不会超过 1000 。\n * 保证返回的最终结果能被 32 位整数存下。\n\n\n# 解题思路\n\n方法1、回溯：\n\n每一步选择都有该位置数的正负2种选择方案，画成树状图可以知道需要DFS遍历2棵树\n\n1棵树以第1位数为正开始寻找，1棵树以第1位数为负开始寻找，找到符合要求的答案。\n\n类似于暴力穷举。\n\n当遍历的深度达到数组长度，且路径和等于S的时候，说明找到了一条路径，count++\n\n当不满足路径和要求时，返回上一层，进行回溯，撤销上一次的选择。\n\n方法2、动态规划：\n\n详见https://leetcode-cn.com/problems/target-sum/solution/494-mu-biao-he-by-ming-zhi-shan-you-m9rfkvkdad/\n\n\n# Java代码1\n\nclass Solution {\n    int res = 0;\n    int count = 0;\n    public int findTargetSumWays(int[] nums, int S) {\n        int len = nums.length;\n        backtrack(0,nums,S,len);\n        return count;\n    }\n\n    public void backtrack(int i,int[] nums,int S,int len){\n        if(i==len){\n            if(res==S){\n                count++;\n            }\n            return;\n        }\n        // 选择正号\n        res+=nums[i];\n        backtrack(i+1,nums,S,len);\n        // 撤销选择\n        res-=nums[i];\n        \n        // 选择负号\n        res-=nums[i];\n        backtrack(i+1,nums,S,len);\n        // 撤销选择\n        res+=nums[i];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# Java代码2\n\n\nclass Solution{\n    public int findTargetSumWays(int[] nums, int S){\n        if(nums.length == 0) return 0;\n        int sum = 0;\n        for(int i = 0; i < nums.length; i++) sum += nums[i];\n        if (Math.abs(S) > Math.abs(sum)) return 0;\n        int[][] dp = new int[nums.length][sum*2+1];\n        if(nums[0] == 0) dp[0][sum] = 2;\n        else{\n            dp[0][sum+nums[0]] = 1;\n            dp[0][sum-nums[0]] = 1;\n        }\n        \n        for(int i = 1; i<nums.length; i++){\n            for(int j = 0; j<(sum*2+1);j++){\n                int l = (j - nums[i]) >= 0 ? j - nums[i] : 0;\n                int r = (j + nums[i]) < (sum*2+1) ? j + nums[i] : 0;\n                dp[i][j] = dp[i-1][l] + dp[i-1][r];\n            }\n        }\n        return dp[nums.length-1][sum+S];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n",normalizedContent:"# leetcode-494-目标和\n\n给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，s。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。\n\n返回可以使最终数组和为目标数 s 的所有添加符号的方法数。\n\n示例1：\n\n输入：nums: [1, 1, 1, 1, 1], s: 3\n输出：5\n解释：\n\n-1+1+1+1+1 = 3\n+1-1+1+1+1 = 3\n+1+1-1+1+1 = 3\n+1+1+1-1+1 = 3\n+1+1+1+1-1 = 3\n\n一共有5种方法让最终目标和为3。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n提示：\n\n * 数组非空，且长度不会超过 20 。\n * 初始的数组的和不会超过 1000 。\n * 保证返回的最终结果能被 32 位整数存下。\n\n\n# 解题思路\n\n方法1、回溯：\n\n每一步选择都有该位置数的正负2种选择方案，画成树状图可以知道需要dfs遍历2棵树\n\n1棵树以第1位数为正开始寻找，1棵树以第1位数为负开始寻找，找到符合要求的答案。\n\n类似于暴力穷举。\n\n当遍历的深度达到数组长度，且路径和等于s的时候，说明找到了一条路径，count++\n\n当不满足路径和要求时，返回上一层，进行回溯，撤销上一次的选择。\n\n方法2、动态规划：\n\n详见https://leetcode-cn.com/problems/target-sum/solution/494-mu-biao-he-by-ming-zhi-shan-you-m9rfkvkdad/\n\n\n# java代码1\n\nclass solution {\n    int res = 0;\n    int count = 0;\n    public int findtargetsumways(int[] nums, int s) {\n        int len = nums.length;\n        backtrack(0,nums,s,len);\n        return count;\n    }\n\n    public void backtrack(int i,int[] nums,int s,int len){\n        if(i==len){\n            if(res==s){\n                count++;\n            }\n            return;\n        }\n        // 选择正号\n        res+=nums[i];\n        backtrack(i+1,nums,s,len);\n        // 撤销选择\n        res-=nums[i];\n        \n        // 选择负号\n        res-=nums[i];\n        backtrack(i+1,nums,s,len);\n        // 撤销选择\n        res+=nums[i];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# java代码2\n\n\nclass solution{\n    public int findtargetsumways(int[] nums, int s){\n        if(nums.length == 0) return 0;\n        int sum = 0;\n        for(int i = 0; i < nums.length; i++) sum += nums[i];\n        if (math.abs(s) > math.abs(sum)) return 0;\n        int[][] dp = new int[nums.length][sum*2+1];\n        if(nums[0] == 0) dp[0][sum] = 2;\n        else{\n            dp[0][sum+nums[0]] = 1;\n            dp[0][sum-nums[0]] = 1;\n        }\n        \n        for(int i = 1; i<nums.length; i++){\n            for(int j = 0; j<(sum*2+1);j++){\n                int l = (j - nums[i]) >= 0 ? j - nums[i] : 0;\n                int r = (j + nums[i]) < (sum*2+1) ? j + nums[i] : 0;\n                dp[i][j] = dp[i-1][l] + dp[i-1][r];\n            }\n        }\n        return dp[nums.length-1][sum+s];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-538-把二叉搜索树转换为累加树",frontmatter:{title:"LeetCode-538-把二叉搜索树转换为累加树",date:"2020-07-09T09:09:37.000Z",description:"把二叉搜索树转换为累加树",tags:["树","Java","Easy"],keywords:"树,Java,Easy,LeetCode",permalink:"/pages/9d7aee/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/82.LeetCode-538-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91.html",relativePath:"06.算法/02.LeetCode/82.LeetCode-538-把二叉搜索树转换为累加树.md",key:"v-a3c4af02",path:"/pages/9d7aee/",headers:[{level:2,title:"LeetCode-538-把二叉搜索树转换为累加树",slug:"leetcode-538-把二叉搜索树转换为累加树",normalizedTitle:"leetcode-538-把二叉搜索树转换为累加树",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:298},{level:3,title:"Java代码1",slug:"java代码1",normalizedTitle:"java代码1",charIndex:580},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:1160}],headersStr:"LeetCode-538-把二叉搜索树转换为累加树 解题思路 Java代码1 Java代码2",content:"# LeetCode-538-把二叉搜索树转换为累加树\n\n给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。\n\n示例1：\n\n输入: 原始二叉搜索树:\n              5\n            /   \\\n           2     13\n\n输出: 转换为累加树:\n             18\n            /   \\\n          20     13\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 解题思路\n\n方法1、递归：\n\n二叉搜索树是，当树中根节点不为空的时候，其左子树上所有节点的值均小于它的根节点的值。若它的右子树不空，则右子树上所有结点的值均大于它的根节点的值。\n\n根据这一特点，累加树就可以通过反向的中序遍历得到，即先遍历右根左的顺序进行遍历，同时进行节点值累加，满足当一个节点的值是由所有大于它的节点值累加得到的这一定义。\n\n当root不为空时，进行右子树递归，并累加节点值，之后进行左子树递归，最后返回root节点\n\n方法2、迭代：\n\n使用一个Stack来存储节点，利用反序的中序遍历进行节点值累加，实现方法和中序遍历的迭代方式类似。\n\n\n# Java代码1\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    private int sum = 0;\n    public TreeNode convertBST(TreeNode root) {\n        if(root!=null){\n            convertBST(root.right);\n            sum+= root.val;\n            root.val = sum;\n            convertBST(root.left);\n        }\n        return root;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# Java代码2\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode convertBST(TreeNode root) {\n        int sum = 0;\n        Stack<TreeNode> stack = new Stack<>();\n        TreeNode temp = root;\n        while(temp!=null||!stack.isEmpty()){\n            while(temp!=null){\n                stack.push(temp);\n                temp = temp.right;\n            }\n            temp = stack.pop();\n            sum +=temp.val;\n            temp.val = sum;\n            temp = temp.left;\n        }\n        return root;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n",normalizedContent:"# leetcode-538-把二叉搜索树转换为累加树\n\n给定一个二叉搜索树（binary search tree），把它转换成为累加树（greater tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。\n\n示例1：\n\n输入: 原始二叉搜索树:\n              5\n            /   \\\n           2     13\n\n输出: 转换为累加树:\n             18\n            /   \\\n          20     13\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 解题思路\n\n方法1、递归：\n\n二叉搜索树是，当树中根节点不为空的时候，其左子树上所有节点的值均小于它的根节点的值。若它的右子树不空，则右子树上所有结点的值均大于它的根节点的值。\n\n根据这一特点，累加树就可以通过反向的中序遍历得到，即先遍历右根左的顺序进行遍历，同时进行节点值累加，满足当一个节点的值是由所有大于它的节点值累加得到的这一定义。\n\n当root不为空时，进行右子树递归，并累加节点值，之后进行左子树递归，最后返回root节点\n\n方法2、迭代：\n\n使用一个stack来存储节点，利用反序的中序遍历进行节点值累加，实现方法和中序遍历的迭代方式类似。\n\n\n# java代码1\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    private int sum = 0;\n    public treenode convertbst(treenode root) {\n        if(root!=null){\n            convertbst(root.right);\n            sum+= root.val;\n            root.val = sum;\n            convertbst(root.left);\n        }\n        return root;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# java代码2\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public treenode convertbst(treenode root) {\n        int sum = 0;\n        stack<treenode> stack = new stack<>();\n        treenode temp = root;\n        while(temp!=null||!stack.isempty()){\n            while(temp!=null){\n                stack.push(temp);\n                temp = temp.right;\n            }\n            temp = stack.pop();\n            sum +=temp.val;\n            temp.val = sum;\n            temp = temp.left;\n        }\n        return root;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-543-二叉树的直径",frontmatter:{title:"LeetCode-543-二叉树的直径",date:"2020-08-07T09:29:27.000Z",description:"二叉树的直径",tags:["树","DFS","Java","Easy"],keywords:"树,DFS,Java,Easy,LeetCode",permalink:"/pages/a78f8c/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/83.LeetCode-543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84.html",relativePath:"06.算法/02.LeetCode/83.LeetCode-543-二叉树的直径.md",key:"v-5459e177",path:"/pages/a78f8c/",headers:[{level:2,title:"LeetCode-543-二叉树的直径",slug:"leetcode-543-二叉树的直径",normalizedTitle:"leetcode-543-二叉树的直径",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:271},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:420}],headersStr:"LeetCode-543-二叉树的直径 解题思路 Java代码",content:"# LeetCode-543-二叉树的直径\n\n给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。\n\n示例1：\n\n给定二叉树\n\n          1\n         / \\\n        2   3\n       / \\     \n      4   5  \n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。\n\n**注意：**两结点之间的路径长度是以它们之间边的数目表示。\n\n\n# 解题思路\n\n方法1、DFS：\n\n 1. 二叉树的直径是不一定经过root节点的，可能存在于每个子树中，所以需要遍历每个节点的左右子树深度。动态记录最大的直径\n 2. 直径 = max(左子树深度+右子树深度)\n 3. 某节点子树的深度 = max(某节点左子树深度，某节点右子树深度)+1\n\n\n# Java代码\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    private int res = 0;\n    public int diameterOfBinaryTree(TreeNode root) {\n        if(root==null) return 0;\n        calDepth(root);\n        return res;\n    }\n\n    public int calDepth(TreeNode root){\n        if(root==null) return 0;\n        int left = calDepth(root.left);\n        int right = calDepth(root.right);\n        res = Math.max(left+right,res);\n        return Math.max(left,right)+1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n",normalizedContent:"# leetcode-543-二叉树的直径\n\n给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。\n\n示例1：\n\n给定二叉树\n\n          1\n         / \\\n        2   3\n       / \\     \n      4   5  \n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。\n\n**注意：**两结点之间的路径长度是以它们之间边的数目表示。\n\n\n# 解题思路\n\n方法1、dfs：\n\n 1. 二叉树的直径是不一定经过root节点的，可能存在于每个子树中，所以需要遍历每个节点的左右子树深度。动态记录最大的直径\n 2. 直径 = max(左子树深度+右子树深度)\n 3. 某节点子树的深度 = max(某节点左子树深度，某节点右子树深度)+1\n\n\n# java代码\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    private int res = 0;\n    public int diameterofbinarytree(treenode root) {\n        if(root==null) return 0;\n        caldepth(root);\n        return res;\n    }\n\n    public int caldepth(treenode root){\n        if(root==null) return 0;\n        int left = caldepth(root.left);\n        int right = caldepth(root.right);\n        res = math.max(left+right,res);\n        return math.max(left,right)+1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-560-和为K的子数组",frontmatter:{title:"LeetCode-560-和为K的子数组",date:"2020-07-31T17:52:50.000Z",description:"和为K的子数组",tags:["数组","Java","Medium"],keywords:"数组,Java,Medium,LeetCode",permalink:"/pages/c7dca6/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/84.LeetCode-560-%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html",relativePath:"06.算法/02.LeetCode/84.LeetCode-560-和为K的子数组.md",key:"v-52535292",path:"/pages/c7dca6/",headers:[{level:2,title:"LeetCode-560-和为K的子数组",slug:"leetcode-560-和为k的子数组",normalizedTitle:"leetcode-560-和为k的子数组",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:234},{level:3,title:"Java代码1",slug:"java代码1",normalizedTitle:"java代码1",charIndex:981},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:1448}],headersStr:"LeetCode-560-和为K的子数组 解题思路 Java代码1 Java代码2",content:"# LeetCode-560-和为K的子数组\n\n给定一个整数数组和一个整数 **k，**你需要找到该数组中和为 k 的连续的子数组的个数。\n\n示例1：\n\n输入:nums = [1,1,1], k = 2\n输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。\n\n\n1\n2\n\n1\n2\n\n\n说明 :\n\n 1. 数组的长度为 [1, 20,000]。\n 2. 数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。\n\n\n# 解题思路\n\n方法1、暴力累加：\n\n以数组中每一个数字作为起点，不断向后累加，找到一个累加和为k的就让count++\n\n当以下一个数字为起点时，重置sum为0，即可得到最终结果\n\n方法2、哈希表：\n\n更好的题解https://leetcode-cn.com/problems/subarray-sum-equals-k/solution/dai-ni-da-tong-qian-zhui-he-cong-zui-ben-fang-fa-y/\n\n方法1的瓶颈在于对于每个数字i，需要枚举所有的j来判断是否符合条件\n\n这一步其实是可优化的\n\n我们定义sum[i] 为 [0..i] 里所有数的和，则 sum[i]可以由sum[i−1]递推而来，即：sum[i]=sum[i−1]+nums[i]\n\n那么[j..i]这个子数组和为 k这个条件我们可以转化为sum[i]−sum[j−1]==k\n\n简单移项可得符合条件的下标j需要满足sum[j−1]==sum[i]−k\n\n所以我们考虑以i结尾的和为k的连续子数组个数时只要统计有多少个前缀和为 sum[i]−k的 sum[j]即可。我们建立哈希表 mp，以和为键，出现次数为对应的值，记录 sum[i]出现的次数，从左往右边更新 mp边计算答案，那么以 i结尾的答案 mp[sum[i]−k] 即可在 O(1)时间内得到。最后的答案即为所有下标结尾的和为 k的子数组个数之和。\n\n需要注意的是，从左往右边更新边计算的时候已经保证了mp[sum[i]−k]里记录的 sum[j]的下标范围是 0≤j≤i 。同时，由于sum[i]的计算只与前一项的答案有关，因此我们可以不用建立 sum数组，直接用sum变量来记录 sum[i−1] 的答案即可。\n\n\n# Java代码1\n\nclass Solution {\n    public int subarraySum(int[] nums, int k) {\n        int count = 0;\n        for (int i = 0; i < nums.length; i++) {\n            int sum = 0;\n            for (int j = i; j < nums.length; j++) {\n                sum += nums[j];\n                if (sum == k) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# Java代码2\n\nclass Solution {\n    public int subarraySum(int[] nums, int k) {\n        int count = 0;\n        int sum = 0;\n        Map<Integer,Integer> map = new HashMap<>();\n        map.put(0,1);\n        for(int i=0;i<nums.length;i++){\n            sum+=nums[i];\n            // 如果sum-k这个数值之前存在，则需要统计在这个区间内之前的前缀和\n            if(map.containsKey(sum-k)){\n                count+=map.get(sum-k);\n            }\n            // 存储当前的sum值，如果没有就是1，有则获取sum值出现的次数，次数再+1\n            map.put(sum,map.getOrDefault(sum,0)+1);\n        }\n        return count;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n",normalizedContent:"# leetcode-560-和为k的子数组\n\n给定一个整数数组和一个整数 **k，**你需要找到该数组中和为 k 的连续的子数组的个数。\n\n示例1：\n\n输入:nums = [1,1,1], k = 2\n输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。\n\n\n1\n2\n\n1\n2\n\n\n说明 :\n\n 1. 数组的长度为 [1, 20,000]。\n 2. 数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。\n\n\n# 解题思路\n\n方法1、暴力累加：\n\n以数组中每一个数字作为起点，不断向后累加，找到一个累加和为k的就让count++\n\n当以下一个数字为起点时，重置sum为0，即可得到最终结果\n\n方法2、哈希表：\n\n更好的题解https://leetcode-cn.com/problems/subarray-sum-equals-k/solution/dai-ni-da-tong-qian-zhui-he-cong-zui-ben-fang-fa-y/\n\n方法1的瓶颈在于对于每个数字i，需要枚举所有的j来判断是否符合条件\n\n这一步其实是可优化的\n\n我们定义sum[i] 为 [0..i] 里所有数的和，则 sum[i]可以由sum[i−1]递推而来，即：sum[i]=sum[i−1]+nums[i]\n\n那么[j..i]这个子数组和为 k这个条件我们可以转化为sum[i]−sum[j−1]==k\n\n简单移项可得符合条件的下标j需要满足sum[j−1]==sum[i]−k\n\n所以我们考虑以i结尾的和为k的连续子数组个数时只要统计有多少个前缀和为 sum[i]−k的 sum[j]即可。我们建立哈希表 mp，以和为键，出现次数为对应的值，记录 sum[i]出现的次数，从左往右边更新 mp边计算答案，那么以 i结尾的答案 mp[sum[i]−k] 即可在 o(1)时间内得到。最后的答案即为所有下标结尾的和为 k的子数组个数之和。\n\n需要注意的是，从左往右边更新边计算的时候已经保证了mp[sum[i]−k]里记录的 sum[j]的下标范围是 0≤j≤i 。同时，由于sum[i]的计算只与前一项的答案有关，因此我们可以不用建立 sum数组，直接用sum变量来记录 sum[i−1] 的答案即可。\n\n\n# java代码1\n\nclass solution {\n    public int subarraysum(int[] nums, int k) {\n        int count = 0;\n        for (int i = 0; i < nums.length; i++) {\n            int sum = 0;\n            for (int j = i; j < nums.length; j++) {\n                sum += nums[j];\n                if (sum == k) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# java代码2\n\nclass solution {\n    public int subarraysum(int[] nums, int k) {\n        int count = 0;\n        int sum = 0;\n        map<integer,integer> map = new hashmap<>();\n        map.put(0,1);\n        for(int i=0;i<nums.length;i++){\n            sum+=nums[i];\n            // 如果sum-k这个数值之前存在，则需要统计在这个区间内之前的前缀和\n            if(map.containskey(sum-k)){\n                count+=map.get(sum-k);\n            }\n            // 存储当前的sum值，如果没有就是1，有则获取sum值出现的次数，次数再+1\n            map.put(sum,map.getordefault(sum,0)+1);\n        }\n        return count;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-567-字符串的排列",frontmatter:{title:"LeetCode-567-字符串的排列",date:"2020-08-18T15:30:45.000Z",description:"字符串的排列",tags:["字符串","滑动窗口","Java","Medium"],keywords:"字符串,滑动窗口,Java,Medium,LeetCode",permalink:"/pages/5997b7/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/85.LeetCode-567-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97.html",relativePath:"06.算法/02.LeetCode/85.LeetCode-567-字符串的排列.md",key:"v-52132daa",path:"/pages/5997b7/",headers:[{level:2,title:"LeetCode-567-字符串的排列",slug:"leetcode-567-字符串的排列",normalizedTitle:"leetcode-567-字符串的排列",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:298},{level:3,title:"Java代码1",slug:"java代码1",normalizedTitle:"java代码1",charIndex:508}],headersStr:"LeetCode-567-字符串的排列 解题思路 Java代码1",content:"# LeetCode-567-字符串的排列\n\n给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。\n\n换句话说，第一个字符串的排列之一是第二个字符串的子串。\n\n示例1：\n\n输入: s1 = \"ab\" s2 = \"eidbaooo\"\n输出: True\n解释: s2 包含 s1 的排列之一 (\"ba\").\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2：\n\n输入: s1= \"ab\" s2 = \"eidboaoo\"\n输出: False\n\n\n1\n2\n\n1\n2\n\n\n注意：\n\n 1. 输入的字符串只包含小写字母\n 2. 两个字符串的长度都在 [1, 10,000] 之间\n\n\n# 解题思路\n\n方法1、滑动窗口(套模版)：\n\nhttps://leetcode-cn.com/problems/permutation-in-string/solution/wo-xie-liao-yi-shou-shi-ba-suo-you-hua-dong-chuang/\n\n方法2、滑动窗口(数组优化)：\n\n由于都是小写字符，所以初始化两个数组作为need和window，剩余步骤依旧按照模版走，详见注释。\n\n\n# Java代码1\n\nclass Solution {\n    public boolean checkInclusion(String s1, String s2) {\n        Map<Character,Integer> need =new HashMap<>();\n        Map<Character,Integer> window =new HashMap<>();\n        for(char c:s1.toCharArray()) \n            need.put(c,need.getOrDefault(c,0)+1);\n        int left = 0,right = 0;\n        int valid = 0;\n        int start=0,len =Integer.MAX_VALUE;\n        while(right < s2.length()){\n            char c = s2.charAt(right);\n            right++;\n            if(need.containsKey(c)){\n                window.put(c,window.getOrDefault(c,0)+1);\n                if((int)window.get(c) ==(int) need.get(c)){\n                    valid++;\n                }\n            }\n            while(right-left == s1.length()){\n                if(valid == need.size()){\n                    return true;\n                }\n                char d = s2.charAt(left);\n                left++;\n                if(need.containsKey(d)){\n                    if((int)window.get(d) == (int)need.get(d)){\n                        valid--;\n                    }\n                    window.put(d,window.get(d)-1);\n                }\n            }\n        }\n\n        return false;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n###Java代码2\n\nclass Solution {\n    public boolean checkInclusion(String s1, String s2) {\n        char[] arrS1 = s1.toCharArray();\n        char[] arrS2 = s2.toCharArray();\n        int[] needs = new int[26];\n        int[] window = new int[26]; \n        int cntChar = 0; // 有效字母个数(不同的字母个数)\n        for(char c: arrS1){\n            if(needs[c-'a']==0) cntChar++;// 如果该字母第一次出现，记录下来\n            needs[c-'a']+=1;\n        }\n        int left = 0;\n        int right = 0;\n        int valid = 0;\n        while(right < arrS2.length){\n            char c = arrS2[right];\n            // 对窗口内数据进行一系列更新\n            window[c-'a']+=1;\n            if(window[c-'a']==needs[c-'a']){\n                valid++;\n            }\n            // 当窗口扩散到包含s1时，进行左边界收缩\n            while(cntChar==valid){\n                // 如果窗口大小为s1的长度，则说明找到了\n                if(right-left+1==arrS1.length){\n                    return true;\n                }\n                \n                char d = arrS2[left];\n                // 窗口缩小，对应字符出现次数-1\n                window[d-'a']-=1;\n                // 当字符次数小于s1中字符出现次数时，则说明窗口达到包含s1字符的最小窗口\n                if(window[d-'a']<needs[d-'a']){\n                    valid--;\n                }\n                left++;\n            }\n            right++;\n        }\n        return false;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n",normalizedContent:"# leetcode-567-字符串的排列\n\n给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。\n\n换句话说，第一个字符串的排列之一是第二个字符串的子串。\n\n示例1：\n\n输入: s1 = \"ab\" s2 = \"eidbaooo\"\n输出: true\n解释: s2 包含 s1 的排列之一 (\"ba\").\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2：\n\n输入: s1= \"ab\" s2 = \"eidboaoo\"\n输出: false\n\n\n1\n2\n\n1\n2\n\n\n注意：\n\n 1. 输入的字符串只包含小写字母\n 2. 两个字符串的长度都在 [1, 10,000] 之间\n\n\n# 解题思路\n\n方法1、滑动窗口(套模版)：\n\nhttps://leetcode-cn.com/problems/permutation-in-string/solution/wo-xie-liao-yi-shou-shi-ba-suo-you-hua-dong-chuang/\n\n方法2、滑动窗口(数组优化)：\n\n由于都是小写字符，所以初始化两个数组作为need和window，剩余步骤依旧按照模版走，详见注释。\n\n\n# java代码1\n\nclass solution {\n    public boolean checkinclusion(string s1, string s2) {\n        map<character,integer> need =new hashmap<>();\n        map<character,integer> window =new hashmap<>();\n        for(char c:s1.tochararray()) \n            need.put(c,need.getordefault(c,0)+1);\n        int left = 0,right = 0;\n        int valid = 0;\n        int start=0,len =integer.max_value;\n        while(right < s2.length()){\n            char c = s2.charat(right);\n            right++;\n            if(need.containskey(c)){\n                window.put(c,window.getordefault(c,0)+1);\n                if((int)window.get(c) ==(int) need.get(c)){\n                    valid++;\n                }\n            }\n            while(right-left == s1.length()){\n                if(valid == need.size()){\n                    return true;\n                }\n                char d = s2.charat(left);\n                left++;\n                if(need.containskey(d)){\n                    if((int)window.get(d) == (int)need.get(d)){\n                        valid--;\n                    }\n                    window.put(d,window.get(d)-1);\n                }\n            }\n        }\n\n        return false;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n###java代码2\n\nclass solution {\n    public boolean checkinclusion(string s1, string s2) {\n        char[] arrs1 = s1.tochararray();\n        char[] arrs2 = s2.tochararray();\n        int[] needs = new int[26];\n        int[] window = new int[26]; \n        int cntchar = 0; // 有效字母个数(不同的字母个数)\n        for(char c: arrs1){\n            if(needs[c-'a']==0) cntchar++;// 如果该字母第一次出现，记录下来\n            needs[c-'a']+=1;\n        }\n        int left = 0;\n        int right = 0;\n        int valid = 0;\n        while(right < arrs2.length){\n            char c = arrs2[right];\n            // 对窗口内数据进行一系列更新\n            window[c-'a']+=1;\n            if(window[c-'a']==needs[c-'a']){\n                valid++;\n            }\n            // 当窗口扩散到包含s1时，进行左边界收缩\n            while(cntchar==valid){\n                // 如果窗口大小为s1的长度，则说明找到了\n                if(right-left+1==arrs1.length){\n                    return true;\n                }\n                \n                char d = arrs2[left];\n                // 窗口缩小，对应字符出现次数-1\n                window[d-'a']-=1;\n                // 当字符次数小于s1中字符出现次数时，则说明窗口达到包含s1字符的最小窗口\n                if(window[d-'a']<needs[d-'a']){\n                    valid--;\n                }\n                left++;\n            }\n            right++;\n        }\n        return false;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-581-最短无序连续子数组",frontmatter:{title:"LeetCode-581-最短无序连续子数组",date:"2020-07-14T10:03:46.000Z",description:"最短无序连续子数组",tags:["Java","数组","Easy"],keywords:"Java,数组,Easy,LeetCode",permalink:"/pages/9686ce/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/86.LeetCode-581-%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84.html",relativePath:"06.算法/02.LeetCode/86.LeetCode-581-最短无序连续子数组.md",key:"v-6830aa98",path:"/pages/9686ce/",headers:[{level:2,title:"LeetCode-581-最短无序连续子数组",slug:"leetcode-581-最短无序连续子数组",normalizedTitle:"leetcode-581-最短无序连续子数组",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:283},{level:3,title:"Java代码1",slug:"java代码1",normalizedTitle:"java代码1",charIndex:928},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:1461}],headersStr:"LeetCode-581-最短无序连续子数组 解题思路 Java代码1 Java代码2",content:"# LeetCode-581-最短无序连续子数组\n\n给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。\n\n你找到的子数组应是最短的，请输出它的长度。\n\n示例1：\n\n输入: [2, 6, 4, 8, 10, 9, 15]\n输出: 5\n解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n说明 :\n\n 1. 输入的数组长度范围在 [1, 10,000]。\n 2. 输入的数组可能包含重复元素 ，所以升序的意思是**<=。**\n\n\n# 解题思路\n\n方法1、排序比较：\n\n先给数组排序，然后进行一一比较，遇到不相等的位置就更新start和end\n\nstart始终靠最小值比较，end始终靠最大值比较\n\n之后就能够通过end-start+1得到未排序子数组的长度\n\n特例判断：只有当end-start+1>=0时，长度计算有效，否则为0\n\n方法2、双指针找边界：\n\n初步思路是，使用双指针，指针i从头开始遍历，指针j从尾开始遍历。分别找到第一个逆序的位置，之后返回长度即可，但这种方法不适用于数组中有重复的数字的情况，如[1,6,5,5]，这使得逆序位置的判断失效。\n\n于是换一种思路，让指针分别找到最后逆序的位置\n\n同时从前往后和从后往前遍历，分别得到要排序数组的右边界和左边界； 寻找右边界： 从前往后遍历的过程中，用max记录遍历过的最大值，如果max大于当前的nums[i]，说明nums[i]的位置不正确，属于需要排序的数组，因此将右边界更新为i，然后更新max；这样最终可以找到需要排序的数组的右边界，右边界之后的元素都大于max； 寻找左边界： 从后往前遍历的过程中，用min记录遍历过的最小值，如果min小于当前的nums[j]，说明nums[j]的位置不正确，应该属于需要排序的数组，因此将左边界更新为j，然后更新min；这样最终可以找到需要排序的数组的左边界，左边界之前的元素都小于min； （从前往后遍历和从后往前遍历两个过程可以分两次循环完成，也可以放一起完成，这样的话就有：j=len-i-1）\n\n\n# Java代码1\n\nclass Solution {\n    public int findUnsortedSubarray(int[] nums) {\n        int[] temp = nums.clone();\n        Arrays.sort(temp);\n        int start = temp.length;\n        int end = 0;\n        for (int i = 0; i < temp.length; i++) {\n            if (nums[i] != temp[i]) {\n                start = Math.min(start, i);\n                end = Math.max(end, i);\n            }\n        }\n        return end - start + 1 >= 0 ? end - start + 1 : 0;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# Java代码2\n\nclass Solution {\n    public int findUnsortedSubarray(int[] nums) {\n        int len = nums.length;\n        int max = nums[0];\n        int min = nums[len-1];\n        int l = 0, r = -1;\n        for(int i=0;i<len;i++){\n            if(max>nums[i]){\n                r = i;\n            }else{\n                max = nums[i];\n            }\n            if(min<nums[len-i-1]){\n                l = len-i-1;\n            }else{\n                min = nums[len-i-1];\n            }\n        }\n        return r-l+1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n",normalizedContent:"# leetcode-581-最短无序连续子数组\n\n给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。\n\n你找到的子数组应是最短的，请输出它的长度。\n\n示例1：\n\n输入: [2, 6, 4, 8, 10, 9, 15]\n输出: 5\n解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n说明 :\n\n 1. 输入的数组长度范围在 [1, 10,000]。\n 2. 输入的数组可能包含重复元素 ，所以升序的意思是**<=。**\n\n\n# 解题思路\n\n方法1、排序比较：\n\n先给数组排序，然后进行一一比较，遇到不相等的位置就更新start和end\n\nstart始终靠最小值比较，end始终靠最大值比较\n\n之后就能够通过end-start+1得到未排序子数组的长度\n\n特例判断：只有当end-start+1>=0时，长度计算有效，否则为0\n\n方法2、双指针找边界：\n\n初步思路是，使用双指针，指针i从头开始遍历，指针j从尾开始遍历。分别找到第一个逆序的位置，之后返回长度即可，但这种方法不适用于数组中有重复的数字的情况，如[1,6,5,5]，这使得逆序位置的判断失效。\n\n于是换一种思路，让指针分别找到最后逆序的位置\n\n同时从前往后和从后往前遍历，分别得到要排序数组的右边界和左边界； 寻找右边界： 从前往后遍历的过程中，用max记录遍历过的最大值，如果max大于当前的nums[i]，说明nums[i]的位置不正确，属于需要排序的数组，因此将右边界更新为i，然后更新max；这样最终可以找到需要排序的数组的右边界，右边界之后的元素都大于max； 寻找左边界： 从后往前遍历的过程中，用min记录遍历过的最小值，如果min小于当前的nums[j]，说明nums[j]的位置不正确，应该属于需要排序的数组，因此将左边界更新为j，然后更新min；这样最终可以找到需要排序的数组的左边界，左边界之前的元素都小于min； （从前往后遍历和从后往前遍历两个过程可以分两次循环完成，也可以放一起完成，这样的话就有：j=len-i-1）\n\n\n# java代码1\n\nclass solution {\n    public int findunsortedsubarray(int[] nums) {\n        int[] temp = nums.clone();\n        arrays.sort(temp);\n        int start = temp.length;\n        int end = 0;\n        for (int i = 0; i < temp.length; i++) {\n            if (nums[i] != temp[i]) {\n                start = math.min(start, i);\n                end = math.max(end, i);\n            }\n        }\n        return end - start + 1 >= 0 ? end - start + 1 : 0;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# java代码2\n\nclass solution {\n    public int findunsortedsubarray(int[] nums) {\n        int len = nums.length;\n        int max = nums[0];\n        int min = nums[len-1];\n        int l = 0, r = -1;\n        for(int i=0;i<len;i++){\n            if(max>nums[i]){\n                r = i;\n            }else{\n                max = nums[i];\n            }\n            if(min<nums[len-i-1]){\n                l = len-i-1;\n            }else{\n                min = nums[len-i-1];\n            }\n        }\n        return r-l+1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-617-合并二叉树",frontmatter:{title:"LeetCode-617-合并二叉树",date:"2020-07-06T15:48:22.000Z",description:"合并二叉树",tags:["树","Java","Easy"],keywords:"树,Java,Easy,LeetCode",permalink:"/pages/f24660/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/87.LeetCode-617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91.html",relativePath:"06.算法/02.LeetCode/87.LeetCode-617-合并二叉树.md",key:"v-72503416",path:"/pages/f24660/",headers:[{level:2,title:"LeetCode-617-合并二叉树",slug:"leetcode-617-合并二叉树",normalizedTitle:"leetcode-617-合并二叉树",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:690},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:1011},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:1586}],headersStr:"LeetCode-617-合并二叉树 解题思路 Java代码 Java代码2",content:"# LeetCode-617-合并二叉树\n\n给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。\n\n你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。\n\n示例1：\n\n输入: \n\tTree 1                     Tree 2                  \n          1                         2                             \n         / \\                       / \\                            \n        3   2                     1   3                        \n       /                           \\   \\                      \n      5                             4   7                  \n输出: \n合并后的树:\n\t     3\n\t    / \\\n\t   4   5\n\t  / \\   \\ \n\t 5   4   7\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n注意: 合并必须从两个树的根节点开始。\n\n\n# 解题思路\n\n方法1、递归：\n\n合并两个树可以按照前序遍历的方式进行合并\n\n当节点t1为空时，返回t2，当t2为空时，返回t1\n\n每次合并需要将对应的节点值相加\n\n递归进行左子树和右子树的构建即可\n\n方法2、迭代：\n\n用一个stack存储两棵树的节点，将树的根节点t1,t2放入stack中，当stack不为空的时候\n\n当任意一棵树的节点为空的时候，直接跳过\n\n当两者不为空时，进行节点值相加，当前两个节点判断完毕，之后进行左子节点和右子节点的判断\n\n当左子节点/右子节点为空时，说明该位置没有左/右节点，直接拼接左右子树的节点\n\n当左子节点/右子节点不为空时，将两棵树的左节点或者右节点都添加进stack中\n\n最后返回t1根节点即可\n\n\n# Java代码\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\n        if(t1==null) return t2;\n        if(t2==null) return t1;\n        t1.val+=t2.val;\n        t1.left = mergeTrees(t1.left,t2.left);\n        t1.right = mergeTrees(t1.right,t2.right);\n        return t1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# Java代码2\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\n        if(t1==null) return t2;\n        if(t2==null) return t1;\n        Stack<TreeNode[]> stack = new Stack<>();\n        stack.push(new TreeNode[] {t1, t2});\n        while(!stack.isEmpty()){\n            TreeNode[] temp = stack.pop();\n            if(temp[0]==null||temp[1]==null){\n                continue;\n            }\n            temp[0].val+=temp[1].val;\n            if(temp[0].left==null){\n                temp[0].left = temp[1].left;\n            }else{\n                stack.push(new TreeNode[]{temp[0].left,temp[1].left});\n            }\n            if(temp[0].right==null){\n                temp[0].right = temp[1].right;\n            }else{\n                stack.push(new TreeNode[]{temp[0].right,temp[1].right});\n            }\n        }\n        return t1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n",normalizedContent:"# leetcode-617-合并二叉树\n\n给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。\n\n你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 null 的节点将直接作为新二叉树的节点。\n\n示例1：\n\n输入: \n\ttree 1                     tree 2                  \n          1                         2                             \n         / \\                       / \\                            \n        3   2                     1   3                        \n       /                           \\   \\                      \n      5                             4   7                  \n输出: \n合并后的树:\n\t     3\n\t    / \\\n\t   4   5\n\t  / \\   \\ \n\t 5   4   7\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n注意: 合并必须从两个树的根节点开始。\n\n\n# 解题思路\n\n方法1、递归：\n\n合并两个树可以按照前序遍历的方式进行合并\n\n当节点t1为空时，返回t2，当t2为空时，返回t1\n\n每次合并需要将对应的节点值相加\n\n递归进行左子树和右子树的构建即可\n\n方法2、迭代：\n\n用一个stack存储两棵树的节点，将树的根节点t1,t2放入stack中，当stack不为空的时候\n\n当任意一棵树的节点为空的时候，直接跳过\n\n当两者不为空时，进行节点值相加，当前两个节点判断完毕，之后进行左子节点和右子节点的判断\n\n当左子节点/右子节点为空时，说明该位置没有左/右节点，直接拼接左右子树的节点\n\n当左子节点/右子节点不为空时，将两棵树的左节点或者右节点都添加进stack中\n\n最后返回t1根节点即可\n\n\n# java代码\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public treenode mergetrees(treenode t1, treenode t2) {\n        if(t1==null) return t2;\n        if(t2==null) return t1;\n        t1.val+=t2.val;\n        t1.left = mergetrees(t1.left,t2.left);\n        t1.right = mergetrees(t1.right,t2.right);\n        return t1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# java代码2\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public treenode mergetrees(treenode t1, treenode t2) {\n        if(t1==null) return t2;\n        if(t2==null) return t1;\n        stack<treenode[]> stack = new stack<>();\n        stack.push(new treenode[] {t1, t2});\n        while(!stack.isempty()){\n            treenode[] temp = stack.pop();\n            if(temp[0]==null||temp[1]==null){\n                continue;\n            }\n            temp[0].val+=temp[1].val;\n            if(temp[0].left==null){\n                temp[0].left = temp[1].left;\n            }else{\n                stack.push(new treenode[]{temp[0].left,temp[1].left});\n            }\n            if(temp[0].right==null){\n                temp[0].right = temp[1].right;\n            }else{\n                stack.push(new treenode[]{temp[0].right,temp[1].right});\n            }\n        }\n        return t1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-704-二分查找",frontmatter:{title:"LeetCode-704-二分查找",date:"2020-04-10T15:44:53.000Z",description:"二分查找",tags:["查找","Java","Python","Easy"],keywords:"查找,Java,Python,Easy",permalink:"/pages/326143/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/88.LeetCode-704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html",relativePath:"06.算法/02.LeetCode/88.LeetCode-704-二分查找.md",key:"v-617dbfbc",path:"/pages/326143/",headers:[{level:2,title:"LeetCode-704-二分查找",slug:"leetcode-704-二分查找",normalizedTitle:"leetcode-704-二分查找",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:385},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:513},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:1214}],headersStr:"LeetCode-704-二分查找 解题思路 Java代码 Python代码",content:'# LeetCode-704-二分查找\n\n给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。\n\n示例1\n\n输入: nums = [-1,0,3,5,9,12], target = 9\n输出: 4\n解释: 9 出现在 nums 中并且下标为 4\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2\n\n输入: nums = [-1,0,3,5,9,12], target = 2\n输出: -1\n解释: 2 不存在 nums 中因此返回 -1\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n提示：\n\n * 你可以假设 nums 中的所有元素是不重复的。\n * n 将在 [1, 10000]之间。\n * nums 的每个元素都将在 [-9999, 9999]之间。`\n\n\n# 解题思路\n\n二分查找是一个基本算法，简单来说就是头尾2个指针，看中间数比查找数大还是小，大的话说明要在右边范围找，小的话就要在左边范围找。\n\n**注意：**防止直接相加int溢出，取中点mid时，可采用start+(end-start)/2的方式\n\n\n# Java代码\n\nclass Solution {\n    public int search(int[] nums, int target) {\n        if (nums.length == 0) {\n            return -1;\n        }\n        int start = 0;\n        int end = nums.length - 1;\n        while (start <= end) {\n            // 防止int溢出\n            // int mid = start + (end - start) / 2;\n            int middle = (start + end) / 2;\n            if (target == nums[middle])\n                return middle;\n            else if (target < nums[middle])\n                end = middle - 1;\n            else\n                start = middle + 1;\n        }\n        return -1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# Python代码\n\nclass Solution(object):\n    def search(self, nums, target):\n        """\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        """\n        if (len(nums)==0):\n            return -1\n        start,end = 0,len(nums)-1\n        while(start<=end):\n            middle = (start+end)/2\n            if target==nums[middle]:\n                return middle\n            elif target<nums[middle]:\n                end = middle-1\n            else:\n                start = middle+1\n        return -1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n',normalizedContent:'# leetcode-704-二分查找\n\n给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。\n\n示例1\n\n输入: nums = [-1,0,3,5,9,12], target = 9\n输出: 4\n解释: 9 出现在 nums 中并且下标为 4\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2\n\n输入: nums = [-1,0,3,5,9,12], target = 2\n输出: -1\n解释: 2 不存在 nums 中因此返回 -1\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n提示：\n\n * 你可以假设 nums 中的所有元素是不重复的。\n * n 将在 [1, 10000]之间。\n * nums 的每个元素都将在 [-9999, 9999]之间。`\n\n\n# 解题思路\n\n二分查找是一个基本算法，简单来说就是头尾2个指针，看中间数比查找数大还是小，大的话说明要在右边范围找，小的话就要在左边范围找。\n\n**注意：**防止直接相加int溢出，取中点mid时，可采用start+(end-start)/2的方式\n\n\n# java代码\n\nclass solution {\n    public int search(int[] nums, int target) {\n        if (nums.length == 0) {\n            return -1;\n        }\n        int start = 0;\n        int end = nums.length - 1;\n        while (start <= end) {\n            // 防止int溢出\n            // int mid = start + (end - start) / 2;\n            int middle = (start + end) / 2;\n            if (target == nums[middle])\n                return middle;\n            else if (target < nums[middle])\n                end = middle - 1;\n            else\n                start = middle + 1;\n        }\n        return -1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# python代码\n\nclass solution(object):\n    def search(self, nums, target):\n        """\n        :type nums: list[int]\n        :type target: int\n        :rtype: int\n        """\n        if (len(nums)==0):\n            return -1\n        start,end = 0,len(nums)-1\n        while(start<=end):\n            middle = (start+end)/2\n            if target==nums[middle]:\n                return middle\n            elif target<nums[middle]:\n                end = middle-1\n            else:\n                start = middle+1\n        return -1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-739-每日温度",frontmatter:{title:"LeetCode-739-每日温度",date:"2020-07-16T09:33:43.000Z",description:"每日温度",tags:["数组","栈","Java","Medium"],keywords:"数组,栈,Java,Medium,LeetCode",permalink:"/pages/d7d595/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/89.LeetCode-739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6.html",relativePath:"06.算法/02.LeetCode/89.LeetCode-739-每日温度.md",key:"v-7cea714c",path:"/pages/d7d595/",headers:[{level:2,title:"LeetCode-739-每日温度",slug:"leetcode-739-每日温度",normalizedTitle:"leetcode-739-每日温度",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:255},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:480},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:1019}],headersStr:"LeetCode-739-每日温度 解题思路 Java代码 Java代码2",content:"# LeetCode-739-每日温度\n\n请根据每日气温列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。\n\n例如，给定一个列表temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。\n\n提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100]范围内的整数。\n\n\n# 解题思路\n\n方法1、暴力破解：\n\n顺序遍历数组，固定第一个数，往后找比他大的数的位置，位置之差就是新数组中该数位置的值。之后固定第二个...直到数组结束\n\n方法2、单调栈：\n\n使用一个栈存储元素下标，当栈内有元素(不为空)，且新温度大于栈顶元素时，弹出栈顶元素，计算下标差值，作为栈顶元素位置的值。\n\n继续看新的栈顶元素，直到当前数字小于等于栈顶元素停止，然后将数字入栈，这样就可以保持递减栈，且每个数字和第一个大于它的数的距离也可以算出来\n\n\n# Java代码\n\nclass Solution {\n    public int[] dailyTemperatures(int[] T) {\n        int len = T.length;\n        int[] dp = new int[len];\n        for (int i = 0; i < len; i++) {\n            int j = i;\n            while (j < len) {\n                if (T[i] < T[j]) {\n                    dp[i] = j - i;\n                    break;\n                } else {\n                    j++;\n                }\n            }\n        }\n        return dp;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# Java代码2\n\nclass Solution {\n    public int[] dailyTemperatures(int[] T) {\n        Stack<Integer> stack = new Stack<>();\n        int len = T.length;\n        int[] res = new int[len];\n        for(int i=0;i<len;i++){\n            while(!stack.isEmpty()&&T[i]>T[stack.peek()]){\n                int pre = stack.pop();\n                res[pre] = i-pre;\n            }\n            stack.add(i);\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n",normalizedContent:"# leetcode-739-每日温度\n\n请根据每日气温列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。\n\n例如，给定一个列表temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。\n\n提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100]范围内的整数。\n\n\n# 解题思路\n\n方法1、暴力破解：\n\n顺序遍历数组，固定第一个数，往后找比他大的数的位置，位置之差就是新数组中该数位置的值。之后固定第二个...直到数组结束\n\n方法2、单调栈：\n\n使用一个栈存储元素下标，当栈内有元素(不为空)，且新温度大于栈顶元素时，弹出栈顶元素，计算下标差值，作为栈顶元素位置的值。\n\n继续看新的栈顶元素，直到当前数字小于等于栈顶元素停止，然后将数字入栈，这样就可以保持递减栈，且每个数字和第一个大于它的数的距离也可以算出来\n\n\n# java代码\n\nclass solution {\n    public int[] dailytemperatures(int[] t) {\n        int len = t.length;\n        int[] dp = new int[len];\n        for (int i = 0; i < len; i++) {\n            int j = i;\n            while (j < len) {\n                if (t[i] < t[j]) {\n                    dp[i] = j - i;\n                    break;\n                } else {\n                    j++;\n                }\n            }\n        }\n        return dp;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# java代码2\n\nclass solution {\n    public int[] dailytemperatures(int[] t) {\n        stack<integer> stack = new stack<>();\n        int len = t.length;\n        int[] res = new int[len];\n        for(int i=0;i<len;i++){\n            while(!stack.isempty()&&t[i]>t[stack.peek()]){\n                int pre = stack.pop();\n                res[pre] = i-pre;\n            }\n            stack.add(i);\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-747-至少是其他数字两倍的最大数",frontmatter:{title:"LeetCode-747-至少是其他数字两倍的最大数",date:"2020-03-19T19:00:16.000Z",description:"至少是其他数字两倍的最大数",tags:["数组","Java","Python","Easy"],keywords:"数组,Java,Python,Easy",permalink:"/pages/0343b2/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/90.LeetCode-747-%E8%87%B3%E5%B0%91%E6%98%AF%E5%85%B6%E4%BB%96%E6%95%B0%E5%AD%97%E4%B8%A4%E5%80%8D%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0.html",relativePath:"06.算法/02.LeetCode/90.LeetCode-747-至少是其他数字两倍的最大数.md",key:"v-a188cbf8",path:"/pages/0343b2/",headers:[{level:2,title:"LeetCode-747-至少是其他数字两倍的最大数",slug:"leetcode-747-至少是其他数字两倍的最大数",normalizedTitle:"leetcode-747-至少是其他数字两倍的最大数",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:374},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:496},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:1069}],headersStr:"LeetCode-747-至少是其他数字两倍的最大数 解题思路 Java代码 Python代码",content:'# LeetCode-747-至少是其他数字两倍的最大数\n\n在一个给定的数组nums中，总是存在一个最大元素 。\n\n查找数组中的最大元素是否至少是数组中每个其他数字的两倍。\n\n如果是，则返回最大元素的索引，否则返回-1。\n\n示例 1:\n\n输入: nums = [3, 6, 1, 0]\n输出: 1\n解释: 6是最大的整数, 对于数组中的其他整数,\n6大于数组中其他元素的两倍。6的索引是1, 所以我们返回1.\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n示例 2:\n\n输入: nums = [1, 2, 3, 4]\n输出: -1\n解释: 4没有超过3的两倍大, 所以我们返回 -1. \n\n\n1\n2\n3\n\n1\n2\n3\n\n\n提示:\n\n 1. nums 的长度范围在[1, 50].\n 2. 每个 nums[i] 的整数范围在 [0, 100].\n\n\n# 解题思路\n\n想要找最大数至少大于所有其他数的两倍，只需要知道最大数比次大数大两倍就可以了，一次遍历用两个参数分别记录最大数和次大数，在当前索引比最大数大的时候，次大数的数值也应该变为原本的最大数，比最大数小的时候判断是否大于次大数即可\n\n\n# Java代码\n\nclass Solution {\n    public int dominantIndex(int[] nums) {\n        int max = 0;\n        int sec_max = 0;\n        int max_index = -1;\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] > max) {\n                sec_max = max;\n                max = nums[i];\n                max_index = i;\n            } else if (nums[i] > sec_max) {\n                sec_max = nums[i];\n            }\n        }\n        return max >= (2 * sec_max) ? max_index : -1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# Python代码\n\nclass Solution(object):\n    def dominantIndex(self, nums):\n        """\n        :type nums: List[int]\n        :rtype: int\n        """\n        max, sec_max, max_index = 0, 0, 0\n        for index, i in enumerate(nums):\n            if i > max:\n                sec_max = max\n                max = i\n                max_index = index\n            elif i > sec_max:\n                sec_max = i\n        return (max_index if (max >= 2 * sec_max) else -1)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n',normalizedContent:'# leetcode-747-至少是其他数字两倍的最大数\n\n在一个给定的数组nums中，总是存在一个最大元素 。\n\n查找数组中的最大元素是否至少是数组中每个其他数字的两倍。\n\n如果是，则返回最大元素的索引，否则返回-1。\n\n示例 1:\n\n输入: nums = [3, 6, 1, 0]\n输出: 1\n解释: 6是最大的整数, 对于数组中的其他整数,\n6大于数组中其他元素的两倍。6的索引是1, 所以我们返回1.\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n示例 2:\n\n输入: nums = [1, 2, 3, 4]\n输出: -1\n解释: 4没有超过3的两倍大, 所以我们返回 -1. \n\n\n1\n2\n3\n\n1\n2\n3\n\n\n提示:\n\n 1. nums 的长度范围在[1, 50].\n 2. 每个 nums[i] 的整数范围在 [0, 100].\n\n\n# 解题思路\n\n想要找最大数至少大于所有其他数的两倍，只需要知道最大数比次大数大两倍就可以了，一次遍历用两个参数分别记录最大数和次大数，在当前索引比最大数大的时候，次大数的数值也应该变为原本的最大数，比最大数小的时候判断是否大于次大数即可\n\n\n# java代码\n\nclass solution {\n    public int dominantindex(int[] nums) {\n        int max = 0;\n        int sec_max = 0;\n        int max_index = -1;\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] > max) {\n                sec_max = max;\n                max = nums[i];\n                max_index = i;\n            } else if (nums[i] > sec_max) {\n                sec_max = nums[i];\n            }\n        }\n        return max >= (2 * sec_max) ? max_index : -1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# python代码\n\nclass solution(object):\n    def dominantindex(self, nums):\n        """\n        :type nums: list[int]\n        :rtype: int\n        """\n        max, sec_max, max_index = 0, 0, 0\n        for index, i in enumerate(nums):\n            if i > max:\n                sec_max = max\n                max = i\n                max_index = index\n            elif i > sec_max:\n                sec_max = i\n        return (max_index if (max >= 2 * sec_max) else -1)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-890-查找和替换模式",frontmatter:{title:"LeetCode-890-查找和替换模式",date:"2020-07-26T17:00:32.000Z",description:"查找和替换模式",tags:["数组","Java","Medium"],keywords:"数组,Java,Medium,LeetCode",permalink:"/pages/a29fa8/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/91.LeetCode-890-%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9B%BF%E6%8D%A2%E6%A8%A1%E5%BC%8F.html",relativePath:"06.算法/02.LeetCode/91.LeetCode-890-查找和替换模式.md",key:"v-1786b60e",path:"/pages/a29fa8/",headers:[{level:2,title:"LeetCode-890-查找和替换模式",slug:"leetcode-890-查找和替换模式",normalizedTitle:"leetcode-890-查找和替换模式",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:546},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:689}],headersStr:"LeetCode-890-查找和替换模式 解题思路 Java代码",content:'# LeetCode-890-查找和替换模式\n\n你有一个单词列表 words 和一个模式 pattern，你想知道 words 中的哪些单词与模式匹配。\n\n如果存在字母的排列 p ，使得将模式中的每个字母 x 替换为 p(x) 之后，我们就得到了所需的单词，那么单词与模式是匹配的。\n\n（回想一下，字母的排列是从字母到字母的双射：每个字母映射到另一个字母，没有两个字母映射到同一个字母。）\n\n返回 words 中与给定模式匹配的单词列表。\n\n你可以按任何顺序返回答案。\n\n示例1：\n\n输入：words = ["abc","deq","mee","aqq","dkd","ccc"], pattern = "abb"\n输出：["mee","aqq"]\n解释：\n"mee" 与模式匹配，因为存在排列 {a -> m, b -> e, ...}。\n"ccc" 与模式不匹配，因为 {a -> c, b -> c, ...} 不是排列。\n因为 a 和 b 映射到同一个字母。\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n提示：\n\n * 1 <= words.length <= 50\n * 1 <= pattern.length = words[i].length <= 20\n\n\n# 解题思路\n\n我们可以用两个映射表（map）存储字母到字母的映射关系，第一个映射表保证一个字母不会映射到两个字母，第二个映射表保证不会有两个字母映射到同一个字母。例如 word 为 a，pattern 为 x，那么第一个映射表存储 a -> x，第二个映射表存储 x -> a。\n\n\n# Java代码\n\nclass Solution {\n    public List<String> findAndReplacePattern(String[] words, String pattern) {\n        List<String> ans = new ArrayList();\n        for (String word : words)\n            if (match(word, pattern))\n                ans.add(word);\n        return ans;\n    }\n\n    public boolean match(String word, String pattern) {\n        Map<Character, Character> m1 = new HashMap();\n        Map<Character, Character> m2 = new HashMap();\n\n        for (int i = 0; i < word.length(); ++i) {\n            char w = word.charAt(i);\n            char p = pattern.charAt(i);\n            if (!m1.containsKey(w)) m1.put(w, p);\n            if (!m2.containsKey(p)) m2.put(p, w);\n            if (m1.get(w) != p || m2.get(p) != w)\n                return false;\n        }\n        return true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n',normalizedContent:'# leetcode-890-查找和替换模式\n\n你有一个单词列表 words 和一个模式 pattern，你想知道 words 中的哪些单词与模式匹配。\n\n如果存在字母的排列 p ，使得将模式中的每个字母 x 替换为 p(x) 之后，我们就得到了所需的单词，那么单词与模式是匹配的。\n\n（回想一下，字母的排列是从字母到字母的双射：每个字母映射到另一个字母，没有两个字母映射到同一个字母。）\n\n返回 words 中与给定模式匹配的单词列表。\n\n你可以按任何顺序返回答案。\n\n示例1：\n\n输入：words = ["abc","deq","mee","aqq","dkd","ccc"], pattern = "abb"\n输出：["mee","aqq"]\n解释：\n"mee" 与模式匹配，因为存在排列 {a -> m, b -> e, ...}。\n"ccc" 与模式不匹配，因为 {a -> c, b -> c, ...} 不是排列。\n因为 a 和 b 映射到同一个字母。\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n提示：\n\n * 1 <= words.length <= 50\n * 1 <= pattern.length = words[i].length <= 20\n\n\n# 解题思路\n\n我们可以用两个映射表（map）存储字母到字母的映射关系，第一个映射表保证一个字母不会映射到两个字母，第二个映射表保证不会有两个字母映射到同一个字母。例如 word 为 a，pattern 为 x，那么第一个映射表存储 a -> x，第二个映射表存储 x -> a。\n\n\n# java代码\n\nclass solution {\n    public list<string> findandreplacepattern(string[] words, string pattern) {\n        list<string> ans = new arraylist();\n        for (string word : words)\n            if (match(word, pattern))\n                ans.add(word);\n        return ans;\n    }\n\n    public boolean match(string word, string pattern) {\n        map<character, character> m1 = new hashmap();\n        map<character, character> m2 = new hashmap();\n\n        for (int i = 0; i < word.length(); ++i) {\n            char w = word.charat(i);\n            char p = pattern.charat(i);\n            if (!m1.containskey(w)) m1.put(w, p);\n            if (!m2.containskey(p)) m2.put(p, w);\n            if (m1.get(w) != p || m2.get(p) != w)\n                return false;\n        }\n        return true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-1143-最长公共子序列",frontmatter:{title:"LeetCode-1143-最长公共子序列",date:"2020-08-14T10:02:20.000Z",description:"最长公共子序列",tags:["字符串","DP","Java","Medium"],keywords:"字符串,DP,Java,Medium,LeetCode",permalink:"/pages/77c839/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/92.LeetCode-1143-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97.html",relativePath:"06.算法/02.LeetCode/92.LeetCode-1143-最长公共子序列.md",key:"v-aca2ff6e",path:"/pages/77c839/",headers:[{level:2,title:"LeetCode-1143-最长公共子序列",slug:"leetcode-1143-最长公共子序列",normalizedTitle:"leetcode-1143-最长公共子序列",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:593},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:870}],headersStr:"LeetCode-1143-最长公共子序列 解题思路 Java代码",content:'# LeetCode-1143-最长公共子序列\n\n给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。\n\n一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。 例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。\n\n若这两个字符串没有公共子序列，则返回 0。\n\n示例1：\n\n输入：text1 = "abcde", text2 = "ace" \n输出：3  \n解释：最长公共子序列是 "ace"，它的长度为 3。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2：\n\n输入：text1 = "abc", text2 = "abc"\n输出：3\n解释：最长公共子序列是 "abc"，它的长度为 3。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例3：\n\n输入：text1 = "abc", text2 = "def"\n输出：0\n解释：两个字符串没有公共子序列，返回 0。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n提示:\n\n * 1 <= text1.length <= 1000\n * 1 <= text2.length <= 1000\n * 输入的字符串只含有小写英文字符。\n\n\n# 解题思路\n\n方法1、动态规划： 详见大佬解析https://leetcode-cn.com/problems/longest-common-subsequence/solution/dong-tai-gui-hua-zhi-zui-chang-gong-gong-zi-xu-lie/\n\n初始化DP表\n\n第0列和第0行均为空串，对应位置为0\n\n状态dp[i][j]表示：对于text1[1...i]和text2[1...j]，他们的LCS的长度为dp[i][j]\n\n状态转移方程：根据DP表得到，是前一列的LCS长度和上一行的LCS长度的最大值\n\n\n# Java代码\n\nclass Solution {\n    public int longestCommonSubsequence(String text1, String text2) {\n        int lenT1 = text1.length();\n        int lenT2 = text2.length();\n        int[][] dp = new int[lenT1+1][lenT2+1];\n        for(int i=1;i<=lenT1;i++){\n            for(int j=1;j<=lenT2;j++){\n                if(text1.charAt(i-1)==text2.charAt(j-1)){\n                    dp[i][j] = dp[i-1][j-1]+1;\n                }else{\n                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);\n                }\n                \n            }\n        }\n        return dp[text1.length()][text2.length()];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n',normalizedContent:'# leetcode-1143-最长公共子序列\n\n给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。\n\n一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。 例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。\n\n若这两个字符串没有公共子序列，则返回 0。\n\n示例1：\n\n输入：text1 = "abcde", text2 = "ace" \n输出：3  \n解释：最长公共子序列是 "ace"，它的长度为 3。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2：\n\n输入：text1 = "abc", text2 = "abc"\n输出：3\n解释：最长公共子序列是 "abc"，它的长度为 3。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例3：\n\n输入：text1 = "abc", text2 = "def"\n输出：0\n解释：两个字符串没有公共子序列，返回 0。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n提示:\n\n * 1 <= text1.length <= 1000\n * 1 <= text2.length <= 1000\n * 输入的字符串只含有小写英文字符。\n\n\n# 解题思路\n\n方法1、动态规划： 详见大佬解析https://leetcode-cn.com/problems/longest-common-subsequence/solution/dong-tai-gui-hua-zhi-zui-chang-gong-gong-zi-xu-lie/\n\n初始化dp表\n\n第0列和第0行均为空串，对应位置为0\n\n状态dp[i][j]表示：对于text1[1...i]和text2[1...j]，他们的lcs的长度为dp[i][j]\n\n状态转移方程：根据dp表得到，是前一列的lcs长度和上一行的lcs长度的最大值\n\n\n# java代码\n\nclass solution {\n    public int longestcommonsubsequence(string text1, string text2) {\n        int lent1 = text1.length();\n        int lent2 = text2.length();\n        int[][] dp = new int[lent1+1][lent2+1];\n        for(int i=1;i<=lent1;i++){\n            for(int j=1;j<=lent2;j++){\n                if(text1.charat(i-1)==text2.charat(j-1)){\n                    dp[i][j] = dp[i-1][j-1]+1;\n                }else{\n                    dp[i][j] = math.max(dp[i-1][j],dp[i][j-1]);\n                }\n                \n            }\n        }\n        return dp[text1.length()][text2.length()];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-1247-交换字符使得字符串相同",frontmatter:{title:"LeetCode-1247-交换字符使得字符串相同",date:"2020-08-11T09:43:28.000Z",description:"交换字符使得字符串相同",tags:["字符串","Java","Medium"],keywords:"字符串,Java,Medium,LeetCode",permalink:"/pages/961a11/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/93.LeetCode-1247-%E4%BA%A4%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%BD%BF%E5%BE%97%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%90%8C.html",relativePath:"06.算法/02.LeetCode/93.LeetCode-1247-交换字符使得字符串相同.md",key:"v-a163964a",path:"/pages/961a11/",headers:[{level:2,title:"LeetCode-1247-交换字符使得字符串相同",slug:"leetcode-1247-交换字符使得字符串相同",normalizedTitle:"leetcode-1247-交换字符使得字符串相同",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:768},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:1078}],headersStr:"LeetCode-1247-交换字符使得字符串相同 解题思路 Java代码",content:'# LeetCode-1247-交换字符使得字符串相同\n\n有两个长度相同的字符串 s1 和 s2，且它们其中 只含有 字符 "x" 和 "y"，你需要通过「交换字符」的方式使这两个字符串相同。\n\n每次「交换字符」的时候，你都可以在两个字符串中各选一个字符进行交换。\n\n交换只能发生在两个不同的字符串之间，绝对不能发生在同一个字符串内部。也就是说，我们可以交换 s1[i] 和 s2[j]，但不能交换 s1[i] 和 s1[j]。\n\n最后，请你返回使 s1 和 s2 相同的最小交换次数，如果没有方法能够使得这两个字符串相同，则返回 -1 。\n\n示例1：\n\n输入：s1 = "xx", s2 = "yy"\n输出：1\n解释：\n交换 s1[0] 和 s2[1]，得到 s1 = "yx"，s2 = "yx"。\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n示例2：\n\n输入：s1 = "xy", s2 = "yx"\n输出：2\n解释：\n交换 s1[0] 和 s2[0]，得到 s1 = "yy"，s2 = "xx" 。\n交换 s1[0] 和 s2[1]，得到 s1 = "xy"，s2 = "xy" 。\n注意，你不能交换 s1[0] 和 s1[1] 使得 s1 变成 "yx"，因为我们只能交换属于两个不同字符串的字符。\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n示例3：\n\n输入：s1 = "xx", s2 = "xy"\n输出：-1\n\n\n1\n2\n\n1\n2\n\n\n示例4：\n\n输入：s1 = "xxyyxyxyxx", s2 = "xyyxyxxxyx"\n输出：4\n\n\n1\n2\n\n1\n2\n\n\n提示：\n\n * 1 <= s1.length, s2.length <= 1000\n * s1, s2 只包含 \'x\' 或 \'y\'。\n\n\n# 解题思路\n\n根据示例1和示例2可知，\n\n * 当满足\'xx\'和\'yy\'、\'yy\'和\'xx\'的时候，只需要1步就可以完成交换\n * 当满足\'xy\'和\'yx\'、\'yx\'和\'xy\'的时候，只需要2步就可以完成交换\n\n以上两种情况可以总结为，当s1=x、s2=y时，记录位x++；当s1=y、s2=x时，记录位y++\n\n通过判断x和y的个数，计算最少交换字符的次数\n\n如果x+y是奇数，则返回-1，因为这说明最后还剩下一对，x和y，单字符无法进行交换\n\n如果x+y是偶数，则分为以下两种情况：\n\n * 奇数x+奇数y：每两个x和y对应移动1次，剩下一对x和y对应移动2次\n * 偶数x+偶数y：每两个x和y对应移动1次\n\n\n# Java代码\n\nclass Solution {\n    public int minimumSwap(String s1, String s2) {\n        int x = 0;\n        int y = 0;\n        for(int i=0;i<s1.length();i++){\n            if(s1.charAt(i)==\'x\'&&s2.charAt(i)==\'y\'){\n                x++;\n            }\n            if(s1.charAt(i)==\'y\'&&s2.charAt(i)==\'x\'){\n                y++;\n            }\n        }\n        if((x+y)%2==1) return -1;\n        // x是奇数\n        if(x%2!=0){\n            return x/2+y/2+2;\n        }else{\n            return x/2+y/2;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n',normalizedContent:'# leetcode-1247-交换字符使得字符串相同\n\n有两个长度相同的字符串 s1 和 s2，且它们其中 只含有 字符 "x" 和 "y"，你需要通过「交换字符」的方式使这两个字符串相同。\n\n每次「交换字符」的时候，你都可以在两个字符串中各选一个字符进行交换。\n\n交换只能发生在两个不同的字符串之间，绝对不能发生在同一个字符串内部。也就是说，我们可以交换 s1[i] 和 s2[j]，但不能交换 s1[i] 和 s1[j]。\n\n最后，请你返回使 s1 和 s2 相同的最小交换次数，如果没有方法能够使得这两个字符串相同，则返回 -1 。\n\n示例1：\n\n输入：s1 = "xx", s2 = "yy"\n输出：1\n解释：\n交换 s1[0] 和 s2[1]，得到 s1 = "yx"，s2 = "yx"。\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n示例2：\n\n输入：s1 = "xy", s2 = "yx"\n输出：2\n解释：\n交换 s1[0] 和 s2[0]，得到 s1 = "yy"，s2 = "xx" 。\n交换 s1[0] 和 s2[1]，得到 s1 = "xy"，s2 = "xy" 。\n注意，你不能交换 s1[0] 和 s1[1] 使得 s1 变成 "yx"，因为我们只能交换属于两个不同字符串的字符。\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n示例3：\n\n输入：s1 = "xx", s2 = "xy"\n输出：-1\n\n\n1\n2\n\n1\n2\n\n\n示例4：\n\n输入：s1 = "xxyyxyxyxx", s2 = "xyyxyxxxyx"\n输出：4\n\n\n1\n2\n\n1\n2\n\n\n提示：\n\n * 1 <= s1.length, s2.length <= 1000\n * s1, s2 只包含 \'x\' 或 \'y\'。\n\n\n# 解题思路\n\n根据示例1和示例2可知，\n\n * 当满足\'xx\'和\'yy\'、\'yy\'和\'xx\'的时候，只需要1步就可以完成交换\n * 当满足\'xy\'和\'yx\'、\'yx\'和\'xy\'的时候，只需要2步就可以完成交换\n\n以上两种情况可以总结为，当s1=x、s2=y时，记录位x++；当s1=y、s2=x时，记录位y++\n\n通过判断x和y的个数，计算最少交换字符的次数\n\n如果x+y是奇数，则返回-1，因为这说明最后还剩下一对，x和y，单字符无法进行交换\n\n如果x+y是偶数，则分为以下两种情况：\n\n * 奇数x+奇数y：每两个x和y对应移动1次，剩下一对x和y对应移动2次\n * 偶数x+偶数y：每两个x和y对应移动1次\n\n\n# java代码\n\nclass solution {\n    public int minimumswap(string s1, string s2) {\n        int x = 0;\n        int y = 0;\n        for(int i=0;i<s1.length();i++){\n            if(s1.charat(i)==\'x\'&&s2.charat(i)==\'y\'){\n                x++;\n            }\n            if(s1.charat(i)==\'y\'&&s2.charat(i)==\'x\'){\n                y++;\n            }\n        }\n        if((x+y)%2==1) return -1;\n        // x是奇数\n        if(x%2!=0){\n            return x/2+y/2+2;\n        }else{\n            return x/2+y/2;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-1367-二叉树中的列表",frontmatter:{title:"LeetCode-1367-二叉树中的列表",date:"2020-06-11T16:38:13.000Z",description:"二叉树中的列表",tags:["树","DFS","Java","Medium"],keywords:"树,DFS,Java,Medium",permalink:"/pages/053bcf/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/94.LeetCode-1367-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E5%88%97%E8%A1%A8.html",relativePath:"06.算法/02.LeetCode/94.LeetCode-1367-二叉树中的列表.md",key:"v-f4c738d4",path:"/pages/053bcf/",headers:[{level:2,title:"LeetCode-1367-二叉树中的列表",slug:"leetcode-1367-二叉树中的列表",normalizedTitle:"leetcode-1367-二叉树中的列表",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:676},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:1076}],headersStr:"LeetCode-1367-二叉树中的列表 解题思路 Java代码",content:"# LeetCode-1367-二叉树中的列表\n\n给你一棵以 root 为根的二叉树和一个 head 为第一个节点的链表。\n\n如果在二叉树中，存在一条一直向下的路径，且每个点的数值恰好一一对应以 head 为首的链表中每个节点的值，那么请你返回 True ，否则返回 False 。\n\n一直向下的路径的意思是：从树中某个节点开始，一直连续向下的路径。\n\n示例 1:\n\n输入：head = [4,2,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\n输出：true\n解释：树中蓝色的节点构成了与链表对应的子路径。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例 2:\n\n输入：head = [1,4,2,6], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\n输出：true\n\n\n1\n2\n\n1\n2\n\n\n示例3：\n\n输入：head = [1,4,2,6,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\n输出：false\n解释：二叉树中不存在一一对应链表的路径。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n提示:\n\n * 二叉树和链表中的每个节点的值都满足 1 <= node.val <= 100 。\n * 链表包含的节点数目在 1 到 100 之间。\n * 二叉树包含的节点数目在 1 到 2500 之间。\n\n\n# 解题思路\n\nDFS递归：\n\n根据题意知道，head的长度<=root\n\n我们可以设计一个递归函数，如果head==null说明匹配完成，返回true，如果root==null则说明找完了也没有匹配上\n\n首先开启root节点的递归，判断开始的路径是否和head匹配，如果匹配则进一步看是这个节点的左子树匹配？还是这个节点的右子树匹配。任意一个子树匹配成功则算匹配成功。\n\n如果root节点匹配失败，那么需要看root节点的左子树或者root节点的右子树是否能够匹配，分别开启DFS遍历，左右子树应该和root节点进行一样的匹配，同样需要看左子节点的左右节点和右子节点的左右节点到底是哪一个匹配的\n\n当根节点或者左右子树任意一个匹配成功，则说明包含路径，即dfs(head,root)||isSubPath(head,root.left)||isSubPath(head,root.right)\n\n\n# Java代码\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public boolean isSubPath(ListNode head, TreeNode root) {\n        if(head==null) return true;\n        if(root==null) return false;\n        // 先判断当前的节点，如果不对，就看看左子树和右子树\n        return dfs(head,root)||isSubPath(head,root.left)||isSubPath(head,root.right);\n    }\n\n    public boolean dfs(ListNode head,TreeNode root){\n        // 如果链表没了，那就说明匹配完了\n        if(head==null) return true;\n        // 如果链表没完，树走完了，那就是没匹配上\n        if(root==null) return false;\n        // 如果值不同，那肯定也是没匹配上\n        if(head.val!=root.val) return false;\n        // 如果值相同，就继续看看左边右边是不是有相同的\n        return dfs(head.next,root.left)||dfs(head.next,root.right);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n",normalizedContent:"# leetcode-1367-二叉树中的列表\n\n给你一棵以 root 为根的二叉树和一个 head 为第一个节点的链表。\n\n如果在二叉树中，存在一条一直向下的路径，且每个点的数值恰好一一对应以 head 为首的链表中每个节点的值，那么请你返回 true ，否则返回 false 。\n\n一直向下的路径的意思是：从树中某个节点开始，一直连续向下的路径。\n\n示例 1:\n\n输入：head = [4,2,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\n输出：true\n解释：树中蓝色的节点构成了与链表对应的子路径。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例 2:\n\n输入：head = [1,4,2,6], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\n输出：true\n\n\n1\n2\n\n1\n2\n\n\n示例3：\n\n输入：head = [1,4,2,6,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\n输出：false\n解释：二叉树中不存在一一对应链表的路径。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n提示:\n\n * 二叉树和链表中的每个节点的值都满足 1 <= node.val <= 100 。\n * 链表包含的节点数目在 1 到 100 之间。\n * 二叉树包含的节点数目在 1 到 2500 之间。\n\n\n# 解题思路\n\ndfs递归：\n\n根据题意知道，head的长度<=root\n\n我们可以设计一个递归函数，如果head==null说明匹配完成，返回true，如果root==null则说明找完了也没有匹配上\n\n首先开启root节点的递归，判断开始的路径是否和head匹配，如果匹配则进一步看是这个节点的左子树匹配？还是这个节点的右子树匹配。任意一个子树匹配成功则算匹配成功。\n\n如果root节点匹配失败，那么需要看root节点的左子树或者root节点的右子树是否能够匹配，分别开启dfs遍历，左右子树应该和root节点进行一样的匹配，同样需要看左子节点的左右节点和右子节点的左右节点到底是哪一个匹配的\n\n当根节点或者左右子树任意一个匹配成功，则说明包含路径，即dfs(head,root)||issubpath(head,root.left)||issubpath(head,root.right)\n\n\n# java代码\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode(int x) { val = x; }\n * }\n */\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public boolean issubpath(listnode head, treenode root) {\n        if(head==null) return true;\n        if(root==null) return false;\n        // 先判断当前的节点，如果不对，就看看左子树和右子树\n        return dfs(head,root)||issubpath(head,root.left)||issubpath(head,root.right);\n    }\n\n    public boolean dfs(listnode head,treenode root){\n        // 如果链表没了，那就说明匹配完了\n        if(head==null) return true;\n        // 如果链表没完，树走完了，那就是没匹配上\n        if(root==null) return false;\n        // 如果值不同，那肯定也是没匹配上\n        if(head.val!=root.val) return false;\n        // 如果值相同，就继续看看左边右边是不是有相同的\n        return dfs(head.next,root.left)||dfs(head.next,root.right);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-字符串排序",frontmatter:{title:"LeetCode-字符串排序",date:"2020-08-30T17:23:46.000Z",description:"零钱兑换",tags:["字符串","Java","Easy"],keywords:"字符串,Java,Easy,LeetCode",permalink:"/pages/a64c8b/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/95.LeetCode-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F.html",relativePath:"06.算法/02.LeetCode/95.LeetCode-字符串排序.md",key:"v-8402c606",path:"/pages/a64c8b/",headers:[{level:2,title:"LeetCode-字符串排序",slug:"leetcode-字符串排序",normalizedTitle:"leetcode-字符串排序",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:479}],headersStr:"LeetCode-字符串排序 解题思路",content:"# LeetCode-字符串排序\n\n编写一个程序，将输入字符串中的字符按如下规则排序。 规则 1 ：英文字母从 A 到 Z 排列，不区分大小写。 如，输入： Type 输出： epTy 规则 2 ：同一个英文字母的大小写同时存在时，按照输入顺序排列。 如，输入： BabA 输出： aABb 规则 3 ：非英文字母的其它字符保持原来的位置。 如，输入： By?e 输出： Be?y\n\n示例1：\n\n输入：\nA Famous Saying: Much Ado About Nothing(2012/8).\n\n输出：\nA aaAAbc dFgghh : iimM nNn oooos Sttuuuy (2012/8).\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n示例2：\n\n输入例子:\nA Famous Saying: Much Ado About Nothing (2012/8).\n\n输出例子:\nA aaAAbc dFgghh: iimM nNn oooos Sttuuuy (2012/8).\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n\n# 解题思路\n\n外层循环按照26个字母的顺序循环，内层进行字母顺序进行字符串的遍历，如按照A字母内层一轮，将A和a加入到结果集。循环完毕之后，res中即存储的排序好的字符串\n\n由于需要保持原本的非英文字符串不变，再遍历一次字符串，将非英文字符按照原位置插入到res中即可。\n\nimport java.util.Scanner;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String str = sc.nextLine().trim();\n        char[] cs = str.toCharArray();\n        StringBuilder res = new StringBuilder();\n        //  循环26个字符\n        for (int i = 0; i < 26; i++) {\n            // 循环字符串排序，按照A字母一轮，B字母一轮添加进builder\n            for (int j = 0; j < str.length(); j++) {\n                if (cs[j] == (i + 'a') || cs[j] == (i + 'A')) {\n                    res.append(cs[j]);\n                }\n            }\n        }\n        //再次遍历字符串\n        for (int i = 0; i < str.length(); i++) {\n            // 如果不是英文字符，直接添加进结果\n            if (!(cs[i] >= 'a' && cs[i] <= 'z' || cs[i] >= 'A' && cs[i] <= 'Z')) {\n                res.insert(i, cs[i]);\n            }\n        }\n        System.out.println(res.toString());\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n",normalizedContent:"# leetcode-字符串排序\n\n编写一个程序，将输入字符串中的字符按如下规则排序。 规则 1 ：英文字母从 a 到 z 排列，不区分大小写。 如，输入： type 输出： epty 规则 2 ：同一个英文字母的大小写同时存在时，按照输入顺序排列。 如，输入： baba 输出： aabb 规则 3 ：非英文字母的其它字符保持原来的位置。 如，输入： by?e 输出： be?y\n\n示例1：\n\n输入：\na famous saying: much ado about nothing(2012/8).\n\n输出：\na aaaabc dfgghh : iimm nnn oooos sttuuuy (2012/8).\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n示例2：\n\n输入例子:\na famous saying: much ado about nothing (2012/8).\n\n输出例子:\na aaaabc dfgghh: iimm nnn oooos sttuuuy (2012/8).\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n\n# 解题思路\n\n外层循环按照26个字母的顺序循环，内层进行字母顺序进行字符串的遍历，如按照a字母内层一轮，将a和a加入到结果集。循环完毕之后，res中即存储的排序好的字符串\n\n由于需要保持原本的非英文字符串不变，再遍历一次字符串，将非英文字符按照原位置插入到res中即可。\n\nimport java.util.scanner;\n\npublic class solution {\n    public static void main(string[] args) {\n        scanner sc = new scanner(system.in);\n        string str = sc.nextline().trim();\n        char[] cs = str.tochararray();\n        stringbuilder res = new stringbuilder();\n        //  循环26个字符\n        for (int i = 0; i < 26; i++) {\n            // 循环字符串排序，按照a字母一轮，b字母一轮添加进builder\n            for (int j = 0; j < str.length(); j++) {\n                if (cs[j] == (i + 'a') || cs[j] == (i + 'a')) {\n                    res.append(cs[j]);\n                }\n            }\n        }\n        //再次遍历字符串\n        for (int i = 0; i < str.length(); i++) {\n            // 如果不是英文字符，直接添加进结果\n            if (!(cs[i] >= 'a' && cs[i] <= 'z' || cs[i] >= 'a' && cs[i] <= 'z')) {\n                res.insert(i, cs[i]);\n            }\n        }\n        system.out.println(res.tostring());\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题02.02-返回倒数第k个节点",frontmatter:{title:"LeetCode-面试题02.02-返回倒数第k个节点",date:"2020-06-10T15:28:54.000Z",description:"返回倒数第k个节点",tags:["链表","Java","Easy","LeetCode"],keywords:"链表,Java,Easy,LeetCode",permalink:"/pages/7899ff/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/96.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9802-02-%E8%BF%94%E5%9B%9E%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9.html",relativePath:"06.算法/02.LeetCode/96.LeetCode-面试题02-02-返回倒数第k个节点.md",key:"v-4bb14ca2",path:"/pages/7899ff/",headers:[{level:2,title:"LeetCode-面试题02.02-返回倒数第k个节点",slug:"leetcode-面试题02-02-返回倒数第k个节点",normalizedTitle:"leetcode-面试题02.02-返回倒数第k个节点",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:158},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:339},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:1015}],headersStr:"LeetCode-面试题02.02-返回倒数第k个节点 解题思路 Java代码 Java代码2",content:"# LeetCode-面试题02.02-返回倒数第k个节点\n\n实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。\n\n注意：本题相对原题稍作改动\n\n示例 1:\n\n输入： 1->2->3->4->5 和 k = 2\n输出： 4\n\n\n1\n2\n\n1\n2\n\n\n说明：\n\n * 给定的 k 保证是有效的。\n\n\n# 解题思路\n\n双指针：\n\n根据链表的性质，要获得倒数第k个节点，就等于求n-(k-1)个节点，\n\n但这需要知道链表的长度，意味着需要两次遍历链表。\n\n换一种想法，想要知道倒数第k个节点，那么就让一个指针先走k-1步，另外一个指针始终和第一个指针保持k-1的距离\n\n当第一个指针到达链表结尾时，第二个指针则正好在n-(k-1)的位置，只需要一次遍历即可完成\n\n\n# Java代码\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public int kthToLast(ListNode head, int k) {\n        if(head==null) return 0;\n        ListNode fast = head;\n        ListNode low = null;\n        for(int i=0;i<k-1;i++){\n            fast = fast.next;\n        }\n        low = head;\n        while(fast.next!=null){\n            fast = fast.next;\n            low = low.next;\n        }\n        return low.val;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# Java代码2\n\nclass Solution {\n    public int kthToLast(ListNode head, int k) {\n        if(head==null){\n            return -1;\n        }\n        ListNode slow = head;\n        ListNode fast = head;\n        for(int i=0;i<k;i++){\n            fast = fast.next;\n        }\n        while(fast!=null){\n            slow = slow.next;\n            fast = fast.next;\n        }\n        return slow.val;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n",normalizedContent:"# leetcode-面试题02.02-返回倒数第k个节点\n\n实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。\n\n注意：本题相对原题稍作改动\n\n示例 1:\n\n输入： 1->2->3->4->5 和 k = 2\n输出： 4\n\n\n1\n2\n\n1\n2\n\n\n说明：\n\n * 给定的 k 保证是有效的。\n\n\n# 解题思路\n\n双指针：\n\n根据链表的性质，要获得倒数第k个节点，就等于求n-(k-1)个节点，\n\n但这需要知道链表的长度，意味着需要两次遍历链表。\n\n换一种想法，想要知道倒数第k个节点，那么就让一个指针先走k-1步，另外一个指针始终和第一个指针保持k-1的距离\n\n当第一个指针到达链表结尾时，第二个指针则正好在n-(k-1)的位置，只需要一次遍历即可完成\n\n\n# java代码\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode(int x) { val = x; }\n * }\n */\nclass solution {\n    public int kthtolast(listnode head, int k) {\n        if(head==null) return 0;\n        listnode fast = head;\n        listnode low = null;\n        for(int i=0;i<k-1;i++){\n            fast = fast.next;\n        }\n        low = head;\n        while(fast.next!=null){\n            fast = fast.next;\n            low = low.next;\n        }\n        return low.val;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# java代码2\n\nclass solution {\n    public int kthtolast(listnode head, int k) {\n        if(head==null){\n            return -1;\n        }\n        listnode slow = head;\n        listnode fast = head;\n        for(int i=0;i<k;i++){\n            fast = fast.next;\n        }\n        while(fast!=null){\n            slow = slow.next;\n            fast = fast.next;\n        }\n        return slow.val;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题17.16-按摩师",frontmatter:{title:"LeetCode-面试题17.16-按摩师",date:"2020-06-06T13:50:17.000Z",description:"按摩师",tags:["DP","数组","Java","Easy","LeetCode"],keywords:"DP,数组,Java,Easy,LeetCode",permalink:"/pages/0c5197/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/97.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9817-16-%E6%8C%89%E6%91%A9%E5%B8%88.html",relativePath:"06.算法/02.LeetCode/97.LeetCode-面试题17-16-按摩师.md",key:"v-22683f86",path:"/pages/0c5197/",headers:[{level:2,title:"LeetCode-面试题17.16-按摩师",slug:"leetcode-面试题17-16-按摩师",normalizedTitle:"leetcode-面试题17.16-按摩师",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:439},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:741}],headersStr:"LeetCode-面试题17.16-按摩师 解题思路 Java代码",content:"# LeetCode-面试题17.16-按摩师\n\n一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。\n\n注意：本题相对原题稍作改动\n\n示例 1:\n\n输入： [1,2,3,1]\n输出： 4\n解释： 选择 1 号预约和 3 号预约，总时长 = 1 + 3 = 4。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2：\n\n输入： [2,7,9,3,1]\n输出： 12\n解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 = 2 + 9 + 1 = 12。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例3：\n\n输入： [2,1,4,5,3,1,1,3]\n输出： 12\n解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 = 2 + 4 + 3 + 3 = 12。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n\n# 解题思路\n\n动态规划：\n\n看示例1示例2，以为是奇数位置和偶数位置的动态规划，这样就不需要额外的空间....然后发现示例3不是这样的\n\n于是还是老老实实拿个dp数组吧\n\ndp数组的状态：当前位置前相隔数据的最大值\n\n初始化：dp[0] = nums[0] ,dp[1] = Math.max(nums[0],nums[1])\n\n转移方程：索引从2开始，由于dp[i-1]存储前面相隔数据的最大值，所以需要比较，当前位置的num[i]和前面间隔位置的数值最大值dp[i-2]之和，与dp[i-1]之间的大小关系，即dp[i] = Math.max(dp[i-1],dp[i-2]+nums[i])\n\n\n# Java代码\n\nclass Solution {\n    public int massage(int[] nums) {\n        int len = nums.length;\n        if(nums==null||len==0) return 0;\n        if(len<2)\n            return nums[0];\n        int[] dp = new int[len];\n        dp[0] = nums[0];\n        dp[1] = Math.max(nums[0],nums[1]);\n        for(int i=2;i<len;i++){\n            dp[i] = Math.max(dp[i-1],dp[i-2]+nums[i]);\n        }\n        return dp[len-1];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n",normalizedContent:"# leetcode-面试题17.16-按摩师\n\n一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。\n\n注意：本题相对原题稍作改动\n\n示例 1:\n\n输入： [1,2,3,1]\n输出： 4\n解释： 选择 1 号预约和 3 号预约，总时长 = 1 + 3 = 4。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例2：\n\n输入： [2,7,9,3,1]\n输出： 12\n解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 = 2 + 9 + 1 = 12。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n示例3：\n\n输入： [2,1,4,5,3,1,1,3]\n输出： 12\n解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 = 2 + 4 + 3 + 3 = 12。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n\n# 解题思路\n\n动态规划：\n\n看示例1示例2，以为是奇数位置和偶数位置的动态规划，这样就不需要额外的空间....然后发现示例3不是这样的\n\n于是还是老老实实拿个dp数组吧\n\ndp数组的状态：当前位置前相隔数据的最大值\n\n初始化：dp[0] = nums[0] ,dp[1] = math.max(nums[0],nums[1])\n\n转移方程：索引从2开始，由于dp[i-1]存储前面相隔数据的最大值，所以需要比较，当前位置的num[i]和前面间隔位置的数值最大值dp[i-2]之和，与dp[i-1]之间的大小关系，即dp[i] = math.max(dp[i-1],dp[i-2]+nums[i])\n\n\n# java代码\n\nclass solution {\n    public int massage(int[] nums) {\n        int len = nums.length;\n        if(nums==null||len==0) return 0;\n        if(len<2)\n            return nums[0];\n        int[] dp = new int[len];\n        dp[0] = nums[0];\n        dp[1] = math.max(nums[0],nums[1]);\n        for(int i=2;i<len;i++){\n            dp[i] = math.max(dp[i-1],dp[i-2]+nums[i]);\n        }\n        return dp[len-1];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"获取满足指数的最长字符串",frontmatter:{title:"获取满足指数的最长字符串",date:"2020-08-20T19:16:41.000Z",description:"笔试题",tags:["Java","Medium"],keywords:"Java,Medium",permalink:"/pages/5969d4/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/98.%E8%8E%B7%E5%8F%96%E6%BB%A1%E8%B6%B3%E6%8C%87%E6%95%B0%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E7%AC%A6%E4%B8%B2.html",relativePath:"06.算法/02.LeetCode/98.获取满足指数的最长字符串.md",key:"v-7a505fa0",path:"/pages/5969d4/",headers:[{level:2,title:"获取满足指数的最长字符串",slug:"获取满足指数的最长字符串",normalizedTitle:"获取满足指数的最长字符串",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:354},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:710}],headersStr:"获取满足指数的最长字符串 解题思路 Java代码",content:"# 获取满足指数的最长字符串\n\n字母表的26个字母，每个字母(忽略大小写)按照他们在字母表的顺序，代表一个数，例如：a代表1，h代表8，z代表26\n\n对于任意由英文字母组成的字符串，我们可以把他们每一位对应的数加起来，便可以计算出这个字符串的指数，例如：abc的指数为6。\n\n现在给你一个字符串与一个期望的指数，希望可以找出这个字符串的所有满足这个指数子串中，最长子串的长度。\n\n要求：时间复杂度为O(n)，空间复杂度为O(1)\n\n输入描述：\n\n输入为两行，第一行是字符串，第二行是期望的指数，例如：\n\nbcdafga\n8\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n输出描述:\n\n输出为最长子串的长度。如果没有合适的子串，则应该返回0，例如，对于示例中的输入，应该输出：\n3\n\n\n1\n2\n\n1\n2\n\n\n\n# 解题思路\n\n方法1、双指针：\n\n初始化left和right指针，len指针记录最长子串的长度，res记录当前窗口内数值的和\n\n采用类似滑动窗口的思想\n\n * 当[left,right)窗口内的值等于期望值时，说明找到了一个满足期望的子串，更新最长子串长度，因为此时窗口值已经等于期望值，向右扩展必定会使窗口值增加，所以此时应该缩减左窗口，才有可能在后续的子串中找到另外的满足期望值的left和right，res减去缩减左窗口的值，同时使得left++\n * 当[left,right)窗口内的值大于期望值时，需要缩减左窗口，即left++，同时时res减去左窗口的缩减部分的值\n * 当[left,right)窗口内的值小于期望值时，需要向右扩展窗口，即right++，同时res加上右窗口增加部分的值\n\n\n# Java代码\n\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        char[] s = sc.nextLine().toCharArray();\n        int exNum = Integer.parseInt(sc.nextLine().trim());\n        int left = 0;\n        int right = 0;\n        int len = 0;\n        int res = 0;\n        while (right < s.length) {\n            if (res == exNum) {\n                len = Math.max(len, right - left);\n                res -= (s[left] - 'a' + 1);\n                left++;\n            } else if (res > exNum) {\n                res -= (s[left] - 'a' + 1);\n                left++;\n            } else {\n                res += (s[right] - 'a' + 1);\n                right++;\n            }\n        }\n        System.out.println(len);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n",normalizedContent:"# 获取满足指数的最长字符串\n\n字母表的26个字母，每个字母(忽略大小写)按照他们在字母表的顺序，代表一个数，例如：a代表1，h代表8，z代表26\n\n对于任意由英文字母组成的字符串，我们可以把他们每一位对应的数加起来，便可以计算出这个字符串的指数，例如：abc的指数为6。\n\n现在给你一个字符串与一个期望的指数，希望可以找出这个字符串的所有满足这个指数子串中，最长子串的长度。\n\n要求：时间复杂度为o(n)，空间复杂度为o(1)\n\n输入描述：\n\n输入为两行，第一行是字符串，第二行是期望的指数，例如：\n\nbcdafga\n8\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n输出描述:\n\n输出为最长子串的长度。如果没有合适的子串，则应该返回0，例如，对于示例中的输入，应该输出：\n3\n\n\n1\n2\n\n1\n2\n\n\n\n# 解题思路\n\n方法1、双指针：\n\n初始化left和right指针，len指针记录最长子串的长度，res记录当前窗口内数值的和\n\n采用类似滑动窗口的思想\n\n * 当[left,right)窗口内的值等于期望值时，说明找到了一个满足期望的子串，更新最长子串长度，因为此时窗口值已经等于期望值，向右扩展必定会使窗口值增加，所以此时应该缩减左窗口，才有可能在后续的子串中找到另外的满足期望值的left和right，res减去缩减左窗口的值，同时使得left++\n * 当[left,right)窗口内的值大于期望值时，需要缩减左窗口，即left++，同时时res减去左窗口的缩减部分的值\n * 当[left,right)窗口内的值小于期望值时，需要向右扩展窗口，即right++，同时res加上右窗口增加部分的值\n\n\n# java代码\n\nimport java.util.scanner;\n\npublic class main {\n    public static void main(string[] args) {\n        scanner sc = new scanner(system.in);\n        char[] s = sc.nextline().tochararray();\n        int exnum = integer.parseint(sc.nextline().trim());\n        int left = 0;\n        int right = 0;\n        int len = 0;\n        int res = 0;\n        while (right < s.length) {\n            if (res == exnum) {\n                len = math.max(len, right - left);\n                res -= (s[left] - 'a' + 1);\n                left++;\n            } else if (res > exnum) {\n                res -= (s[left] - 'a' + 1);\n                left++;\n            } else {\n                res += (s[right] - 'a' + 1);\n                right++;\n            }\n        }\n        system.out.println(len);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"数组的最多素数个数",frontmatter:{title:"数组的最多素数个数",date:"2020-08-10T09:50:59.000Z",description:"数组的最多素数个数",tags:["数组","Java","Easy"],keywords:"数组,Java,Easy,LeetCode",permalink:"/pages/13f871/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/02.LeetCode/99.%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%9A%E7%B4%A0%E6%95%B0%E4%B8%AA%E6%95%B0.html",relativePath:"06.算法/02.LeetCode/99.数组的最多素数个数.md",key:"v-0a5cdba6",path:"/pages/13f871/",headers:[{level:2,title:"网易2021秋招-数组的最多素数个数",slug:"网易2021秋招-数组的最多素数个数",normalizedTitle:"网易2021秋招-数组的最多素数个数",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:195},{level:3,title:"Java代码1",slug:"java代码1",normalizedTitle:"java代码1",charIndex:405},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:1178}],headersStr:"网易2021秋招-数组的最多素数个数 解题思路 Java代码1 Java代码2",content:"# 网易2021秋招-数组的最多素数个数\n\n第一行输入一个数字n\n\n第二行输入n个数字，求这n个数字最多能够拆解为多少个素数，且数字拆解之后素数之后等于数字本身。如5可以拆解为2，3；3本身为素数；7可以拆解为2，2，3\n\n第三行输出数组最多能够拆解成的素数个数\n\n最多1e6个数，每个数字最大为1e9，1不是素数\n\n示例1：\n\n3\n5 3 7\n6\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n\n# 解题思路\n\n观察题目可知，当2的数量最多的时候，数组就拥有最多的素数个数。\n\n考虑数字范围，需要通过long存储结果，因为累加肯定是超过了int范围\n\n可以通过判断数字的奇数和偶数来分别进行计算：\n\n偶数情况直接除以2，奇数情况减去3再除以2，再+1个即可\n\n观察可知，上面的奇数情况可以直接合并为数字除以2即可，因为减去3也是减去的一个数，这个数最后还是要加回来的。\n\n所以对每个数字除以2累加即可得到答案。\n\n\n# Java代码1\n\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        long sum = 0;\n        int n = Integer.parseInt(sc.nextLine().trim());\n        Main main = new Main();\n        for (int i = 0; i < n; i++) {\n            int num = sc.nextInt();\n            sum += main.countSu(num);\n        }\n        System.out.println(sum);\n    }\n\n    public long countSu(int num) {\n        long sum = 0;\n        if (num % 2 == 0) {\n            sum += num / 2;\n        } else {\n            sum += ((num - 3) / 2) + 1;\n        }\n        return sum;\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# Java代码2\n\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        long res = 0;\n        int n = sc.nextInt();\n        for (int i = 0; i < n; i++) {\n            res += sc.nextInt() >> 1;\n        }\n        System.out.println(res);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n",normalizedContent:"# 网易2021秋招-数组的最多素数个数\n\n第一行输入一个数字n\n\n第二行输入n个数字，求这n个数字最多能够拆解为多少个素数，且数字拆解之后素数之后等于数字本身。如5可以拆解为2，3；3本身为素数；7可以拆解为2，2，3\n\n第三行输出数组最多能够拆解成的素数个数\n\n最多1e6个数，每个数字最大为1e9，1不是素数\n\n示例1：\n\n3\n5 3 7\n6\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n\n# 解题思路\n\n观察题目可知，当2的数量最多的时候，数组就拥有最多的素数个数。\n\n考虑数字范围，需要通过long存储结果，因为累加肯定是超过了int范围\n\n可以通过判断数字的奇数和偶数来分别进行计算：\n\n偶数情况直接除以2，奇数情况减去3再除以2，再+1个即可\n\n观察可知，上面的奇数情况可以直接合并为数字除以2即可，因为减去3也是减去的一个数，这个数最后还是要加回来的。\n\n所以对每个数字除以2累加即可得到答案。\n\n\n# java代码1\n\nimport java.util.scanner;\n\npublic class main {\n    public static void main(string[] args) {\n        scanner sc = new scanner(system.in);\n        long sum = 0;\n        int n = integer.parseint(sc.nextline().trim());\n        main main = new main();\n        for (int i = 0; i < n; i++) {\n            int num = sc.nextint();\n            sum += main.countsu(num);\n        }\n        system.out.println(sum);\n    }\n\n    public long countsu(int num) {\n        long sum = 0;\n        if (num % 2 == 0) {\n            sum += num / 2;\n        } else {\n            sum += ((num - 3) / 2) + 1;\n        }\n        return sum;\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# java代码2\n\nimport java.util.scanner;\n\npublic class main {\n    public static void main(string[] args) {\n        scanner sc = new scanner(system.in);\n        long res = 0;\n        int n = sc.nextint();\n        for (int i = 0; i < n; i++) {\n            res += sc.nextint() >> 1;\n        }\n        system.out.println(res);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"常见排序算法总结",frontmatter:{title:"常见排序算法总结",date:"2020-07-02T16:17:37.000Z",description:"排序算法总结",tags:["排序算法","Java"],keywords:"排序,Java",permalink:"/pages/8d006a/",categories:["算法","排序算法"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/03.%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/00.%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.html",relativePath:"06.算法/03.排序算法/00.常见排序算法总结.md",key:"v-1925ed26",path:"/pages/8d006a/",headers:[{level:2,title:"常见排序算法总结",slug:"常见排序算法总结",normalizedTitle:"常见排序算法总结",charIndex:2}],headersStr:"常见排序算法总结",content:"# 常见排序算法总结\n\n总结了常用的排序算法，以及对应分析\n\n相关链接：\n\n 1. 冒泡排序\n 2. 选择排序\n 3. 插入排序\n 4. 快速排序\n 5. 归并排序\n 6. 希尔排序\n 7. 桶排序\n 8. 基数排序\n 9. 堆排序\n\n总结各种排序算法的时间复杂度和空间复杂度，以及其对应的稳定性\n\n算法种类   最好情况        平均时间复杂度             最坏情况        空间复杂度     是否稳定\n冒泡排序   O(n)        O(n^2)              O(n^2)      O(1)      是\n选择排序   O(n^2)      O(n^2)              O(n^2)      O(1)      是\n插入排序   O(n)        O(n^2)              O(n^2)      O(1)      是\n快速排序   O(nlogn)    O(nlogn)            O(n^2)      O(logn)   否\n归并排序   O(nlogn)    O(nlogn)            O(nlogn)    O(n)      是\n希尔排序               O(n1.3)-O(n2)                   O(1)      否\n桶排序    O(n)        O(n*(log(n/m)+1))   O(n^2)      O(n+m)    是\n基数排序   O(d(n+r))   O(d(n+r))           O(d(n+r))   O(r)      是\n堆排序    O(nlogn)    O(nlogn)            O(nlogn)    O(1)      否",normalizedContent:"# 常见排序算法总结\n\n总结了常用的排序算法，以及对应分析\n\n相关链接：\n\n 1. 冒泡排序\n 2. 选择排序\n 3. 插入排序\n 4. 快速排序\n 5. 归并排序\n 6. 希尔排序\n 7. 桶排序\n 8. 基数排序\n 9. 堆排序\n\n总结各种排序算法的时间复杂度和空间复杂度，以及其对应的稳定性\n\n算法种类   最好情况        平均时间复杂度             最坏情况        空间复杂度     是否稳定\n冒泡排序   o(n)        o(n^2)              o(n^2)      o(1)      是\n选择排序   o(n^2)      o(n^2)              o(n^2)      o(1)      是\n插入排序   o(n)        o(n^2)              o(n^2)      o(1)      是\n快速排序   o(nlogn)    o(nlogn)            o(n^2)      o(logn)   否\n归并排序   o(nlogn)    o(nlogn)            o(nlogn)    o(n)      是\n希尔排序               o(n1.3)-o(n2)                   o(1)      否\n桶排序    o(n)        o(n*(log(n/m)+1))   o(n^2)      o(n+m)    是\n基数排序   o(d(n+r))   o(d(n+r))           o(d(n+r))   o(r)      是\n堆排序    o(nlogn)    o(nlogn)            o(nlogn)    o(1)      否",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"冒泡排序",frontmatter:{title:"冒泡排序",date:"2020-06-28T16:02:20.000Z",description:"冒泡排序",tags:["排序算法","Java"],keywords:"排序,Java",permalink:"/pages/3fd3f6/",categories:["算法","排序算法"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/03.%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/01.%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.html",relativePath:"06.算法/03.排序算法/01.冒泡排序.md",key:"v-0e4708a1",path:"/pages/3fd3f6/",headers:[{level:2,title:"LeetCode-冒泡排序",slug:"leetcode-冒泡排序",normalizedTitle:"leetcode-冒泡排序",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:91},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:173}],headersStr:"LeetCode-冒泡排序 解题思路 Java代码",content:"# LeetCode-冒泡排序\n\n冒泡排序算法回顾\n\n示例1\n\n输入: nums = [4,0,1,2,0,5]\n输出: [0,0,1,2,4,5]\n\n\n1\n2\n\n1\n2\n\n\n\n# 解题思路\n\n冒泡排序算法回顾，列表中两个相邻的数比较大小，如果前面的比后面的大，则交换位置\n\n整个过程像冒泡一样，时间复杂度O(n^2)，是稳定的排序算法\n\n\n# Java代码\n\npublic class BubbleSort {\n    public static void main(String[] args) {\n        int[] arr = {4, 0, 1, 2, 0, 5};\n        bubbleSort(arr, arr.length - 1);\n        for (Integer i : arr) {\n            System.out.print(i);\n        }\n    }\n\n    public static void bubbleSort(int[] arr, int len) {\n        for (int i = 0; i < len; i++) {\n            for (int j = 0; j < len - i; j++) {\n                if (arr[j] > arr[j + 1]) {\n                    int temp = arr[j + 1];\n                    arr[j + 1] = arr[j];\n                    arr[j] = temp;\n                }\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n",normalizedContent:"# leetcode-冒泡排序\n\n冒泡排序算法回顾\n\n示例1\n\n输入: nums = [4,0,1,2,0,5]\n输出: [0,0,1,2,4,5]\n\n\n1\n2\n\n1\n2\n\n\n\n# 解题思路\n\n冒泡排序算法回顾，列表中两个相邻的数比较大小，如果前面的比后面的大，则交换位置\n\n整个过程像冒泡一样，时间复杂度o(n^2)，是稳定的排序算法\n\n\n# java代码\n\npublic class bubblesort {\n    public static void main(string[] args) {\n        int[] arr = {4, 0, 1, 2, 0, 5};\n        bubblesort(arr, arr.length - 1);\n        for (integer i : arr) {\n            system.out.print(i);\n        }\n    }\n\n    public static void bubblesort(int[] arr, int len) {\n        for (int i = 0; i < len; i++) {\n            for (int j = 0; j < len - i; j++) {\n                if (arr[j] > arr[j + 1]) {\n                    int temp = arr[j + 1];\n                    arr[j + 1] = arr[j];\n                    arr[j] = temp;\n                }\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"基数排序",frontmatter:{title:"基数排序",date:"2020-07-01T15:23:25.000Z",description:"基数排序",tags:["排序算法","Java"],keywords:"排序,Java",permalink:"/pages/5ee1b6/",categories:["算法","排序算法"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/03.%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/02.%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.html",relativePath:"06.算法/03.排序算法/02.基数排序.md",key:"v-7653f6cc",path:"/pages/5ee1b6/",headers:[{level:2,title:"LeetCode-基数排序",slug:"leetcode-基数排序",normalizedTitle:"leetcode-基数排序",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:158}],headersStr:"LeetCode-基数排序 解题思路",content:'# LeetCode-基数排序\n\n基数排序算法回顾\n\n示例1\n\n输入: nums = [1, 4, 3, 100, 323, 53, 13, 559230, 123, 20, 43, 12]\n输出: [1,3,4,12,13,20,43,53,100,123,323,559230]\n\n\n1\n2\n\n1\n2\n\n\n\n# 解题思路\n\n基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数；\n\n基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。基数排序基于分别排序，分别收集，所以是稳定的。\n\n时间复杂度：设待排序列为n个记录，d个关键码，关键码的取值范围为radix，则进行链式基数排序的时间复杂度为O(d(n+radix))，其中，一趟分配时间复杂度为O(n)，一趟收集时间复杂度为O(radix)，共进行d趟分配和收集。\n\n基数排序是稳定的排序算法\n\nimport java.util.*;\n\npublic class RadixSort {\n    public static void main(String[] args) {\n        int[] array = {1, 4, 3, 100, 323, 53, 13, 559230, 123, 20, 43, 12};\n        sort(array);\n        for (Integer i : array) {\n            System.out.print(i+" ");\n        }\n    }\n\n    // 基数排序，注意这里只能排序正整数\n    public static void sort(int[] array) {\n        // 找到数组中最大数max，并计算它的位数maxDig\n        int max = array[0];\n        for (int maxTemp : array) {\n            max = Math.max(max, maxTemp);\n        }\n        int maxDig = String.valueOf(max).length();\n        // 创建从0-9的基数数据集\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        for (int i = 0; i < 10; i++) {\n            map.put(i, new ArrayList<Integer>());\n        }\n        // 从低位baseDig开始到高位maxDig进行指定位的基数排序\n        int baseDig = 1;\n        while (baseDig <= maxDig) {\n            // 第一阶段，遍历目标数组，将数组元素放入指定的基数数据集中\n            for (int temp : array) {\n                String strVal = String.valueOf(temp);\n                // 获取元素baseDig位的数字，放入相对的基数数据集中\n                // 如果不存在，将该元素放入0基数数据集中\n                Integer key = null;\n                if (strVal.length() < baseDig) {\n                    key = 0;\n                } else {\n                    // 获取指定位上的字符，并转化成目标基数key\n                    char bitNum = strVal.charAt(strVal.length() - baseDig);\n                    key = Integer.valueOf(String.valueOf(bitNum));\n                }\n                map.get(key).add(temp);\n            }\n            int j = 0;\n            // 第二阶段，将0-9基数数据集中的数据，放回到数组中\n            // 表示当前baseDig位的基数排序完成\n            for (int i = 0; i < 10; i++) {\n                Iterator<Integer> it = map.get(i).iterator();\n                while (it.hasNext()) {\n                    array[j++] = it.next();\n                }\n                map.get(i).clear();\n            }\n            baseDig++;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n',normalizedContent:'# leetcode-基数排序\n\n基数排序算法回顾\n\n示例1\n\n输入: nums = [1, 4, 3, 100, 323, 53, 13, 559230, 123, 20, 43, 12]\n输出: [1,3,4,12,13,20,43,53,100,123,323,559230]\n\n\n1\n2\n\n1\n2\n\n\n\n# 解题思路\n\n基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为o(kn),为数组长度，k为数组中的数的最大的位数；\n\n基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。基数排序基于分别排序，分别收集，所以是稳定的。\n\n时间复杂度：设待排序列为n个记录，d个关键码，关键码的取值范围为radix，则进行链式基数排序的时间复杂度为o(d(n+radix))，其中，一趟分配时间复杂度为o(n)，一趟收集时间复杂度为o(radix)，共进行d趟分配和收集。\n\n基数排序是稳定的排序算法\n\nimport java.util.*;\n\npublic class radixsort {\n    public static void main(string[] args) {\n        int[] array = {1, 4, 3, 100, 323, 53, 13, 559230, 123, 20, 43, 12};\n        sort(array);\n        for (integer i : array) {\n            system.out.print(i+" ");\n        }\n    }\n\n    // 基数排序，注意这里只能排序正整数\n    public static void sort(int[] array) {\n        // 找到数组中最大数max，并计算它的位数maxdig\n        int max = array[0];\n        for (int maxtemp : array) {\n            max = math.max(max, maxtemp);\n        }\n        int maxdig = string.valueof(max).length();\n        // 创建从0-9的基数数据集\n        map<integer, list<integer>> map = new hashmap<>();\n        for (int i = 0; i < 10; i++) {\n            map.put(i, new arraylist<integer>());\n        }\n        // 从低位basedig开始到高位maxdig进行指定位的基数排序\n        int basedig = 1;\n        while (basedig <= maxdig) {\n            // 第一阶段，遍历目标数组，将数组元素放入指定的基数数据集中\n            for (int temp : array) {\n                string strval = string.valueof(temp);\n                // 获取元素basedig位的数字，放入相对的基数数据集中\n                // 如果不存在，将该元素放入0基数数据集中\n                integer key = null;\n                if (strval.length() < basedig) {\n                    key = 0;\n                } else {\n                    // 获取指定位上的字符，并转化成目标基数key\n                    char bitnum = strval.charat(strval.length() - basedig);\n                    key = integer.valueof(string.valueof(bitnum));\n                }\n                map.get(key).add(temp);\n            }\n            int j = 0;\n            // 第二阶段，将0-9基数数据集中的数据，放回到数组中\n            // 表示当前basedig位的基数排序完成\n            for (int i = 0; i < 10; i++) {\n                iterator<integer> it = map.get(i).iterator();\n                while (it.hasnext()) {\n                    array[j++] = it.next();\n                }\n                map.get(i).clear();\n            }\n            basedig++;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"堆排序",frontmatter:{title:"堆排序",date:"2020-07-01T15:23:25.000Z",description:"堆排序",tags:["排序算法","Java"],keywords:"排序,Java",permalink:"/pages/c0468a/",categories:["算法","排序算法"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/03.%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/03.%E5%A0%86%E6%8E%92%E5%BA%8F.html",relativePath:"06.算法/03.排序算法/03.堆排序.md",key:"v-374674c3",path:"/pages/c0468a/",headers:[{level:2,title:"LeetCode-堆排序",slug:"leetcode-堆排序",normalizedTitle:"leetcode-堆排序",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:156},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:675}],headersStr:"LeetCode-堆排序 解题思路 Java代码",content:'# LeetCode-堆排序\n\n堆排序算法回顾\n\n示例1\n\n输入: nums = [1, 4, 3, 100, 323, 53, 13, 559230, 123, 20, 43, 12]\n输出: [1,3,4,12,13,20,43,53,100,123,323,559230]\n\n\n1\n2\n\n1\n2\n\n\n\n# 解题思路\n\n一个不错的堆排序讲解，出处在这\n\n了解堆排序首先需要了解堆\n\n堆是一种具有如下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆\n\n大顶堆满足：arr[i]>=arr[2i+1]&&arr[i]>=arr[2i+2]\n\n小顶堆满足：arr[i]<=arr[2i+1]&&arr[i]<=arr[2i+2]\n\n堆排序的基本思想是：\n\n * 将待排序序列构造成一个大顶堆/小顶堆，此时，整个序列的最大值就是堆顶的根节点。\n * 将其与末尾元素进行交换，此时末尾就为最大/小值。\n * 然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。\n * 如此反复执行，便能得到一个有序序列了\n\n堆排序是一种选择排序，整体主要由构建初始堆+交换堆顶元素和末尾元素并重建堆两部分组成。\n\n其中构建初始堆的复杂度为O(n)，在交换并重建堆的过程中，需交换n-1次，而重建堆的过程中，根据完全二叉树的性质\n\n[log2(n-1),log2(n-2),....,1]逐步递减，所以时间复杂度近似为O(nlogn)，堆排序是一种不稳定的排序算法\n\n\n# Java代码\n\npublic class HeapSort {\n    public static void main(String[] args) {\n        int[] array = {1, 4, 3, 100, 323, 53, 13, 559230, 123, 20, 43, 12};\n        sort(array);\n        for (Integer i : array) {\n            System.out.print(i + " ");\n        }\n    }\n\n    public static void sort(int[] arr) {\n        // 构建大顶堆\n        for (int i = arr.length / 2 - 1; i >= 0; i--) {\n            //从第一个非叶子节点从下至上，从右至左调整结构\n            adjustHeap(arr, i, arr.length);\n        }\n        // 调整堆结构+交换堆顶元素与末尾元素\n        for (int j = arr.length - 1; j > 0; j--) {\n            swap(arr, 0, j);// 将堆顶元素和末尾元素进行交换\n            adjustHeap(arr, 0, j);// 重新对堆进行调整\n        }\n    }\n\n    // 调整大顶堆(仅是调整过程，建立在大顶堆已构建的基础上)\n    private static void adjustHeap(int[] arr, int i, int length) {\n        int temp = arr[i];// 先取出当前元素i\n        for (int k = i * 2 + 1; k < length; k = k * 2 + 1) {// 从i节点的左子节点开始，也就是2i+1处开始\n            if (k + 1 < length && arr[k] < arr[k + 1]) {// 如果左子节点小于右子节点，k指向右子节点\n                k++;\n            }\n            if (arr[k] > temp) {// 如果子节点大于父节点，将子节点值赋给父节点(不用进行交换)\n                arr[i] = arr[k];\n                i = k;\n            } else {\n                break;\n            }\n        }\n        arr[i] = temp;// 将temp值放到最终的位置\n    }\n\n    private static void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n',normalizedContent:'# leetcode-堆排序\n\n堆排序算法回顾\n\n示例1\n\n输入: nums = [1, 4, 3, 100, 323, 53, 13, 559230, 123, 20, 43, 12]\n输出: [1,3,4,12,13,20,43,53,100,123,323,559230]\n\n\n1\n2\n\n1\n2\n\n\n\n# 解题思路\n\n一个不错的堆排序讲解，出处在这\n\n了解堆排序首先需要了解堆\n\n堆是一种具有如下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆\n\n大顶堆满足：arr[i]>=arr[2i+1]&&arr[i]>=arr[2i+2]\n\n小顶堆满足：arr[i]<=arr[2i+1]&&arr[i]<=arr[2i+2]\n\n堆排序的基本思想是：\n\n * 将待排序序列构造成一个大顶堆/小顶堆，此时，整个序列的最大值就是堆顶的根节点。\n * 将其与末尾元素进行交换，此时末尾就为最大/小值。\n * 然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。\n * 如此反复执行，便能得到一个有序序列了\n\n堆排序是一种选择排序，整体主要由构建初始堆+交换堆顶元素和末尾元素并重建堆两部分组成。\n\n其中构建初始堆的复杂度为o(n)，在交换并重建堆的过程中，需交换n-1次，而重建堆的过程中，根据完全二叉树的性质\n\n[log2(n-1),log2(n-2),....,1]逐步递减，所以时间复杂度近似为o(nlogn)，堆排序是一种不稳定的排序算法\n\n\n# java代码\n\npublic class heapsort {\n    public static void main(string[] args) {\n        int[] array = {1, 4, 3, 100, 323, 53, 13, 559230, 123, 20, 43, 12};\n        sort(array);\n        for (integer i : array) {\n            system.out.print(i + " ");\n        }\n    }\n\n    public static void sort(int[] arr) {\n        // 构建大顶堆\n        for (int i = arr.length / 2 - 1; i >= 0; i--) {\n            //从第一个非叶子节点从下至上，从右至左调整结构\n            adjustheap(arr, i, arr.length);\n        }\n        // 调整堆结构+交换堆顶元素与末尾元素\n        for (int j = arr.length - 1; j > 0; j--) {\n            swap(arr, 0, j);// 将堆顶元素和末尾元素进行交换\n            adjustheap(arr, 0, j);// 重新对堆进行调整\n        }\n    }\n\n    // 调整大顶堆(仅是调整过程，建立在大顶堆已构建的基础上)\n    private static void adjustheap(int[] arr, int i, int length) {\n        int temp = arr[i];// 先取出当前元素i\n        for (int k = i * 2 + 1; k < length; k = k * 2 + 1) {// 从i节点的左子节点开始，也就是2i+1处开始\n            if (k + 1 < length && arr[k] < arr[k + 1]) {// 如果左子节点小于右子节点，k指向右子节点\n                k++;\n            }\n            if (arr[k] > temp) {// 如果子节点大于父节点，将子节点值赋给父节点(不用进行交换)\n                arr[i] = arr[k];\n                i = k;\n            } else {\n                break;\n            }\n        }\n        arr[i] = temp;// 将temp值放到最终的位置\n    }\n\n    private static void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"希尔排序",frontmatter:{title:"希尔排序",date:"2020-06-28T17:16:04.000Z",description:"希尔排序",tags:["排序算法","Java"],keywords:"排序,Java",permalink:"/pages/05578a/",categories:["算法","排序算法"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/03.%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/04.%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.html",relativePath:"06.算法/03.排序算法/04.希尔排序.md",key:"v-25268267",path:"/pages/05578a/",headers:[{level:2,title:"LeetCode-希尔排序",slug:"leetcode-希尔排序",normalizedTitle:"leetcode-希尔排序",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:91},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:248}],headersStr:"LeetCode-希尔排序 解题思路 Java代码",content:'# LeetCode-希尔排序\n\n希尔排序算法回顾\n\n示例1\n\n输入: nums = [4,0,1,2,0,5]\n输出: [0,0,1,2,4,5]\n\n\n1\n2\n\n1\n2\n\n\n\n# 解题思路\n\n希尔排序算法回顾\n\n希尔排序是插入排序的一种又称"缩小增量排序"\n\n它是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止\n\n希尔排序是不稳定的排序算法，时间复杂度O(n1.3)-O(n2)\n\n\n# Java代码\n\npublic class ShellSort {\n    public static void main(String[] args) {\n        int[] arr = {4, 0, 1, 2, 0, 5};\n        shellSort(arr);\n        for (Integer i : arr) {\n            System.out.print(i);\n        }\n    }\n\n    public static void shellSort(int[] arr) {\n        //当前正在比较的数字\n        int current;\n        //初始增量\n        int gap = arr.length / 2;\n        //gap==1的时候，数组已经有序\n        while (gap > 0) {\n            for (int i = gap; i < arr.length; i++) {//内部就是一个插入排序\n                current = arr[i];\n                // 与current同组的前一个数字\n                int preIndex = i - gap;\n                // 找到同组内比current小的数字\n                while (preIndex >= 0 && current < arr[preIndex]) {\n                    // 向后移动同组内已排好序的，大于current的数字\n                    arr[preIndex + gap] = arr[preIndex];\n                    preIndex -= gap;\n                }\n                //插入current到相应的位置\n                arr[preIndex + gap] = current;\n            }\n            //缩小增量\n            gap /= 2;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n',normalizedContent:'# leetcode-希尔排序\n\n希尔排序算法回顾\n\n示例1\n\n输入: nums = [4,0,1,2,0,5]\n输出: [0,0,1,2,4,5]\n\n\n1\n2\n\n1\n2\n\n\n\n# 解题思路\n\n希尔排序算法回顾\n\n希尔排序是插入排序的一种又称"缩小增量排序"\n\n它是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止\n\n希尔排序是不稳定的排序算法，时间复杂度o(n1.3)-o(n2)\n\n\n# java代码\n\npublic class shellsort {\n    public static void main(string[] args) {\n        int[] arr = {4, 0, 1, 2, 0, 5};\n        shellsort(arr);\n        for (integer i : arr) {\n            system.out.print(i);\n        }\n    }\n\n    public static void shellsort(int[] arr) {\n        //当前正在比较的数字\n        int current;\n        //初始增量\n        int gap = arr.length / 2;\n        //gap==1的时候，数组已经有序\n        while (gap > 0) {\n            for (int i = gap; i < arr.length; i++) {//内部就是一个插入排序\n                current = arr[i];\n                // 与current同组的前一个数字\n                int preindex = i - gap;\n                // 找到同组内比current小的数字\n                while (preindex >= 0 && current < arr[preindex]) {\n                    // 向后移动同组内已排好序的，大于current的数字\n                    arr[preindex + gap] = arr[preindex];\n                    preindex -= gap;\n                }\n                //插入current到相应的位置\n                arr[preindex + gap] = current;\n            }\n            //缩小增量\n            gap /= 2;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"归并排序",frontmatter:{title:"归并排序",date:"2020-05-09T18:16:01.000Z",description:"归并排序",tags:["排序算法","Java","Easy"],keywords:"排序,JavaEasy",permalink:"/pages/246724/",categories:["算法","排序算法"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/03.%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/05.%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.html",relativePath:"06.算法/03.排序算法/05.归并排序.md",key:"v-16be0b75",path:"/pages/246724/",headers:[{level:2,title:"LeetCode-归并排序",slug:"leetcode-归并排序",normalizedTitle:"leetcode-归并排序",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:91},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:181}],headersStr:"LeetCode-归并排序 解题思路 Java代码",content:"# LeetCode-归并排序\n\n归并排序算法回顾\n\n示例1\n\n输入: nums = [4,0,1,2,0,5]\n输出: [0,0,1,2,4,5]\n\n\n1\n2\n\n1\n2\n\n\n\n# 解题思路\n\n归并排序算法采用分治的思想\n\n把原本的数组不断进行二分，直到分为数组元素是单个的时候，之后开始排序合并\n\n归并排序是稳定的排序算法，时间复杂度O(nlogn)\n\n\n# Java代码\n\npublic class Solution{\n    public static void main(String[] args) {\n        int[] arr = {9, 8, 7, 6, 5, 4, 3, 2, 1};\n        // 创建临时数组避免重复开辟空间\n        int[] temp = new int[arr.length];\n        MergerSort(arr, 0, arr.length - 1, temp);\n        for(int i : arr){\n            System.out.print(i);\n        }\n    }\n\n    private static void MergerSort(int[] arr, int left, int right, int[] temp) {\n        if (left < right) {\n            int mid = (left + right) / 2;\n            MergerSort(arr, left, mid, temp); // 左边归并排序，使得左子序列有序\n            MergerSort(arr, mid + 1, right, temp); // 右边归并排序，使得右子序列有序\n            Merge(arr, left, mid, right, temp); // 将两个有序子数组合并\n        }\n    }\n\n    private static void Merge(int[] arr, int left, int mid, int right, int[] temp) {\n        int i = left; // 左序列指针\n        int j = mid + 1; // 右序列指针\n        int t = 0; // 临时数组指针\n        while (i <= mid && j <= right) {\n            if (arr[i] < arr[j]) {\n                temp[t++] = arr[i++];\n            } else {\n                temp[t++] = arr[j++];\n            }\n        }\n        // 将左边剩余元素填充进temp中\n        while (i <= mid) {\n            temp[t++] = arr[i++];\n        }\n        // 将右边剩余元素填充进temp中\n        while (j <= right) {\n            temp[t++] = arr[j++];\n        }\n        t = 0;\n        // 拷贝回原数组\n        while (left <= right) {\n            arr[left++] = temp[t++];\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n",normalizedContent:"# leetcode-归并排序\n\n归并排序算法回顾\n\n示例1\n\n输入: nums = [4,0,1,2,0,5]\n输出: [0,0,1,2,4,5]\n\n\n1\n2\n\n1\n2\n\n\n\n# 解题思路\n\n归并排序算法采用分治的思想\n\n把原本的数组不断进行二分，直到分为数组元素是单个的时候，之后开始排序合并\n\n归并排序是稳定的排序算法，时间复杂度o(nlogn)\n\n\n# java代码\n\npublic class solution{\n    public static void main(string[] args) {\n        int[] arr = {9, 8, 7, 6, 5, 4, 3, 2, 1};\n        // 创建临时数组避免重复开辟空间\n        int[] temp = new int[arr.length];\n        mergersort(arr, 0, arr.length - 1, temp);\n        for(int i : arr){\n            system.out.print(i);\n        }\n    }\n\n    private static void mergersort(int[] arr, int left, int right, int[] temp) {\n        if (left < right) {\n            int mid = (left + right) / 2;\n            mergersort(arr, left, mid, temp); // 左边归并排序，使得左子序列有序\n            mergersort(arr, mid + 1, right, temp); // 右边归并排序，使得右子序列有序\n            merge(arr, left, mid, right, temp); // 将两个有序子数组合并\n        }\n    }\n\n    private static void merge(int[] arr, int left, int mid, int right, int[] temp) {\n        int i = left; // 左序列指针\n        int j = mid + 1; // 右序列指针\n        int t = 0; // 临时数组指针\n        while (i <= mid && j <= right) {\n            if (arr[i] < arr[j]) {\n                temp[t++] = arr[i++];\n            } else {\n                temp[t++] = arr[j++];\n            }\n        }\n        // 将左边剩余元素填充进temp中\n        while (i <= mid) {\n            temp[t++] = arr[i++];\n        }\n        // 将右边剩余元素填充进temp中\n        while (j <= right) {\n            temp[t++] = arr[j++];\n        }\n        t = 0;\n        // 拷贝回原数组\n        while (left <= right) {\n            arr[left++] = temp[t++];\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"快速排序",frontmatter:{title:"快速排序",date:"2020-05-04T16:33:58.000Z",description:"快速排序",tags:["排序算法","Java","Easy"],keywords:"排序,JavaEasy",permalink:"/pages/c1fce8/",categories:["算法","排序算法"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/03.%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/06.%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html",relativePath:"06.算法/03.排序算法/06.快速排序.md",key:"v-bcc2cd22",path:"/pages/c1fce8/",headers:[{level:2,title:"LeetCode-快速排序",slug:"leetcode-快速排序",normalizedTitle:"leetcode-快速排序",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:91},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:203},{level:3,title:"算法推导",slug:"算法推导",normalizedTitle:"算法推导",charIndex:1777}],headersStr:"LeetCode-快速排序 解题思路 Java代码 算法推导",content:"# LeetCode-快速排序\n\n快速排序算法回顾\n\n示例1\n\n输入: nums = [4,0,1,2,0,5]\n输出: [0,0,1,2,4,5]\n\n\n1\n2\n\n1\n2\n\n\n\n# 解题思路\n\n快速排序算法回顾，左右两个指针进行操作，判断基准数和指针位置的大小关系，使得基准数左边的数字比它小，右边的数字比它大。递归进行求解\n\n快速排序是不稳定的排序算法，时间复杂度O(nlogn)-O(n^2)\n\n\n# Java代码\n\npublic class Solotion {\n    public static void main(String[] args) {\n        int[] arr = {4, 0, 1, 2, 0, 5};\n        quickSort(arr, 0, arr.length - 1);\n        for (Integer i : arr) {\n            System.out.print(i);\n        }\n    }\n\n    public static void quickSort(int[] list, int left, int right) {\n        if (left < right) {\n            // 分割数组，找到分割点\n            int point = partition(list, left, right);\n            // 对左子数组进行快排\n            quickSort(list, left, point - 1);\n            // 对右子数组进行快排\n            quickSort(list, point + 1, right);\n        }\n    }\n\n    public static int partition(int[] list, int left, int right) {\n        // 用数组的第一个元素作为基准数\n        int first = list[left];\n        while (left < right) {\n            while (left < right && list[right] >= first) {\n                right--;\n            }\n            swap(list, left, right);\n            while (left < right && list[left] < first) {\n                left++;\n            }\n            swap(list, left, right);\n        }\n        // 返回分割点所在的位置\n        return left;\n    }\n\n    public static void swap(int[] list, int left, int right) {\n        int temp;\n        if (list != null && list.length > 0) {\n            temp = list[left];\n            list[left] = list[right];\n            list[right] = temp;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# 算法推导\n\n第一轮快排结果推导\n\n",normalizedContent:"# leetcode-快速排序\n\n快速排序算法回顾\n\n示例1\n\n输入: nums = [4,0,1,2,0,5]\n输出: [0,0,1,2,4,5]\n\n\n1\n2\n\n1\n2\n\n\n\n# 解题思路\n\n快速排序算法回顾，左右两个指针进行操作，判断基准数和指针位置的大小关系，使得基准数左边的数字比它小，右边的数字比它大。递归进行求解\n\n快速排序是不稳定的排序算法，时间复杂度o(nlogn)-o(n^2)\n\n\n# java代码\n\npublic class solotion {\n    public static void main(string[] args) {\n        int[] arr = {4, 0, 1, 2, 0, 5};\n        quicksort(arr, 0, arr.length - 1);\n        for (integer i : arr) {\n            system.out.print(i);\n        }\n    }\n\n    public static void quicksort(int[] list, int left, int right) {\n        if (left < right) {\n            // 分割数组，找到分割点\n            int point = partition(list, left, right);\n            // 对左子数组进行快排\n            quicksort(list, left, point - 1);\n            // 对右子数组进行快排\n            quicksort(list, point + 1, right);\n        }\n    }\n\n    public static int partition(int[] list, int left, int right) {\n        // 用数组的第一个元素作为基准数\n        int first = list[left];\n        while (left < right) {\n            while (left < right && list[right] >= first) {\n                right--;\n            }\n            swap(list, left, right);\n            while (left < right && list[left] < first) {\n                left++;\n            }\n            swap(list, left, right);\n        }\n        // 返回分割点所在的位置\n        return left;\n    }\n\n    public static void swap(int[] list, int left, int right) {\n        int temp;\n        if (list != null && list.length > 0) {\n            temp = list[left];\n            list[left] = list[right];\n            list[right] = temp;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# 算法推导\n\n第一轮快排结果推导\n\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"插入排序",frontmatter:{title:"插入排序",date:"2020-06-28T16:46:47.000Z",description:"插入排序",tags:["排序算法","Java"],keywords:"排序,Java",permalink:"/pages/db04fa/",categories:["算法","排序算法"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/03.%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/07.%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.html",relativePath:"06.算法/03.排序算法/07.插入排序.md",key:"v-5519367f",path:"/pages/db04fa/",headers:[{level:2,title:"LeetCode-插入排序",slug:"leetcode-插入排序",normalizedTitle:"leetcode-插入排序",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:91},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:251}],headersStr:"LeetCode-插入排序 解题思路 Java代码",content:"# LeetCode-插入排序\n\n插入排序算法回顾\n\n示例1\n\n输入: nums = [4,0,1,2,0,5]\n输出: [0,0,1,2,4,5]\n\n\n1\n2\n\n1\n2\n\n\n\n# 解题思路\n\n插入排序算法回顾\n\n插入排序是一种简单直观的排序算法，其基本原理是通过构建有序序列，对未排序的数组，需要在已排序的序列中从后向前进行扫描，找到相应位置并插入。在从后向前扫描的过程中，需要反复把已排序的元素向后移动，为新元素提供插入的空间。\n\n插入排序是稳定的排序算法，时间复杂度O(n^(1-2))\n\n\n# Java代码\n\npublic class InsertSort {\n    public static void main(String[] args) {\n        int[] arr = {4, 0, 1, 2, 0, 5};\n        insertSort(arr, arr.length - 1);\n        for (Integer i : arr) {\n            System.out.print(i);\n        }\n    }\n\n    public static void insertSort(int arr[], int len) {\n        for (int i = 1; i < len; i++) {\n            int temp = arr[i];\n            int left = i - 1;\n            while (left >= 0 && arr[left] > temp) {\n                arr[left + 1] = arr[left];\n                left--;\n            }\n            arr[left + 1] = temp;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n",normalizedContent:"# leetcode-插入排序\n\n插入排序算法回顾\n\n示例1\n\n输入: nums = [4,0,1,2,0,5]\n输出: [0,0,1,2,4,5]\n\n\n1\n2\n\n1\n2\n\n\n\n# 解题思路\n\n插入排序算法回顾\n\n插入排序是一种简单直观的排序算法，其基本原理是通过构建有序序列，对未排序的数组，需要在已排序的序列中从后向前进行扫描，找到相应位置并插入。在从后向前扫描的过程中，需要反复把已排序的元素向后移动，为新元素提供插入的空间。\n\n插入排序是稳定的排序算法，时间复杂度o(n^(1-2))\n\n\n# java代码\n\npublic class insertsort {\n    public static void main(string[] args) {\n        int[] arr = {4, 0, 1, 2, 0, 5};\n        insertsort(arr, arr.length - 1);\n        for (integer i : arr) {\n            system.out.print(i);\n        }\n    }\n\n    public static void insertsort(int arr[], int len) {\n        for (int i = 1; i < len; i++) {\n            int temp = arr[i];\n            int left = i - 1;\n            while (left >= 0 && arr[left] > temp) {\n                arr[left + 1] = arr[left];\n                left--;\n            }\n            arr[left + 1] = temp;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"桶排序",frontmatter:{title:"桶排序",date:"2020-07-01T09:59:15.000Z",description:"桶排序",tags:["排序算法","Java"],keywords:"排序,Java",permalink:"/pages/7a5e99/",categories:["算法","排序算法"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/03.%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/08.%E6%A1%B6%E6%8E%92%E5%BA%8F.html",relativePath:"06.算法/03.排序算法/08.桶排序.md",key:"v-f68eea1a",path:"/pages/7a5e99/",headers:[{level:2,title:"LeetCode-桶排序",slug:"leetcode-桶排序",normalizedTitle:"leetcode-桶排序",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:89},{level:3,title:"Java代码1",slug:"java代码1",normalizedTitle:"java代码1",charIndex:360},{level:3,title:"Java代码2",slug:"java代码2",normalizedTitle:"java代码2",charIndex:1514},{level:3,title:"时间复杂度",slug:"时间复杂度",normalizedTitle:"时间复杂度",charIndex:3236},{level:3,title:"空间复杂度",slug:"空间复杂度",normalizedTitle:"空间复杂度",charIndex:3453}],headersStr:"LeetCode-桶排序 解题思路 Java代码1 Java代码2 时间复杂度 空间复杂度",content:'# LeetCode-桶排序\n\n桶排序算法回顾\n\n示例1\n\n输入: nums = [4,0,1,2,0,5]\n输出: [0,0,1,2,4,5]\n\n\n1\n2\n\n1\n2\n\n\n\n# 解题思路\n\n桶排序(Bucket Sort)的原理很简单，它是将数组分到有限数量的桶子里。是一种非比较的排序方法\n\n在了解桶排序之前，先了解计数排序\n\n其中计数排序思想如下：\n\n假设待排序的数组a中共有N个整数，并且已知数组a中数据的范围[0, MAX)。在桶排序时，创建容量为MAX的桶数组r，并将桶数组元素都初始化为0；将容量为MAX的桶数组中的每一个单元都看作一个"桶"。 在排序时，逐个遍历数组a，将数组a的值，作为"桶数组r"的下标。当a中数据被读取时，就将桶的值加1。例如，读取到数组a[3]=5，则将r[5]的值+1。\n\n\n# Java代码1\n\n\npublic class BucketSort2 {\n    public static void main(String[] args) {\n        int[] arr = {4, 0, 1, 2, 0, 10};\n        bucketSort2(arr);\n        for (Integer i : arr) {\n            System.out.print(i);\n        }\n    }\n\n    public static void bucketSort2(int[] arr) {\n        if (arr == null || arr.length < 2) {\n            return;\n        }\n        int max = Integer.MIN_VALUE;\n        for (int i = 0; i < arr.length; i++) {\n            max = Math.max(max, arr[i]);\n        }\n        int[] bucket = new int[max + 1];\n        for (int i = 0; i < arr.length; i++) {\n            bucket[arr[i]]++;\n        }\n        int index = 0;\n        for (int j = 0; j < bucket.length; j++) {\n            while (bucket[j]-- > 0) {\n                arr[index++] = j;\n            }\n        }\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n桶排序可以看做是计数排序的扩展，在计数排序中，每个桶只存储相同的元素\n\n而桶排序中每个桶存储一定范围的元素，通过映射函数，将待排序数组中的元素存储到各个对应的桶中\n\n之后对每个桶中的元素进行排序\n\n最后将非空桶中的元素逐个放入原序列中\n\n桶排序需要尽量保证元素分散均匀，否则当所有数据集中在同一个桶中时，桶排序就会失效\n\n桶排序的稳定性取决于桶内部使用的排序算法\n\n\n# Java代码2\n\nimport java.util.ArrayList;\nimport java.util.Collections;\n\npublic class BucketSort {\n    public static void main(String[] args) {\n        int[] arr = {4, 0, 1, 2, 0, 5};\n        bucketSort(arr);\n        for (Integer i : arr) {\n            System.out.print(i);\n        }\n    }\n\n    public static void bucketSort(int[] arr) {\n        // 计算最大值与最小值\n        int max = Integer.MIN_VALUE;\n        int min = Integer.MAX_VALUE;\n        for (int i = 0; i < arr.length; i++) {\n            max = Math.max(max, arr[i]);\n            min = Math.min(min, arr[i]);\n        }\n\n        // 计算桶的数量\n        int bucketNum = (max - min) / arr.length + 1; //保证每个桶存的区间范围平均，+1代表余数补1个桶\n        ArrayList<ArrayList<Integer>> bucketArr = new ArrayList<>(bucketNum);\n        for (int i = 0; i < bucketNum; i++) {\n            bucketArr.add(new ArrayList<Integer>());\n        }\n\n        // 将每个元素放入桶\n        for (int i = 0; i < arr.length; i++) {\n            int num = (arr[i] - min) / (arr.length); //确定arr[i]存储在哪个桶\n            bucketArr.get(num).add(arr[i]);\n        }\n\n        // 对每个桶进行排序\n        for (int i = 0; i < bucketArr.size(); i++) {\n            Collections.sort(bucketArr.get(i)); // 内层排序算法可选择\n        }\n\n        // 将桶中的元素赋值到原序列\n        int index = 0;\n        for (int i = 0; i < bucketArr.size(); i++) {\n            for (int j = 0; j < bucketArr.get(i).size(); j++) {\n                arr[index++] = bucketArr.get(i).get(j);\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n# 时间复杂度\n\n对于待排序序列大小为N，共分为M个桶，主要步骤有：\n\n * N次循环，将每个元素装入对应的桶中\n * M次循环，对每个桶中的数据进行排序(平均每个桶有N/M个元素)\n\n一般使用较为快速的排序算法，时间复杂度为O(nlogn)，实际的桶排序过程是以链表形式插入的\n\n整个桶排序的时间复杂度为：\n\nO(N)+O(M*(N/M*log(N/M)))=O(N*(log(N/M)+1))\n\n当N=M时，复杂度为O(N)\n\n\n# 空间复杂度\n\nO(N+M)',normalizedContent:'# leetcode-桶排序\n\n桶排序算法回顾\n\n示例1\n\n输入: nums = [4,0,1,2,0,5]\n输出: [0,0,1,2,4,5]\n\n\n1\n2\n\n1\n2\n\n\n\n# 解题思路\n\n桶排序(bucket sort)的原理很简单，它是将数组分到有限数量的桶子里。是一种非比较的排序方法\n\n在了解桶排序之前，先了解计数排序\n\n其中计数排序思想如下：\n\n假设待排序的数组a中共有n个整数，并且已知数组a中数据的范围[0, max)。在桶排序时，创建容量为max的桶数组r，并将桶数组元素都初始化为0；将容量为max的桶数组中的每一个单元都看作一个"桶"。 在排序时，逐个遍历数组a，将数组a的值，作为"桶数组r"的下标。当a中数据被读取时，就将桶的值加1。例如，读取到数组a[3]=5，则将r[5]的值+1。\n\n\n# java代码1\n\n\npublic class bucketsort2 {\n    public static void main(string[] args) {\n        int[] arr = {4, 0, 1, 2, 0, 10};\n        bucketsort2(arr);\n        for (integer i : arr) {\n            system.out.print(i);\n        }\n    }\n\n    public static void bucketsort2(int[] arr) {\n        if (arr == null || arr.length < 2) {\n            return;\n        }\n        int max = integer.min_value;\n        for (int i = 0; i < arr.length; i++) {\n            max = math.max(max, arr[i]);\n        }\n        int[] bucket = new int[max + 1];\n        for (int i = 0; i < arr.length; i++) {\n            bucket[arr[i]]++;\n        }\n        int index = 0;\n        for (int j = 0; j < bucket.length; j++) {\n            while (bucket[j]-- > 0) {\n                arr[index++] = j;\n            }\n        }\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n桶排序可以看做是计数排序的扩展，在计数排序中，每个桶只存储相同的元素\n\n而桶排序中每个桶存储一定范围的元素，通过映射函数，将待排序数组中的元素存储到各个对应的桶中\n\n之后对每个桶中的元素进行排序\n\n最后将非空桶中的元素逐个放入原序列中\n\n桶排序需要尽量保证元素分散均匀，否则当所有数据集中在同一个桶中时，桶排序就会失效\n\n桶排序的稳定性取决于桶内部使用的排序算法\n\n\n# java代码2\n\nimport java.util.arraylist;\nimport java.util.collections;\n\npublic class bucketsort {\n    public static void main(string[] args) {\n        int[] arr = {4, 0, 1, 2, 0, 5};\n        bucketsort(arr);\n        for (integer i : arr) {\n            system.out.print(i);\n        }\n    }\n\n    public static void bucketsort(int[] arr) {\n        // 计算最大值与最小值\n        int max = integer.min_value;\n        int min = integer.max_value;\n        for (int i = 0; i < arr.length; i++) {\n            max = math.max(max, arr[i]);\n            min = math.min(min, arr[i]);\n        }\n\n        // 计算桶的数量\n        int bucketnum = (max - min) / arr.length + 1; //保证每个桶存的区间范围平均，+1代表余数补1个桶\n        arraylist<arraylist<integer>> bucketarr = new arraylist<>(bucketnum);\n        for (int i = 0; i < bucketnum; i++) {\n            bucketarr.add(new arraylist<integer>());\n        }\n\n        // 将每个元素放入桶\n        for (int i = 0; i < arr.length; i++) {\n            int num = (arr[i] - min) / (arr.length); //确定arr[i]存储在哪个桶\n            bucketarr.get(num).add(arr[i]);\n        }\n\n        // 对每个桶进行排序\n        for (int i = 0; i < bucketarr.size(); i++) {\n            collections.sort(bucketarr.get(i)); // 内层排序算法可选择\n        }\n\n        // 将桶中的元素赋值到原序列\n        int index = 0;\n        for (int i = 0; i < bucketarr.size(); i++) {\n            for (int j = 0; j < bucketarr.get(i).size(); j++) {\n                arr[index++] = bucketarr.get(i).get(j);\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n# 时间复杂度\n\n对于待排序序列大小为n，共分为m个桶，主要步骤有：\n\n * n次循环，将每个元素装入对应的桶中\n * m次循环，对每个桶中的数据进行排序(平均每个桶有n/m个元素)\n\n一般使用较为快速的排序算法，时间复杂度为o(nlogn)，实际的桶排序过程是以链表形式插入的\n\n整个桶排序的时间复杂度为：\n\no(n)+o(m*(n/m*log(n/m)))=o(n*(log(n/m)+1))\n\n当n=m时，复杂度为o(n)\n\n\n# 空间复杂度\n\no(n+m)',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"选择排序",frontmatter:{title:"选择排序",date:"2020-06-28T16:16:47.000Z",description:"选择排序",tags:["排序算法","Java"],keywords:"排序,Java",permalink:"/pages/ee0279/",categories:["算法","排序算法"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/03.%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/09.%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.html",relativePath:"06.算法/03.排序算法/09.选择排序.md",key:"v-70d91d55",path:"/pages/ee0279/",headers:[{level:2,title:"LeetCode-选择排序",slug:"leetcode-选择排序",normalizedTitle:"leetcode-选择排序",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:91},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:198}],headersStr:"LeetCode-选择排序 解题思路 Java代码",content:"# LeetCode-选择排序\n\n选择排序算法回顾\n\n示例1\n\n输入: nums = [4,0,1,2,0,5]\n输出: [0,0,1,2,4,5]\n\n\n1\n2\n\n1\n2\n\n\n\n# 解题思路\n\n选择排序算法回顾\n\n选择排序是指每一趟从待排序的数据元素中选出最大（或最小）的一个元素，顺序放在已排好序的数列的最后，直到全部待排序的数据元素排完。时间复杂度O(n^2)，是不稳定的排序算法。\n\n\n# Java代码\n\npublic class SelectionSort {\n    public static void main(String[] args) {\n        int[] arr = {4, 0, 1, 2, 0, 5};\n        selectionSort(arr);\n        for (Integer i : arr) {\n            System.out.print(i);\n        }\n    }\n\n    public static void selectionSort(int[] arr) {\n        for (int i = 0; i < arr.length - 1; i++) {\n            int min = i;\n            for (int j = min + 1; j < arr.length; j++) {\n                if (arr[min] > arr[j]) {\n                    min = j;\n                }\n            }\n            if (min != i) {\n                int temp = arr[min];\n                arr[min] = arr[i];\n                arr[i] = temp;\n            }\n        }\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n",normalizedContent:"# leetcode-选择排序\n\n选择排序算法回顾\n\n示例1\n\n输入: nums = [4,0,1,2,0,5]\n输出: [0,0,1,2,4,5]\n\n\n1\n2\n\n1\n2\n\n\n\n# 解题思路\n\n选择排序算法回顾\n\n选择排序是指每一趟从待排序的数据元素中选出最大（或最小）的一个元素，顺序放在已排好序的数列的最后，直到全部待排序的数据元素排完。时间复杂度o(n^2)，是不稳定的排序算法。\n\n\n# java代码\n\npublic class selectionsort {\n    public static void main(string[] args) {\n        int[] arr = {4, 0, 1, 2, 0, 5};\n        selectionsort(arr);\n        for (integer i : arr) {\n            system.out.print(i);\n        }\n    }\n\n    public static void selectionsort(int[] arr) {\n        for (int i = 0; i < arr.length - 1; i++) {\n            int min = i;\n            for (int j = min + 1; j < arr.length; j++) {\n                if (arr[min] > arr[j]) {\n                    min = j;\n                }\n            }\n            if (min != i) {\n                int temp = arr[min];\n                arr[min] = arr[i];\n                arr[i] = temp;\n            }\n        }\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"将hexo自定义域名升级https",frontmatter:{title:"将hexo自定义域名升级https",date:"2018-08-29T16:02:44.000Z",categories:["Hexo"],tags:["Hexo"],permalink:"/pages/f6b758/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/07.%E5%AE%9E%E8%B7%B5/01.hexo/01.%E5%B0%86hexo%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%8D%87%E7%BA%A7https.html",relativePath:"07.实践/01.hexo/01.将hexo自定义域名升级https.md",key:"v-968013f4",path:"/pages/f6b758/",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:2},{level:2,title:"打开Github Pages页面的强制HTTPS",slug:"打开github-pages页面的强制https",normalizedTitle:"打开github pages页面的强制https",charIndex:233},{level:2,title:"打开Coding Pages服务的强制HTTPS访问",slug:"打开coding-pages服务的强制https访问",normalizedTitle:"打开coding pages服务的强制https访问",charIndex:343},{level:2,title:"云存储对象的选择（腾讯云）",slug:"云存储对象的选择-腾讯云",normalizedTitle:"云存储对象的选择（腾讯云）",charIndex:486},{level:2,title:"腾讯云对象存储添加",slug:"腾讯云对象存储添加",normalizedTitle:"腾讯云对象存储添加",charIndex:735},{level:3,title:"1、在云产品中选择对象存储",slug:"_1、在云产品中选择对象存储",normalizedTitle:"1、在云产品中选择对象存储",charIndex:749},{level:3,title:"2、创建存储桶",slug:"_2、创建存储桶",normalizedTitle:"2、创建存储桶",charIndex:769},{level:4,title:"2.1关于存储的容量问题：",slug:"_2-1关于存储的容量问题",normalizedTitle:"2.1关于存储的容量问题：",charIndex:782},{level:3,title:"3、创建存储桶后上传自己的文件，然后点击详情，可以看到他的https外部链接",slug:"_3、创建存储桶后上传自己的文件-然后点击详情-可以看到他的https外部链接",normalizedTitle:"3、创建存储桶后上传自己的文件，然后点击详情，可以看到他的https外部链接",charIndex:863},{level:3,title:"4、更换自己的md文件的外部链接即可，然后重新部署hexo，就可以看到效果了",slug:"_4、更换自己的md文件的外部链接即可-然后重新部署hexo-就可以看到效果了",normalizedTitle:"4、更换自己的md文件的外部链接即可，然后重新部署hexo，就可以看到效果了",charIndex:908}],headersStr:"前言 打开Github Pages页面的强制HTTPS 打开Coding Pages服务的强制HTTPS访问 云存储对象的选择（腾讯云） 腾讯云对象存储添加 1、在云产品中选择对象存储 2、创建存储桶 2.1关于存储的容量问题： 3、创建存储桶后上传自己的文件，然后点击详情，可以看到他的https外部链接 4、更换自己的md文件的外部链接即可，然后重新部署hexo，就可以看到效果了",content:"# 前言\n\n最近在折腾博客，发现github上很多人说个人博客支持https很重要，原本的github.io域名本来支持https协议，但是在自定义域名之后，协议变成了http。这使得网站变得不够安全，容易被劫持。\n\n但是网上的支持https很多都是反向代理，以及SSL证书等，涉及到备案还有一些配置操作，算是比较麻烦，期间如果不对还会出现各种bug。所以针对简单想支持全站https的站长而言，我们可以选择如下操作：\n\n提示\n\n对于github解析的用户\n\n\n# 打开Github Pages页面的强制HTTPS\n\n\n\n在此之前，请确认上图中的Custom domain已经写为你的自定义域名\n\n然后再勾选Enforce HTTPS即可\n\n提示\n\n对于coding解析的用户\n\n\n# 打开Coding Pages服务的强制HTTPS访问\n\n\n\n对于没有引用外部链接的同学来说，你已经获得了https认证，在谷歌浏览器中可见网站的小绿锁，但是对于大部分站长来说都有自己的云存储来保存自己的图片或者文件，于是我们需要一个图床或者云对象存储并且它支持https协议。\n\n\n# 云存储对象的选择（腾讯云）\n\n在百度中想要支持https外链的图床有不少，如简单图床、SM.MS、imgur、路过图床等，读者如果仅仅需要引用图片文件，那么这些图床完全满足你的要求，并可以保证全站https。但是笔者需要存储的不仅仅是图片，有事还会存储文件，而这些图床只能存储图片，不能存储其他文件，这就无法保证我其他文件的https链接，笔者偶然间发现，腾讯云的对象存储具有不错的空间，并且支持https协议的外链，而且免费，于是把整个云存储搬去腾讯云，更换外链后完成了全站https。\n\n\n# 腾讯云对象存储添加\n\n\n# 1、在云产品中选择对象存储\n\n\n\n\n# 2、创建存储桶\n\n\n\n# 2.1关于存储的容量问题：\n\n每个存储桶中的对象不限\n\n\n\n每月免费存储额度50GB，下行流量10GB，对于一个个人博客流量还不大的情况下完全足够了\n\n\n\n\n# 3、创建存储桶后上传自己的文件，然后点击详情，可以看到他的https外部链接\n\n\n\n\n# 4、更换自己的md文件的外部链接即可，然后重新部署hexo，就可以看到效果了\n\n",normalizedContent:"# 前言\n\n最近在折腾博客，发现github上很多人说个人博客支持https很重要，原本的github.io域名本来支持https协议，但是在自定义域名之后，协议变成了http。这使得网站变得不够安全，容易被劫持。\n\n但是网上的支持https很多都是反向代理，以及ssl证书等，涉及到备案还有一些配置操作，算是比较麻烦，期间如果不对还会出现各种bug。所以针对简单想支持全站https的站长而言，我们可以选择如下操作：\n\n提示\n\n对于github解析的用户\n\n\n# 打开github pages页面的强制https\n\n\n\n在此之前，请确认上图中的custom domain已经写为你的自定义域名\n\n然后再勾选enforce https即可\n\n提示\n\n对于coding解析的用户\n\n\n# 打开coding pages服务的强制https访问\n\n\n\n对于没有引用外部链接的同学来说，你已经获得了https认证，在谷歌浏览器中可见网站的小绿锁，但是对于大部分站长来说都有自己的云存储来保存自己的图片或者文件，于是我们需要一个图床或者云对象存储并且它支持https协议。\n\n\n# 云存储对象的选择（腾讯云）\n\n在百度中想要支持https外链的图床有不少，如简单图床、sm.ms、imgur、路过图床等，读者如果仅仅需要引用图片文件，那么这些图床完全满足你的要求，并可以保证全站https。但是笔者需要存储的不仅仅是图片，有事还会存储文件，而这些图床只能存储图片，不能存储其他文件，这就无法保证我其他文件的https链接，笔者偶然间发现，腾讯云的对象存储具有不错的空间，并且支持https协议的外链，而且免费，于是把整个云存储搬去腾讯云，更换外链后完成了全站https。\n\n\n# 腾讯云对象存储添加\n\n\n# 1、在云产品中选择对象存储\n\n\n\n\n# 2、创建存储桶\n\n\n\n# 2.1关于存储的容量问题：\n\n每个存储桶中的对象不限\n\n\n\n每月免费存储额度50gb，下行流量10gb，对于一个个人博客流量还不大的情况下完全足够了\n\n\n\n\n# 3、创建存储桶后上传自己的文件，然后点击详情，可以看到他的https外部链接\n\n\n\n\n# 4、更换自己的md文件的外部链接即可，然后重新部署hexo，就可以看到效果了\n\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"hexo到Typecho的迁移日志",frontmatter:{title:"hexo到Typecho的迁移日志",date:"2021-11-22T22:48:38.000Z",categories:["Hexo"],tags:["Hexo","Typecho","VuePress"],permalink:"/pages/a07112/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/07.%E5%AE%9E%E8%B7%B5/01.hexo/02.hexo%E5%88%B0Typecho%E7%9A%84%E8%BF%81%E7%A7%BB%E6%97%A5%E5%BF%97.html",relativePath:"07.实践/01.hexo/02.hexo到Typecho的迁移日志.md",key:"v-ecf02760",path:"/pages/a07112/",headers:[{level:3,title:"📘迁移日志🚩",slug:"📘迁移日志🚩",normalizedTitle:"📘迁移日志🚩",charIndex:2},{level:3,title:"🔎为什么迁移？",slug:"🔎为什么迁移",normalizedTitle:"🔎为什么迁移？",charIndex:205},{level:3,title:"🚠关于分站",slug:"🚠关于分站",normalizedTitle:"🚠关于分站",charIndex:976},{level:3,title:"🚴Typecho环境",slug:"🚴typecho环境",normalizedTitle:"🚴typecho环境",charIndex:1169},{level:3,title:"🥗愿景",slug:"🥗愿景",normalizedTitle:"🥗愿景",charIndex:1357}],headersStr:"📘迁移日志🚩 🔎为什么迁移？ 🚠关于分站 🚴Typecho环境 🥗愿景",content:'# 📘迁移日志🚩\n\n2018年hexo博客是当红炸子鸡，第一次接触博客的我搭建了第一个个人博客。搭建好的一个月内，给博客做了大量的折腾工作。包括：各种插件、自定义样式、自定义页面、SEO优化、缓存加速、百度统计等。光样式表就写了700+行，可以说是基本更换了NexT主题的原始样式。之后也没有更新很多文章，进入了半弃坑状态，2020年疫情在家开始重拾博客更新，期间给博客水了N篇LeetCode题\n\n\n# 🔎为什么迁移？\n\n2021年，距离上次折腾博客已经过去了三年，在长时间更新博客时，hexo总有让我不太满意的地方。\n\n 1. 比如local search在本地文章多的时候，生成search.xml的速度太慢，导致同学经常吐槽博客"搜个东西转圈那么久"，由于hexo本身是纯静态博客，由nodejs支撑其主要功能，所以快速的搜索只能依赖于本地索引或者第三方api。\n 2. 插件和定制化过多，拖慢了网站访问速度，后期加上了CDN才勉强压缩到2s左右。\n 3. NexT的简约扁平化风格看腻了，几年过去了，hexo已经衍生了更多优秀的主题，升级主题带来的成本比较大(由于个人定制内容过多)。\n 4. 因为部署在服务器，hexo三连部署太慢，每次都要生成全部文章等在电脑前部署\n 5. 评论区、邮件发送功能、数值统计功能均依赖于第三方api\n\n🍡为了更好的博客体验，我决定重新搭建个人博客，选用Typecho作为博客的引擎。\nTypecho博客由PHP驱动，以前总会觉得Typecho需要数据库支撑会带来许多运维困难，但如今随着宝塔面板在云服务器的充分使用，运维问题已经非常简化了。相对于hexo，Typecho带来了如下优点：\n\n\n 6.  更加快速、简洁的网站体验，网站访问速度基本在1-2s内。\n 7.  得益于数据库驱动，文章搜索不再需要前端在用户访问时生成动态索引，避免了搜索东西转圈的问题。\n 8.  更好更现代的运维方式，文章发布不再需要三连部署，后台点击发布即可实时看到发布的新文章，组件通过宝塔面板能够更好的维护，支持定时任务备份数据。\n 9.  不再需要第三方api接入，评论系统从hexo的valine+leancloud的组合改为存储在数据库中，数值统计不再依赖于busuanzi\n 10. 更好的视觉效果~\n\n\n# 🚠关于分站\n\n以前的站点是服务器+github+coding的三线部署，为了更好的保留以前的分站效果，旧站的hexo博客托管到了github，如今的github也是全面拥抱了DevOps，hexo用户不再需要通过烦琐的三连命令部署了，直接推送分支代码到仓库，github便会快速的CI/CD，变得更加易用了！同时，主站和分站也开启了相互链接，欢迎从顶部导航栏进入曾经的分站~\n\n\n# 🚴Typecho环境\n\n数据库：Mysql: 8.x+ 后端语言：PHP: 7.x+ Web服务器: Nginx: 1.20+ 缓存：CDN、Service Work、Redis\n\n笔记\n\n2022年4月，基于VuePress，voding主题搭建的个人知识库上线~用于以更适合阅读的方式总结知识\n\n博客主站：here\n\nhexo旧站：here\n\n知识库：here\n\n\n# 🥗愿景\n\n希望在今后的日子里，分享更多更高质量的文章~😋',normalizedContent:'# 📘迁移日志🚩\n\n2018年hexo博客是当红炸子鸡，第一次接触博客的我搭建了第一个个人博客。搭建好的一个月内，给博客做了大量的折腾工作。包括：各种插件、自定义样式、自定义页面、seo优化、缓存加速、百度统计等。光样式表就写了700+行，可以说是基本更换了next主题的原始样式。之后也没有更新很多文章，进入了半弃坑状态，2020年疫情在家开始重拾博客更新，期间给博客水了n篇leetcode题\n\n\n# 🔎为什么迁移？\n\n2021年，距离上次折腾博客已经过去了三年，在长时间更新博客时，hexo总有让我不太满意的地方。\n\n 1. 比如local search在本地文章多的时候，生成search.xml的速度太慢，导致同学经常吐槽博客"搜个东西转圈那么久"，由于hexo本身是纯静态博客，由nodejs支撑其主要功能，所以快速的搜索只能依赖于本地索引或者第三方api。\n 2. 插件和定制化过多，拖慢了网站访问速度，后期加上了cdn才勉强压缩到2s左右。\n 3. next的简约扁平化风格看腻了，几年过去了，hexo已经衍生了更多优秀的主题，升级主题带来的成本比较大(由于个人定制内容过多)。\n 4. 因为部署在服务器，hexo三连部署太慢，每次都要生成全部文章等在电脑前部署\n 5. 评论区、邮件发送功能、数值统计功能均依赖于第三方api\n\n🍡为了更好的博客体验，我决定重新搭建个人博客，选用typecho作为博客的引擎。\ntypecho博客由php驱动，以前总会觉得typecho需要数据库支撑会带来许多运维困难，但如今随着宝塔面板在云服务器的充分使用，运维问题已经非常简化了。相对于hexo，typecho带来了如下优点：\n\n\n 6.  更加快速、简洁的网站体验，网站访问速度基本在1-2s内。\n 7.  得益于数据库驱动，文章搜索不再需要前端在用户访问时生成动态索引，避免了搜索东西转圈的问题。\n 8.  更好更现代的运维方式，文章发布不再需要三连部署，后台点击发布即可实时看到发布的新文章，组件通过宝塔面板能够更好的维护，支持定时任务备份数据。\n 9.  不再需要第三方api接入，评论系统从hexo的valine+leancloud的组合改为存储在数据库中，数值统计不再依赖于busuanzi\n 10. 更好的视觉效果~\n\n\n# 🚠关于分站\n\n以前的站点是服务器+github+coding的三线部署，为了更好的保留以前的分站效果，旧站的hexo博客托管到了github，如今的github也是全面拥抱了devops，hexo用户不再需要通过烦琐的三连命令部署了，直接推送分支代码到仓库，github便会快速的ci/cd，变得更加易用了！同时，主站和分站也开启了相互链接，欢迎从顶部导航栏进入曾经的分站~\n\n\n# 🚴typecho环境\n\n数据库：mysql: 8.x+ 后端语言：php: 7.x+ web服务器: nginx: 1.20+ 缓存：cdn、service work、redis\n\n笔记\n\n2022年4月，基于vuepress，voding主题搭建的个人知识库上线~用于以更适合阅读的方式总结知识\n\n博客主站：here\n\nhexo旧站：here\n\n知识库：here\n\n\n# 🥗愿景\n\n希望在今后的日子里，分享更多更高质量的文章~😋',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"海量数据TopK问题",frontmatter:{title:"海量数据TopK问题",date:"2020-06-29T16:18:11.000Z",description:"总结",categories:["常见问题"],tags:["TopK","Java"],keywords:"TopK,Java",permalink:"/pages/2c256c/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/07.%E5%AE%9E%E8%B7%B5/02.%E6%80%9D%E8%80%83%E4%B8%8E%E6%96%B9%E6%A1%88/01.%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AETopK%E9%97%AE%E9%A2%98.html",relativePath:"07.实践/02.思考与方案/01.海量数据TopK问题.md",key:"v-2b4bdefd",path:"/pages/2c256c/",headers:[{level:2,title:"海量数据TopK问题",slug:"海量数据topk问题",normalizedTitle:"海量数据topk问题",charIndex:2}],headersStr:"海量数据TopK问题",content:"# 海量数据TopK问题\n\n在大规模数据处理中，经常会遇到这类问题：在海量数据中找到出现频率/数值最大的前K个数\n\n本文主要提供这类问题的基本解决方法\n\n假设这样一个场景，一个问题阅读量越高，说明这个问题越有价值，越应该推送给用户\n\n假设数据量有1亿，取Top100\n\n 1. 最容易想到的方法是将全部数据进行排序，但如果数据量太大 ，这显然是不能接受的。\n 2. 第二种方法为局部淘汰法，该方法与排序方法类似，用一个容器保存前K个数，然后将剩余的所有数字——与容器内的最小数字相比，如果所有后续的元素都比容器内的K个数还小，那么容器内这个K个数就是最大K个数。如果某一后续元素比容器内最小数字大，则删掉容器内最小元素，并将该元素插入容器，最后遍历完这1亿个数，得到的结果容器中保存的数即为最终结果了。此时的时间复杂度为O（n+m^2），其中m为容器的大小，即K。\n 3. 第三种方法是分治法，将1亿个数据分成100份，每份100万个数据，找到每份数据中最大的100个(即每份数据的TopK)，最后在剩下的100*100个数据里面找出最大的100个。如果100万数据选择足够理想，那么可以过滤掉1亿数据里面99%的数据。100万个数据里面查找最大的100个数据的方法如下：用快速排序的方法，将数据分为2堆，如果大的那堆个数N大于100个，继续对大堆快速排序一次分成2堆，如果大的那堆个数N大于100个，继续对大堆快速排序一次分成2堆，如果大堆个数N小于100个，就在小的那堆里面快速排序一次，找第100-n大的数字；递归以上过程，就可以找到第100大的数。参考上面的找出第100大数字，就可以类似的方法找到前100大数字了。\n 4. 第四种方法是Hash法。如果这1亿个数里面有很多重复的数，先通过Hash法，把这1亿个数字去重复，这样如果重复率很高的话，会减少很大的内存用量，从而缩小运算空间，然后通过分治法或最小堆法查找最大的100个数。\n 5. 第五种方法采用最小堆。首先读入前100个数来创建大小为100的最小堆，然后遍历后续的数字，并于堆顶（最小）数字进行比较。如果比最小的数小，则继续读取后续数字；如果比堆顶数字大，则替换堆顶元素并重新调整堆为最小堆。整个过程直至1亿个数全部遍历完为止。然后按照中序遍历的方式输出当前堆中的所有100个数字。建堆时间复杂度是O(m)，堆调整的时间复杂度是O(logm)，最终的时间复杂度=1次建堆的时间+n次堆调整的时间，所以该算法的时间复杂度为O(nlogm)，空间复杂度是100（常数）。\n\n代码示例：\n\n我们首先可以用HashMap去存储问题和阅读量的映射\n\n//伪代码\nString read;\nHashMap<String, Integer> map = new HashMap<String, Integer>();\nwhile (fileStream.hasNext()){\n    url = read();\n   if (map.containsKey(read)){\n        map.put(read,map.get(read)+1);\n    }else{\n        map.put(read, 1);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n之后， 我们使用长度为100的最小堆来找到最热的100条数据。\n\nPriorityQueue<Map.Entry<String, Integer>> queue =\n    new PriorityQueue<Map.Entry<String, Integer>>(100,\n           new Comparator<Map.Entry<String, Integer>>(){\n            @Override public int compare(Entry<String, Integer> o1, Entry<String, Integer> o2) {\n                return o1.getValue() - o2.getValue();\n                }\n        });\n         \nint k = 100;\nfor (Map.Entry<String, Integer> entry : map.entrySet()){\n    if (queue.size() < k){\n        queue.add(entry);\n    } else {\n        if (entry.getValue() > queue.peek().getValue()){\n            queue.poll();\n        \tqueue.add(entry);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n",normalizedContent:"# 海量数据topk问题\n\n在大规模数据处理中，经常会遇到这类问题：在海量数据中找到出现频率/数值最大的前k个数\n\n本文主要提供这类问题的基本解决方法\n\n假设这样一个场景，一个问题阅读量越高，说明这个问题越有价值，越应该推送给用户\n\n假设数据量有1亿，取top100\n\n 1. 最容易想到的方法是将全部数据进行排序，但如果数据量太大 ，这显然是不能接受的。\n 2. 第二种方法为局部淘汰法，该方法与排序方法类似，用一个容器保存前k个数，然后将剩余的所有数字——与容器内的最小数字相比，如果所有后续的元素都比容器内的k个数还小，那么容器内这个k个数就是最大k个数。如果某一后续元素比容器内最小数字大，则删掉容器内最小元素，并将该元素插入容器，最后遍历完这1亿个数，得到的结果容器中保存的数即为最终结果了。此时的时间复杂度为o（n+m^2），其中m为容器的大小，即k。\n 3. 第三种方法是分治法，将1亿个数据分成100份，每份100万个数据，找到每份数据中最大的100个(即每份数据的topk)，最后在剩下的100*100个数据里面找出最大的100个。如果100万数据选择足够理想，那么可以过滤掉1亿数据里面99%的数据。100万个数据里面查找最大的100个数据的方法如下：用快速排序的方法，将数据分为2堆，如果大的那堆个数n大于100个，继续对大堆快速排序一次分成2堆，如果大的那堆个数n大于100个，继续对大堆快速排序一次分成2堆，如果大堆个数n小于100个，就在小的那堆里面快速排序一次，找第100-n大的数字；递归以上过程，就可以找到第100大的数。参考上面的找出第100大数字，就可以类似的方法找到前100大数字了。\n 4. 第四种方法是hash法。如果这1亿个数里面有很多重复的数，先通过hash法，把这1亿个数字去重复，这样如果重复率很高的话，会减少很大的内存用量，从而缩小运算空间，然后通过分治法或最小堆法查找最大的100个数。\n 5. 第五种方法采用最小堆。首先读入前100个数来创建大小为100的最小堆，然后遍历后续的数字，并于堆顶（最小）数字进行比较。如果比最小的数小，则继续读取后续数字；如果比堆顶数字大，则替换堆顶元素并重新调整堆为最小堆。整个过程直至1亿个数全部遍历完为止。然后按照中序遍历的方式输出当前堆中的所有100个数字。建堆时间复杂度是o(m)，堆调整的时间复杂度是o(logm)，最终的时间复杂度=1次建堆的时间+n次堆调整的时间，所以该算法的时间复杂度为o(nlogm)，空间复杂度是100（常数）。\n\n代码示例：\n\n我们首先可以用hashmap去存储问题和阅读量的映射\n\n//伪代码\nstring read;\nhashmap<string, integer> map = new hashmap<string, integer>();\nwhile (filestream.hasnext()){\n    url = read();\n   if (map.containskey(read)){\n        map.put(read,map.get(read)+1);\n    }else{\n        map.put(read, 1);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n之后， 我们使用长度为100的最小堆来找到最热的100条数据。\n\npriorityqueue<map.entry<string, integer>> queue =\n    new priorityqueue<map.entry<string, integer>>(100,\n           new comparator<map.entry<string, integer>>(){\n            @override public int compare(entry<string, integer> o1, entry<string, integer> o2) {\n                return o1.getvalue() - o2.getvalue();\n                }\n        });\n         \nint k = 100;\nfor (map.entry<string, integer> entry : map.entryset()){\n    if (queue.size() < k){\n        queue.add(entry);\n    } else {\n        if (entry.getvalue() > queue.peek().getvalue()){\n            queue.poll();\n        \tqueue.add(entry);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"关于DO,VO,DTO,QueryParam的思考",frontmatter:{title:"关于DO,VO,DTO,QueryParam的思考",date:"2021-08-10T17:51:47.000Z",description:"Java接口规范化思考",categories:["Java"],tags:["SpringBoot","Java"],keywords:"SpringBoot,Java",permalink:"/pages/45617b/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/07.%E5%AE%9E%E8%B7%B5/02.%E6%80%9D%E8%80%83%E4%B8%8E%E6%96%B9%E6%A1%88/02.%E5%85%B3%E4%BA%8EDO,VO,DTO,QueryParam%E7%9A%84%E6%80%9D%E8%80%83.html",relativePath:"07.实践/02.思考与方案/02.关于DO,VO,DTO,QueryParam的思考.md",key:"v-c983e334",path:"/pages/45617b/",headers:[{level:2,title:"关于DO,VO,DTO,QueryParam的思考",slug:"关于do-vo-dto-queryparam的思考",normalizedTitle:"关于do,vo,dto,queryparam的思考",charIndex:2},{level:3,title:"实际例子",slug:"实际例子",normalizedTitle:"实际例子",charIndex:407},{level:4,title:"POJO类设计",slug:"pojo类设计",normalizedTitle:"pojo类设计",charIndex:538},{level:4,title:"Controller",slug:"controller",normalizedTitle:"controller",charIndex:215},{level:5,title:"类型转换",slug:"类型转换",normalizedTitle:"类型转换",charIndex:2493},{level:4,title:"Service层",slug:"service层",normalizedTitle:"service层",charIndex:2969},{level:4,title:"Dao层",slug:"dao层",normalizedTitle:"dao层",charIndex:116},{level:4,title:"Mapper层",slug:"mapper层",normalizedTitle:"mapper层",charIndex:3202},{level:4,title:"数据返回",slug:"数据返回",normalizedTitle:"数据返回",charIndex:3315},{level:3,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:29}],headersStr:"关于DO,VO,DTO,QueryParam的思考 实际例子 POJO类设计 Controller 类型转换 Service层 Dao层 Mapper层 数据返回 总结",content:'# 关于DO,VO,DTO,QueryParam的思考\n\n总结一下最近项目中的一些问题\n\nDO（Domain Object）：领域对象，就是从现实世界中抽象出来的有形或无形的业务实体。\n\n> 在项目中Do的作用域用于真正操作数据库的Dao层实现类中。\n\nVO（View Object）：视图对象，用于前端展示层，它的作用是把某个指定页面（或组件）的所有数据封装起来\n\n> 在项目中涉及到-----新增、删除、修改等操作时，作为后端Controller接口的入参对象。当针对的查询语句时，可以将查询的VO对象单独定义一个，用QueryParam作为查询对象，与基本的VO区别开来\n\nDTO（Data Transfer Object）：数据传输对象，主要用于外部接口参数传递封装，接口与接口进行传递使用\n\n> 在项目中接口和接口间常常需要获取大量参数，DTO就是将这些参数封装成为一个对象，简化参数的直接传递\n\n\n# 实际例子\n\n下面用一个实际的例子展示上述几个对象在具体的开发中的作用域\n\n本文的项目结构为如下\n\n\n\n以一个简单的数据库为例，数据库中包含id、name、address、ctime、state五种字段，分别表示用户的id，名字，地址，数据创建事件，状态。\n\n# POJO类设计\n\n与之对应的DO、DTO、VO、QueryParam如下\n\nDO：设计上需要包含所有数据库字段\n\npackage com.test.understand.pojo.domain;\n\nimport com.baomidou.mybatisplus.annotation.FieldFill;\nimport com.baomidou.mybatisplus.annotation.TableField;\nimport com.baomidou.mybatisplus.annotation.TableId;\nimport com.baomidou.mybatisplus.annotation.TableName;\nimport java.util.Date;\nimport lombok.Data;\n\n@Data\n@TableName("test")\npublic class TestDataDO {\n    @TableId\n    private Integer id;\n\n    @TableField("name")\n    private String name;\n\n    @TableField("address")\n    private String location;\n\n    @TableField(value = "ctime",fill = FieldFill.INSERT)\n    private Date creatTime;\n\n    @TableField("state")\n    private Byte state;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\nDTO：用于接口间的传输，可以不同于DO传递接口间需要的参数，本文DTO和DO一致\n\npackage com.test.understand.pojo.dto;\nimport java.util.Date;\nimport lombok.Data;\n\n@Data\npublic class TestDataDTO {\n\n    private Integer id;\n\n    private String name;\n\n    private String location;\n\n    private Date creatTime;\n\n    private Byte state;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nVO：用于页面展示，不同于DO，有些数据库字段是不必要展示的，VO可以抛弃这些字段，如本文中的id或ctime等\n\npackage com.test.understand.pojo.vo;\n\nimport lombok.Data;\n\n@Data\npublic class TestDataVO {\n    private String name;\n\n    private String location;\n\n    private Byte state;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nQueryParam：为了查询参数专门封装的类对象，可包含查询相关字段\n\npackage com.test.understand.pojo.query;\n\nimport lombok.Data;\n\n@Data\npublic class TestDataQueryParam {\n    \n    private Integer id; \n    \n    private String name;\n\n    private String location;\n\n    private Byte state;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n# Controller\n\n以最简单的增删改查为例。我们规定前端传输为JSON，对于增加、修改和删除来说，入参统一接收为VO对象。对于查询操作，我们规定入参统一为QueryParam对象。如下图红框所示：\n\n\n\n# 类型转换\n\n首先讲解saveOrUpdate方法和deleteTestData方法。\n\n在这两个方法中，VO对象进入到Controller之后需要转化为DTO对象，因为后续他将经过Service--\x3eServiceImpl--\x3eDao--\x3eDaoImpl，即接口之间的传输，其作用域在Controller进入之后到Mapper操作数据库之前。\n\n转化的过程也很简单，可以利用spring提供的BeanUtils.copyProperites快速的将VO中的属性赋值给DTO对象，避免一堆set方法赋值的麻烦。\n\nsaveOrUpdate方法：\n\n\n\ndeleteTestData方法：\n\n\n\n对于getTestDataLocation方法其入参QueryParam进入Controller之后无需转换，因为其包含查询字段，可直接通过Service--\x3eServiceImpl--\x3eDao--\x3eDaoImpl传递。其作用域在Controller进入之后到Mapper操作完数据库之后的整个阶段。\n\ngetTestDataLocation方法：\n\n\n\n# Service层\n\n在service和serviceImpl层中，对DTO对象和QueryParam对象无需做对象类型转化\n\n\n\n\n\n# Dao层\n\n在Dao和DaoImpl的入参定义中，DTO和QueryParam统一不需要转换对象，因为还是接口之间的参数传递，但在DaoImpl中，操作数据库之前，需要将DTO对象转化为DO对象，而QueryParam可以选择用QueryWapper等包装类或者直接传输的方式交给Mapper操作。如下图红框所示\n\n\n\n\n\n# Mapper层\n\nmapper层用于真正操作数据库，这里采用Mybatis-plus中的BaseMapper提供的接口实现增删改，查询则通过Location查数据，重写一下对应的mapper.xml文件的sql即可\n\n\n\n# 数据返回\n\n增加删除修改等操作，前端往往只需要判断操作成功没有即可，所以返回值一般不是一个对象，对于非对象的传输可以直接返回。另外如查询操作，一般会涉及到分页，查出来的数据是List形式展现而从数据库查到的是DO对象，当这种操作返回值时会从Mapper--\x3eDao--\x3eService--\x3eController一层一层返回回去，这时候就又变成了接口之间的参数传输了，DO对象显然不适合，所以还需转化为DTO对象。如下图红框操作所示，从DO的list转化为DTO的list作为返回值列表。\n\n\n\n在返回值到达Controller之后，由于需要展示给前端，DTO对象还需要转化为VO对象\n\n\n\n\n# 总结\n\n 1. 除QueryParam以外，VO对象进入Controller之后需要进行对象转换变为DTO方便数据在接口中间的传递\n 2. 在数据库操作之前，DTO对象需要转换为DO\n 3. 在返回值的过程中，数据库返回的对象除基本类型之外需要转为DTO传递\n 4. 在返回值回到Controller时，需要将DTO对象转换为VO对象，从而返回给前端',normalizedContent:'# 关于do,vo,dto,queryparam的思考\n\n总结一下最近项目中的一些问题\n\ndo（domain object）：领域对象，就是从现实世界中抽象出来的有形或无形的业务实体。\n\n> 在项目中do的作用域用于真正操作数据库的dao层实现类中。\n\nvo（view object）：视图对象，用于前端展示层，它的作用是把某个指定页面（或组件）的所有数据封装起来\n\n> 在项目中涉及到-----新增、删除、修改等操作时，作为后端controller接口的入参对象。当针对的查询语句时，可以将查询的vo对象单独定义一个，用queryparam作为查询对象，与基本的vo区别开来\n\ndto（data transfer object）：数据传输对象，主要用于外部接口参数传递封装，接口与接口进行传递使用\n\n> 在项目中接口和接口间常常需要获取大量参数，dto就是将这些参数封装成为一个对象，简化参数的直接传递\n\n\n# 实际例子\n\n下面用一个实际的例子展示上述几个对象在具体的开发中的作用域\n\n本文的项目结构为如下\n\n\n\n以一个简单的数据库为例，数据库中包含id、name、address、ctime、state五种字段，分别表示用户的id，名字，地址，数据创建事件，状态。\n\n# pojo类设计\n\n与之对应的do、dto、vo、queryparam如下\n\ndo：设计上需要包含所有数据库字段\n\npackage com.test.understand.pojo.domain;\n\nimport com.baomidou.mybatisplus.annotation.fieldfill;\nimport com.baomidou.mybatisplus.annotation.tablefield;\nimport com.baomidou.mybatisplus.annotation.tableid;\nimport com.baomidou.mybatisplus.annotation.tablename;\nimport java.util.date;\nimport lombok.data;\n\n@data\n@tablename("test")\npublic class testdatado {\n    @tableid\n    private integer id;\n\n    @tablefield("name")\n    private string name;\n\n    @tablefield("address")\n    private string location;\n\n    @tablefield(value = "ctime",fill = fieldfill.insert)\n    private date creattime;\n\n    @tablefield("state")\n    private byte state;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\ndto：用于接口间的传输，可以不同于do传递接口间需要的参数，本文dto和do一致\n\npackage com.test.understand.pojo.dto;\nimport java.util.date;\nimport lombok.data;\n\n@data\npublic class testdatadto {\n\n    private integer id;\n\n    private string name;\n\n    private string location;\n\n    private date creattime;\n\n    private byte state;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nvo：用于页面展示，不同于do，有些数据库字段是不必要展示的，vo可以抛弃这些字段，如本文中的id或ctime等\n\npackage com.test.understand.pojo.vo;\n\nimport lombok.data;\n\n@data\npublic class testdatavo {\n    private string name;\n\n    private string location;\n\n    private byte state;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nqueryparam：为了查询参数专门封装的类对象，可包含查询相关字段\n\npackage com.test.understand.pojo.query;\n\nimport lombok.data;\n\n@data\npublic class testdataqueryparam {\n    \n    private integer id; \n    \n    private string name;\n\n    private string location;\n\n    private byte state;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n# controller\n\n以最简单的增删改查为例。我们规定前端传输为json，对于增加、修改和删除来说，入参统一接收为vo对象。对于查询操作，我们规定入参统一为queryparam对象。如下图红框所示：\n\n\n\n# 类型转换\n\n首先讲解saveorupdate方法和deletetestdata方法。\n\n在这两个方法中，vo对象进入到controller之后需要转化为dto对象，因为后续他将经过service--\x3eserviceimpl--\x3edao--\x3edaoimpl，即接口之间的传输，其作用域在controller进入之后到mapper操作数据库之前。\n\n转化的过程也很简单，可以利用spring提供的beanutils.copyproperites快速的将vo中的属性赋值给dto对象，避免一堆set方法赋值的麻烦。\n\nsaveorupdate方法：\n\n\n\ndeletetestdata方法：\n\n\n\n对于gettestdatalocation方法其入参queryparam进入controller之后无需转换，因为其包含查询字段，可直接通过service--\x3eserviceimpl--\x3edao--\x3edaoimpl传递。其作用域在controller进入之后到mapper操作完数据库之后的整个阶段。\n\ngettestdatalocation方法：\n\n\n\n# service层\n\n在service和serviceimpl层中，对dto对象和queryparam对象无需做对象类型转化\n\n\n\n\n\n# dao层\n\n在dao和daoimpl的入参定义中，dto和queryparam统一不需要转换对象，因为还是接口之间的参数传递，但在daoimpl中，操作数据库之前，需要将dto对象转化为do对象，而queryparam可以选择用querywapper等包装类或者直接传输的方式交给mapper操作。如下图红框所示\n\n\n\n\n\n# mapper层\n\nmapper层用于真正操作数据库，这里采用mybatis-plus中的basemapper提供的接口实现增删改，查询则通过location查数据，重写一下对应的mapper.xml文件的sql即可\n\n\n\n# 数据返回\n\n增加删除修改等操作，前端往往只需要判断操作成功没有即可，所以返回值一般不是一个对象，对于非对象的传输可以直接返回。另外如查询操作，一般会涉及到分页，查出来的数据是list形式展现而从数据库查到的是do对象，当这种操作返回值时会从mapper--\x3edao--\x3eservice--\x3econtroller一层一层返回回去，这时候就又变成了接口之间的参数传输了，do对象显然不适合，所以还需转化为dto对象。如下图红框操作所示，从do的list转化为dto的list作为返回值列表。\n\n\n\n在返回值到达controller之后，由于需要展示给前端，dto对象还需要转化为vo对象\n\n\n\n\n# 总结\n\n 1. 除queryparam以外，vo对象进入controller之后需要进行对象转换变为dto方便数据在接口中间的传递\n 2. 在数据库操作之前，dto对象需要转换为do\n 3. 在返回值的过程中，数据库返回的对象除基本类型之外需要转为dto传递\n 4. 在返回值回到controller时，需要将dto对象转换为vo对象，从而返回给前端',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"异步消息通知—异步改造",frontmatter:{title:"异步消息通知—异步改造",date:"2021/11/02 17:00:15",description:"总结",categories:["Java"],tags:["异步","消息队列","线程池","事务","Java","Spring"],keywords:"Java,异步,消息队列,事务,Spring,线程池",permalink:"/pages/3572ad/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/07.%E5%AE%9E%E8%B7%B5/02.%E6%80%9D%E8%80%83%E4%B8%8E%E6%96%B9%E6%A1%88/03.%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E9%80%9A%E7%9F%A5.html",relativePath:"07.实践/02.思考与方案/03.异步消息通知.md",key:"v-104bb908",path:"/pages/3572ad/",headers:[{level:2,title:"异步消息通知—异步改造",slug:"异步消息通知-异步改造",normalizedTitle:"异步消息通知—异步改造",charIndex:2},{level:3,title:"背景",slug:"背景",normalizedTitle:"背景",charIndex:54},{level:3,title:"主要目的及场景",slug:"主要目的及场景",normalizedTitle:"主要目的及场景",charIndex:210},{level:3,title:"Domain对象",slug:"domain对象",normalizedTitle:"domain对象",charIndex:419},{level:4,title:"QueryParam",slug:"queryparam",normalizedTitle:"queryparam",charIndex:449},{level:4,title:"DTO",slug:"dto",normalizedTitle:"dto",charIndex:442},{level:4,title:"DO",slug:"do",normalizedTitle:"do",charIndex:446},{level:4,title:"消息实体",slug:"消息实体",normalizedTitle:"消息实体",charIndex:2911},{level:3,title:"Controller层",slug:"controller层",normalizedTitle:"controller层",charIndex:3387},{level:4,title:"UserController",slug:"usercontroller",normalizedTitle:"usercontroller",charIndex:3402},{level:3,title:"Service层",slug:"service层",normalizedTitle:"service层",charIndex:5966},{level:4,title:"UserService",slug:"userservice",normalizedTitle:"userservice",charIndex:3586},{level:4,title:"UserServiceImpl",slug:"userserviceimpl",normalizedTitle:"userserviceimpl",charIndex:6793},{level:3,title:"异步化",slug:"异步化",normalizedTitle:"异步化",charIndex:181},{level:4,title:"基本异步方案",slug:"基本异步方案",normalizedTitle:"基本异步方案",charIndex:12215},{level:4,title:"线程池+事务管理复用",slug:"线程池-事务管理复用",normalizedTitle:"线程池+事务管理复用",charIndex:13263},{level:5,title:"全局线程池配置",slug:"全局线程池配置",normalizedTitle:"全局线程池配置",charIndex:13399},{level:5,title:"事务管理执行器",slug:"事务管理执行器",normalizedTitle:"事务管理执行器",charIndex:15324},{level:4,title:"引入消息队列",slug:"引入消息队列",normalizedTitle:"引入消息队列",charIndex:21156},{level:5,title:"前文缺陷",slug:"前文缺陷",normalizedTitle:"前文缺陷",charIndex:21166},{level:5,title:"消息消费者",slug:"消息消费者",normalizedTitle:"消息消费者",charIndex:21522},{level:5,title:"消息生产者",slug:"消息生产者",normalizedTitle:"消息生产者",charIndex:24237},{level:3,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:25738},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:25843}],headersStr:"异步消息通知—异步改造 背景 主要目的及场景 Domain对象 QueryParam DTO DO 消息实体 Controller层 UserController Service层 UserService UserServiceImpl 异步化 基本异步方案 线程池+事务管理复用 全局线程池配置 事务管理执行器 引入消息队列 前文缺陷 消息消费者 消息生产者 总结 参考资料",content:'# 异步消息通知—异步改造\n\n异步消息通知，解耦业务中需要发送消息的场景，非中间件框架方式使用方法\n\n\n# 背景\n\n消息通知是项目中遇到的常见场景，通常而言消息通知会涉及到数据库操作，且面临着通知用户多，消息处理需要时间的问题。假设一个接口本身的业务逻辑执行只需要50ms，而消息通知需要500ms，如果串行进行调用，就难免遇到接口长时间阻塞等待结果的情况。所以异步化操作解耦消息通知，在这种场景显得十分必要。\n\n\n# 主要目的及场景\n\n主要目的：市面上有非常多完善的消息中间件如Kafka、RocketMQ、RabbitMQ等已经能够很好的应对这种场景。这篇文章的主要目的是提供一种异步改造的可用思路。为了简单起见，本文采用LinkedBlockingQueue模拟消息队列。\n\n场景：假设有一个用户注册接口，我们希望该用户注册后同时通知他在应用内的所有已注册朋友\n\n采用SpringBoot+Mybatis-plus进行演示\n\n\n# Domain对象\n\n为了规范起见，过程中使用了DTO、DO、QueryParam等对象\n\n# QueryParam\n\npackage com.test.message.domain.query;\n\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport java.io.Serializable;\nimport javax.validation.constraints.NotNull;\nimport lombok.Data;\n\n@Data\npublic class UserQueryParam implements Serializable {\n\n    private static final long serialVersionUID = 7076273323311739844L;\n    /**\n     * 用户名\n     */\n    @NotNull\n    @JsonProperty("UserName")\n    private String userName;\n\n    /**\n     * 用户手机号\n     */\n    @NotNull\n    @JsonProperty("UserPhone")\n    private String userPhone;\n\n    /**\n     * 用户邮箱\n     */\n    @NotNull\n    @JsonProperty("UserEmail")\n    private String userEmail;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n# DTO\n\npackage com.test.message.domain.dto;\n\nimport java.io.Serializable;\nimport lombok.Data;\n\n/**\n * userDTO\n */\n@Data\npublic class UserDTO implements Serializable {\n\n    private static final long serialVersionUID = -7055429600592391854L;\n    /**\n     * 用户名\n     */\n    private String userName;\n\n    /**\n     * 用户手机号\n     */\n    private String userPhone;\n\n    /**\n     * 用户邮箱\n     */\n    private String userEmail;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n# DO\n\npackage com.test.message.domain.model;\n\nimport com.baomidou.mybatisplus.annotation.IdType;\nimport com.baomidou.mybatisplus.annotation.TableField;\nimport com.baomidou.mybatisplus.annotation.TableId;\nimport com.baomidou.mybatisplus.annotation.TableName;\nimport java.io.Serializable;\nimport lombok.Data;\n\n/**\n * User表实体类\n */\n@TableName("user")\n@Data\npublic class UserDO implements Serializable {\n\n    private static final long serialVersionUID = -5268838066640437272L;\n    /**\n     * 用户id\n     */\n    @TableId(type = IdType.AUTO)\n    private Integer id;\n\n    /**\n     * 用户名\n     */\n    @TableField("user_name")\n    private String userName;\n\n    /**\n     * 用户手机号\n     */\n    @TableField("user_phone")\n    private String userPhone;\n\n    /**\n     * 用户邮箱\n     */\n    @TableField("user_email")\n    private String userEmail;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n# 消息实体\n\npackage com.test.message.domain.query;\n\nimport java.util.List;\nimport lombok.Data;\n\n/**\n * 消息实体类\n */\n@Data\npublic class MessageEntity {\n\n    /**\n     * 消息发送者\n     */\n    private String sender;\n\n    /**\n     * 消息接受者\n     */\n    private List<String> receiver;\n\n    /**\n     * 消息内容\n     */\n    private String content;\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# Controller层\n\n# UserController\n\npackage com.test.message.controller;\n\n\nimport com.test.message.domain.dto.UserDTO;\nimport com.test.message.domain.query.UserQueryParam;\nimport com.test.message.service.UserService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.cglib.beans.BeanCopier;\nimport org.springframework.validation.annotation.Validated;\nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping("/testuser")\npublic class UserController {\n\n    @Autowired\n    private UserService userService;\n\n    /**\n     * 保存用户，并发送消息通知\n     *\n     * @param userQueryParam 用户信息\n     * @return Integer\n     */\n    @PostMapping("/save")\n    public Integer saveUser(@Validated @RequestBody UserQueryParam userQueryParam) {\n        UserDTO userDTO = new UserDTO();\n        BeanCopier beanCopier = BeanCopier.create(UserQueryParam.class, UserDTO.class, false);\n        beanCopier.copy(userQueryParam, userDTO, null);\n        return userService.save(userDTO);\n    }\n\n    /**\n     * 保存用户，并发送消息通知，异步，不使用消息队列\n     *\n     * @param userQueryParam 用户信息\n     * @return Integer\n     */\n    @PostMapping("/saveAsyncNoQueue")\n    public Integer saveUserAsyncWithNoQueue(@Validated @RequestBody UserQueryParam userQueryParam) {\n        UserDTO userDTO = new UserDTO();\n        BeanCopier beanCopier = BeanCopier.create(UserQueryParam.class, UserDTO.class, false);\n        beanCopier.copy(userQueryParam, userDTO, null);\n        return userService.saveAsyncWithNoQueue(userDTO);\n    }\n\n    /**\n     * 保存用户，并发送消息通知，异步，使用消息队列\n     *\n     * @param userQueryParam 用户信息\n     * @return Integer\n     */\n    @PostMapping("/saveWithQueue")\n    public Integer saveUserWithQueue(@Validated @RequestBody UserQueryParam userQueryParam) {\n        UserDTO userDTO = new UserDTO();\n        BeanCopier beanCopier = BeanCopier.create(UserQueryParam.class, UserDTO.class, false);\n        beanCopier.copy(userQueryParam, userDTO, null);\n        return userService.saveWithQueue(userDTO);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n\n\n\n# Service层\n\n# UserService\n\n在UserService层，我们简单定义三个接口：\n\n * 保存用户和通知串行执行\n * 保存用户后异步发送通知，未使用消息队列\n * 保存用户后异步发送通知，使用消息队列\n\npackage com.test.message.service;\n\n\nimport com.test.message.domain.dto.UserDTO;\n\npublic interface UserService {\n\n    /**\n     * 保存用户并发送通知，串行\n     *\n     * @param userDTO 用户实体\n     * @return Integer\n     */\n    Integer save(UserDTO userDTO);\n\n    /**\n     * 保存用户并发送异步通知，未使用消息队列\n     *\n     * @param userDTO 用户实体\n     * @return Integer\n     */\n    Integer saveAsyncWithNoQueue(UserDTO userDTO);\n\n    /**\n     * 保存用户并发送异步通知，使用消息队列\n     *\n     * @param userDTO 用户实体\n     * @return Integer\n     */\n    Integer saveWithQueue(UserDTO userDTO);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n# UserServiceImpl\n\n在实现类里面，提供一个简单的生成消息发送对象数组的方法generalData\n\npackage com.test.message.service.impl;\n\n\nimport com.test.message.domain.dto.UserDTO;\nimport com.test.message.domain.model.UserDO;\nimport com.test.message.domain.query.MessageEntity;\nimport com.test.message.mapper.UserMapper;\nimport com.test.message.service.MessageService;\nimport com.test.message.service.UserService;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport javax.annotation.Resource;\nimport org.springframework.cglib.beans.BeanCopier;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\nimport org.springframework.transaction.support.TransactionSynchronizationAdapter;\nimport org.springframework.transaction.support.TransactionSynchronizationManager;\n\n@Service\npublic class UserServiceImpl implements UserService {\n\n    @Resource\n    private UserMapper userMapper;\n\n    @Resource\n    private MessageService messageService;\n\n    @Transactional\n    @Override\n    public Integer save(UserDTO userDTO) {\n        UserDO userDO = new UserDO();\n        BeanCopier beanCopier = BeanCopier.create(UserDTO.class, UserDO.class, false);\n        beanCopier.copy(userDTO, userDO, null);\n        Integer result = userMapper.insert(userDO);\n        MessageEntity messageEntity = new MessageEntity();\n        messageEntity.setSender(userDO.getUserName());\n        messageEntity.setContent("成功创建用户");\n        List<String> recevier = generalData(10000);\n        messageEntity.setReceiver(recevier);\n        // 直接调用消息发送模块\n        messageService.sendMessage(messageEntity);\n        return result;\n    }\n\n    @Override\n    public Integer saveAsyncWithNoQueue(UserDTO userDTO) {\n        UserDO userDO = new UserDO();\n        BeanCopier beanCopier = BeanCopier.create(UserDTO.class, UserDO.class, false);\n        beanCopier.copy(userDTO, userDO, null);\n        Integer result = userMapper.insert(userDO);\n        MessageEntity messageEntity = new MessageEntity();\n        messageEntity.setSender(userDO.getUserName());\n        messageEntity.setContent("成功创建用户");\n        List<String> recevier = generalData(10000);\n        messageEntity.setReceiver(recevier);\n        // 直接异步发送消息\n        messageService.sendMessageAsyncWithNoQueue(messageEntity);\n        return result;\n    }\n\n    @Transactional\n    @Override\n    public Integer saveWithQueue(UserDTO userDTO) {\n        UserDO userDO = new UserDO();\n        BeanCopier beanCopier = BeanCopier.create(UserDTO.class, UserDO.class, false);\n        beanCopier.copy(userDTO, userDO, null);\n        Integer result = userMapper.insert(userDO);\n        MessageEntity messageEntity = new MessageEntity();\n        messageEntity.setSender(userDO.getUserName());\n        messageEntity.setContent("成功创建用户");\n        List<String> recevier = generalData(10000);\n        messageEntity.setReceiver(recevier);\n        // 将消息发送给队列\n        messageService.sendMessageToQueue(messageEntity);\n        return result;\n    }\n\n    public List<String> generalData(Integer num) {\n        List<String> data = new ArrayList<>();\n        for (int i = 0; i < num; i++) {\n            data.add("朋友" + i);\n        }\n        return data;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n\n\n先看传统串行方法save，具体发送消息的逻辑是简单的打印，如下\n\n/**\n * 发送消息具体业务逻辑\n */\n@Override\npublic void sendMessage(MessageEntity messageEntity) {\n    messageEntity.getReceiver().forEach(receiver -> {\n        logger.info("发送消息，消息发送者:{}，消息接受者:{}", messageEntity.getSender(), receiver);\n    });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n我们用POSTMAN简单测试一下，保存用户数据后发送10000条消息，需要的时间大概为169ms\n\n\n\n这是简单的打印所需要的时间，如果内部消息处理逻辑复杂，这个时间将会变得很长，以至于接口长时间等待\n\n那么我们如何将整个消息通知异步化呢？\n\n * 采用线程异步执行消息任务与主线程分离开\n\n同时一般来说，我们需要在接口内部业务执行完毕之后进行消息的处理\n\n * 如果内部业务不涉及到数据库操作，那么直接在最后开启异步线程去执行消息业务即可\n * 如果内部业务涉及到数据库操作，我们则应该在数据库操作之后在进行异步提交\n\n\n# 异步化\n\n我们可以通过事务的提交状态来判断数据库操作是否完毕\n\n在Spring中提供了事务管理器TransactionSynchronizationManager，其内部的registerSynchronization方法接受一个TransactionSynchronizationAdapter对象，而TransactionSynchronizationAdapter是一个抽象类，其源码如下\n\n@Deprecated\npublic abstract class TransactionSynchronizationAdapter implements TransactionSynchronization, Ordered {\n\n\t@Override\n\tpublic int getOrder() {\n\t\treturn Ordered.LOWEST_PRECEDENCE;\n\t}\n\n\t@Override\n\tpublic void suspend() {\n\t}\n\n\t@Override\n\tpublic void resume() {\n\t}\n\n\t@Override\n\tpublic void flush() {\n\t}\n\n\t@Override\n\tpublic void beforeCommit(boolean readOnly) {\n\t}\n\n\t@Override\n\tpublic void beforeCompletion() {\n\t}\n\n\t@Override\n\tpublic void afterCommit() {\n\t}\n\n\t@Override\n\tpublic void afterCompletion(int status) {\n\t}\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n实现该方法其中的beforeCommit、beforeCompletion、afterCommit、afterCompletion方法可以方便的在事务提交前，事务提交完成前、事务提交后、事务提交完成后，进行事务方法的自定义\n\n由于该方法是抽象类，所以想要自定义事务方法必须采用继承的形式，由于单继承的缺点，这个方法已经打上了@Deprecated废弃，取而代之的是接口形式的TransactionSynchronization\n\n# 基本异步方案\n\n一个简单点的基于TransactionSynchronizationAdapter的事务提交后发送消息方法如下\n\n@Transactional\n@Override\npublic Integer save(UserDTO userDTO) {\n    // 省略...\n    Integer result = userMapper.insert(userDO);\n    // 省略...\n    \n    // 事务提交后调用\n    TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() {\n        @Override\n        public void afterCommit() {\n            messageService.sendMessage(messageEntity);\n        }\n    });\n    return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n异步化的方法也很简单，新开启一个线程，将事务提交后的调用的这段代码包裹进去即可\n\nThread thread = new Thread(new Runnable() {\n    @Override\n    public void run() {\n        // 事务提交后调用\n        TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() {\n            @Override\n            public void afterCommit() {\n                messageService.sendMessage(messageEntity);\n            }\n        });\n    }\n});\nthread.start();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 线程池+事务管理复用\n\n上述方法能够快速的实现消息通知的异步化，且满足事务提交后进行操作，但是这样的代码不具有复用性，如果需要发送消息的地方很多，那么就会重复写很多这样的方法，而且线程的创建与销毁也将很消耗系统资源。\n\n为了避免这些情况，可以进行如下操作：\n\n 1. 创建全局线程池配置，并注册Bean到Spring中\n 2. 将ServiceImpl实现事务管理器接口，并交给Spring管理，同时为了方便线程执行，将对应的Service接口继承Executor接口\n\n# 全局线程池配置\n\n这里采用guava提供的方法来进行线程池的装饰，以便需要线程执行的返回值时得到对应的Future对象\n\npackage com.test.message.config;\n\nimport com.google.common.util.concurrent.ListeningExecutorService;\nimport com.google.common.util.concurrent.MoreExecutors;\nimport com.google.common.util.concurrent.ThreadFactoryBuilder;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.ThreadPoolExecutor.AbortPolicy;\nimport java.util.concurrent.TimeUnit;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n/**\n * 将线程池交给spring管理\n */\n@Configuration\npublic class ExecutorsConfig {\n\n    private static final Logger logger = LoggerFactory.getLogger(ExecutorsConfig.class);\n\n    public static final int MAX_POOL_SIZE = 100;\n\n    @Bean\n    public ListeningExecutorService injectExecutorService() {\n        int coreThreadNum = Runtime.getRuntime().availableProcessors();\n        int maxThreadNum = coreThreadNum * 2;\n        logger.info("初始化线程池，核心线程数:{},最大线程数:{}", coreThreadNum, maxThreadNum);\n        ThreadFactory threadFactory = new ThreadFactoryBuilder().setNameFormat("自定义线程名称-%d").build();\n        ExecutorService executorService = new ThreadPoolExecutor(coreThreadNum, maxThreadNum,0L,\n                TimeUnit.MILLISECONDS, new LinkedBlockingQueue<>(MAX_POOL_SIZE), threadFactory, new AbortPolicy());\n        return MoreExecutors.listeningDecorator(executorService);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n# 事务管理执行器\n\nMessageAfterCommitExecutor接口：\n\npackage com.test.message.transaction;\n\nimport java.util.concurrent.Executor;\n\n/**\n * 继承Exector方法，用于事务提交后execute异步执行任务\n */\npublic interface MessageAfterCommitExecutor extends Executor {\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nMessageAfterCommitExecutorImpl实现类：\n\n实现MessageAfterCommitExecutor接口的同时，实现TransactionSynchronization接口，支持事务管理的自定义，同时采用一个ThreadLocal变量隔离各线程提交的任务，并存储外部提交线程到list中。针对外围无事务方法，则只需要直接执行提交线程，针对有事务的方法，则需要注册当前事务。事务提交之后利用线程池异步执行存储在RUNNABLES中的线程。\n\npackage com.test.message.transaction.impl;\n\n\nimport com.google.common.util.concurrent.ListeningExecutorService;\nimport com.test.message.transaction.MessageAfterCommitExecutor;\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\nimport org.springframework.transaction.support.TransactionSynchronization;\nimport org.springframework.transaction.support.TransactionSynchronizationManager;\n\n@Component\npublic class MessageAfterCommitExecutorImpl implements TransactionSynchronization,\n        MessageAfterCommitExecutor {\n\n    private static final Logger logger = LoggerFactory.getLogger(MessageAfterCommitExecutorImpl.class);\n\n    private static final ThreadLocal<List<Runnable>> RUNNABLES = new ThreadLocal<>();\n\n    @Autowired\n    private ListeningExecutorService listeningExecutorService;\n\n    /**\n     * 当该方法被调用时，会检查当前线程的同步器是否处于激活状态，即上下文是否存在事务\n     * <p/>\n     * 如果没有，则立即执行runnable\n     * <p/>\n     * 否则，将提交的runnable存储在一个ThreadLocal变量中\n     * <p/>\n     * 如果这是当前线程第一次提交runnable\n     * <p/>\n     * 那么我们会将自身注册为当前进程的事务同步器(如果同步没有激活，则无法注册)\n     * <p/>\n     *\n     * @param runnable 由外部提交的线程\n     */\n    @Override\n    public void execute(Runnable runnable) {\n        logger.info("【事务已提交】新线程开始运行:{}", runnable);\n        if (!TransactionSynchronizationManager.isSynchronizationActive()) {\n            logger.info("【当前方法无事务】立即执行消息入库操作:{}", runnable);\n            runnable.run();\n            return;\n        }\n        List<Runnable> threadRunnables = RUNNABLES.get();\n        if (threadRunnables == null) {\n            threadRunnables = new ArrayList<>();\n            RUNNABLES.set(threadRunnables);\n            TransactionSynchronizationManager.registerSynchronization(this);\n        }\n        threadRunnables.add(runnable);\n    }\n\n    /**\n     * 因为注册了事务同步器，所以只要事务成功提交，就会调用afterCommit()方法\n     * <p/>\n     * 此时，我们为成功完成事务的线程获取所有提交的runnable对象，并采用异步线程池执行他们\n     * <p/>\n     */\n    @Override\n    public void afterCommit() {\n        List<Runnable> threadRunnables = RUNNABLES.get();\n        logger.info("【事务提交成功】开始执行线程:{}", threadRunnables);\n        threadRunnables.forEach(nowRunnable -> {\n            logger.info("【执行线程】:{}", nowRunnable);\n            try {\n                listeningExecutorService.submit(nowRunnable);\n            } catch (Exception e) {\n                logger.error("【事务线程】执行失败", e);\n            }\n        });\n    }\n\n    /**\n     * 为刚刚完成事务的线程清理ThreadLocal变量\n     *\n     * @param status 当前事务状态\n     */\n    @Override\n    public void afterCompletion(int status) {\n        logger.info("【事务已完成】状态为:{}", status == STATUS_COMMITTED ? "已完成" : "已回滚");\n        RUNNABLES.remove();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n\n\n创建一个消息相关的服务接口MessageService：\n\npackage com.test.message.service;\n\nimport com.test.message.domain.query.MessageEntity;\n\n/**\n * 消息通知Service\n */\npublic interface MessageService {\n\n    /**\n     * 异步发送消息，无消息队列\n     */\n    void sendMessageAsyncWithNoQueue(MessageEntity messageEntity);\n\n    /**\n     * 发送消息\n     */\n    void sendMessage(MessageEntity messageEntity);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nMessageServiceImpl实现类:\n\n将前文的事务执行器注入进实现类，在异步线程池内调用发送消息的具体业务，就可以实现事务完成后异步多线程的执行消息发送逻辑\n\npackage com.test.message.service.impl;\n\nimport static com.test.message.listener.MessageQueueListener.messageQueue;\n\nimport com.test.message.domain.query.MessageEntity;\nimport com.test.message.service.MessageService;\nimport com.test.message.transaction.MessageAfterCommitExecutor;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class MessageServiceImpl implements MessageService {\n\n    private static final Logger logger = LoggerFactory.getLogger(MessageServiceImpl.class);\n\n    @Autowired\n    private MessageAfterCommitExecutor messageAfterCommitExecutor;\n\n    /**\n     * 异步发送消息，未使用消息队列\n     */\n    @Override\n    public void sendMessageAsyncWithNoQueue(MessageEntity messageEntity) {\n        messageAfterCommitExecutor.execute(() -> {\n            sendMessage(messageEntity);\n        });\n    }\n\n    /**\n     * 发送消息具体业务逻辑\n     */\n    @Override\n    public void sendMessage(MessageEntity messageEntity) {\n        messageEntity.getReceiver().forEach(receiver -> {\n            logger.info("发送消息，消息发送者:{}，消息接受者:{}", messageEntity.getSender(), receiver);\n        });\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n同样用POSTMAN简单测试一下，保存用户数据后发送10000条消息，需要的时间大概为119ms，由于消息发送的业务简单，所以只相对于前文串行执行快了一点\n\n\n\n# 引入消息队列\n\n# 前文缺陷\n\n * 线程池+事务管理复用的方案已经实现了普通的异步消息发送，但如果接口请求频繁，海量的请求势必会对数据库造成很大的压力，甚至可能让数据库宕机。\n * 同时如果业务中需要做异步消息发送的时候很多，那么每个接口都要去弄一遍异步多线程发送，不仅仅耦合程度很高，如果某一个接口出问题了，这种异步多线程的方法也很难去排查问题，编码的同时也需要不停的try catch异常。\n\n此时引入消息队列就显得十分有必要，其异步、解耦、削峰的特性广为人知，这里不再阐述消息队列中可能遇到的问题和优点。\n\n在本节中，我们引入JDK中自带的LinkedBlockingQueue内存队列作为消息中间件，由于该队列内部实现有加锁机制，是一个并发安全队列，所以我们也暂时不需要考虑并发传入数据和取出数据时可能产生的问题。\n\n# 消息消费者\n\n先思考如何构建消费者，由于不像成熟的中间件那样需要部署。在单体应用里面，内存队列应该在Spring启动前或启动后加载。Spring的提供了许多方法在生命周期范围内进行自定义，可以选择在Spring启动类中实现CommandLineRunner，也可以选择使用对象实现ApplicationListener\n\n本节采用后者，实现一个MessageQueueListener，在Spring上下文准备就绪时，开启消息消费者对内存队列的监听(采用循环监听即可)，异步多线程的取出队列内的数据，并发送消息。规定内存队列为static保证在单体应用内的可见性，这里也可以单独写一个单例模式将这个队列注入到Spring容器中，效果一样。\n\n提示\n\n注意，异步多线程消费数据会造成消费顺序不一致的情况，本文暂不需要考虑顺序消费场景，同时内存消息队列具有不可靠性，实际使用时请采用成熟的消息中间件\n\npackage com.test.message.listener;\n\nimport com.google.common.util.concurrent.ListeningExecutorService;\nimport com.test.message.domain.query.MessageEntity;\nimport com.test.message.service.MessageService;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport javax.annotation.Resource;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.context.event.ApplicationReadyEvent;\nimport org.springframework.context.ApplicationListener;\nimport org.springframework.stereotype.Component;\n\n/**\n * 消息队列监听器-消费者, spring上下文准备就绪时，监听队列内消息进行消费\n */\n@Component\npublic class MessageQueueListener implements ApplicationListener<ApplicationReadyEvent> {\n\n    private static final Logger logger = LoggerFactory.getLogger(MessageQueueListener.class);\n\n    // 限制队列长度\n    private static final Integer MAX_MESSAGEQUEUE_SIZE = 1000;\n\n    // 阻塞队列，并发安全\n    public static final LinkedBlockingQueue<MessageEntity> messageQueue = new LinkedBlockingQueue<>(\n            MAX_MESSAGEQUEUE_SIZE);\n\n    @Autowired\n    private ListeningExecutorService listeningExecutorService;\n\n    @Resource\n    private MessageService messageService;\n\n    /**\n     * 消息消费者\n     * <p/>\n     * 如果循环在异步提交外围\n     * <p/>\n     * 可能出现消息还没发送完，while循环又判断了\n     * <p/>\n     * 多次提交了任务，但此时队列已经为空\n     * <p/>\n     * 所以这里while循环在线程池提交的任务内部\n     */\n    @Override\n    public void onApplicationEvent(ApplicationReadyEvent event) {\n        listeningExecutorService.submit(() -> {\n            try {\n                while (true) {\n                    if (messageQueue.size() != 0) {\n                        // take 队列为空的时候线程阻塞不会执行后续方法\n                        MessageEntity message = messageQueue.take();\n                        messageService.sendMessage(message);\n                    }\n                }\n            } catch (Exception e) {\n                logger.error("队列: 消息发送失败", e);\n            }\n        });\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n\n\n# 消息生产者\n\n生产者主要是将消息实体传入消息队列，不过由于是事务后进行的消息生产，需要有些注意的地方，详见注释\n\n在MessageService中添加sendMessageToQueue方法\n\n/**\n * 消息通知Service\n */\npublic interface MessageService {\n\n    /**\n     * 发送消息到消息队列\n     */\n    void sendMessageToQueue(MessageEntity messageEntity);\n    // 省略...\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n在MessageServiceImpl中添加sendMessageToQueue的实现\n\n@Service\npublic class MessageServiceImpl implements MessageService {\n\n    private static final Logger logger = LoggerFactory.getLogger(MessageServiceImpl.class);\n\n    @Autowired\n    private MessageAfterCommitExecutor messageAfterCommitExecutor;\n\n    /**\n     * 消息生产者\n     * <p/>\n     * 注意由事务管理器提交的runnable进程，如果涉及到写入操作\n     * <p/>\n     * 则必须采用Propagation.REQUIRES_NEW的事务传播类型\n     * <p/>\n     * 现有管理器是上文事务提交之后执行新线程\n     * <p/>\n     * 如果新线程内未开启事务，则会因传播机制加入到上文事务中\n     * <p/>\n     * 由于上文事务已提交，所以新线程的执行在事务完成之后\n     * <p/>\n     * 将会出现线程虽然执行了，但事务未提交的情况，导致写操作失败\n     * <p/>\n     * 本次生产者仅将消息实体加入到消息队列，无需额外声明事务传播类型\n     */\n    @Override\n    public void sendMessageToQueue(MessageEntity messageEntity) {\n        messageAfterCommitExecutor.execute(() -> {\n            messageQueue.offer(messageEntity);\n        });\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n至此，整个异步化的消息改造完成，消息在送入队列之后接口就可以返回了，后续的消息消费将在后台执行\n\n同样用POSTMAN简单测试一下，保存用户数据后发送10000条消息，需要的时间大概为10ms\n\n\n\n消耗的时间大概为：保存用户需要的时间+发送消息实体到内存队列的时间\n\n\n# 总结\n\n异步化改造是应用中场景的方法，本文从简单的异步方法出发，提供了线程池+事务管理+消息队列联合运用的整体方法，测试结果发现相对比串行和单纯使用异步调用的方法，加入消息队列的方案具有更快的调用速度\n\n\n# 参考资料\n\n>  1. https://segmentfault.com/a/1190000004235193?utm_source=tag-newest\n>  2. http://azagorneanu.blogspot.com/2013/06/transaction-synchronization-callbacks.html\n>  3. https://www.jyoryo.com/archives/155.html\n>  4. https://www.ithere.net/article/550\n>  5. https://juejin.cn/post/6984574787511123999',normalizedContent:'# 异步消息通知—异步改造\n\n异步消息通知，解耦业务中需要发送消息的场景，非中间件框架方式使用方法\n\n\n# 背景\n\n消息通知是项目中遇到的常见场景，通常而言消息通知会涉及到数据库操作，且面临着通知用户多，消息处理需要时间的问题。假设一个接口本身的业务逻辑执行只需要50ms，而消息通知需要500ms，如果串行进行调用，就难免遇到接口长时间阻塞等待结果的情况。所以异步化操作解耦消息通知，在这种场景显得十分必要。\n\n\n# 主要目的及场景\n\n主要目的：市面上有非常多完善的消息中间件如kafka、rocketmq、rabbitmq等已经能够很好的应对这种场景。这篇文章的主要目的是提供一种异步改造的可用思路。为了简单起见，本文采用linkedblockingqueue模拟消息队列。\n\n场景：假设有一个用户注册接口，我们希望该用户注册后同时通知他在应用内的所有已注册朋友\n\n采用springboot+mybatis-plus进行演示\n\n\n# domain对象\n\n为了规范起见，过程中使用了dto、do、queryparam等对象\n\n# queryparam\n\npackage com.test.message.domain.query;\n\nimport com.fasterxml.jackson.annotation.jsonproperty;\nimport java.io.serializable;\nimport javax.validation.constraints.notnull;\nimport lombok.data;\n\n@data\npublic class userqueryparam implements serializable {\n\n    private static final long serialversionuid = 7076273323311739844l;\n    /**\n     * 用户名\n     */\n    @notnull\n    @jsonproperty("username")\n    private string username;\n\n    /**\n     * 用户手机号\n     */\n    @notnull\n    @jsonproperty("userphone")\n    private string userphone;\n\n    /**\n     * 用户邮箱\n     */\n    @notnull\n    @jsonproperty("useremail")\n    private string useremail;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n# dto\n\npackage com.test.message.domain.dto;\n\nimport java.io.serializable;\nimport lombok.data;\n\n/**\n * userdto\n */\n@data\npublic class userdto implements serializable {\n\n    private static final long serialversionuid = -7055429600592391854l;\n    /**\n     * 用户名\n     */\n    private string username;\n\n    /**\n     * 用户手机号\n     */\n    private string userphone;\n\n    /**\n     * 用户邮箱\n     */\n    private string useremail;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n# do\n\npackage com.test.message.domain.model;\n\nimport com.baomidou.mybatisplus.annotation.idtype;\nimport com.baomidou.mybatisplus.annotation.tablefield;\nimport com.baomidou.mybatisplus.annotation.tableid;\nimport com.baomidou.mybatisplus.annotation.tablename;\nimport java.io.serializable;\nimport lombok.data;\n\n/**\n * user表实体类\n */\n@tablename("user")\n@data\npublic class userdo implements serializable {\n\n    private static final long serialversionuid = -5268838066640437272l;\n    /**\n     * 用户id\n     */\n    @tableid(type = idtype.auto)\n    private integer id;\n\n    /**\n     * 用户名\n     */\n    @tablefield("user_name")\n    private string username;\n\n    /**\n     * 用户手机号\n     */\n    @tablefield("user_phone")\n    private string userphone;\n\n    /**\n     * 用户邮箱\n     */\n    @tablefield("user_email")\n    private string useremail;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n# 消息实体\n\npackage com.test.message.domain.query;\n\nimport java.util.list;\nimport lombok.data;\n\n/**\n * 消息实体类\n */\n@data\npublic class messageentity {\n\n    /**\n     * 消息发送者\n     */\n    private string sender;\n\n    /**\n     * 消息接受者\n     */\n    private list<string> receiver;\n\n    /**\n     * 消息内容\n     */\n    private string content;\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# controller层\n\n# usercontroller\n\npackage com.test.message.controller;\n\n\nimport com.test.message.domain.dto.userdto;\nimport com.test.message.domain.query.userqueryparam;\nimport com.test.message.service.userservice;\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.cglib.beans.beancopier;\nimport org.springframework.validation.annotation.validated;\nimport org.springframework.web.bind.annotation.postmapping;\nimport org.springframework.web.bind.annotation.requestbody;\nimport org.springframework.web.bind.annotation.requestmapping;\nimport org.springframework.web.bind.annotation.restcontroller;\n\n@restcontroller\n@requestmapping("/testuser")\npublic class usercontroller {\n\n    @autowired\n    private userservice userservice;\n\n    /**\n     * 保存用户，并发送消息通知\n     *\n     * @param userqueryparam 用户信息\n     * @return integer\n     */\n    @postmapping("/save")\n    public integer saveuser(@validated @requestbody userqueryparam userqueryparam) {\n        userdto userdto = new userdto();\n        beancopier beancopier = beancopier.create(userqueryparam.class, userdto.class, false);\n        beancopier.copy(userqueryparam, userdto, null);\n        return userservice.save(userdto);\n    }\n\n    /**\n     * 保存用户，并发送消息通知，异步，不使用消息队列\n     *\n     * @param userqueryparam 用户信息\n     * @return integer\n     */\n    @postmapping("/saveasyncnoqueue")\n    public integer saveuserasyncwithnoqueue(@validated @requestbody userqueryparam userqueryparam) {\n        userdto userdto = new userdto();\n        beancopier beancopier = beancopier.create(userqueryparam.class, userdto.class, false);\n        beancopier.copy(userqueryparam, userdto, null);\n        return userservice.saveasyncwithnoqueue(userdto);\n    }\n\n    /**\n     * 保存用户，并发送消息通知，异步，使用消息队列\n     *\n     * @param userqueryparam 用户信息\n     * @return integer\n     */\n    @postmapping("/savewithqueue")\n    public integer saveuserwithqueue(@validated @requestbody userqueryparam userqueryparam) {\n        userdto userdto = new userdto();\n        beancopier beancopier = beancopier.create(userqueryparam.class, userdto.class, false);\n        beancopier.copy(userqueryparam, userdto, null);\n        return userservice.savewithqueue(userdto);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n\n\n\n# service层\n\n# userservice\n\n在userservice层，我们简单定义三个接口：\n\n * 保存用户和通知串行执行\n * 保存用户后异步发送通知，未使用消息队列\n * 保存用户后异步发送通知，使用消息队列\n\npackage com.test.message.service;\n\n\nimport com.test.message.domain.dto.userdto;\n\npublic interface userservice {\n\n    /**\n     * 保存用户并发送通知，串行\n     *\n     * @param userdto 用户实体\n     * @return integer\n     */\n    integer save(userdto userdto);\n\n    /**\n     * 保存用户并发送异步通知，未使用消息队列\n     *\n     * @param userdto 用户实体\n     * @return integer\n     */\n    integer saveasyncwithnoqueue(userdto userdto);\n\n    /**\n     * 保存用户并发送异步通知，使用消息队列\n     *\n     * @param userdto 用户实体\n     * @return integer\n     */\n    integer savewithqueue(userdto userdto);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n# userserviceimpl\n\n在实现类里面，提供一个简单的生成消息发送对象数组的方法generaldata\n\npackage com.test.message.service.impl;\n\n\nimport com.test.message.domain.dto.userdto;\nimport com.test.message.domain.model.userdo;\nimport com.test.message.domain.query.messageentity;\nimport com.test.message.mapper.usermapper;\nimport com.test.message.service.messageservice;\nimport com.test.message.service.userservice;\nimport java.util.arraylist;\nimport java.util.arrays;\nimport java.util.list;\nimport javax.annotation.resource;\nimport org.springframework.cglib.beans.beancopier;\nimport org.springframework.stereotype.service;\nimport org.springframework.transaction.annotation.transactional;\nimport org.springframework.transaction.support.transactionsynchronizationadapter;\nimport org.springframework.transaction.support.transactionsynchronizationmanager;\n\n@service\npublic class userserviceimpl implements userservice {\n\n    @resource\n    private usermapper usermapper;\n\n    @resource\n    private messageservice messageservice;\n\n    @transactional\n    @override\n    public integer save(userdto userdto) {\n        userdo userdo = new userdo();\n        beancopier beancopier = beancopier.create(userdto.class, userdo.class, false);\n        beancopier.copy(userdto, userdo, null);\n        integer result = usermapper.insert(userdo);\n        messageentity messageentity = new messageentity();\n        messageentity.setsender(userdo.getusername());\n        messageentity.setcontent("成功创建用户");\n        list<string> recevier = generaldata(10000);\n        messageentity.setreceiver(recevier);\n        // 直接调用消息发送模块\n        messageservice.sendmessage(messageentity);\n        return result;\n    }\n\n    @override\n    public integer saveasyncwithnoqueue(userdto userdto) {\n        userdo userdo = new userdo();\n        beancopier beancopier = beancopier.create(userdto.class, userdo.class, false);\n        beancopier.copy(userdto, userdo, null);\n        integer result = usermapper.insert(userdo);\n        messageentity messageentity = new messageentity();\n        messageentity.setsender(userdo.getusername());\n        messageentity.setcontent("成功创建用户");\n        list<string> recevier = generaldata(10000);\n        messageentity.setreceiver(recevier);\n        // 直接异步发送消息\n        messageservice.sendmessageasyncwithnoqueue(messageentity);\n        return result;\n    }\n\n    @transactional\n    @override\n    public integer savewithqueue(userdto userdto) {\n        userdo userdo = new userdo();\n        beancopier beancopier = beancopier.create(userdto.class, userdo.class, false);\n        beancopier.copy(userdto, userdo, null);\n        integer result = usermapper.insert(userdo);\n        messageentity messageentity = new messageentity();\n        messageentity.setsender(userdo.getusername());\n        messageentity.setcontent("成功创建用户");\n        list<string> recevier = generaldata(10000);\n        messageentity.setreceiver(recevier);\n        // 将消息发送给队列\n        messageservice.sendmessagetoqueue(messageentity);\n        return result;\n    }\n\n    public list<string> generaldata(integer num) {\n        list<string> data = new arraylist<>();\n        for (int i = 0; i < num; i++) {\n            data.add("朋友" + i);\n        }\n        return data;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n\n\n先看传统串行方法save，具体发送消息的逻辑是简单的打印，如下\n\n/**\n * 发送消息具体业务逻辑\n */\n@override\npublic void sendmessage(messageentity messageentity) {\n    messageentity.getreceiver().foreach(receiver -> {\n        logger.info("发送消息，消息发送者:{}，消息接受者:{}", messageentity.getsender(), receiver);\n    });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n我们用postman简单测试一下，保存用户数据后发送10000条消息，需要的时间大概为169ms\n\n\n\n这是简单的打印所需要的时间，如果内部消息处理逻辑复杂，这个时间将会变得很长，以至于接口长时间等待\n\n那么我们如何将整个消息通知异步化呢？\n\n * 采用线程异步执行消息任务与主线程分离开\n\n同时一般来说，我们需要在接口内部业务执行完毕之后进行消息的处理\n\n * 如果内部业务不涉及到数据库操作，那么直接在最后开启异步线程去执行消息业务即可\n * 如果内部业务涉及到数据库操作，我们则应该在数据库操作之后在进行异步提交\n\n\n# 异步化\n\n我们可以通过事务的提交状态来判断数据库操作是否完毕\n\n在spring中提供了事务管理器transactionsynchronizationmanager，其内部的registersynchronization方法接受一个transactionsynchronizationadapter对象，而transactionsynchronizationadapter是一个抽象类，其源码如下\n\n@deprecated\npublic abstract class transactionsynchronizationadapter implements transactionsynchronization, ordered {\n\n\t@override\n\tpublic int getorder() {\n\t\treturn ordered.lowest_precedence;\n\t}\n\n\t@override\n\tpublic void suspend() {\n\t}\n\n\t@override\n\tpublic void resume() {\n\t}\n\n\t@override\n\tpublic void flush() {\n\t}\n\n\t@override\n\tpublic void beforecommit(boolean readonly) {\n\t}\n\n\t@override\n\tpublic void beforecompletion() {\n\t}\n\n\t@override\n\tpublic void aftercommit() {\n\t}\n\n\t@override\n\tpublic void aftercompletion(int status) {\n\t}\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n实现该方法其中的beforecommit、beforecompletion、aftercommit、aftercompletion方法可以方便的在事务提交前，事务提交完成前、事务提交后、事务提交完成后，进行事务方法的自定义\n\n由于该方法是抽象类，所以想要自定义事务方法必须采用继承的形式，由于单继承的缺点，这个方法已经打上了@deprecated废弃，取而代之的是接口形式的transactionsynchronization\n\n# 基本异步方案\n\n一个简单点的基于transactionsynchronizationadapter的事务提交后发送消息方法如下\n\n@transactional\n@override\npublic integer save(userdto userdto) {\n    // 省略...\n    integer result = usermapper.insert(userdo);\n    // 省略...\n    \n    // 事务提交后调用\n    transactionsynchronizationmanager.registersynchronization(new transactionsynchronizationadapter() {\n        @override\n        public void aftercommit() {\n            messageservice.sendmessage(messageentity);\n        }\n    });\n    return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n异步化的方法也很简单，新开启一个线程，将事务提交后的调用的这段代码包裹进去即可\n\nthread thread = new thread(new runnable() {\n    @override\n    public void run() {\n        // 事务提交后调用\n        transactionsynchronizationmanager.registersynchronization(new transactionsynchronizationadapter() {\n            @override\n            public void aftercommit() {\n                messageservice.sendmessage(messageentity);\n            }\n        });\n    }\n});\nthread.start();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 线程池+事务管理复用\n\n上述方法能够快速的实现消息通知的异步化，且满足事务提交后进行操作，但是这样的代码不具有复用性，如果需要发送消息的地方很多，那么就会重复写很多这样的方法，而且线程的创建与销毁也将很消耗系统资源。\n\n为了避免这些情况，可以进行如下操作：\n\n 1. 创建全局线程池配置，并注册bean到spring中\n 2. 将serviceimpl实现事务管理器接口，并交给spring管理，同时为了方便线程执行，将对应的service接口继承executor接口\n\n# 全局线程池配置\n\n这里采用guava提供的方法来进行线程池的装饰，以便需要线程执行的返回值时得到对应的future对象\n\npackage com.test.message.config;\n\nimport com.google.common.util.concurrent.listeningexecutorservice;\nimport com.google.common.util.concurrent.moreexecutors;\nimport com.google.common.util.concurrent.threadfactorybuilder;\nimport java.util.concurrent.executorservice;\nimport java.util.concurrent.linkedblockingqueue;\nimport java.util.concurrent.threadfactory;\nimport java.util.concurrent.threadpoolexecutor;\nimport java.util.concurrent.threadpoolexecutor.abortpolicy;\nimport java.util.concurrent.timeunit;\nimport org.slf4j.logger;\nimport org.slf4j.loggerfactory;\nimport org.springframework.context.annotation.bean;\nimport org.springframework.context.annotation.configuration;\n\n/**\n * 将线程池交给spring管理\n */\n@configuration\npublic class executorsconfig {\n\n    private static final logger logger = loggerfactory.getlogger(executorsconfig.class);\n\n    public static final int max_pool_size = 100;\n\n    @bean\n    public listeningexecutorservice injectexecutorservice() {\n        int corethreadnum = runtime.getruntime().availableprocessors();\n        int maxthreadnum = corethreadnum * 2;\n        logger.info("初始化线程池，核心线程数:{},最大线程数:{}", corethreadnum, maxthreadnum);\n        threadfactory threadfactory = new threadfactorybuilder().setnameformat("自定义线程名称-%d").build();\n        executorservice executorservice = new threadpoolexecutor(corethreadnum, maxthreadnum,0l,\n                timeunit.milliseconds, new linkedblockingqueue<>(max_pool_size), threadfactory, new abortpolicy());\n        return moreexecutors.listeningdecorator(executorservice);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n# 事务管理执行器\n\nmessageaftercommitexecutor接口：\n\npackage com.test.message.transaction;\n\nimport java.util.concurrent.executor;\n\n/**\n * 继承exector方法，用于事务提交后execute异步执行任务\n */\npublic interface messageaftercommitexecutor extends executor {\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nmessageaftercommitexecutorimpl实现类：\n\n实现messageaftercommitexecutor接口的同时，实现transactionsynchronization接口，支持事务管理的自定义，同时采用一个threadlocal变量隔离各线程提交的任务，并存储外部提交线程到list中。针对外围无事务方法，则只需要直接执行提交线程，针对有事务的方法，则需要注册当前事务。事务提交之后利用线程池异步执行存储在runnables中的线程。\n\npackage com.test.message.transaction.impl;\n\n\nimport com.google.common.util.concurrent.listeningexecutorservice;\nimport com.test.message.transaction.messageaftercommitexecutor;\nimport java.util.arraylist;\nimport java.util.list;\nimport org.slf4j.logger;\nimport org.slf4j.loggerfactory;\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.stereotype.component;\nimport org.springframework.transaction.support.transactionsynchronization;\nimport org.springframework.transaction.support.transactionsynchronizationmanager;\n\n@component\npublic class messageaftercommitexecutorimpl implements transactionsynchronization,\n        messageaftercommitexecutor {\n\n    private static final logger logger = loggerfactory.getlogger(messageaftercommitexecutorimpl.class);\n\n    private static final threadlocal<list<runnable>> runnables = new threadlocal<>();\n\n    @autowired\n    private listeningexecutorservice listeningexecutorservice;\n\n    /**\n     * 当该方法被调用时，会检查当前线程的同步器是否处于激活状态，即上下文是否存在事务\n     * <p/>\n     * 如果没有，则立即执行runnable\n     * <p/>\n     * 否则，将提交的runnable存储在一个threadlocal变量中\n     * <p/>\n     * 如果这是当前线程第一次提交runnable\n     * <p/>\n     * 那么我们会将自身注册为当前进程的事务同步器(如果同步没有激活，则无法注册)\n     * <p/>\n     *\n     * @param runnable 由外部提交的线程\n     */\n    @override\n    public void execute(runnable runnable) {\n        logger.info("【事务已提交】新线程开始运行:{}", runnable);\n        if (!transactionsynchronizationmanager.issynchronizationactive()) {\n            logger.info("【当前方法无事务】立即执行消息入库操作:{}", runnable);\n            runnable.run();\n            return;\n        }\n        list<runnable> threadrunnables = runnables.get();\n        if (threadrunnables == null) {\n            threadrunnables = new arraylist<>();\n            runnables.set(threadrunnables);\n            transactionsynchronizationmanager.registersynchronization(this);\n        }\n        threadrunnables.add(runnable);\n    }\n\n    /**\n     * 因为注册了事务同步器，所以只要事务成功提交，就会调用aftercommit()方法\n     * <p/>\n     * 此时，我们为成功完成事务的线程获取所有提交的runnable对象，并采用异步线程池执行他们\n     * <p/>\n     */\n    @override\n    public void aftercommit() {\n        list<runnable> threadrunnables = runnables.get();\n        logger.info("【事务提交成功】开始执行线程:{}", threadrunnables);\n        threadrunnables.foreach(nowrunnable -> {\n            logger.info("【执行线程】:{}", nowrunnable);\n            try {\n                listeningexecutorservice.submit(nowrunnable);\n            } catch (exception e) {\n                logger.error("【事务线程】执行失败", e);\n            }\n        });\n    }\n\n    /**\n     * 为刚刚完成事务的线程清理threadlocal变量\n     *\n     * @param status 当前事务状态\n     */\n    @override\n    public void aftercompletion(int status) {\n        logger.info("【事务已完成】状态为:{}", status == status_committed ? "已完成" : "已回滚");\n        runnables.remove();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n\n\n创建一个消息相关的服务接口messageservice：\n\npackage com.test.message.service;\n\nimport com.test.message.domain.query.messageentity;\n\n/**\n * 消息通知service\n */\npublic interface messageservice {\n\n    /**\n     * 异步发送消息，无消息队列\n     */\n    void sendmessageasyncwithnoqueue(messageentity messageentity);\n\n    /**\n     * 发送消息\n     */\n    void sendmessage(messageentity messageentity);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nmessageserviceimpl实现类:\n\n将前文的事务执行器注入进实现类，在异步线程池内调用发送消息的具体业务，就可以实现事务完成后异步多线程的执行消息发送逻辑\n\npackage com.test.message.service.impl;\n\nimport static com.test.message.listener.messagequeuelistener.messagequeue;\n\nimport com.test.message.domain.query.messageentity;\nimport com.test.message.service.messageservice;\nimport com.test.message.transaction.messageaftercommitexecutor;\nimport org.slf4j.logger;\nimport org.slf4j.loggerfactory;\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.stereotype.service;\n\n@service\npublic class messageserviceimpl implements messageservice {\n\n    private static final logger logger = loggerfactory.getlogger(messageserviceimpl.class);\n\n    @autowired\n    private messageaftercommitexecutor messageaftercommitexecutor;\n\n    /**\n     * 异步发送消息，未使用消息队列\n     */\n    @override\n    public void sendmessageasyncwithnoqueue(messageentity messageentity) {\n        messageaftercommitexecutor.execute(() -> {\n            sendmessage(messageentity);\n        });\n    }\n\n    /**\n     * 发送消息具体业务逻辑\n     */\n    @override\n    public void sendmessage(messageentity messageentity) {\n        messageentity.getreceiver().foreach(receiver -> {\n            logger.info("发送消息，消息发送者:{}，消息接受者:{}", messageentity.getsender(), receiver);\n        });\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n同样用postman简单测试一下，保存用户数据后发送10000条消息，需要的时间大概为119ms，由于消息发送的业务简单，所以只相对于前文串行执行快了一点\n\n\n\n# 引入消息队列\n\n# 前文缺陷\n\n * 线程池+事务管理复用的方案已经实现了普通的异步消息发送，但如果接口请求频繁，海量的请求势必会对数据库造成很大的压力，甚至可能让数据库宕机。\n * 同时如果业务中需要做异步消息发送的时候很多，那么每个接口都要去弄一遍异步多线程发送，不仅仅耦合程度很高，如果某一个接口出问题了，这种异步多线程的方法也很难去排查问题，编码的同时也需要不停的try catch异常。\n\n此时引入消息队列就显得十分有必要，其异步、解耦、削峰的特性广为人知，这里不再阐述消息队列中可能遇到的问题和优点。\n\n在本节中，我们引入jdk中自带的linkedblockingqueue内存队列作为消息中间件，由于该队列内部实现有加锁机制，是一个并发安全队列，所以我们也暂时不需要考虑并发传入数据和取出数据时可能产生的问题。\n\n# 消息消费者\n\n先思考如何构建消费者，由于不像成熟的中间件那样需要部署。在单体应用里面，内存队列应该在spring启动前或启动后加载。spring的提供了许多方法在生命周期范围内进行自定义，可以选择在spring启动类中实现commandlinerunner，也可以选择使用对象实现applicationlistener\n\n本节采用后者，实现一个messagequeuelistener，在spring上下文准备就绪时，开启消息消费者对内存队列的监听(采用循环监听即可)，异步多线程的取出队列内的数据，并发送消息。规定内存队列为static保证在单体应用内的可见性，这里也可以单独写一个单例模式将这个队列注入到spring容器中，效果一样。\n\n提示\n\n注意，异步多线程消费数据会造成消费顺序不一致的情况，本文暂不需要考虑顺序消费场景，同时内存消息队列具有不可靠性，实际使用时请采用成熟的消息中间件\n\npackage com.test.message.listener;\n\nimport com.google.common.util.concurrent.listeningexecutorservice;\nimport com.test.message.domain.query.messageentity;\nimport com.test.message.service.messageservice;\nimport java.util.concurrent.linkedblockingqueue;\nimport javax.annotation.resource;\nimport org.slf4j.logger;\nimport org.slf4j.loggerfactory;\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.boot.context.event.applicationreadyevent;\nimport org.springframework.context.applicationlistener;\nimport org.springframework.stereotype.component;\n\n/**\n * 消息队列监听器-消费者, spring上下文准备就绪时，监听队列内消息进行消费\n */\n@component\npublic class messagequeuelistener implements applicationlistener<applicationreadyevent> {\n\n    private static final logger logger = loggerfactory.getlogger(messagequeuelistener.class);\n\n    // 限制队列长度\n    private static final integer max_messagequeue_size = 1000;\n\n    // 阻塞队列，并发安全\n    public static final linkedblockingqueue<messageentity> messagequeue = new linkedblockingqueue<>(\n            max_messagequeue_size);\n\n    @autowired\n    private listeningexecutorservice listeningexecutorservice;\n\n    @resource\n    private messageservice messageservice;\n\n    /**\n     * 消息消费者\n     * <p/>\n     * 如果循环在异步提交外围\n     * <p/>\n     * 可能出现消息还没发送完，while循环又判断了\n     * <p/>\n     * 多次提交了任务，但此时队列已经为空\n     * <p/>\n     * 所以这里while循环在线程池提交的任务内部\n     */\n    @override\n    public void onapplicationevent(applicationreadyevent event) {\n        listeningexecutorservice.submit(() -> {\n            try {\n                while (true) {\n                    if (messagequeue.size() != 0) {\n                        // take 队列为空的时候线程阻塞不会执行后续方法\n                        messageentity message = messagequeue.take();\n                        messageservice.sendmessage(message);\n                    }\n                }\n            } catch (exception e) {\n                logger.error("队列: 消息发送失败", e);\n            }\n        });\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n\n\n# 消息生产者\n\n生产者主要是将消息实体传入消息队列，不过由于是事务后进行的消息生产，需要有些注意的地方，详见注释\n\n在messageservice中添加sendmessagetoqueue方法\n\n/**\n * 消息通知service\n */\npublic interface messageservice {\n\n    /**\n     * 发送消息到消息队列\n     */\n    void sendmessagetoqueue(messageentity messageentity);\n    // 省略...\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n在messageserviceimpl中添加sendmessagetoqueue的实现\n\n@service\npublic class messageserviceimpl implements messageservice {\n\n    private static final logger logger = loggerfactory.getlogger(messageserviceimpl.class);\n\n    @autowired\n    private messageaftercommitexecutor messageaftercommitexecutor;\n\n    /**\n     * 消息生产者\n     * <p/>\n     * 注意由事务管理器提交的runnable进程，如果涉及到写入操作\n     * <p/>\n     * 则必须采用propagation.requires_new的事务传播类型\n     * <p/>\n     * 现有管理器是上文事务提交之后执行新线程\n     * <p/>\n     * 如果新线程内未开启事务，则会因传播机制加入到上文事务中\n     * <p/>\n     * 由于上文事务已提交，所以新线程的执行在事务完成之后\n     * <p/>\n     * 将会出现线程虽然执行了，但事务未提交的情况，导致写操作失败\n     * <p/>\n     * 本次生产者仅将消息实体加入到消息队列，无需额外声明事务传播类型\n     */\n    @override\n    public void sendmessagetoqueue(messageentity messageentity) {\n        messageaftercommitexecutor.execute(() -> {\n            messagequeue.offer(messageentity);\n        });\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n至此，整个异步化的消息改造完成，消息在送入队列之后接口就可以返回了，后续的消息消费将在后台执行\n\n同样用postman简单测试一下，保存用户数据后发送10000条消息，需要的时间大概为10ms\n\n\n\n消耗的时间大概为：保存用户需要的时间+发送消息实体到内存队列的时间\n\n\n# 总结\n\n异步化改造是应用中场景的方法，本文从简单的异步方法出发，提供了线程池+事务管理+消息队列联合运用的整体方法，测试结果发现相对比串行和单纯使用异步调用的方法，加入消息队列的方案具有更快的调用速度\n\n\n# 参考资料\n\n>  1. https://segmentfault.com/a/1190000004235193?utm_source=tag-newest\n>  2. http://azagorneanu.blogspot.com/2013/06/transaction-synchronization-callbacks.html\n>  3. https://www.jyoryo.com/archives/155.html\n>  4. https://www.ithere.net/article/550\n>  5. https://juejin.cn/post/6984574787511123999',charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"二叉搜索树及AVL树详解",frontmatter:{title:"二叉搜索树及AVL树详解",date:"2022-01-28T15:42:48.000Z",categories:["Java"],tags:["Java","树","平衡二叉搜索树","二叉搜索树"],permalink:"/pages/2efaaf/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/07.%E5%AE%9E%E8%B7%B5/02.%E6%80%9D%E8%80%83%E4%B8%8E%E6%96%B9%E6%A1%88/04.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%8F%8AAVL%E6%A0%91%E8%AF%A6%E8%A7%A3.html",relativePath:"07.实践/02.思考与方案/04.二叉搜索树及AVL树详解.md",key:"v-49f8bbe0",path:"/pages/2efaaf/",headers:[{level:3,title:"二叉搜索树",slug:"二叉搜索树",normalizedTitle:"二叉搜索树",charIndex:2},{level:4,title:"特点",slug:"特点",normalizedTitle:"特点",charIndex:11},{level:4,title:"优点",slug:"优点",normalizedTitle:"优点",charIndex:131},{level:4,title:"缺点",slug:"缺点",normalizedTitle:"缺点",charIndex:448},{level:3,title:"平衡二叉搜索树(AVL树)",slug:"平衡二叉搜索树-avl树",normalizedTitle:"平衡二叉搜索树(avl树)",charIndex:583},{level:4,title:"特点",slug:"特点-2",normalizedTitle:"特点",charIndex:11},{level:4,title:"左旋和右旋",slug:"左旋和右旋",normalizedTitle:"左旋和右旋",charIndex:797},{level:4,title:"详细示例",slug:"详细示例",normalizedTitle:"详细示例",charIndex:1211},{level:3,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:1610},{level:3,title:"代码示例",slug:"代码示例",normalizedTitle:"代码示例",charIndex:1729}],headersStr:"二叉搜索树 特点 优点 缺点 平衡二叉搜索树(AVL树) 特点 左旋和右旋 详细示例 总结 代码示例",content:"# 二叉搜索树\n\n# 特点\n\n二叉搜索树，有如下特点：\n\n 1. 若它的左子树不为空，则左子树上所有的节点值都小于它的根节点值\n 2. 若它的右子树不为空，则右子树上所有的节点值均大于它的根节点值\n 3. 它的左右子树也分别可以充当为二叉查找树 例如\n\n\n\n# 优点\n\n二叉搜索树的优点：能够快速找到想要查找的值。 以查找数值为14的节点为例，由于二叉搜索树的特性，我们可以很快找到它，其查找过程如下：\n\n 1. 和根节点9比较\n\n\n 2. 由于14>9，所以14只可能存在于9的右子树中，因此查看右孩子13\n\n\n 3. 由于14>13，所以继续查看13的右孩子15\n\n\n 4. 由于14<15，所以14只可能存在于15的左孩子中，因此查找15的左孩子14\n\n\n 5. 这时候发现14正是自己查找的值，于是查找结束 这种查找二叉树的方式正是二分查找的思想，可以很快的找到目标节点，查找所需的最大次数等于二叉搜索树的高度。 在插入的时候也是一样，通过一层一层的比较，最后找到适合自己的位置。\n\n# 缺点\n\n二叉搜索树具有什么缺陷呢？ 假设初始的二叉搜索树只有三个节点：\n\n\n\n然后我们按照顺序陆续插入节点4、3、2、1、0。插入之后的结构如下：\n\n\n\n可以观察到，所有的节点都倾向于一边了，当出现这种情况时，二叉搜索树在查找的性能就大打折扣，几乎变成线性了。\n\n\n# 平衡二叉搜索树(AVL树)\n\n为了解决二叉搜索树的缺点，平衡二叉树被提出\n\n# 特点\n\n其具有如下特点：\n\n 1. 具有二叉搜索树的全部特性\n 2. 每个节点的左子树和右子树的高度差至多等于1 例如：下图就是一颗AVL树\n\n\n\n而这张图中的则不是AVL树(节点右边的数字为节点的高度)\n\n\n\n对于上图而言，节点9的左孩子高度为2，而右孩子高度为0，他们之间的差值超过了1。AVL树可以保证不会出现大量节点偏向一边的情况。\n\n# 左旋和右旋\n\n听起来AVL树还不错，但思考一下，如果我们要插入一个节点3，按照查找二叉树的特性，我们只能把3作为节点4的左子树插进去，可是插进去之后，又会破坏了AVL树的特性，那我们那该怎么弄？ 在这之前，先了解一下左旋和右旋的概念。 右旋: 我们在进行节点插入的时候，可能会出现节点都倾向于左边的情况，例如\n\n\n\n我们把这种倾向于左边的情况称之为左-左型。这个时候，我们就可以对节点9进行右旋操作，使它恢复平衡。\n\n\n\n即：顺时针旋转两个节点，使得父节点被自己的左孩子取代，而自己成为自己的右孩子 再举个例子：\n\n\n\n节点4和9高度相差大于1。由于是左孩子的高度较高，此时是左-左型，进行右旋。\n\n\n\n这里要注意，节点4的右孩子成为了节点6的左孩子了 用一个动图示例：\n\n\n\n左旋: 左旋和右旋一样，就是用来解决当大部分节点都偏向右边的时候，通过左旋来还原。例如：\n\n\n\n我们把这种倾向于右边的情况称之为右-右型。\n\n\n\n# 详细示例\n\n以一个具体实例详细讲解： 假设二叉树初试状态如下：\n\n\n\n我们逐渐插入如下数值：1，4，5，6，7，10，9，8\n\n插入1\n\n\n\n此时为左-左型，需要右旋调整\n\n\n\n插入4\n\n\n\n继续插入5\n\n\n\n此时为右-右型，需要左旋调整\n\n\n\n继续插入6\n\n\n\n右-右型，需要进行左旋\n\n\n\n继续插入7\n\n\n\n右-右型，需要进行左旋\n\n\n\n继续插入10\n\n\n\n继续插入9\n\n\n\n出现了这种情况应该怎么办呢？对于这种右-左型的情况，单单一次左旋或右旋是不行的，下面我们先说说如何处理这种情况。\n\n\n\n这种类型我们把他成为右-左型，处理方式是先对节点10进行右旋把它变成右-右型\n\n\n\n然后再进行左旋\n\n\n\n所以对这种右-左型的，我们需要进行一次右旋再左旋，依次类推，左-右型需要进行一次左旋再右旋，与右-左型相反\n\n\n\n回到刚才那道题\n\n\n\n对它进行右旋再左旋\n\n\n\n到此，节点的插入结束\n\n\n# 总结\n\n在插入的过程中，会出现一下四种情况破坏AVL树的特性，我们可以采取如下相应的旋转。\n\n 1. 左-左型：做右旋。\n 2. 右-右型：做左旋。\n 3. 左-右型：先做左旋，后做右旋。\n 4. 右-左型：先做右旋，再做左旋。\n\n\n# 代码示例\n\n//定义节点\nclass AvlNode {\n   int data;\n   AvlNode lchild;//左孩子\n   AvlNode rchild;//右孩子\n   int height;//记录节点的高度\n}\n\n//在这里定义各种操作\npublic class AVLTree{\n   //计算节点的高度\n   static int height(AvlNode T) {\n       if (T == null) {\n           return -1;\n       }else{\n           return T.height;\n       }\n   }\n\n   //左左型，右旋操作\n   static AvlNode R_Rotate(AvlNode K2) {\n       AvlNode K1;\n\n       //进行旋转\n       K1 = K2.lchild;\n       K2.lchild = K1.rchild;\n       K1.rchild = K2;\n\n       //重新计算节点的高度\n       K2.height = Math.max(height(K2.lchild), height(K2.rchild)) + 1;\n       K1.height = Math.max(height(K1.lchild), height(K1.rchild)) + 1;\n\n       return K1;\n   }\n\n   //进行左旋\n   static AvlNode L_Rotate(AvlNode K2) {\n       AvlNode K1;\n\n       K1 = K2.rchild;\n       K2.rchild = K1.lchild;\n       K1.lchild = K2;\n\n       //重新计算高度\n       K2.height = Math.max(height(K2.lchild), height(K2.rchild)) + 1;\n       K1.height = Math.max(height(K1.lchild), height(K1.rchild)) + 1;\n\n       return K1;\n   }\n\n   //左-右型，进行右旋，再左旋\n   static AvlNode R_L_Rotate(AvlNode K3) {\n       //先对其孩子进行左旋\n       K3.lchild = R_Rotate(K3.lchild);\n       //再进行右旋\n       return L_Rotate(K3);\n   }\n\n   //右-左型，先进行左旋，再右旋\n   static AvlNode L_R_Rotate(AvlNode K3) {\n       //先对孩子进行左旋\n       K3.rchild = L_Rotate(K3.rchild);\n       //在右旋\n       return R_Rotate(K3);\n   }\n\n   //插入数值操作\n   static AvlNode insert(int data, AvlNode T) {\n       if (T == null) {\n           T = new AvlNode();\n           T.data = data;\n           T.lchild = T.rchild = null;\n       } else if(data < T.data) {\n           //向左孩子递归插入\n           T.lchild = insert(data, T.lchild);\n           //进行调整操作\n           //如果左孩子的高度比右孩子大2\n           if (height(T.lchild) - height(T.rchild) == 2) {\n               //左-左型\n               if (data < T.lchild.data) {\n                   T = R_Rotate(T);\n               } else {\n                   //左-右型\n                   T = R_L_Rotate(T);\n               }\n           }\n       } else if (data > T.data) {\n           T.rchild = insert(data, T.rchild);\n           //进行调整\n           //右孩子比左孩子高度大2\n           if(height(T.rchild) - height(T.lchild) == 2)\n               //右-右型\n               if (data > T.rchild.data) {\n                   T = L_Rotate(T);\n               } else {\n                   T = L_R_Rotate(T);\n               }\n       }\n       //否则，这个节点已经在书上存在了，我们什么也不做\n       \n       //重新计算T的高度\n       T.height = Math.max(height(T.lchild), height(T.rchild)) + 1;\n       return T;\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n",normalizedContent:"# 二叉搜索树\n\n# 特点\n\n二叉搜索树，有如下特点：\n\n 1. 若它的左子树不为空，则左子树上所有的节点值都小于它的根节点值\n 2. 若它的右子树不为空，则右子树上所有的节点值均大于它的根节点值\n 3. 它的左右子树也分别可以充当为二叉查找树 例如\n\n\n\n# 优点\n\n二叉搜索树的优点：能够快速找到想要查找的值。 以查找数值为14的节点为例，由于二叉搜索树的特性，我们可以很快找到它，其查找过程如下：\n\n 1. 和根节点9比较\n\n\n 2. 由于14>9，所以14只可能存在于9的右子树中，因此查看右孩子13\n\n\n 3. 由于14>13，所以继续查看13的右孩子15\n\n\n 4. 由于14<15，所以14只可能存在于15的左孩子中，因此查找15的左孩子14\n\n\n 5. 这时候发现14正是自己查找的值，于是查找结束 这种查找二叉树的方式正是二分查找的思想，可以很快的找到目标节点，查找所需的最大次数等于二叉搜索树的高度。 在插入的时候也是一样，通过一层一层的比较，最后找到适合自己的位置。\n\n# 缺点\n\n二叉搜索树具有什么缺陷呢？ 假设初始的二叉搜索树只有三个节点：\n\n\n\n然后我们按照顺序陆续插入节点4、3、2、1、0。插入之后的结构如下：\n\n\n\n可以观察到，所有的节点都倾向于一边了，当出现这种情况时，二叉搜索树在查找的性能就大打折扣，几乎变成线性了。\n\n\n# 平衡二叉搜索树(avl树)\n\n为了解决二叉搜索树的缺点，平衡二叉树被提出\n\n# 特点\n\n其具有如下特点：\n\n 1. 具有二叉搜索树的全部特性\n 2. 每个节点的左子树和右子树的高度差至多等于1 例如：下图就是一颗avl树\n\n\n\n而这张图中的则不是avl树(节点右边的数字为节点的高度)\n\n\n\n对于上图而言，节点9的左孩子高度为2，而右孩子高度为0，他们之间的差值超过了1。avl树可以保证不会出现大量节点偏向一边的情况。\n\n# 左旋和右旋\n\n听起来avl树还不错，但思考一下，如果我们要插入一个节点3，按照查找二叉树的特性，我们只能把3作为节点4的左子树插进去，可是插进去之后，又会破坏了avl树的特性，那我们那该怎么弄？ 在这之前，先了解一下左旋和右旋的概念。 右旋: 我们在进行节点插入的时候，可能会出现节点都倾向于左边的情况，例如\n\n\n\n我们把这种倾向于左边的情况称之为左-左型。这个时候，我们就可以对节点9进行右旋操作，使它恢复平衡。\n\n\n\n即：顺时针旋转两个节点，使得父节点被自己的左孩子取代，而自己成为自己的右孩子 再举个例子：\n\n\n\n节点4和9高度相差大于1。由于是左孩子的高度较高，此时是左-左型，进行右旋。\n\n\n\n这里要注意，节点4的右孩子成为了节点6的左孩子了 用一个动图示例：\n\n\n\n左旋: 左旋和右旋一样，就是用来解决当大部分节点都偏向右边的时候，通过左旋来还原。例如：\n\n\n\n我们把这种倾向于右边的情况称之为右-右型。\n\n\n\n# 详细示例\n\n以一个具体实例详细讲解： 假设二叉树初试状态如下：\n\n\n\n我们逐渐插入如下数值：1，4，5，6，7，10，9，8\n\n插入1\n\n\n\n此时为左-左型，需要右旋调整\n\n\n\n插入4\n\n\n\n继续插入5\n\n\n\n此时为右-右型，需要左旋调整\n\n\n\n继续插入6\n\n\n\n右-右型，需要进行左旋\n\n\n\n继续插入7\n\n\n\n右-右型，需要进行左旋\n\n\n\n继续插入10\n\n\n\n继续插入9\n\n\n\n出现了这种情况应该怎么办呢？对于这种右-左型的情况，单单一次左旋或右旋是不行的，下面我们先说说如何处理这种情况。\n\n\n\n这种类型我们把他成为右-左型，处理方式是先对节点10进行右旋把它变成右-右型\n\n\n\n然后再进行左旋\n\n\n\n所以对这种右-左型的，我们需要进行一次右旋再左旋，依次类推，左-右型需要进行一次左旋再右旋，与右-左型相反\n\n\n\n回到刚才那道题\n\n\n\n对它进行右旋再左旋\n\n\n\n到此，节点的插入结束\n\n\n# 总结\n\n在插入的过程中，会出现一下四种情况破坏avl树的特性，我们可以采取如下相应的旋转。\n\n 1. 左-左型：做右旋。\n 2. 右-右型：做左旋。\n 3. 左-右型：先做左旋，后做右旋。\n 4. 右-左型：先做右旋，再做左旋。\n\n\n# 代码示例\n\n//定义节点\nclass avlnode {\n   int data;\n   avlnode lchild;//左孩子\n   avlnode rchild;//右孩子\n   int height;//记录节点的高度\n}\n\n//在这里定义各种操作\npublic class avltree{\n   //计算节点的高度\n   static int height(avlnode t) {\n       if (t == null) {\n           return -1;\n       }else{\n           return t.height;\n       }\n   }\n\n   //左左型，右旋操作\n   static avlnode r_rotate(avlnode k2) {\n       avlnode k1;\n\n       //进行旋转\n       k1 = k2.lchild;\n       k2.lchild = k1.rchild;\n       k1.rchild = k2;\n\n       //重新计算节点的高度\n       k2.height = math.max(height(k2.lchild), height(k2.rchild)) + 1;\n       k1.height = math.max(height(k1.lchild), height(k1.rchild)) + 1;\n\n       return k1;\n   }\n\n   //进行左旋\n   static avlnode l_rotate(avlnode k2) {\n       avlnode k1;\n\n       k1 = k2.rchild;\n       k2.rchild = k1.lchild;\n       k1.lchild = k2;\n\n       //重新计算高度\n       k2.height = math.max(height(k2.lchild), height(k2.rchild)) + 1;\n       k1.height = math.max(height(k1.lchild), height(k1.rchild)) + 1;\n\n       return k1;\n   }\n\n   //左-右型，进行右旋，再左旋\n   static avlnode r_l_rotate(avlnode k3) {\n       //先对其孩子进行左旋\n       k3.lchild = r_rotate(k3.lchild);\n       //再进行右旋\n       return l_rotate(k3);\n   }\n\n   //右-左型，先进行左旋，再右旋\n   static avlnode l_r_rotate(avlnode k3) {\n       //先对孩子进行左旋\n       k3.rchild = l_rotate(k3.rchild);\n       //在右旋\n       return r_rotate(k3);\n   }\n\n   //插入数值操作\n   static avlnode insert(int data, avlnode t) {\n       if (t == null) {\n           t = new avlnode();\n           t.data = data;\n           t.lchild = t.rchild = null;\n       } else if(data < t.data) {\n           //向左孩子递归插入\n           t.lchild = insert(data, t.lchild);\n           //进行调整操作\n           //如果左孩子的高度比右孩子大2\n           if (height(t.lchild) - height(t.rchild) == 2) {\n               //左-左型\n               if (data < t.lchild.data) {\n                   t = r_rotate(t);\n               } else {\n                   //左-右型\n                   t = r_l_rotate(t);\n               }\n           }\n       } else if (data > t.data) {\n           t.rchild = insert(data, t.rchild);\n           //进行调整\n           //右孩子比左孩子高度大2\n           if(height(t.rchild) - height(t.lchild) == 2)\n               //右-右型\n               if (data > t.rchild.data) {\n                   t = l_rotate(t);\n               } else {\n                   t = l_r_rotate(t);\n               }\n       }\n       //否则，这个节点已经在书上存在了，我们什么也不做\n       \n       //重新计算t的高度\n       t.height = math.max(height(t.lchild), height(t.rchild)) + 1;\n       return t;\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"无惧性能烦恼-12款Bean拷贝工具压测大比拼",frontmatter:{title:"无惧性能烦恼-12款Bean拷贝工具压测大比拼",date:"2022-11-17T23:06:41.000Z",categories:["开源项目","Rpamis"],tags:["工具类","BeanUtil","压测","JMH"],permalink:"/pages/3147fe/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/08.%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/01.Rpamis/01.Utils/01.%E6%97%A0%E6%83%A7%E6%80%A7%E8%83%BD%E7%83%A6%E6%81%BC-12%E6%AC%BEBean%E6%8B%B7%E8%B4%9D%E5%B7%A5%E5%85%B7%E5%8E%8B%E6%B5%8B%E5%A4%A7%E6%AF%94%E6%8B%BC.html",relativePath:"08.开源项目/01.Rpamis/01.Utils/01.无惧性能烦恼-12款Bean拷贝工具压测大比拼.md",key:"v-788ad340",path:"/pages/3147fe/",headers:[{level:2,title:"背景",slug:"背景",normalizedTitle:"背景",charIndex:2},{level:2,title:"对比方法",slug:"对比方法",normalizedTitle:"对比方法",charIndex:413},{level:2,title:"实验设置",slug:"实验设置",normalizedTitle:"实验设置",charIndex:918},{level:3,title:"基准参数设置",slug:"基准参数设置",normalizedTitle:"基准参数设置",charIndex:1334},{level:3,title:"实验对象",slug:"实验对象",normalizedTitle:"实验对象",charIndex:1789},{level:2,title:"实验结果",slug:"实验结果",normalizedTitle:"实验结果",charIndex:1376},{level:2,title:"结论",slug:"结论",normalizedTitle:"结论",charIndex:5078},{level:2,title:"附录",slug:"附录",normalizedTitle:"附录",charIndex:5478}],headersStr:"背景 对比方法 实验设置 基准参数设置 实验对象 实验结果 结论 附录",content:'# 背景\n\n在开发过程中，我们通常会用到DO、DTO、VO、PO等对象，一般来说这些对象之间的字段具有一定的相似性。在进行对象转换时，除了手动get/set之外，开发者大概率会使用到类似BeanUtils等对象拷贝工具类。由于许多拷贝工具类性能低下，开发者经常在工具类没有进行选型的情况下引入项目，造成了开发社区或公司对这类工具类使用时有了更多的性能担忧。在前期的调研当中，也有类似于本文的比较，大多数使用循环/StopWatch/计算执行时间等形式衡量，少数文章采用了压测的方法。这类评价方式，能反应出一定的性能问题，但通常实验做的不够严谨准确。\n\n本文将对比市面上10款常见拷贝工具+1款基本封装的个人工具+1原生get/set方法，采用JMH进行公平性压测比较。以此让我们对工具类有一个清晰的对比，选择出合适的工具类。\n\n实验代码 https://github.com/benym/benchmark-test\n\n\n# 对比方法\n\n * get/set: 原生get/set\n * RpasBeanUtils: 基于Cglib BeanCopier+ConcurrentReferenceHashMap封装、基于ASM字节码拷贝原理\n * MapStruct: 编译器生成get/set\n * BeanCopier: 原生Cglib BeanCopier、基于ASM字节码拷贝原理\n * JackSon: Spring官方JackSon序列化工具ObjectMapper\n * FastJson: Alibaba Json序列化工具\n * Hutool BeanUtil: Hutool提供的BeanUtil工具\n * Hutool CglibUtil: Hutool提供的Cglib工具、基于Cglib BeanCopier、ASM字节码拷贝\n * Spring BeanUtils: Spring官方提供的BeanUtils、基于反射\n * Apache BeanUtils: 基于反射\n * Orkia: 基于javassist类库生成Bean映射的字节码\n * Dozer: 基于反射、定制化属性映射、XML映射\n\n\n# 实验设置\n\n本次实验只针对各工具类最核心接口，为了进行公平性比较，测试时将对需要动态根据source、target创建拷贝对象的工具类(RpasBeanUtils、MapStruct、BeanCopier、Jackson、Hutool BeanUtil、Hutool CglibUtil、Orkia、Dozer)进行实例缓存、同时对源数据进行缓存，尽可能展示核心拷贝接口的性能。实际上在日常开发过程中，开发者对于经常使用的工具类也会选择用static final修饰，或采用诸如Map等进行实例缓存。或许是碍于需要每个给对比工具类增加缓存操作的工作量，在调研的文章中很少有考虑对实例进行缓存的操作，造成比如BeanCopier实验效果和MapStruct差异过大等问题。\n\n在JMH中我们可以通过@State(Scope.Benchmark)+@Setup(Level.Trial)注解轻松实现在基准测试开始前的缓存初始化\n\n\n# 基准参数设置\n\n实验环境\n\n提示\n\n实验过程中应确保CPU拉满切避免发生降频现象导致实验结果不准确\n\n * jmhVersion : 1.29\n * IntelliJ IDEA 2021.2.2\n * jdkVersion : 1.8.0_351\n * CPU : Intel(R) Core(TM) i5-10600KF CPU @ 4.10GHz\n * Fork : 1, 对于每个Benchmark Fork出一个线程，避免实验数据倾斜\n * BenchmarkModel : Mode.Throughput, 采用吞吐量作为衡量指标\n * Warmup : 3, JIT预热3次之后进入正式测试\n * Measurement : iterations=10、time=5, 每个Benchmark迭代10次，每次迭代5秒\n * OutputTimeUnit : TimeUnit.MILLISECONDS, 吞吐量时间单位ops/ms\n * Threads : 10, 生成10个线程进行发压\n\n\n# 实验对象\n\n本次实验有2组对象\n\n * 简单类型对象DataBaseDO、DataBaseVO，简单类型仅有5个字段；\n * 复杂类型对象DbDO、DbVo、MockOne、MockTwo，复杂类型对象中包含108个字段，且字段中存在MockOne、MockTwo对象，在MockOne中包含其自身的嵌套子集List<MockOne>\n\n\n# 实验结果\n\n结果中Score表示测试的吞吐量，Error表示测试结果的平均差\n\n 1. 程序运行结果\n\n简单对象\n        \nBenchmark                                 Mode  Cnt       Score     Error   Units\nBenchmarkTestSimple.testApacheBeanUtils  thrpt   10    1014.681 ±   5.442  ops/ms\nBenchmarkTestSimple.testBeanCopier       thrpt   10  341581.539 ± 668.458  ops/ms\nBenchmarkTestSimple.testDozerMapping     thrpt   10    1444.746 ±   6.486  ops/ms\nBenchmarkTestSimple.testFastJson         thrpt   10    9816.492 ±  64.882  ops/ms\nBenchmarkTestSimple.testGetSet           thrpt   10  341429.391 ± 407.244  ops/ms\nBenchmarkTestSimple.testHutoolBeanUtil   thrpt   10    1201.178 ±  14.053  ops/ms\nBenchmarkTestSimple.testHutoolCglibUtil  thrpt   10  340730.983 ± 757.836  ops/ms\nBenchmarkTestSimple.testJackSon          thrpt   10    7333.661 ±  36.987  ops/ms\nBenchmarkTestSimple.testMapStruct        thrpt   10  341577.692 ± 487.573  ops/ms\nBenchmarkTestSimple.testOrikaMapper      thrpt   10    2377.357 ±   3.422  ops/ms\nBenchmarkTestSimple.testRpasBeanUtils    thrpt   10  340737.565 ± 774.559  ops/ms\nBenchmarkTestSimple.testSpringBeanUtils  thrpt   10    1949.802 ±   2.807  ops/ms\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n复杂对象\n\nBenchmark                                  Mode  Cnt      Score     Error   Units\nBenchmarkTestComplex.testApacheBeanUtils  thrpt   10     34.609 ±   0.405  ops/ms\nBenchmarkTestComplex.testBeanCopier       thrpt   10  24113.092 ± 127.129  ops/ms\nBenchmarkTestComplex.testDozerMapping     thrpt   10     96.133 ±   0.676  ops/ms\nBenchmarkTestComplex.testFastJson         thrpt   10    226.692 ±   1.215  ops/ms\nBenchmarkTestComplex.testGetSet           thrpt   10  24200.668 ±  43.997  ops/ms\nBenchmarkTestComplex.testHutoolBeanUtil   thrpt   10     68.630 ±   0.161  ops/ms\nBenchmarkTestComplex.testHutoolCglibUtil  thrpt   10  24147.446 ±  80.792  ops/ms\nBenchmarkTestComplex.testJackSon          thrpt   10    256.080 ±   2.660  ops/ms\nBenchmarkTestComplex.testMapStruct        thrpt   10  24111.832 ± 100.456  ops/ms\nBenchmarkTestComplex.testOrikaMapper      thrpt   10   1775.526 ±   1.818  ops/ms\nBenchmarkTestComplex.testRpasBeanUtils    thrpt   10  24109.377 ± 160.851  ops/ms\nBenchmarkTestComplex.testSpringBeanUtils  thrpt   10     94.354 ±   0.694  ops/ms\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n 2. 数值可视化\n\n简单对象\n\n\n\n从实验结果中我们可以看出BeanCopier、MapStruct和原生get/set效率类似，吞吐量都很接近。\n\n对于本文封装的RpasBeanUtils以及热门的Hutool CglibUtil，两者效率近似，同时也离get/set很接近，本质上这两款均基于BeanCopier封装，其主要性能损耗在弱引用的Map缓存上。\n\n同时以上4款工具，在平均差的表现也相对稳定。\n\n对于知名的2组JSON工具类，由于其本身定位不为高频Bean拷贝而设计，所以2者的效率对比前者差出好几倍。FastJson在这种场景下也明显快于Jackson。\n\nOrika虽然采用了字节码技术，但由于其是深拷贝，需要创建新对象的原因，其效率也不尽人意。\n\n其余的知名解决方案SpringBeanUtils、Dozer、ApacheBeanUtils由于采用反射+深拷贝的原因，其效率严重低下。\n\nHutool零依赖自研的BeanUtil，在本轮测试结果中同样也存在效率低下的问题。\n\n复杂对象\n\n\n\n不同于简单对象测试，对于复杂对象的拷贝尤其考验拷贝工具类的性能，毕竟在拷贝场景中，我们不仅仅只有简单的对象。更有嵌套、多字段、多类型等复杂情况。\n\n从实验结果中可以看出在简单对象排名前5的工具，在复杂对象的拷贝场景下依旧经受住了考验，这5个之间的排名波动可以理解为测试结果的误差性。\n\n继续往下观察，我们可以发现在上一轮实验中，表现比其他好的2组JSON工具类性能出现了明显的下滑，原本高于JackSon吞吐量的FastJson，在本轮测试中屈居后位。\n\n而Orika却在复杂对象拷贝中稳定住了他的位置。\n\n排名最后的4个工具依旧如简单对象拷贝排名类似，性能均很差。\n\n 3. CPU频率图\n\n\n\n\n# 结论\n\n通过两组不同类型的对象，我们对12款工具进行了压测实验，最后结果表示BeanCopier和MapStruct依旧是市场中最顶级的两款工具类，两者均拥有相同于原生get/set的性能，在使用时需要考虑使用缓存，两者均是高频Bean拷贝的工具首选。Hutool CglibUtil提供了开箱即用的基于BeanCopier的拷贝工具，如果没有特殊需求，又不想自己写工具类代码，也是强力的候选工具。如果Hutool提供的工具类满足不了项目，可以选择本文中RpasBeanUtils，基于Spring的弱引用ConcurrentReferenceHashMapmap，和缓存Cglib BeanCopier或MapStruct构建工具类，站在巨人的肩膀上，开发者也能快速的构建出适配项目且高性能的工具。同时在该场景下，我们应该避免使用其余基于反射、序列化等技术做出的工具，即使他们已经很出名。\n\n\n# 附录\n\n 1. 如果你的拷贝类中get/set含有特殊操作，以上主流的5款高性能的拷贝工具均会无法拷贝对应字段的值，其本质上是由于拷贝本身依赖于干净的get/set方法。此时基于反射的工具，例如SpringBeanUtils能够对这种特殊操作的实体进行拷贝，本质上是因为反射拷贝不需要依赖get/set只需要反射获取字段动态赋值即可，但代价是性能十分低下。建议实体对象中，尽量不修改原始get/set，如有实体类特殊需求，采用和get/set生成方法不重名方法。\n 2. 高性能拷贝的基石是浅拷贝，请确保拷贝后不再对源对象source进行修改，即拷贝时机发生在必要的转换时，如Controller层返回给前端VO，数据库层对象DO出库给各个接口使用返回DTO，因为源对象source的赋值改变会引起目标对象target的值变化，拷贝时本身是传递实体引用，如有特殊深拷贝需要可以了解MapStruct的@DeepClone\n 3. BeanCopier和MapStruct都是顶尖的工具，在源对象source和目标对象target字段类型不同，但字段名相同时。可以采用BeanCopier的Converter定义转换规则，或采用MapStruct的@mapping注解。通常而言MapStruct更为强大，编译期生成get/set让人更加放心，但缺点就是基本的转换也需要写interface，而BeanCopier不需要这点，仅在特殊转换时需要写Converter。\n\n压测核心代码\n\n简单对象\n\npackage com.benym.benchmark.test;\n\nimport cn.hutool.core.bean.BeanUtil;\nimport cn.hutool.extra.cglib.BeanCopierCache;\nimport com.alibaba.fastjson.JSON;\nimport com.benym.benchmark.test.interfaces.MapStructMapper;\nimport com.benym.benchmark.test.model.complex.DbDO;\nimport com.benym.benchmark.test.model.complex.DbVO;\nimport com.benym.benchmark.test.model.simple.DataBaseDO;\nimport com.benym.benchmark.test.model.simple.DataBaseVO;\nimport com.benym.benchmark.test.service.ModelService;\nimport com.benym.benchmark.test.utils.RpasBeanUtils;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport ma.glasnost.orika.MapperFacade;\nimport ma.glasnost.orika.MapperFactory;\nimport ma.glasnost.orika.impl.DefaultMapperFactory;\nimport net.sf.cglib.beans.BeanCopier;\nimport org.dozer.DozerBeanMapper;\nimport org.mapstruct.factory.Mappers;\nimport org.openjdk.jmh.annotations.*;\nimport org.openjdk.jmh.results.format.ResultFormatType;\nimport org.openjdk.jmh.runner.Runner;\nimport org.openjdk.jmh.runner.RunnerException;\nimport org.openjdk.jmh.runner.options.Options;\nimport org.openjdk.jmh.runner.options.OptionsBuilder;\nimport org.springframework.beans.BeanUtils;\n\nimport java.util.concurrent.TimeUnit;\n\n/**\n * 简单对象拷贝基准测试\n *\n * @author: benym\n */\n@Fork(1) // Fork 1个进程进行测试\n@BenchmarkMode(Mode.Throughput) // 吞吐量\n@Warmup(iterations = 3) // JIT预热\n@Measurement(iterations = 10, time = 5) // 迭代10次,每次5s\n@OutputTimeUnit(TimeUnit.MILLISECONDS) // 结果所使用的时间单位\n@Threads(10) // 线程10个\npublic class BenchmarkTestSimple {\n\n    /**\n     * 作用域为本次JMH测试，线程共享\n     * <p>\n     * 初始化source数据集\n     */\n    @State(Scope.Benchmark)\n    public static class GenerateModel {\n        DataBaseDO dataBaseModel;\n\n        // 初始化\n        @Setup(Level.Trial)\n        public void prepare() {\n            dataBaseModel = new ModelService().get();\n        }\n    }\n\n    /**\n     * 初始化Orika\n     */\n    @State(Scope.Benchmark)\n    public static class OrikaMapper {\n        MapperFactory mapperFactory;\n\n        @Setup(Level.Trial)\n        public void prepare() {\n            mapperFactory = new DefaultMapperFactory.Builder().build();\n        }\n    }\n\n    /**\n     * 初始化Dozer\n     */\n    @State(Scope.Benchmark)\n    public static class DozerMapper {\n        DozerBeanMapper mapper;\n\n        @Setup(Level.Trial)\n        public void prepare() {\n            mapper = new DozerBeanMapper();\n        }\n    }\n\n\n    @State(Scope.Benchmark)\n    public static class RpasBeanUtilsInit {\n        BeanCopier copier;\n\n        @Setup(Level.Trial)\n        public void prepare() {\n            copier = RpasBeanUtils.getBeanCopierWithNoConverter(DataBaseDO.class, DataBaseVO.class);\n        }\n    }\n\n    /**\n     * 初始化BeanCopier\n     */\n    @State(Scope.Benchmark)\n    public static class BeanCopierInit {\n        BeanCopier copier;\n\n        @Setup(Level.Trial)\n        public void prepare() {\n            copier = BeanCopier.create(DataBaseDO.class, DataBaseVO.class, false);\n        }\n    }\n\n    /**\n     * 初始化MapStruct\n     */\n    @State(Scope.Benchmark)\n    public static class MapStructInit {\n        MapStructMapper mapStructMapper;\n\n        @Setup(Level.Trial)\n        public void prepare() {\n            mapStructMapper = Mappers.getMapper(MapStructMapper.class);\n        }\n    }\n\n    /**\n     * 初始化Objectmapper\n     */\n    @State(Scope.Benchmark)\n    public static class ObjectMapperInit {\n        ObjectMapper objectMapper;\n\n        @Setup(Level.Trial)\n        public void prepare() {\n            objectMapper = new ObjectMapper();\n        }\n    }\n\n    /**\n     * 初始化hutool cglibUtil\n     */\n    @State(Scope.Benchmark)\n    public static class HutoolCglibInit {\n        BeanCopier copier;\n\n        @Setup(Level.Trial)\n        public void prepare(){\n            copier = BeanCopierCache.INSTANCE.get(DataBaseDO.class, DataBaseVO.class, null);\n        }\n    }\n\n    /**\n     * get/set 基准测试\n     *\n     * @param generateModel source\n     * @return target\n     * @throws Exception\n     */\n    @Benchmark\n    public DataBaseVO testGetSet(GenerateModel generateModel) throws Exception {\n        DataBaseVO dataBaseVO = new DataBaseVO();\n        DataBaseDO dataBaseModel = generateModel.dataBaseModel;\n        dataBaseVO.setAge(dataBaseModel.getAge());\n        dataBaseVO.setName(dataBaseModel.getName());\n        dataBaseVO.setTime(dataBaseModel.getTime());\n        dataBaseVO.setYear(dataBaseModel.getYear());\n        dataBaseVO.setOtherTime(dataBaseModel.getOtherTime());\n        return dataBaseVO;\n    }\n\n    /**\n     * RpasBeanUtils基准测试\n     *\n     * @param generateModel source\n     * @param init 初始化copier\n     * @return target\n     * @throws Exception\n     */\n    @Benchmark\n    public DataBaseVO testRpasBeanUtils(GenerateModel generateModel, RpasBeanUtilsInit init) throws Exception {\n        DataBaseVO dataBaseVO = new DataBaseVO();\n        init.copier.copy(generateModel.dataBaseModel, dataBaseVO, null);\n        return dataBaseVO;\n    }\n\n    /**\n     * MapStruct基准测试\n     *\n     * @param generateModel source\n     * @param init          初始化的mapper\n     * @return target\n     * @throws Exception\n     */\n    @Benchmark\n    public DataBaseVO testMapStruct(GenerateModel generateModel, MapStructInit init) throws Exception {\n        DataBaseVO dataBaseVO = init.mapStructMapper.copy(generateModel.dataBaseModel);\n        return dataBaseVO;\n    }\n\n    /**\n     * BeanCopier基准测试\n     *\n     * @param generateModel source\n     * @param beanCopier    初始化的BeanCopier\n     * @return target\n     * @throws Exception\n     */\n    @Benchmark\n    public DataBaseVO testBeanCopier(GenerateModel generateModel, BeanCopierInit beanCopier) throws Exception {\n        BeanCopier copier = beanCopier.copier;\n        DataBaseVO dataBaseVO = new DataBaseVO();\n        copier.copy(generateModel.dataBaseModel, dataBaseVO, null);\n        return dataBaseVO;\n    }\n\n    /**\n     * Jackson objectMapper基准测试\n     *\n     * @param generateModel source\n     * @param init          初始化的ObjectMapper\n     * @return target\n     * @throws Exception\n     */\n    @Benchmark\n    public DataBaseVO testJackSon(GenerateModel generateModel, ObjectMapperInit init) throws Exception {\n        String str = init.objectMapper.writeValueAsString(generateModel.dataBaseModel);\n        DataBaseVO dataBaseVO = init.objectMapper.readValue(str, DataBaseVO.class);\n        return dataBaseVO;\n    }\n\n\n    /**\n     * FastJson基准测试\n     *\n     * @param generateModel source\n     * @return target\n     * @throws Exception\n     */\n    @Benchmark\n    public DataBaseVO testFastJson(GenerateModel generateModel) throws Exception {\n        String str = JSON.toJSONString(generateModel.dataBaseModel);\n        return JSON.parseObject(str, DataBaseVO.class);\n    }\n\n    /**\n     * Hutool BeanUtil基准测试\n     *\n     * @param generateModel source\n     * @return target\n     * @throws Exception\n     */\n    @Benchmark\n    public DataBaseVO testHutoolBeanUtil(GenerateModel generateModel) throws Exception {\n        DataBaseVO dataBaseVO = new DataBaseVO();\n        BeanUtil.copyProperties(generateModel.dataBaseModel, dataBaseVO);\n        return dataBaseVO;\n    }\n\n\n    /**\n     * Hutool CglibUtil基准测试\n     *\n     * @param generateModel source\n     * @return target\n     * @throws Exception\n     */\n    @Benchmark\n    public DataBaseVO testHutoolCglibUtil(GenerateModel generateModel, HutoolCglibInit init) throws Exception {\n        DataBaseVO dataBaseVO = new DataBaseVO();\n        init.copier.copy(generateModel.dataBaseModel, dataBaseVO, null);\n        return dataBaseVO;\n    }\n\n    /**\n     * SpringBeanUtils基准测试\n     *\n     * @param generateModel source\n     * @return target\n     * @throws Exception\n     */\n    @Benchmark\n    public DataBaseVO testSpringBeanUtils(GenerateModel generateModel) throws Exception {\n        DataBaseVO dataBaseVO = new DataBaseVO();\n        BeanUtils.copyProperties(generateModel.dataBaseModel, dataBaseVO);\n        return dataBaseVO;\n    }\n\n    /**\n     * Apache BeanUtils基准测试\n     *\n     * @param generateModel source\n     * @return target\n     * @throws Exception\n     */\n    @Benchmark\n    public DataBaseVO testApacheBeanUtils(GenerateModel generateModel) throws Exception {\n        DataBaseVO dataBaseVO = new DataBaseVO();\n        org.apache.commons.beanutils.BeanUtils.copyProperties(dataBaseVO, generateModel.dataBaseModel);\n        return dataBaseVO;\n    }\n\n    /**\n     * Orika基准测试\n     *\n     * @param generateModel source\n     * @param orikaMapper   初始化orika\n     * @return target\n     * @throws Exception\n     */\n    @Benchmark\n    public DataBaseVO testOrikaMapper(GenerateModel generateModel, OrikaMapper orikaMapper) throws Exception {\n        MapperFacade mapperFacade = orikaMapper.mapperFactory.getMapperFacade();\n        DataBaseVO dataBaseVO = mapperFacade.map(generateModel.dataBaseModel, DataBaseVO.class);\n        return dataBaseVO;\n    }\n\n    /**\n     * Dozer基准测试\n     *\n     * @param generateModel source\n     * @param dozerMapper   初始化dozer\n     * @return target\n     * @throws Exception\n     */\n    @Benchmark\n    public DataBaseVO testDozerMapping(GenerateModel generateModel, DozerMapper dozerMapper) throws Exception {\n        DataBaseVO dataBaseVO = dozerMapper.mapper.map(generateModel.dataBaseModel, DataBaseVO.class);\n        return dataBaseVO;\n    }\n\n    public static void main(String[] args) throws RunnerException {\n        Options options = new OptionsBuilder()\n                .include(BenchmarkTestSimple.class.getSimpleName())\n                .result("result-simple.json")\n                .resultFormat(ResultFormatType.JSON)\n                .build();\n        new Runner(options).run();\n    }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n\n\n复杂对象\n\npackage com.benym.benchmark.test;\n\nimport cn.hutool.core.bean.BeanUtil;\nimport cn.hutool.extra.cglib.BeanCopierCache;\nimport com.alibaba.fastjson.JSON;\nimport com.benym.benchmark.test.interfaces.MapStructMapperComplex;\nimport com.benym.benchmark.test.model.complex.DbDO;\nimport com.benym.benchmark.test.model.complex.DbVO;\nimport com.benym.benchmark.test.model.simple.DataBaseVO;\nimport com.benym.benchmark.test.service.ModelService;\nimport com.benym.benchmark.test.utils.RpasBeanUtils;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport ma.glasnost.orika.MapperFacade;\nimport ma.glasnost.orika.MapperFactory;\nimport ma.glasnost.orika.impl.DefaultMapperFactory;\nimport net.sf.cglib.beans.BeanCopier;\nimport org.dozer.DozerBeanMapper;\nimport org.mapstruct.factory.Mappers;\nimport org.openjdk.jmh.annotations.*;\nimport org.openjdk.jmh.results.format.ResultFormatType;\nimport org.openjdk.jmh.runner.Runner;\nimport org.openjdk.jmh.runner.RunnerException;\nimport org.openjdk.jmh.runner.options.Options;\nimport org.openjdk.jmh.runner.options.OptionsBuilder;\nimport org.springframework.beans.BeanUtils;\n\nimport java.util.concurrent.TimeUnit;\n\n/**\n * 复杂对象拷贝基准测试\n *\n * @author: benym\n */\n@Fork(1) // Fork 1个进程进行测试\n@BenchmarkMode(Mode.Throughput) // 吞吐量\n@Warmup(iterations = 3) // JIT预热\n@Measurement(iterations = 10, time = 5) // 迭代10次,每次5s\n@OutputTimeUnit(TimeUnit.MILLISECONDS) // 结果所使用的时间单位\n@Threads(10) // 线程10个\npublic class BenchmarkTestComplex {\n    /**\n     * 作用域为本次JMH测试，线程共享\n     * <p>\n     * 初始化source数据集\n     */\n    @State(Scope.Benchmark)\n    public static class GenerateModel {\n        DbDO dbDo;\n\n        // 初始化\n        @Setup(Level.Trial)\n        public void prepare() {\n            dbDo = new ModelService().getComplex();\n        }\n    }\n\n    /**\n     * 初始化Orika\n     */\n    @State(Scope.Benchmark)\n    public static class OrikaMapper {\n        MapperFactory mapperFactory;\n\n        @Setup(Level.Trial)\n        public void prepare() {\n            mapperFactory = new DefaultMapperFactory.Builder().build();\n        }\n    }\n\n    /**\n     * 初始化Dozer\n     */\n    @State(Scope.Benchmark)\n    public static class DozerMapper {\n        DozerBeanMapper mapper;\n\n        @Setup(Level.Trial)\n        public void prepare() {\n            mapper = new DozerBeanMapper();\n        }\n    }\n\n    @State(Scope.Benchmark)\n    public static class RpasBeanUtilsInit {\n        BeanCopier copier;\n\n        @Setup(Level.Trial)\n        public void prepare() {\n            copier = RpasBeanUtils.getBeanCopierWithNoConverter(DbDO.class, DbVO.class);\n        }\n    }\n\n    /**\n     * 初始化BeanCopier\n     */\n    @State(Scope.Benchmark)\n    public static class BeanCopierInit {\n        BeanCopier copier;\n\n        @Setup(Level.Trial)\n        public void prepare() {\n            copier = BeanCopier.create(DbDO.class, DbVO.class, false);\n        }\n    }\n\n    /**\n     * 初始化MapStruct\n     */\n    @State(Scope.Benchmark)\n    public static class MapStructInit {\n        MapStructMapperComplex mapStructMapper;\n\n        @Setup(Level.Trial)\n        public void prepare() {\n            mapStructMapper = Mappers.getMapper(MapStructMapperComplex.class);\n        }\n    }\n\n    /**\n     * 初始化Objectmapper\n     */\n    @State(Scope.Benchmark)\n    public static class ObjectMapperInit {\n        ObjectMapper objectMapper;\n\n        @Setup(Level.Trial)\n        public void prepare() {\n            objectMapper = new ObjectMapper();\n        }\n    }\n\n    /**\n     * 初始化hutool cglibUtil\n     */\n    @State(Scope.Benchmark)\n    public static class HutoolCglibInit {\n        BeanCopier copier;\n\n        @Setup(Level.Trial)\n        public void prepare(){\n            copier = BeanCopierCache.INSTANCE.get(DbDO.class, DbVO.class, null);\n        }\n    }\n\n    /**\n     * get/set 基准测试\n     *\n     * @param generateModel source\n     * @return target\n     * @throws Exception\n     */\n    @Benchmark\n    public DbVO testGetSet(GenerateModel generateModel) throws Exception {\n        DbVO DbVO = new DbVO();\n        DbDO dbDo = generateModel.dbDo;\n        DbVO.setAge(dbDo.getAge());\n        DbVO.setName(dbDo.getName());\n        DbVO.setTime(dbDo.getTime());\n        DbVO.setYear(dbDo.getYear());\n        DbVO.setMockModelOne(dbDo.getMockModelOne());\n        DbVO.setMockModelTwo(dbDo.getMockModelTwo());\n        DbVO.setOtherTime(dbDo.getOtherTime());\n        DbVO.setField00(dbDo.getField00());\n        DbVO.setField01(dbDo.getField01());\n        DbVO.setField02(dbDo.getField02());\n        DbVO.setField03(dbDo.getField03());\n        DbVO.setField04(dbDo.getField04());\n        DbVO.setField05(dbDo.getField05());\n        DbVO.setField06(dbDo.getField06());\n        DbVO.setField07(dbDo.getField07());\n        DbVO.setField08(dbDo.getField08());\n        DbVO.setField09(dbDo.getField09());\n        DbVO.setField10(dbDo.getField10());\n        DbVO.setField11(dbDo.getField11());\n        DbVO.setField12(dbDo.getField12());\n        DbVO.setField13(dbDo.getField13());\n        DbVO.setField14(dbDo.getField14());\n        DbVO.setField15(dbDo.getField15());\n        DbVO.setField16(dbDo.getField16());\n        DbVO.setField17(dbDo.getField17());\n        DbVO.setField18(dbDo.getField18());\n        DbVO.setField19(dbDo.getField19());\n        DbVO.setField20(dbDo.getField20());\n        DbVO.setField21(dbDo.getField21());\n        DbVO.setField22(dbDo.getField22());\n        DbVO.setField23(dbDo.getField23());\n        DbVO.setField24(dbDo.getField24());\n        DbVO.setField25(dbDo.getField25());\n        DbVO.setField26(dbDo.getField26());\n        DbVO.setField27(dbDo.getField27());\n        DbVO.setField28(dbDo.getField28());\n        DbVO.setField29(dbDo.getField29());\n        DbVO.setField30(dbDo.getField30());\n        DbVO.setField31(dbDo.getField31());\n        DbVO.setField32(dbDo.getField32());\n        DbVO.setField33(dbDo.getField33());\n        DbVO.setField34(dbDo.getField34());\n        DbVO.setField35(dbDo.getField35());\n        DbVO.setField36(dbDo.getField36());\n        DbVO.setField37(dbDo.getField37());\n        DbVO.setField38(dbDo.getField38());\n        DbVO.setField39(dbDo.getField39());\n        DbVO.setField40(dbDo.getField40());\n        DbVO.setField41(dbDo.getField41());\n        DbVO.setField42(dbDo.getField42());\n        DbVO.setField43(dbDo.getField43());\n        DbVO.setField44(dbDo.getField44());\n        DbVO.setField45(dbDo.getField45());\n        DbVO.setField46(dbDo.getField46());\n        DbVO.setField47(dbDo.getField47());\n        DbVO.setField48(dbDo.getField48());\n        DbVO.setField49(dbDo.getField49());\n        DbVO.setField50(dbDo.getField50());\n        DbVO.setField51(dbDo.getField51());\n        DbVO.setField52(dbDo.getField52());\n        DbVO.setField53(dbDo.getField53());\n        DbVO.setField54(dbDo.getField54());\n        DbVO.setField55(dbDo.getField55());\n        DbVO.setField56(dbDo.getField56());\n        DbVO.setField57(dbDo.getField57());\n        DbVO.setField58(dbDo.getField58());\n        DbVO.setField59(dbDo.getField59());\n        DbVO.setField60(dbDo.getField60());\n        DbVO.setField61(dbDo.getField61());\n        DbVO.setField62(dbDo.getField62());\n        DbVO.setField63(dbDo.getField63());\n        DbVO.setField64(dbDo.getField64());\n        DbVO.setField65(dbDo.getField65());\n        DbVO.setField66(dbDo.getField66());\n        DbVO.setField67(dbDo.getField67());\n        DbVO.setField68(dbDo.getField68());\n        DbVO.setField69(dbDo.getField69());\n        DbVO.setField70(dbDo.getField70());\n        DbVO.setField71(dbDo.getField71());\n        DbVO.setField72(dbDo.getField72());\n        DbVO.setField73(dbDo.getField73());\n        DbVO.setField74(dbDo.getField74());\n        DbVO.setField75(dbDo.getField75());\n        DbVO.setField76(dbDo.getField76());\n        DbVO.setField77(dbDo.getField77());\n        DbVO.setField78(dbDo.getField78());\n        DbVO.setField79(dbDo.getField79());\n        DbVO.setField80(dbDo.getField80());\n        DbVO.setField81(dbDo.getField81());\n        DbVO.setField82(dbDo.getField82());\n        DbVO.setField83(dbDo.getField83());\n        DbVO.setField84(dbDo.getField84());\n        DbVO.setField85(dbDo.getField85());\n        DbVO.setField86(dbDo.getField86());\n        DbVO.setField87(dbDo.getField87());\n        DbVO.setField88(dbDo.getField88());\n        DbVO.setField89(dbDo.getField89());\n        DbVO.setField90(dbDo.getField90());\n        DbVO.setField91(dbDo.getField91());\n        DbVO.setField92(dbDo.getField92());\n        DbVO.setField93(dbDo.getField93());\n        DbVO.setField94(dbDo.getField94());\n        DbVO.setField95(dbDo.getField95());\n        DbVO.setField96(dbDo.getField96());\n        DbVO.setField97(dbDo.getField97());\n        DbVO.setField98(dbDo.getField98());\n        DbVO.setField99(dbDo.getField99());\n        DbVO.setField100(dbDo.getField100());\n        return DbVO;\n    }\n\n    /**\n     * RpasBeanUtils基准测试\n     *\n     * @param generateModel source\n     * @param init 初始化copier\n     * @return target\n     * @throws Exception\n     */\n    @Benchmark\n    public DbVO testRpasBeanUtils(GenerateModel generateModel, RpasBeanUtilsInit init) throws Exception {\n        DbVO dbVO = new DbVO();\n        init.copier.copy(generateModel.dbDo, dbVO, null);\n        return dbVO;\n    }\n\n    /**\n     * MapStruct基准测试\n     *\n     * @param generateModel source\n     * @param init          初始化的mapper\n     * @return target\n     * @throws Exception\n     */\n    @Benchmark\n    public DbVO testMapStruct(GenerateModel generateModel, MapStructInit init) throws Exception {\n        DbVO DbVO = init.mapStructMapper.copy(generateModel.dbDo);\n        return DbVO;\n    }\n\n    /**\n     * BeanCopier基准测试\n     *\n     * @param generateModel source\n     * @param beanCopier    初始化的BeanCopier\n     * @return target\n     * @throws Exception\n     */\n    @Benchmark\n    public DbVO testBeanCopier(GenerateModel generateModel, BeanCopierInit beanCopier) throws Exception {\n        BeanCopier copier = beanCopier.copier;\n        DbVO DbVO = new DbVO();\n        copier.copy(generateModel.dbDo, DbVO, null);\n        return DbVO;\n    }\n\n    /**\n     * Jackson objectMapper基准测试\n     *\n     * @param generateModel source\n     * @param init          初始化的ObjectMapper\n     * @return target\n     * @throws Exception\n     */\n    @Benchmark\n    public DbVO testJackSon(GenerateModel generateModel, ObjectMapperInit init) throws Exception {\n        String str = init.objectMapper.writeValueAsString(generateModel.dbDo);\n        DbVO dbVO = init.objectMapper.readValue(str, DbVO.class);\n        return dbVO;\n    }\n\n\n    /**\n     * FastJson基准测试\n     *\n     * @param generateModel source\n     * @return target\n     * @throws Exception\n     */\n    @Benchmark\n    public DbVO testFastJson(GenerateModel generateModel) throws Exception {\n        String str = JSON.toJSONString(generateModel.dbDo);\n        return JSON.parseObject(str, DbVO.class);\n    }\n\n    /**\n     * Hutool BeanUtil基准测试\n     *\n     * @param generateModel source\n     * @return target\n     * @throws Exception\n     */\n    @Benchmark\n    public DbVO testHutoolBeanUtil(GenerateModel generateModel) throws Exception {\n        DbVO DbVO = new DbVO();\n        BeanUtil.copyProperties(generateModel.dbDo, DbVO);\n        return DbVO;\n    }\n\n    /**\n     * Hutool CglibUtil基准测试\n     *\n     * @param generateModel source\n     * @return target\n     * @throws Exception\n     */\n    @Benchmark\n    public DbVO testHutoolCglibUtil(GenerateModel generateModel, HutoolCglibInit init) throws Exception {\n        DbVO dbVO = new DbVO();\n        init.copier.copy(generateModel.dbDo, dbVO, null);\n        return dbVO;\n    }\n\n    /**\n     * SpringBeanUtils基准测试\n     *\n     * @param generateModel source\n     * @return target\n     * @throws Exception\n     */\n    @Benchmark\n    public DbVO testSpringBeanUtils(GenerateModel generateModel) throws Exception {\n        DbVO DbVO = new DbVO();\n        BeanUtils.copyProperties(generateModel.dbDo, DbVO);\n        return DbVO;\n    }\n\n    /**\n     * Apache BeanUtils基准测试\n     *\n     * @param generateModel source\n     * @return target\n     * @throws Exception\n     */\n    @Benchmark\n    public DbVO testApacheBeanUtils(GenerateModel generateModel) throws Exception {\n        DbVO DbVO = new DbVO();\n        org.apache.commons.beanutils.BeanUtils.copyProperties(DbVO, generateModel.dbDo);\n        return DbVO;\n    }\n\n    /**\n     * Orika基准测试\n     *\n     * @param generateModel source\n     * @param orikaMapper   初始化orika\n     * @return target\n     * @throws Exception\n     */\n    @Benchmark\n    public DbVO testOrikaMapper(GenerateModel generateModel, OrikaMapper orikaMapper) throws Exception {\n        MapperFacade mapperFacade = orikaMapper.mapperFactory.getMapperFacade();\n        DbVO DbVO = mapperFacade.map(generateModel.dbDo, DbVO.class);\n        return DbVO;\n    }\n\n    /**\n     * Dozer基准测试\n     *\n     * @param generateModel source\n     * @param dozerMapper   初始化dozer\n     * @return target\n     * @throws Exception\n     */\n    @Benchmark\n    public DbVO testDozerMapping(GenerateModel generateModel, DozerMapper dozerMapper) throws Exception {\n        DbVO DbVO = dozerMapper.mapper.map(generateModel.dbDo, DbVO.class);\n        return DbVO;\n    }\n\n    public static void main(String[] args) throws RunnerException {\n        Options options = new OptionsBuilder()\n                .include(BenchmarkTestComplex.class.getSimpleName())\n                .result("result-complex.json")\n                .resultFormat(ResultFormatType.JSON)\n                .build();\n        new Runner(options).run();\n    }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n394\n395\n396\n397\n398\n399\n400\n401\n402\n403\n404\n405\n406\n407\n408\n409\n410\n411\n412\n413\n414\n415\n416\n417\n418\n419\n420\n421\n422\n423\n424\n425\n426\n427\n428\n429\n430\n431\n432\n433\n434\n435\n436\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n394\n395\n396\n397\n398\n399\n400\n401\n402\n403\n404\n405\n406\n407\n408\n409\n410\n411\n412\n413\n414\n415\n416\n417\n418\n419\n420\n421\n422\n423\n424\n425\n426\n427\n428\n429\n430\n431\n432\n433\n434\n435\n436\n',normalizedContent:'# 背景\n\n在开发过程中，我们通常会用到do、dto、vo、po等对象，一般来说这些对象之间的字段具有一定的相似性。在进行对象转换时，除了手动get/set之外，开发者大概率会使用到类似beanutils等对象拷贝工具类。由于许多拷贝工具类性能低下，开发者经常在工具类没有进行选型的情况下引入项目，造成了开发社区或公司对这类工具类使用时有了更多的性能担忧。在前期的调研当中，也有类似于本文的比较，大多数使用循环/stopwatch/计算执行时间等形式衡量，少数文章采用了压测的方法。这类评价方式，能反应出一定的性能问题，但通常实验做的不够严谨准确。\n\n本文将对比市面上10款常见拷贝工具+1款基本封装的个人工具+1原生get/set方法，采用jmh进行公平性压测比较。以此让我们对工具类有一个清晰的对比，选择出合适的工具类。\n\n实验代码 https://github.com/benym/benchmark-test\n\n\n# 对比方法\n\n * get/set: 原生get/set\n * rpasbeanutils: 基于cglib beancopier+concurrentreferencehashmap封装、基于asm字节码拷贝原理\n * mapstruct: 编译器生成get/set\n * beancopier: 原生cglib beancopier、基于asm字节码拷贝原理\n * jackson: spring官方jackson序列化工具objectmapper\n * fastjson: alibaba json序列化工具\n * hutool beanutil: hutool提供的beanutil工具\n * hutool cglibutil: hutool提供的cglib工具、基于cglib beancopier、asm字节码拷贝\n * spring beanutils: spring官方提供的beanutils、基于反射\n * apache beanutils: 基于反射\n * orkia: 基于javassist类库生成bean映射的字节码\n * dozer: 基于反射、定制化属性映射、xml映射\n\n\n# 实验设置\n\n本次实验只针对各工具类最核心接口，为了进行公平性比较，测试时将对需要动态根据source、target创建拷贝对象的工具类(rpasbeanutils、mapstruct、beancopier、jackson、hutool beanutil、hutool cglibutil、orkia、dozer)进行实例缓存、同时对源数据进行缓存，尽可能展示核心拷贝接口的性能。实际上在日常开发过程中，开发者对于经常使用的工具类也会选择用static final修饰，或采用诸如map等进行实例缓存。或许是碍于需要每个给对比工具类增加缓存操作的工作量，在调研的文章中很少有考虑对实例进行缓存的操作，造成比如beancopier实验效果和mapstruct差异过大等问题。\n\n在jmh中我们可以通过@state(scope.benchmark)+@setup(level.trial)注解轻松实现在基准测试开始前的缓存初始化\n\n\n# 基准参数设置\n\n实验环境\n\n提示\n\n实验过程中应确保cpu拉满切避免发生降频现象导致实验结果不准确\n\n * jmhversion : 1.29\n * intellij idea 2021.2.2\n * jdkversion : 1.8.0_351\n * cpu : intel(r) core(tm) i5-10600kf cpu @ 4.10ghz\n * fork : 1, 对于每个benchmark fork出一个线程，避免实验数据倾斜\n * benchmarkmodel : mode.throughput, 采用吞吐量作为衡量指标\n * warmup : 3, jit预热3次之后进入正式测试\n * measurement : iterations=10、time=5, 每个benchmark迭代10次，每次迭代5秒\n * outputtimeunit : timeunit.milliseconds, 吞吐量时间单位ops/ms\n * threads : 10, 生成10个线程进行发压\n\n\n# 实验对象\n\n本次实验有2组对象\n\n * 简单类型对象databasedo、databasevo，简单类型仅有5个字段；\n * 复杂类型对象dbdo、dbvo、mockone、mocktwo，复杂类型对象中包含108个字段，且字段中存在mockone、mocktwo对象，在mockone中包含其自身的嵌套子集list<mockone>\n\n\n# 实验结果\n\n结果中score表示测试的吞吐量，error表示测试结果的平均差\n\n 1. 程序运行结果\n\n简单对象\n        \nbenchmark                                 mode  cnt       score     error   units\nbenchmarktestsimple.testapachebeanutils  thrpt   10    1014.681 ±   5.442  ops/ms\nbenchmarktestsimple.testbeancopier       thrpt   10  341581.539 ± 668.458  ops/ms\nbenchmarktestsimple.testdozermapping     thrpt   10    1444.746 ±   6.486  ops/ms\nbenchmarktestsimple.testfastjson         thrpt   10    9816.492 ±  64.882  ops/ms\nbenchmarktestsimple.testgetset           thrpt   10  341429.391 ± 407.244  ops/ms\nbenchmarktestsimple.testhutoolbeanutil   thrpt   10    1201.178 ±  14.053  ops/ms\nbenchmarktestsimple.testhutoolcglibutil  thrpt   10  340730.983 ± 757.836  ops/ms\nbenchmarktestsimple.testjackson          thrpt   10    7333.661 ±  36.987  ops/ms\nbenchmarktestsimple.testmapstruct        thrpt   10  341577.692 ± 487.573  ops/ms\nbenchmarktestsimple.testorikamapper      thrpt   10    2377.357 ±   3.422  ops/ms\nbenchmarktestsimple.testrpasbeanutils    thrpt   10  340737.565 ± 774.559  ops/ms\nbenchmarktestsimple.testspringbeanutils  thrpt   10    1949.802 ±   2.807  ops/ms\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n复杂对象\n\nbenchmark                                  mode  cnt      score     error   units\nbenchmarktestcomplex.testapachebeanutils  thrpt   10     34.609 ±   0.405  ops/ms\nbenchmarktestcomplex.testbeancopier       thrpt   10  24113.092 ± 127.129  ops/ms\nbenchmarktestcomplex.testdozermapping     thrpt   10     96.133 ±   0.676  ops/ms\nbenchmarktestcomplex.testfastjson         thrpt   10    226.692 ±   1.215  ops/ms\nbenchmarktestcomplex.testgetset           thrpt   10  24200.668 ±  43.997  ops/ms\nbenchmarktestcomplex.testhutoolbeanutil   thrpt   10     68.630 ±   0.161  ops/ms\nbenchmarktestcomplex.testhutoolcglibutil  thrpt   10  24147.446 ±  80.792  ops/ms\nbenchmarktestcomplex.testjackson          thrpt   10    256.080 ±   2.660  ops/ms\nbenchmarktestcomplex.testmapstruct        thrpt   10  24111.832 ± 100.456  ops/ms\nbenchmarktestcomplex.testorikamapper      thrpt   10   1775.526 ±   1.818  ops/ms\nbenchmarktestcomplex.testrpasbeanutils    thrpt   10  24109.377 ± 160.851  ops/ms\nbenchmarktestcomplex.testspringbeanutils  thrpt   10     94.354 ±   0.694  ops/ms\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n 2. 数值可视化\n\n简单对象\n\n\n\n从实验结果中我们可以看出beancopier、mapstruct和原生get/set效率类似，吞吐量都很接近。\n\n对于本文封装的rpasbeanutils以及热门的hutool cglibutil，两者效率近似，同时也离get/set很接近，本质上这两款均基于beancopier封装，其主要性能损耗在弱引用的map缓存上。\n\n同时以上4款工具，在平均差的表现也相对稳定。\n\n对于知名的2组json工具类，由于其本身定位不为高频bean拷贝而设计，所以2者的效率对比前者差出好几倍。fastjson在这种场景下也明显快于jackson。\n\norika虽然采用了字节码技术，但由于其是深拷贝，需要创建新对象的原因，其效率也不尽人意。\n\n其余的知名解决方案springbeanutils、dozer、apachebeanutils由于采用反射+深拷贝的原因，其效率严重低下。\n\nhutool零依赖自研的beanutil，在本轮测试结果中同样也存在效率低下的问题。\n\n复杂对象\n\n\n\n不同于简单对象测试，对于复杂对象的拷贝尤其考验拷贝工具类的性能，毕竟在拷贝场景中，我们不仅仅只有简单的对象。更有嵌套、多字段、多类型等复杂情况。\n\n从实验结果中可以看出在简单对象排名前5的工具，在复杂对象的拷贝场景下依旧经受住了考验，这5个之间的排名波动可以理解为测试结果的误差性。\n\n继续往下观察，我们可以发现在上一轮实验中，表现比其他好的2组json工具类性能出现了明显的下滑，原本高于jackson吞吐量的fastjson，在本轮测试中屈居后位。\n\n而orika却在复杂对象拷贝中稳定住了他的位置。\n\n排名最后的4个工具依旧如简单对象拷贝排名类似，性能均很差。\n\n 3. cpu频率图\n\n\n\n\n# 结论\n\n通过两组不同类型的对象，我们对12款工具进行了压测实验，最后结果表示beancopier和mapstruct依旧是市场中最顶级的两款工具类，两者均拥有相同于原生get/set的性能，在使用时需要考虑使用缓存，两者均是高频bean拷贝的工具首选。hutool cglibutil提供了开箱即用的基于beancopier的拷贝工具，如果没有特殊需求，又不想自己写工具类代码，也是强力的候选工具。如果hutool提供的工具类满足不了项目，可以选择本文中rpasbeanutils，基于spring的弱引用concurrentreferencehashmapmap，和缓存cglib beancopier或mapstruct构建工具类，站在巨人的肩膀上，开发者也能快速的构建出适配项目且高性能的工具。同时在该场景下，我们应该避免使用其余基于反射、序列化等技术做出的工具，即使他们已经很出名。\n\n\n# 附录\n\n 1. 如果你的拷贝类中get/set含有特殊操作，以上主流的5款高性能的拷贝工具均会无法拷贝对应字段的值，其本质上是由于拷贝本身依赖于干净的get/set方法。此时基于反射的工具，例如springbeanutils能够对这种特殊操作的实体进行拷贝，本质上是因为反射拷贝不需要依赖get/set只需要反射获取字段动态赋值即可，但代价是性能十分低下。建议实体对象中，尽量不修改原始get/set，如有实体类特殊需求，采用和get/set生成方法不重名方法。\n 2. 高性能拷贝的基石是浅拷贝，请确保拷贝后不再对源对象source进行修改，即拷贝时机发生在必要的转换时，如controller层返回给前端vo，数据库层对象do出库给各个接口使用返回dto，因为源对象source的赋值改变会引起目标对象target的值变化，拷贝时本身是传递实体引用，如有特殊深拷贝需要可以了解mapstruct的@deepclone\n 3. beancopier和mapstruct都是顶尖的工具，在源对象source和目标对象target字段类型不同，但字段名相同时。可以采用beancopier的converter定义转换规则，或采用mapstruct的@mapping注解。通常而言mapstruct更为强大，编译期生成get/set让人更加放心，但缺点就是基本的转换也需要写interface，而beancopier不需要这点，仅在特殊转换时需要写converter。\n\n压测核心代码\n\n简单对象\n\npackage com.benym.benchmark.test;\n\nimport cn.hutool.core.bean.beanutil;\nimport cn.hutool.extra.cglib.beancopiercache;\nimport com.alibaba.fastjson.json;\nimport com.benym.benchmark.test.interfaces.mapstructmapper;\nimport com.benym.benchmark.test.model.complex.dbdo;\nimport com.benym.benchmark.test.model.complex.dbvo;\nimport com.benym.benchmark.test.model.simple.databasedo;\nimport com.benym.benchmark.test.model.simple.databasevo;\nimport com.benym.benchmark.test.service.modelservice;\nimport com.benym.benchmark.test.utils.rpasbeanutils;\nimport com.fasterxml.jackson.databind.objectmapper;\nimport ma.glasnost.orika.mapperfacade;\nimport ma.glasnost.orika.mapperfactory;\nimport ma.glasnost.orika.impl.defaultmapperfactory;\nimport net.sf.cglib.beans.beancopier;\nimport org.dozer.dozerbeanmapper;\nimport org.mapstruct.factory.mappers;\nimport org.openjdk.jmh.annotations.*;\nimport org.openjdk.jmh.results.format.resultformattype;\nimport org.openjdk.jmh.runner.runner;\nimport org.openjdk.jmh.runner.runnerexception;\nimport org.openjdk.jmh.runner.options.options;\nimport org.openjdk.jmh.runner.options.optionsbuilder;\nimport org.springframework.beans.beanutils;\n\nimport java.util.concurrent.timeunit;\n\n/**\n * 简单对象拷贝基准测试\n *\n * @author: benym\n */\n@fork(1) // fork 1个进程进行测试\n@benchmarkmode(mode.throughput) // 吞吐量\n@warmup(iterations = 3) // jit预热\n@measurement(iterations = 10, time = 5) // 迭代10次,每次5s\n@outputtimeunit(timeunit.milliseconds) // 结果所使用的时间单位\n@threads(10) // 线程10个\npublic class benchmarktestsimple {\n\n    /**\n     * 作用域为本次jmh测试，线程共享\n     * <p>\n     * 初始化source数据集\n     */\n    @state(scope.benchmark)\n    public static class generatemodel {\n        databasedo databasemodel;\n\n        // 初始化\n        @setup(level.trial)\n        public void prepare() {\n            databasemodel = new modelservice().get();\n        }\n    }\n\n    /**\n     * 初始化orika\n     */\n    @state(scope.benchmark)\n    public static class orikamapper {\n        mapperfactory mapperfactory;\n\n        @setup(level.trial)\n        public void prepare() {\n            mapperfactory = new defaultmapperfactory.builder().build();\n        }\n    }\n\n    /**\n     * 初始化dozer\n     */\n    @state(scope.benchmark)\n    public static class dozermapper {\n        dozerbeanmapper mapper;\n\n        @setup(level.trial)\n        public void prepare() {\n            mapper = new dozerbeanmapper();\n        }\n    }\n\n\n    @state(scope.benchmark)\n    public static class rpasbeanutilsinit {\n        beancopier copier;\n\n        @setup(level.trial)\n        public void prepare() {\n            copier = rpasbeanutils.getbeancopierwithnoconverter(databasedo.class, databasevo.class);\n        }\n    }\n\n    /**\n     * 初始化beancopier\n     */\n    @state(scope.benchmark)\n    public static class beancopierinit {\n        beancopier copier;\n\n        @setup(level.trial)\n        public void prepare() {\n            copier = beancopier.create(databasedo.class, databasevo.class, false);\n        }\n    }\n\n    /**\n     * 初始化mapstruct\n     */\n    @state(scope.benchmark)\n    public static class mapstructinit {\n        mapstructmapper mapstructmapper;\n\n        @setup(level.trial)\n        public void prepare() {\n            mapstructmapper = mappers.getmapper(mapstructmapper.class);\n        }\n    }\n\n    /**\n     * 初始化objectmapper\n     */\n    @state(scope.benchmark)\n    public static class objectmapperinit {\n        objectmapper objectmapper;\n\n        @setup(level.trial)\n        public void prepare() {\n            objectmapper = new objectmapper();\n        }\n    }\n\n    /**\n     * 初始化hutool cglibutil\n     */\n    @state(scope.benchmark)\n    public static class hutoolcglibinit {\n        beancopier copier;\n\n        @setup(level.trial)\n        public void prepare(){\n            copier = beancopiercache.instance.get(databasedo.class, databasevo.class, null);\n        }\n    }\n\n    /**\n     * get/set 基准测试\n     *\n     * @param generatemodel source\n     * @return target\n     * @throws exception\n     */\n    @benchmark\n    public databasevo testgetset(generatemodel generatemodel) throws exception {\n        databasevo databasevo = new databasevo();\n        databasedo databasemodel = generatemodel.databasemodel;\n        databasevo.setage(databasemodel.getage());\n        databasevo.setname(databasemodel.getname());\n        databasevo.settime(databasemodel.gettime());\n        databasevo.setyear(databasemodel.getyear());\n        databasevo.setothertime(databasemodel.getothertime());\n        return databasevo;\n    }\n\n    /**\n     * rpasbeanutils基准测试\n     *\n     * @param generatemodel source\n     * @param init 初始化copier\n     * @return target\n     * @throws exception\n     */\n    @benchmark\n    public databasevo testrpasbeanutils(generatemodel generatemodel, rpasbeanutilsinit init) throws exception {\n        databasevo databasevo = new databasevo();\n        init.copier.copy(generatemodel.databasemodel, databasevo, null);\n        return databasevo;\n    }\n\n    /**\n     * mapstruct基准测试\n     *\n     * @param generatemodel source\n     * @param init          初始化的mapper\n     * @return target\n     * @throws exception\n     */\n    @benchmark\n    public databasevo testmapstruct(generatemodel generatemodel, mapstructinit init) throws exception {\n        databasevo databasevo = init.mapstructmapper.copy(generatemodel.databasemodel);\n        return databasevo;\n    }\n\n    /**\n     * beancopier基准测试\n     *\n     * @param generatemodel source\n     * @param beancopier    初始化的beancopier\n     * @return target\n     * @throws exception\n     */\n    @benchmark\n    public databasevo testbeancopier(generatemodel generatemodel, beancopierinit beancopier) throws exception {\n        beancopier copier = beancopier.copier;\n        databasevo databasevo = new databasevo();\n        copier.copy(generatemodel.databasemodel, databasevo, null);\n        return databasevo;\n    }\n\n    /**\n     * jackson objectmapper基准测试\n     *\n     * @param generatemodel source\n     * @param init          初始化的objectmapper\n     * @return target\n     * @throws exception\n     */\n    @benchmark\n    public databasevo testjackson(generatemodel generatemodel, objectmapperinit init) throws exception {\n        string str = init.objectmapper.writevalueasstring(generatemodel.databasemodel);\n        databasevo databasevo = init.objectmapper.readvalue(str, databasevo.class);\n        return databasevo;\n    }\n\n\n    /**\n     * fastjson基准测试\n     *\n     * @param generatemodel source\n     * @return target\n     * @throws exception\n     */\n    @benchmark\n    public databasevo testfastjson(generatemodel generatemodel) throws exception {\n        string str = json.tojsonstring(generatemodel.databasemodel);\n        return json.parseobject(str, databasevo.class);\n    }\n\n    /**\n     * hutool beanutil基准测试\n     *\n     * @param generatemodel source\n     * @return target\n     * @throws exception\n     */\n    @benchmark\n    public databasevo testhutoolbeanutil(generatemodel generatemodel) throws exception {\n        databasevo databasevo = new databasevo();\n        beanutil.copyproperties(generatemodel.databasemodel, databasevo);\n        return databasevo;\n    }\n\n\n    /**\n     * hutool cglibutil基准测试\n     *\n     * @param generatemodel source\n     * @return target\n     * @throws exception\n     */\n    @benchmark\n    public databasevo testhutoolcglibutil(generatemodel generatemodel, hutoolcglibinit init) throws exception {\n        databasevo databasevo = new databasevo();\n        init.copier.copy(generatemodel.databasemodel, databasevo, null);\n        return databasevo;\n    }\n\n    /**\n     * springbeanutils基准测试\n     *\n     * @param generatemodel source\n     * @return target\n     * @throws exception\n     */\n    @benchmark\n    public databasevo testspringbeanutils(generatemodel generatemodel) throws exception {\n        databasevo databasevo = new databasevo();\n        beanutils.copyproperties(generatemodel.databasemodel, databasevo);\n        return databasevo;\n    }\n\n    /**\n     * apache beanutils基准测试\n     *\n     * @param generatemodel source\n     * @return target\n     * @throws exception\n     */\n    @benchmark\n    public databasevo testapachebeanutils(generatemodel generatemodel) throws exception {\n        databasevo databasevo = new databasevo();\n        org.apache.commons.beanutils.beanutils.copyproperties(databasevo, generatemodel.databasemodel);\n        return databasevo;\n    }\n\n    /**\n     * orika基准测试\n     *\n     * @param generatemodel source\n     * @param orikamapper   初始化orika\n     * @return target\n     * @throws exception\n     */\n    @benchmark\n    public databasevo testorikamapper(generatemodel generatemodel, orikamapper orikamapper) throws exception {\n        mapperfacade mapperfacade = orikamapper.mapperfactory.getmapperfacade();\n        databasevo databasevo = mapperfacade.map(generatemodel.databasemodel, databasevo.class);\n        return databasevo;\n    }\n\n    /**\n     * dozer基准测试\n     *\n     * @param generatemodel source\n     * @param dozermapper   初始化dozer\n     * @return target\n     * @throws exception\n     */\n    @benchmark\n    public databasevo testdozermapping(generatemodel generatemodel, dozermapper dozermapper) throws exception {\n        databasevo databasevo = dozermapper.mapper.map(generatemodel.databasemodel, databasevo.class);\n        return databasevo;\n    }\n\n    public static void main(string[] args) throws runnerexception {\n        options options = new optionsbuilder()\n                .include(benchmarktestsimple.class.getsimplename())\n                .result("result-simple.json")\n                .resultformat(resultformattype.json)\n                .build();\n        new runner(options).run();\n    }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n\n\n复杂对象\n\npackage com.benym.benchmark.test;\n\nimport cn.hutool.core.bean.beanutil;\nimport cn.hutool.extra.cglib.beancopiercache;\nimport com.alibaba.fastjson.json;\nimport com.benym.benchmark.test.interfaces.mapstructmappercomplex;\nimport com.benym.benchmark.test.model.complex.dbdo;\nimport com.benym.benchmark.test.model.complex.dbvo;\nimport com.benym.benchmark.test.model.simple.databasevo;\nimport com.benym.benchmark.test.service.modelservice;\nimport com.benym.benchmark.test.utils.rpasbeanutils;\nimport com.fasterxml.jackson.databind.objectmapper;\nimport ma.glasnost.orika.mapperfacade;\nimport ma.glasnost.orika.mapperfactory;\nimport ma.glasnost.orika.impl.defaultmapperfactory;\nimport net.sf.cglib.beans.beancopier;\nimport org.dozer.dozerbeanmapper;\nimport org.mapstruct.factory.mappers;\nimport org.openjdk.jmh.annotations.*;\nimport org.openjdk.jmh.results.format.resultformattype;\nimport org.openjdk.jmh.runner.runner;\nimport org.openjdk.jmh.runner.runnerexception;\nimport org.openjdk.jmh.runner.options.options;\nimport org.openjdk.jmh.runner.options.optionsbuilder;\nimport org.springframework.beans.beanutils;\n\nimport java.util.concurrent.timeunit;\n\n/**\n * 复杂对象拷贝基准测试\n *\n * @author: benym\n */\n@fork(1) // fork 1个进程进行测试\n@benchmarkmode(mode.throughput) // 吞吐量\n@warmup(iterations = 3) // jit预热\n@measurement(iterations = 10, time = 5) // 迭代10次,每次5s\n@outputtimeunit(timeunit.milliseconds) // 结果所使用的时间单位\n@threads(10) // 线程10个\npublic class benchmarktestcomplex {\n    /**\n     * 作用域为本次jmh测试，线程共享\n     * <p>\n     * 初始化source数据集\n     */\n    @state(scope.benchmark)\n    public static class generatemodel {\n        dbdo dbdo;\n\n        // 初始化\n        @setup(level.trial)\n        public void prepare() {\n            dbdo = new modelservice().getcomplex();\n        }\n    }\n\n    /**\n     * 初始化orika\n     */\n    @state(scope.benchmark)\n    public static class orikamapper {\n        mapperfactory mapperfactory;\n\n        @setup(level.trial)\n        public void prepare() {\n            mapperfactory = new defaultmapperfactory.builder().build();\n        }\n    }\n\n    /**\n     * 初始化dozer\n     */\n    @state(scope.benchmark)\n    public static class dozermapper {\n        dozerbeanmapper mapper;\n\n        @setup(level.trial)\n        public void prepare() {\n            mapper = new dozerbeanmapper();\n        }\n    }\n\n    @state(scope.benchmark)\n    public static class rpasbeanutilsinit {\n        beancopier copier;\n\n        @setup(level.trial)\n        public void prepare() {\n            copier = rpasbeanutils.getbeancopierwithnoconverter(dbdo.class, dbvo.class);\n        }\n    }\n\n    /**\n     * 初始化beancopier\n     */\n    @state(scope.benchmark)\n    public static class beancopierinit {\n        beancopier copier;\n\n        @setup(level.trial)\n        public void prepare() {\n            copier = beancopier.create(dbdo.class, dbvo.class, false);\n        }\n    }\n\n    /**\n     * 初始化mapstruct\n     */\n    @state(scope.benchmark)\n    public static class mapstructinit {\n        mapstructmappercomplex mapstructmapper;\n\n        @setup(level.trial)\n        public void prepare() {\n            mapstructmapper = mappers.getmapper(mapstructmappercomplex.class);\n        }\n    }\n\n    /**\n     * 初始化objectmapper\n     */\n    @state(scope.benchmark)\n    public static class objectmapperinit {\n        objectmapper objectmapper;\n\n        @setup(level.trial)\n        public void prepare() {\n            objectmapper = new objectmapper();\n        }\n    }\n\n    /**\n     * 初始化hutool cglibutil\n     */\n    @state(scope.benchmark)\n    public static class hutoolcglibinit {\n        beancopier copier;\n\n        @setup(level.trial)\n        public void prepare(){\n            copier = beancopiercache.instance.get(dbdo.class, dbvo.class, null);\n        }\n    }\n\n    /**\n     * get/set 基准测试\n     *\n     * @param generatemodel source\n     * @return target\n     * @throws exception\n     */\n    @benchmark\n    public dbvo testgetset(generatemodel generatemodel) throws exception {\n        dbvo dbvo = new dbvo();\n        dbdo dbdo = generatemodel.dbdo;\n        dbvo.setage(dbdo.getage());\n        dbvo.setname(dbdo.getname());\n        dbvo.settime(dbdo.gettime());\n        dbvo.setyear(dbdo.getyear());\n        dbvo.setmockmodelone(dbdo.getmockmodelone());\n        dbvo.setmockmodeltwo(dbdo.getmockmodeltwo());\n        dbvo.setothertime(dbdo.getothertime());\n        dbvo.setfield00(dbdo.getfield00());\n        dbvo.setfield01(dbdo.getfield01());\n        dbvo.setfield02(dbdo.getfield02());\n        dbvo.setfield03(dbdo.getfield03());\n        dbvo.setfield04(dbdo.getfield04());\n        dbvo.setfield05(dbdo.getfield05());\n        dbvo.setfield06(dbdo.getfield06());\n        dbvo.setfield07(dbdo.getfield07());\n        dbvo.setfield08(dbdo.getfield08());\n        dbvo.setfield09(dbdo.getfield09());\n        dbvo.setfield10(dbdo.getfield10());\n        dbvo.setfield11(dbdo.getfield11());\n        dbvo.setfield12(dbdo.getfield12());\n        dbvo.setfield13(dbdo.getfield13());\n        dbvo.setfield14(dbdo.getfield14());\n        dbvo.setfield15(dbdo.getfield15());\n        dbvo.setfield16(dbdo.getfield16());\n        dbvo.setfield17(dbdo.getfield17());\n        dbvo.setfield18(dbdo.getfield18());\n        dbvo.setfield19(dbdo.getfield19());\n        dbvo.setfield20(dbdo.getfield20());\n        dbvo.setfield21(dbdo.getfield21());\n        dbvo.setfield22(dbdo.getfield22());\n        dbvo.setfield23(dbdo.getfield23());\n        dbvo.setfield24(dbdo.getfield24());\n        dbvo.setfield25(dbdo.getfield25());\n        dbvo.setfield26(dbdo.getfield26());\n        dbvo.setfield27(dbdo.getfield27());\n        dbvo.setfield28(dbdo.getfield28());\n        dbvo.setfield29(dbdo.getfield29());\n        dbvo.setfield30(dbdo.getfield30());\n        dbvo.setfield31(dbdo.getfield31());\n        dbvo.setfield32(dbdo.getfield32());\n        dbvo.setfield33(dbdo.getfield33());\n        dbvo.setfield34(dbdo.getfield34());\n        dbvo.setfield35(dbdo.getfield35());\n        dbvo.setfield36(dbdo.getfield36());\n        dbvo.setfield37(dbdo.getfield37());\n        dbvo.setfield38(dbdo.getfield38());\n        dbvo.setfield39(dbdo.getfield39());\n        dbvo.setfield40(dbdo.getfield40());\n        dbvo.setfield41(dbdo.getfield41());\n        dbvo.setfield42(dbdo.getfield42());\n        dbvo.setfield43(dbdo.getfield43());\n        dbvo.setfield44(dbdo.getfield44());\n        dbvo.setfield45(dbdo.getfield45());\n        dbvo.setfield46(dbdo.getfield46());\n        dbvo.setfield47(dbdo.getfield47());\n        dbvo.setfield48(dbdo.getfield48());\n        dbvo.setfield49(dbdo.getfield49());\n        dbvo.setfield50(dbdo.getfield50());\n        dbvo.setfield51(dbdo.getfield51());\n        dbvo.setfield52(dbdo.getfield52());\n        dbvo.setfield53(dbdo.getfield53());\n        dbvo.setfield54(dbdo.getfield54());\n        dbvo.setfield55(dbdo.getfield55());\n        dbvo.setfield56(dbdo.getfield56());\n        dbvo.setfield57(dbdo.getfield57());\n        dbvo.setfield58(dbdo.getfield58());\n        dbvo.setfield59(dbdo.getfield59());\n        dbvo.setfield60(dbdo.getfield60());\n        dbvo.setfield61(dbdo.getfield61());\n        dbvo.setfield62(dbdo.getfield62());\n        dbvo.setfield63(dbdo.getfield63());\n        dbvo.setfield64(dbdo.getfield64());\n        dbvo.setfield65(dbdo.getfield65());\n        dbvo.setfield66(dbdo.getfield66());\n        dbvo.setfield67(dbdo.getfield67());\n        dbvo.setfield68(dbdo.getfield68());\n        dbvo.setfield69(dbdo.getfield69());\n        dbvo.setfield70(dbdo.getfield70());\n        dbvo.setfield71(dbdo.getfield71());\n        dbvo.setfield72(dbdo.getfield72());\n        dbvo.setfield73(dbdo.getfield73());\n        dbvo.setfield74(dbdo.getfield74());\n        dbvo.setfield75(dbdo.getfield75());\n        dbvo.setfield76(dbdo.getfield76());\n        dbvo.setfield77(dbdo.getfield77());\n        dbvo.setfield78(dbdo.getfield78());\n        dbvo.setfield79(dbdo.getfield79());\n        dbvo.setfield80(dbdo.getfield80());\n        dbvo.setfield81(dbdo.getfield81());\n        dbvo.setfield82(dbdo.getfield82());\n        dbvo.setfield83(dbdo.getfield83());\n        dbvo.setfield84(dbdo.getfield84());\n        dbvo.setfield85(dbdo.getfield85());\n        dbvo.setfield86(dbdo.getfield86());\n        dbvo.setfield87(dbdo.getfield87());\n        dbvo.setfield88(dbdo.getfield88());\n        dbvo.setfield89(dbdo.getfield89());\n        dbvo.setfield90(dbdo.getfield90());\n        dbvo.setfield91(dbdo.getfield91());\n        dbvo.setfield92(dbdo.getfield92());\n        dbvo.setfield93(dbdo.getfield93());\n        dbvo.setfield94(dbdo.getfield94());\n        dbvo.setfield95(dbdo.getfield95());\n        dbvo.setfield96(dbdo.getfield96());\n        dbvo.setfield97(dbdo.getfield97());\n        dbvo.setfield98(dbdo.getfield98());\n        dbvo.setfield99(dbdo.getfield99());\n        dbvo.setfield100(dbdo.getfield100());\n        return dbvo;\n    }\n\n    /**\n     * rpasbeanutils基准测试\n     *\n     * @param generatemodel source\n     * @param init 初始化copier\n     * @return target\n     * @throws exception\n     */\n    @benchmark\n    public dbvo testrpasbeanutils(generatemodel generatemodel, rpasbeanutilsinit init) throws exception {\n        dbvo dbvo = new dbvo();\n        init.copier.copy(generatemodel.dbdo, dbvo, null);\n        return dbvo;\n    }\n\n    /**\n     * mapstruct基准测试\n     *\n     * @param generatemodel source\n     * @param init          初始化的mapper\n     * @return target\n     * @throws exception\n     */\n    @benchmark\n    public dbvo testmapstruct(generatemodel generatemodel, mapstructinit init) throws exception {\n        dbvo dbvo = init.mapstructmapper.copy(generatemodel.dbdo);\n        return dbvo;\n    }\n\n    /**\n     * beancopier基准测试\n     *\n     * @param generatemodel source\n     * @param beancopier    初始化的beancopier\n     * @return target\n     * @throws exception\n     */\n    @benchmark\n    public dbvo testbeancopier(generatemodel generatemodel, beancopierinit beancopier) throws exception {\n        beancopier copier = beancopier.copier;\n        dbvo dbvo = new dbvo();\n        copier.copy(generatemodel.dbdo, dbvo, null);\n        return dbvo;\n    }\n\n    /**\n     * jackson objectmapper基准测试\n     *\n     * @param generatemodel source\n     * @param init          初始化的objectmapper\n     * @return target\n     * @throws exception\n     */\n    @benchmark\n    public dbvo testjackson(generatemodel generatemodel, objectmapperinit init) throws exception {\n        string str = init.objectmapper.writevalueasstring(generatemodel.dbdo);\n        dbvo dbvo = init.objectmapper.readvalue(str, dbvo.class);\n        return dbvo;\n    }\n\n\n    /**\n     * fastjson基准测试\n     *\n     * @param generatemodel source\n     * @return target\n     * @throws exception\n     */\n    @benchmark\n    public dbvo testfastjson(generatemodel generatemodel) throws exception {\n        string str = json.tojsonstring(generatemodel.dbdo);\n        return json.parseobject(str, dbvo.class);\n    }\n\n    /**\n     * hutool beanutil基准测试\n     *\n     * @param generatemodel source\n     * @return target\n     * @throws exception\n     */\n    @benchmark\n    public dbvo testhutoolbeanutil(generatemodel generatemodel) throws exception {\n        dbvo dbvo = new dbvo();\n        beanutil.copyproperties(generatemodel.dbdo, dbvo);\n        return dbvo;\n    }\n\n    /**\n     * hutool cglibutil基准测试\n     *\n     * @param generatemodel source\n     * @return target\n     * @throws exception\n     */\n    @benchmark\n    public dbvo testhutoolcglibutil(generatemodel generatemodel, hutoolcglibinit init) throws exception {\n        dbvo dbvo = new dbvo();\n        init.copier.copy(generatemodel.dbdo, dbvo, null);\n        return dbvo;\n    }\n\n    /**\n     * springbeanutils基准测试\n     *\n     * @param generatemodel source\n     * @return target\n     * @throws exception\n     */\n    @benchmark\n    public dbvo testspringbeanutils(generatemodel generatemodel) throws exception {\n        dbvo dbvo = new dbvo();\n        beanutils.copyproperties(generatemodel.dbdo, dbvo);\n        return dbvo;\n    }\n\n    /**\n     * apache beanutils基准测试\n     *\n     * @param generatemodel source\n     * @return target\n     * @throws exception\n     */\n    @benchmark\n    public dbvo testapachebeanutils(generatemodel generatemodel) throws exception {\n        dbvo dbvo = new dbvo();\n        org.apache.commons.beanutils.beanutils.copyproperties(dbvo, generatemodel.dbdo);\n        return dbvo;\n    }\n\n    /**\n     * orika基准测试\n     *\n     * @param generatemodel source\n     * @param orikamapper   初始化orika\n     * @return target\n     * @throws exception\n     */\n    @benchmark\n    public dbvo testorikamapper(generatemodel generatemodel, orikamapper orikamapper) throws exception {\n        mapperfacade mapperfacade = orikamapper.mapperfactory.getmapperfacade();\n        dbvo dbvo = mapperfacade.map(generatemodel.dbdo, dbvo.class);\n        return dbvo;\n    }\n\n    /**\n     * dozer基准测试\n     *\n     * @param generatemodel source\n     * @param dozermapper   初始化dozer\n     * @return target\n     * @throws exception\n     */\n    @benchmark\n    public dbvo testdozermapping(generatemodel generatemodel, dozermapper dozermapper) throws exception {\n        dbvo dbvo = dozermapper.mapper.map(generatemodel.dbdo, dbvo.class);\n        return dbvo;\n    }\n\n    public static void main(string[] args) throws runnerexception {\n        options options = new optionsbuilder()\n                .include(benchmarktestcomplex.class.getsimplename())\n                .result("result-complex.json")\n                .resultformat(resultformattype.json)\n                .build();\n        new runner(options).run();\n    }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n394\n395\n396\n397\n398\n399\n400\n401\n402\n403\n404\n405\n406\n407\n408\n409\n410\n411\n412\n413\n414\n415\n416\n417\n418\n419\n420\n421\n422\n423\n424\n425\n426\n427\n428\n429\n430\n431\n432\n433\n434\n435\n436\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n394\n395\n396\n397\n398\n399\n400\n401\n402\n403\n404\n405\n406\n407\n408\n409\n410\n411\n412\n413\n414\n415\n416\n417\n418\n419\n420\n421\n422\n423\n424\n425\n426\n427\n428\n429\n430\n431\n432\n433\n434\n435\n436\n',charsets:{cjk:!0},lastUpdated:"2023/01/31, 18:41:29",lastUpdatedTimestamp:1675161689e3},{title:"Bean工具类-RpasBeanUtils",frontmatter:{title:"Bean工具类-RpasBeanUtils",date:"2022-11-25T14:58:41.000Z",categories:["开源项目","Rpamis"],tags:["工具类","BeanUtil","RpasBeanUtils"],author:{name:"benym",link:"https://github.com/benym"},permalink:"/pages/cedee6/"},regularPath:"/08.%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/01.Rpamis/01.Utils/02.Bean%E5%B7%A5%E5%85%B7%E7%B1%BB-RpasBeanUtils.html",relativePath:"08.开源项目/01.Rpamis/01.Utils/02.Bean工具类-RpasBeanUtils.md",key:"v-624330b0",path:"/pages/cedee6/",headers:[{level:2,title:"背景",slug:"背景",normalizedTitle:"背景",charIndex:2},{level:2,title:"为什么需要弱引用？",slug:"为什么需要弱引用",normalizedTitle:"为什么需要弱引用？",charIndex:156},{level:2,title:"基本使用",slug:"基本使用",normalizedTitle:"基本使用",charIndex:466}],headersStr:"背景 为什么需要弱引用？ 基本使用",content:"# 背景\n\n当项目中有需要使用拷贝类时，开发者可能会需要将目前的拷贝工具进行二次封装用于适配项目，减少动态创建拷贝工具的性能损耗，这里给出一个简单的封装Bean工具类。\n\n采用并发安全、且弱引用的ConcurrentReferenceHashMap+BeanCopier的形式快速开发出自己的拷贝工具。\n\n\n# 为什么需要弱引用？\n\n当考虑为BeanCopier做实例缓存时，通常会用到ConcurrentHashMap等并发安全的Map工具，在第一次进行拷贝时会将source和target创建的拷贝实例放入map中。\n\n在系统长期运行的情况下，内存是非常宝贵的资源，拷贝场景涉及多、使用高频，如果只是强引用的Map，则GC无法进行回收，有些低频使用的拷贝实例将得不到释放。在Java中有WeakHashMap提供弱引用的帮助，但却没有弱引用+并发安全的Map。\n\nSpring基于这一缺口开发出了ConcurrentReferenceHashMap，提供了GC友好、且并发安全的Map工具，这也是本工具类选择它的原因。\n\n\n# 基本使用\n\n * RpasBeanUtils.copy(Object source, Object target)\n   \n   拷贝source对象属性到target中，名字和类型不严格匹配时将不拷贝，无返回值\n\nEntitySource entitySource = init();\nEntityTarget entityTarget = new EntityTarget();\nRpasBeanUtils.copy(entitySource, entityTarget);\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n * RpasBeanUtils.copy(Object source, Class<T> clazz)\n   \n   拷贝source对象属性到target class中，返回target\n\nEntitySource entitySource = init();\nEntityTarget entityTarget = RpasBeanUtils.copy(entitySource, EntityTarget.class);\n\n\n1\n2\n\n1\n2\n\n * RpasBeanUtils.copy(Object source, Object target, Converter converter)\n\n拷贝source对象属性到target中，使用自定义converter，拷贝规则严格符合converter规则，无返回值\n\nEntitySource entitySource = init();\nEntityTargetDiff entityTargetDiff = new EntityTargetDiff();\nRpasBeanUtils.copy(entitySource, entityTargetDiff, new DiffConverter());\n\n\n1\n2\n3\n\n1\n2\n3\n\n * RpasBeanUtils.copy(Object source, Class<T> clazz, Converter converter)\n\n拷贝source对象属性到target class中，使用自定义converter，拷贝规则严格符合converter规则，返回target\n\nEntitySource entitySource = init();\nEntityTargetDiff entityTargetDiff = RpasBeanUtils.copy(entitySource, EntityTargetDiff.class, new DiffConverter());\n\n\n1\n2\n\n1\n2\n\n * RpasBeanUtils.copyToList(List<?> sources, Class<T> clazz)\n\n拷贝源list对象到新class list，返回List<Target>\n\nList<EntitySource> list = initList();\nList<EntityTarget> entityTargets = RpasBeanUtils.copyToList(list, EntityTarget.class);\n\n\n1\n2\n\n1\n2\n\n * RpasBeanUtils.copyToList(List<?> sources, Class<T> clazz, Converter converter)\n\n拷贝源list对象到新class list，使用自定义converter，返回List<Target>\n\nList<EntitySource> list = initList();\nList<EntityTargetDiff> entityTargetDiffs = RpasBeanUtils.copyToList(list, EntityTargetDiff.class, new DiffConverter());\n\n\n1\n2\n\n1\n2\n\n * RpasBeanUtils.toPageResponse(Page<T> page)\n\n将Mybatis-plus Page对象转化为PageResponse，返回PageResponse<Source>\n\nPage<EntitySource> page = initPage();\nPageResponse<EntitySource> entitySourcePageResponse = RpasBeanUtils.toPageResponse(page);\n\n\n1\n2\n\n1\n2\n\n * RpasBeanUtils.toPageResponse(PageResponse<S> sourcePageResponse, Class<T> clazz)\n\n将PageResponse对象，转化内部class，返回PageResponse<Target>\n\nPage<EntitySource> page = initPage();\nPageResponse<EntitySource> entitySourcePageResponse = RpasBeanUtils.toPageResponse(page);\nPageResponse<EntityTarget> entityTargetPageResponse = RpasBeanUtils.toPageResponse(entitySourcePageResponse, EntityTarget.class);\n\n\n1\n2\n3\n\n1\n2\n3\n\n * RpasBeanUtils.toPageResponse(Page<S> page, Function<S, T> functionConverter)\n\n将Mybatis-plus Page对象转化为PageResponse, Function converter形式，返回PageResponse<Target>\n\nPage<EntitySource> page = initPage();\nPageResponse<EntityTarget> entityTargetPageResponse = RpasBeanUtils.toPageResponse(page, source -> RpasBeanUtils.copy(source, EntityTarget.class));\n\n\n1\n2\n\n1\n2\n\n * RpasBeanUtils.toPageResponse(PageResponse<S> sourcePageResponse, Function<S, T> functionConverter)\n\n将PageResponse对象 转换不同内部class, Function converter形式，返回PageResponse<Target>\n\nPage<EntitySource> page = initPage();\nPageResponse<EntitySource> entitySourcePageResponse = RpasBeanUtils.toPageResponse(page);\nPageResponse<EntityTargetDiff> pageResponse = RpasBeanUtils.toPageResponse(entitySourcePageResponse,\n        source -> RpasBeanUtils.copy(source, EntityTargetDiff.class, new DiffConverter()));\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n",normalizedContent:"# 背景\n\n当项目中有需要使用拷贝类时，开发者可能会需要将目前的拷贝工具进行二次封装用于适配项目，减少动态创建拷贝工具的性能损耗，这里给出一个简单的封装bean工具类。\n\n采用并发安全、且弱引用的concurrentreferencehashmap+beancopier的形式快速开发出自己的拷贝工具。\n\n\n# 为什么需要弱引用？\n\n当考虑为beancopier做实例缓存时，通常会用到concurrenthashmap等并发安全的map工具，在第一次进行拷贝时会将source和target创建的拷贝实例放入map中。\n\n在系统长期运行的情况下，内存是非常宝贵的资源，拷贝场景涉及多、使用高频，如果只是强引用的map，则gc无法进行回收，有些低频使用的拷贝实例将得不到释放。在java中有weakhashmap提供弱引用的帮助，但却没有弱引用+并发安全的map。\n\nspring基于这一缺口开发出了concurrentreferencehashmap，提供了gc友好、且并发安全的map工具，这也是本工具类选择它的原因。\n\n\n# 基本使用\n\n * rpasbeanutils.copy(object source, object target)\n   \n   拷贝source对象属性到target中，名字和类型不严格匹配时将不拷贝，无返回值\n\nentitysource entitysource = init();\nentitytarget entitytarget = new entitytarget();\nrpasbeanutils.copy(entitysource, entitytarget);\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n * rpasbeanutils.copy(object source, class<t> clazz)\n   \n   拷贝source对象属性到target class中，返回target\n\nentitysource entitysource = init();\nentitytarget entitytarget = rpasbeanutils.copy(entitysource, entitytarget.class);\n\n\n1\n2\n\n1\n2\n\n * rpasbeanutils.copy(object source, object target, converter converter)\n\n拷贝source对象属性到target中，使用自定义converter，拷贝规则严格符合converter规则，无返回值\n\nentitysource entitysource = init();\nentitytargetdiff entitytargetdiff = new entitytargetdiff();\nrpasbeanutils.copy(entitysource, entitytargetdiff, new diffconverter());\n\n\n1\n2\n3\n\n1\n2\n3\n\n * rpasbeanutils.copy(object source, class<t> clazz, converter converter)\n\n拷贝source对象属性到target class中，使用自定义converter，拷贝规则严格符合converter规则，返回target\n\nentitysource entitysource = init();\nentitytargetdiff entitytargetdiff = rpasbeanutils.copy(entitysource, entitytargetdiff.class, new diffconverter());\n\n\n1\n2\n\n1\n2\n\n * rpasbeanutils.copytolist(list<?> sources, class<t> clazz)\n\n拷贝源list对象到新class list，返回list<target>\n\nlist<entitysource> list = initlist();\nlist<entitytarget> entitytargets = rpasbeanutils.copytolist(list, entitytarget.class);\n\n\n1\n2\n\n1\n2\n\n * rpasbeanutils.copytolist(list<?> sources, class<t> clazz, converter converter)\n\n拷贝源list对象到新class list，使用自定义converter，返回list<target>\n\nlist<entitysource> list = initlist();\nlist<entitytargetdiff> entitytargetdiffs = rpasbeanutils.copytolist(list, entitytargetdiff.class, new diffconverter());\n\n\n1\n2\n\n1\n2\n\n * rpasbeanutils.topageresponse(page<t> page)\n\n将mybatis-plus page对象转化为pageresponse，返回pageresponse<source>\n\npage<entitysource> page = initpage();\npageresponse<entitysource> entitysourcepageresponse = rpasbeanutils.topageresponse(page);\n\n\n1\n2\n\n1\n2\n\n * rpasbeanutils.topageresponse(pageresponse<s> sourcepageresponse, class<t> clazz)\n\n将pageresponse对象，转化内部class，返回pageresponse<target>\n\npage<entitysource> page = initpage();\npageresponse<entitysource> entitysourcepageresponse = rpasbeanutils.topageresponse(page);\npageresponse<entitytarget> entitytargetpageresponse = rpasbeanutils.topageresponse(entitysourcepageresponse, entitytarget.class);\n\n\n1\n2\n3\n\n1\n2\n3\n\n * rpasbeanutils.topageresponse(page<s> page, function<s, t> functionconverter)\n\n将mybatis-plus page对象转化为pageresponse, function converter形式，返回pageresponse<target>\n\npage<entitysource> page = initpage();\npageresponse<entitytarget> entitytargetpageresponse = rpasbeanutils.topageresponse(page, source -> rpasbeanutils.copy(source, entitytarget.class));\n\n\n1\n2\n\n1\n2\n\n * rpasbeanutils.topageresponse(pageresponse<s> sourcepageresponse, function<s, t> functionconverter)\n\n将pageresponse对象 转换不同内部class, function converter形式，返回pageresponse<target>\n\npage<entitysource> page = initpage();\npageresponse<entitysource> entitysourcepageresponse = rpasbeanutils.topageresponse(page);\npageresponse<entitytargetdiff> pageresponse = rpasbeanutils.topageresponse(entitysourcepageresponse,\n        source -> rpasbeanutils.copy(source, entitytargetdiff.class, new diffconverter()));\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n",charsets:{cjk:!0},lastUpdated:"2023/01/31, 18:41:29",lastUpdatedTimestamp:1675161689e3},{title:"MethodHandle结合LambdaMetafactory-使用方法及性能测试",frontmatter:{title:"MethodHandle结合LambdaMetafactory-使用方法及性能测试",date:"2022-12-27T14:23:30.000Z",categories:["开源项目","Rpamis"],tags:["MethodHandles","LambdaMetafactory","压测","反射"],author:{name:"benym",link:"https://github.com/benym"},permalink:"/pages/b127c7/"},regularPath:"/08.%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/01.Rpamis/02.Exception/01.MethodHandle%E7%BB%93%E5%90%88LambdaMetafactory-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%8F%8A%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95.html",relativePath:"08.开源项目/01.Rpamis/02.Exception/01.MethodHandle结合LambdaMetafactory-使用方法及性能测试.md",key:"v-3c9f3ea4",path:"/pages/b127c7/",headers:[{level:2,title:"背景",slug:"背景",normalizedTitle:"背景",charIndex:2},{level:2,title:"MethodHandle是什么",slug:"methodhandle是什么",normalizedTitle:"methodhandle是什么",charIndex:306},{level:2,title:"MethodHandle性能测试",slug:"methodhandle性能测试",normalizedTitle:"methodhandle性能测试",charIndex:1679},{level:3,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:1700},{level:3,title:"场景1-类外访问private变量并动态赋值",slug:"场景1-类外访问private变量并动态赋值",normalizedTitle:"场景1-类外访问private变量并动态赋值",charIndex:2505},{level:4,title:"小结",slug:"小结",normalizedTitle:"小结",charIndex:8202},{level:4,title:"可优化点",slug:"可优化点",normalizedTitle:"可优化点",charIndex:8405},{level:3,title:"场景2-动态根据class带入参创建实例",slug:"场景2-动态根据class带入参创建实例",normalizedTitle:"场景2-动态根据class带入参创建实例",charIndex:8651},{level:4,title:"小结",slug:"小结-2",normalizedTitle:"小结",charIndex:8202},{level:3,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:2137}],headersStr:"背景 MethodHandle是什么 MethodHandle性能测试 前言 场景1-类外访问private变量并动态赋值 小结 可优化点 场景2-动态根据class带入参创建实例 小结 参考文章",content:'# 背景\n\n在进行实例的动态推断和构建时，我们会经常使用到反射这一技巧，然而在某些场景中反射的效率显得有些力不从心。从JDK7开始，MethodHandle被推出，用于解决反射的效率问题。在JDK8，MethodHandle又与Lambda进行深度结合，成为Lambda的最底层调用方式。在JDK9，MethodHandle又被进一步增强。 在开源项目中，Mybatis Mapper的动态代理实现则运用了MethodHandle。\n\n本文代码地址https://github.com/benym/benchmark-test，其中的MhBenchMark和MhExceptionBenchMark目录\n\n\n# MethodHandle是什么\n\nMethodHandle直译为方法句柄，调用时JVM采用invokedynamic指令[1]，直接调用native方法，引用JDK中的说明\n\n提示\n\nA method handle is a typed, directly executable reference to an underlying method, constructor, field, or similar low-level operation, with optional transformations of arguments or return values.\n\n方法句柄是一个有类型的，可以直接执行的指向底层方法、构造器、field等的引用，可以简单理解为函数指针，它是一种更加底层的查找、调整和调用方法的机制。\n\n一个简单的使用方法为\n\nstep1: 创建mh lookup、根据访问权限任选其一即可\n\n//仅访问public方法\nMethodHandles.Lookup publicLookup = MethodHandles.publicLookup();\n//访问public、private、protected方法\nMethodHandles.Lookup allLookup = MethodHandles.lookup();\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\nstep2: 创建MethodType，它用来描述被访问的方法的参数类型、返回值类型，JVM强制要求声明的Method Type与实际调用方法的参数类型必须匹配\n\n// 即入参为String、返回为void类型\nMethodType methodType = MethodType.methodType(void.class, String.class);\n\n\n1\n2\n\n1\n2\n\n\nstep3: 通过mh lookup和MethodType获取对应方法MethodHandle并执行，下例为通过Test.class字节码，找到类Test中以String为入参，void为返回值的构造方法、并进行invoke赋值，返回赋值后的Test实体类\n\nMethodHandle methodHandle = publicLookup.findConstructor(Test.class, methodType);\nObject invoke = methodHandle.invoke("赋值Test消息");\n\n\n1\n2\n\n1\n2\n\n\n其中step2为可选，根据step3使用方法的不同入参不同，step3还可以为：通过MethodHandle访问普通方法、访问静态方法、访问构造函数、访问私有方法、访问公有成员等。 最终执行，按照对参数数目、参数类型的要求限制不同，分为三类invokeWithArguments(),invoke(),invokeExact()\n\n * invokeWithArguments要求接收变长参数，允许参数拆装箱类型转换\n * invoke要求接收固定的参数列表，允许参拆装箱，类型转换\n * invokeExact要求最严格，参数类型不匹配会报错 这里不再对MethodHandle各个用例的使用进行展开。\n\n\n# MethodHandle性能测试\n\n\n# 前言\n\n参考StackOverflow[2]和OptaPlanner引擎论坛[3]对MethodHandle的测试结果，大多数情况下，mh的执行效率接近原生，但随着JDK对反射的优化，反射的效率也没有想象中的特别慢。\n\n在上述引文的第2篇，作者做了非常全面的实验，包括Traveling Salesman Problem(旅行商问题、反应在调用链路耗时)、直接调用、非静态化调用、静态化调用、Java编译器生成、LambdaMetafactory结合、启动消耗等，值得一读。\n\n提示\n\nOptaPlanner是一个开源的轻量级、可嵌入的约束满足引擎，可求解规划问题，100%由Java编写，可以在任何JVM上运行，也可以在Maven中央存储库中使用、支持多种平台下载。在底层，OptaPlanner 将复杂的人工智能优化算法（例如禁忌搜索、模拟退火、延迟接受和其他元启发式算法）与非常有效的分数计算和其他最先进的 NP-complete 或 NP-约束求解技术相结合。\n\n可参考文章[4][5], 官网为https://www.optaplanner.org/\n\n引文的结论中：非静态化的mh甚至比反射效率更低，这迫使开发者采用其他方法增强mh，想要做到具有通用性、且高效的Methodhandle需要结合LambdaMetafactory；如果不会使用LambdaMetafactory、在字段不多的情况下选择static化的mh同样是选择，而采用Java编译器去动态生成代码的方式，虽然效率上达到原生，但写的很不方便。\n\n在本文中，MethodHandle主要解决如下2个问题\n\n 1. 类外访问private变量并动态赋值\n 2. 动态根据class带入参创建实例\n\n虽然反射实现起来很简单，但由于这两种场景在工具类中使用高频，所以出于性能考量采用了MethodHandle，同时做出性能测试。\n\n\n# 场景1-类外访问private变量并动态赋值\n\n项目中存在某实体，出于某些特殊原因，没有向外部提供对应字段的set方法，赋值需要通过构造特定对象进行实例新建。在转换时有一定的不便捷性。\n\n示例代码如下，这里不展示通过特定对象创建实例的构造方法。\n\npublic class EntityWithNoSet {\n    private int testField;\n\n    public EntityWithNoSet() {\n    }\n\n    public int getTestField() {\n        return testField;\n    }\n\n    public EntityWithNoSet(int testField) {\n        this.testField = testField;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n当不采用构造特定对象的方式进行示例创建，又需要对私有变量赋值时，可以采用反射或MethodHandle实现\n\n一个简单的压测代码为，采用平均时间作为性能衡量指标\n\n@Fork(1) // Fork 1个进程进行测试\n@BenchmarkMode(Mode.AverageTime) // 平均时间\n@Warmup(iterations = 3) // JIT预热\n@Measurement(iterations = 10, time = 5) // 迭代10次,每次5s\n@OutputTimeUnit(TimeUnit.NANOSECONDS) // 结果所使用的时间单位\n@Threads(10) // 线程10个\npublic class MHBenchmark {\n\n    private static final MethodHandle staticMethod = MethodAccessor.getCache(EntityWithNoSet.class + "testField");\n\n    private static final Field field = ReflectInit.init(EntityWithNoSet.class, "testField");\n\n    /**\n     * 作用域为本次JMH测试，线程共享\n     * <p>\n     * 初始化source数据集\n     */\n    @State(Scope.Benchmark)\n    public static class GenerateModel {\n        EntityWithNoSet source;\n\n        // 初始化\n        @Setup(Level.Trial)\n        public void prepare() {\n            source = new EntityWithNoSet(123);\n        }\n    }\n\n    @Benchmark\n    public void testNoStaticReflection(GenerateModel generateModel) throws NoSuchFieldException, IllegalAccessException {\n        EntityWithNoSet entityWithNoSet = new EntityWithNoSet();\n        Class<? extends EntityWithNoSet> EntityWithNoSetClass = entityWithNoSet.getClass();\n        Field testField = EntityWithNoSetClass.getDeclaredField("testField");\n        testField.setAccessible(true);\n        testField.set(entityWithNoSet, generateModel.source.getTestField());\n    }\n\n    @Benchmark\n    public void testStaticReflection(GenerateModel generateModel) throws NoSuchFieldException, IllegalAccessException {\n        EntityWithNoSet entityWithNoSet = new EntityWithNoSet();\n        field.set(entityWithNoSet, generateModel.source.getTestField());\n    }\n\n    @Benchmark\n    public void testStaticMethodHandle(GenerateModel generateModel) throws Throwable {\n        EntityWithNoSet entityWithNoSet = new EntityWithNoSet();\n        staticMethod.invoke(entityWithNoSet, generateModel.source.getTestField());\n    }\n\n    @Benchmark\n    public void testNoStaticMethodHandle(GenerateModel generateModel) throws Throwable {\n        EntityWithNoSet entityWithNoSet = new EntityWithNoSet();\n        MethodAccessor.getCache(EntityWithNoSet.class + "testField").invoke(entityWithNoSet, generateModel.source.getTestField());\n    }\n\n    public static void main(String[] args) throws RunnerException {\n        Options options = new OptionsBuilder()\n                .include(MHBenchmark.class.getSimpleName())\n                .result("./result-mh.json")\n                .resultFormat(ResultFormatType.JSON)\n                .build();\n        new Runner(options).run();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n\n所需要的初始化后的MethodHandle为\n\npublic final class MethodAccessor {\n    private static final Logger logger = LoggerFactory.getLogger(MethodAccessor.class);\n\n    private static final MethodHandles.Lookup lookup = MethodHandles.lookup();\n\n    private static final ConcurrentHashMap<String, MethodHandle> methodHandleCache = new ConcurrentHashMap<>();\n\n    static {\n        initMethodHandles("testField");\n    }\n\n    private static void initMethodHandles(String fieldName) {\n        try {\n            String key = EntityWithNoSet.class + fieldName;\n            MethodHandle cacheHandle = methodHandleCache.get(key);\n            if (cacheHandle != null) {\n                return;\n            }\n            Field field = EntityWithNoSet.class.getDeclaredField(fieldName);\n            field.setAccessible(true);\n            MethodHandle methodHandle = lookup.unreflectSetter(field);\n            methodHandleCache.putIfAbsent(key, methodHandle);\n        } catch (Exception e) {\n            logger.warn("MethodHandle初始化异常", e);\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static MethodHandle getCache(String key) {\n        return methodHandleCache.get(key);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n所需要的初始化后的反射方法为\n\npublic class ReflectInit {\n\n    public static Field init(Class<?> clazz, String fieldName) {\n        Field field;\n        try {\n            field = clazz.getDeclaredField(fieldName);\n            field.setAccessible(true);\n        } catch (NoSuchFieldException e) {\n            throw new RuntimeException(e);\n        }\n        return field;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n压测分别对非静态化MethodHandle、非静态化反射、静态化MethodHandle、静态化反射4种情况进行测试\n\n测试结果、纳秒为单位，数值越小越快：\n\nBenchmark                                              Mode  Cnt    Score    Error  Units\nMethodHandleTest.MHBenchmark.testNoStaticMethodHandle  avgt   10  732.150 ± 40.476  ns/op\nMethodHandleTest.MHBenchmark.testNoStaticReflection    avgt   10  439.412 ±  8.547  ns/op\nMethodHandleTest.MHBenchmark.testStaticMethodHandle    avgt   10    1.561 ±  0.014  ns/op\nMethodHandleTest.MHBenchmark.testStaticReflection      avgt   10   25.693 ±  0.543  ns/op\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n# 小结\n\n可以看出非静态化使用MethodHandle是不会比直接反射更快的，在使用时应该注意这一情况，在静态化之后，反射和MethodHandle都得到了显著的效率提升，此时MethodHandle效率更高。但观察代码我们可以发现，如文章[3:1]所说一致，静态化的方案虽然有效果，但重复代码需要写很多，每个需要动态赋值的变量都需要一个静态申明，在小规模场景使用还好，但这种情况越多代码就越难看了。\n\n# 可优化点\n\n通过调研StackOverflow上对于这种类外访问private变量并动态赋值的场景的文章[6][7]，我们了解到想要在JDK8环境下实现通用性的MethodHandle处理需要用到一些hack方法，单纯结合LambdaMetafactory可能很难做到。\n\n在JDK9环境类外访问private变量的MethodHandle可采用\n\nMethodHandles.privateLookupIn(Class, MethodHandles.Lookup)\n\n\n1\n\n1\n\n\n\n# 场景2-动态根据class带入参创建实例\n\n该场景的主要动机造异常轮子Assert时，动态根据异常消息message和异常class构建出异常实例，从而达到抛出异常的目的，而取代通过new的方式抛出异常\n\n改造前\n\nAssert.isTrue(false,"测试消息");\n\n\n1\n\n1\n\n\n改造后\n\nAssert.isTrue(false,"测试消息", ValidException.class);\n\n\n1\n\n1\n\n\n一个典型的子类为ValidException\n\npublic class ValidException extends AbstractException {\n\n    private static final long serialVersionUID = 1L;\n\n    private static final String DEFAULT_VALID_ERRCODE = "test";\n\n    public ValidException() {\n        super(DEFAULT_VALID_ERRCODE);\n    }\n\n    public ValidException(String errMessage) {\n        super(DEFAULT_VALID_ERRCODE, errMessage);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n他的父类为AbstractException\n\npublic abstract class AbstractException extends RuntimeException {\n\n    private static final long serialVersionUID = 1L;\n\n    private String errMessage;\n\n    public AbstractException(String errMessage) {\n        super(errMessage);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n压测代码为\n\n@Fork(1) // Fork 1个进程进行测试\n@BenchmarkMode(Mode.AverageTime) // 平均时间\n@Warmup(iterations = 3) // JIT预热\n@Measurement(iterations = 10, time = 5) // 迭代10次,每次5s\n@OutputTimeUnit(TimeUnit.NANOSECONDS) // 结果所使用的时间单位\n@Threads(10) // 线程10个\npublic class MhExceptioTest {\n\n    @State(Scope.Benchmark)\n    public static class MhNoLambda{\n        MethodHandle methodHandle;\n\n        @Setup(Level.Trial)\n        public void prepare() throws NoSuchMethodException, IllegalAccessException {\n            MethodType methodType = MethodType.methodType(void.class, String.class);\n            methodHandle = MethodHandles.publicLookup().findConstructor(ValidException.class, methodType);\n        }\n    }\n\n    @State(Scope.Benchmark)\n    public static class MhLambda{\n        Function<String,AbstractException> function;\n\n        @Setup(Level.Trial)\n        public void prepare(){\n            function = MethodAccessor.createConstruct(ValidException.class);\n        }\n    }\n\n    @State(Scope.Benchmark)\n    public static class Constr{\n        Constructor<ValidException> constructor;\n\n        @Setup(Level.Trial)\n        public void prepare() throws NoSuchMethodException {\n            constructor = ValidException.class.getConstructor(String.class);\n        }\n    }\n\n\n    @Benchmark\n    public <T extends AbstractException> AbstractException directNew(){\n        ValidException validException = new ValidException("test");\n        return validException;\n    }\n\n    @Benchmark\n    public <T extends AbstractException> AbstractException mhNoLamda(MhNoLambda mhNoLambda) throws Throwable {\n        return (AbstractException) mhNoLambda.methodHandle.invoke("test");\n    }\n\n    @Benchmark\n    public <T extends AbstractException> AbstractException reflet(Constr constr) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {\n        ValidException validException = constr.constructor.newInstance("test");\n        return validException;\n    }\n\n    @Benchmark\n    public <T extends AbstractException> AbstractException mhLamda(MhLambda mhLambda){\n        return mhLambda.function.apply("test");\n    }\n\n    public static void main(String[] args) throws RunnerException {\n        Options options = new OptionsBuilder()\n                .include(MhExceptioTest.class.getSimpleName())\n                .result("./result-mh-ex.json")\n                .resultFormat(ResultFormatType.JSON)\n                .build();\n        new Runner(options).run();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n\n\n对于反射和Lambda化的MethodHandle，本文进行了方法的初始化，反射代码可见压测代码块中\n\nMethodHandle+LambdaMetafactory封装的类，参考了StackOverflow[8]，代码为\n\npublic final class MethodAccessor {\n\n    private static final Logger logger = LoggerFactory.getLogger(MethodAccessor.class);\n\n    private static final MethodHandles.Lookup lookup = MethodHandles.lookup();\n\n    private static final MethodType methodType = MethodType.methodType(void.class, String.class);\n\n    private static final ConcurrentHashMap<String, Function<String, AbstractException>> cacheFunction = new ConcurrentHashMap<>();\n\n    /**\n     *\n     * @param cls     动态推断的class\n     * @param message 需要抛出的信息\n     * @param <T>     class类型\n     * @return AbstractException或其子类\n     */\n    public static <T extends AbstractException> AbstractException getException(Class<T> cls, String message) {\n        try {\n            Function<String, AbstractException> function = cacheFunction.get(cls.toString());\n            if (function != null) {\n                return applyMessage(function, message);\n            }\n            function = MethodAccessor.createConstruct(cls);\n            cacheFunction.putIfAbsent(cls.toString(), function);\n            return applyMessage(function, message);\n        } catch (Throwable throwable) {\n            throw new RuntimeException("获取cache exception异常", throwable);\n        }\n    }\n\n    /**\n     * 根据异常Class，动态通过LambdaMetafactory寻找构造函数\n     *\n     * @param cls 异常Class\n     * @param <T> 异常Class类型\n     * @return Function<String, AbstractException>\n     */\n    @SuppressWarnings("unchecked")\n    public static <T> Function<String, AbstractException> createConstruct(Class<T> cls) {\n        try {\n            MethodHandle methodHandle = lookup.findConstructor(cls, methodType);\n            CallSite site = LambdaMetafactory.metafactory(\n                    lookup,\n                    "apply",\n                    MethodType.methodType(Function.class),\n                    methodHandle.type().generic(),\n                    methodHandle,\n                    methodHandle.type());\n            return (Function<String, AbstractException>) site.getTarget().invokeExact();\n        } catch (Throwable throwable) {\n            logger.warn("LambdaMetafactory create construct异常:", throwable);\n            throw new RuntimeException(throwable);\n        }\n    }\n\n    /**\n     * 根据Function函数和异常message，调用对应构造函数方法\n     *\n     * @param function function函数\n     * @param message  异常消息\n     * @return AbstractException\n     */\n    public static AbstractException applyMessage(Function<String, AbstractException> function, String message) {\n        try {\n            return function.apply(message);\n        } catch (Throwable throwable) {\n            logger.warn("LambdaMetafactory function apply异常:", throwable);\n            throw new RuntimeException(throwable);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n\n压测分别对直接new set、Lambda MethodHandle、无Lambda MethodHandle、反射4种情况进行测试\n\n测试结果、纳秒为单位，数值越小越快：\n\nBenchmark                                      Mode  Cnt     Score     Error  Units\nMhExceptionBenchMark.MhExceptioTest.directNew  avgt   10  2421.192 ± 165.195  ns/op\nMhExceptionBenchMark.MhExceptioTest.mhLamda    avgt   10  2589.443 ± 204.428  ns/op\nMhExceptionBenchMark.MhExceptioTest.mhNoLamda  avgt   10  2664.148 ± 217.869  ns/op\nMhExceptionBenchMark.MhExceptioTest.reflet     avgt   10  2710.181 ± 304.747  ns/op\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n# 小结\n\n可以看出在创建实例的场景下，其实mh无论是否lambda化，都与反射和原生方法差别不大。还会编写大量的LambdaMetafactory使用的代码。本质上是因为异常类实例化的消耗绝大多数在于堆栈收集上，仅仅是创建实例场景比较有限，优势也不会太明显。一个值得一读的异常性能文章是[9]exceptional-performance。值得注意的是，虽然本文的场景2中MethodHandle的性能并没有提高多少，但依据社区测试经验[10]，大多数情况下，一个正确使用的MethodHandle在性能上依旧会比反射领先，可作为基础组件的不二之选。\n\n\n# 参考文章\n\n----------------------------------------\n\n 1.  https://zhuanlan.zhihu.com/p/30936412 ↩︎\n\n 2.  https://stackoverflow.com/questions/19557829/faster-alternatives-to-javas-reflection ↩︎\n\n 3.  https://www.optaplanner.org/blog/2018/01/09/JavaReflectionButMuchFaster.html ↩︎ ↩︎\n\n 4.  https://zhuanlan.zhihu.com/p/84149346 ↩︎\n\n 5.  https://www.optaplanner.org/localized/zh/index.html ↩︎\n\n 6.  https://stackoverflow.com/questions/28184065/java-8-access-private-member-with-lambda ↩︎\n\n 7.  https://stackoverflow.com/questions/69068124/lambdametafactory-and-private-methods ↩︎\n\n 8.  https://stackoverflow.com/questions/53675777/how-to-instantiate-an-object-using-lambdametafactory ↩︎\n\n 9.  https://shipilev.net/blog/2014/exceptional-performance/ ↩︎\n\n 10. https://stackoverflow.com/questions/19557829/faster-alternatives-to-javas-reflection ↩︎',normalizedContent:'# 背景\n\n在进行实例的动态推断和构建时，我们会经常使用到反射这一技巧，然而在某些场景中反射的效率显得有些力不从心。从jdk7开始，methodhandle被推出，用于解决反射的效率问题。在jdk8，methodhandle又与lambda进行深度结合，成为lambda的最底层调用方式。在jdk9，methodhandle又被进一步增强。 在开源项目中，mybatis mapper的动态代理实现则运用了methodhandle。\n\n本文代码地址https://github.com/benym/benchmark-test，其中的mhbenchmark和mhexceptionbenchmark目录\n\n\n# methodhandle是什么\n\nmethodhandle直译为方法句柄，调用时jvm采用invokedynamic指令[1]，直接调用native方法，引用jdk中的说明\n\n提示\n\na method handle is a typed, directly executable reference to an underlying method, constructor, field, or similar low-level operation, with optional transformations of arguments or return values.\n\n方法句柄是一个有类型的，可以直接执行的指向底层方法、构造器、field等的引用，可以简单理解为函数指针，它是一种更加底层的查找、调整和调用方法的机制。\n\n一个简单的使用方法为\n\nstep1: 创建mh lookup、根据访问权限任选其一即可\n\n//仅访问public方法\nmethodhandles.lookup publiclookup = methodhandles.publiclookup();\n//访问public、private、protected方法\nmethodhandles.lookup alllookup = methodhandles.lookup();\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\nstep2: 创建methodtype，它用来描述被访问的方法的参数类型、返回值类型，jvm强制要求声明的method type与实际调用方法的参数类型必须匹配\n\n// 即入参为string、返回为void类型\nmethodtype methodtype = methodtype.methodtype(void.class, string.class);\n\n\n1\n2\n\n1\n2\n\n\nstep3: 通过mh lookup和methodtype获取对应方法methodhandle并执行，下例为通过test.class字节码，找到类test中以string为入参，void为返回值的构造方法、并进行invoke赋值，返回赋值后的test实体类\n\nmethodhandle methodhandle = publiclookup.findconstructor(test.class, methodtype);\nobject invoke = methodhandle.invoke("赋值test消息");\n\n\n1\n2\n\n1\n2\n\n\n其中step2为可选，根据step3使用方法的不同入参不同，step3还可以为：通过methodhandle访问普通方法、访问静态方法、访问构造函数、访问私有方法、访问公有成员等。 最终执行，按照对参数数目、参数类型的要求限制不同，分为三类invokewitharguments(),invoke(),invokeexact()\n\n * invokewitharguments要求接收变长参数，允许参数拆装箱类型转换\n * invoke要求接收固定的参数列表，允许参拆装箱，类型转换\n * invokeexact要求最严格，参数类型不匹配会报错 这里不再对methodhandle各个用例的使用进行展开。\n\n\n# methodhandle性能测试\n\n\n# 前言\n\n参考stackoverflow[2]和optaplanner引擎论坛[3]对methodhandle的测试结果，大多数情况下，mh的执行效率接近原生，但随着jdk对反射的优化，反射的效率也没有想象中的特别慢。\n\n在上述引文的第2篇，作者做了非常全面的实验，包括traveling salesman problem(旅行商问题、反应在调用链路耗时)、直接调用、非静态化调用、静态化调用、java编译器生成、lambdametafactory结合、启动消耗等，值得一读。\n\n提示\n\noptaplanner是一个开源的轻量级、可嵌入的约束满足引擎，可求解规划问题，100%由java编写，可以在任何jvm上运行，也可以在maven中央存储库中使用、支持多种平台下载。在底层，optaplanner 将复杂的人工智能优化算法（例如禁忌搜索、模拟退火、延迟接受和其他元启发式算法）与非常有效的分数计算和其他最先进的 np-complete 或 np-约束求解技术相结合。\n\n可参考文章[4][5], 官网为https://www.optaplanner.org/\n\n引文的结论中：非静态化的mh甚至比反射效率更低，这迫使开发者采用其他方法增强mh，想要做到具有通用性、且高效的methodhandle需要结合lambdametafactory；如果不会使用lambdametafactory、在字段不多的情况下选择static化的mh同样是选择，而采用java编译器去动态生成代码的方式，虽然效率上达到原生，但写的很不方便。\n\n在本文中，methodhandle主要解决如下2个问题\n\n 1. 类外访问private变量并动态赋值\n 2. 动态根据class带入参创建实例\n\n虽然反射实现起来很简单，但由于这两种场景在工具类中使用高频，所以出于性能考量采用了methodhandle，同时做出性能测试。\n\n\n# 场景1-类外访问private变量并动态赋值\n\n项目中存在某实体，出于某些特殊原因，没有向外部提供对应字段的set方法，赋值需要通过构造特定对象进行实例新建。在转换时有一定的不便捷性。\n\n示例代码如下，这里不展示通过特定对象创建实例的构造方法。\n\npublic class entitywithnoset {\n    private int testfield;\n\n    public entitywithnoset() {\n    }\n\n    public int gettestfield() {\n        return testfield;\n    }\n\n    public entitywithnoset(int testfield) {\n        this.testfield = testfield;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n当不采用构造特定对象的方式进行示例创建，又需要对私有变量赋值时，可以采用反射或methodhandle实现\n\n一个简单的压测代码为，采用平均时间作为性能衡量指标\n\n@fork(1) // fork 1个进程进行测试\n@benchmarkmode(mode.averagetime) // 平均时间\n@warmup(iterations = 3) // jit预热\n@measurement(iterations = 10, time = 5) // 迭代10次,每次5s\n@outputtimeunit(timeunit.nanoseconds) // 结果所使用的时间单位\n@threads(10) // 线程10个\npublic class mhbenchmark {\n\n    private static final methodhandle staticmethod = methodaccessor.getcache(entitywithnoset.class + "testfield");\n\n    private static final field field = reflectinit.init(entitywithnoset.class, "testfield");\n\n    /**\n     * 作用域为本次jmh测试，线程共享\n     * <p>\n     * 初始化source数据集\n     */\n    @state(scope.benchmark)\n    public static class generatemodel {\n        entitywithnoset source;\n\n        // 初始化\n        @setup(level.trial)\n        public void prepare() {\n            source = new entitywithnoset(123);\n        }\n    }\n\n    @benchmark\n    public void testnostaticreflection(generatemodel generatemodel) throws nosuchfieldexception, illegalaccessexception {\n        entitywithnoset entitywithnoset = new entitywithnoset();\n        class<? extends entitywithnoset> entitywithnosetclass = entitywithnoset.getclass();\n        field testfield = entitywithnosetclass.getdeclaredfield("testfield");\n        testfield.setaccessible(true);\n        testfield.set(entitywithnoset, generatemodel.source.gettestfield());\n    }\n\n    @benchmark\n    public void teststaticreflection(generatemodel generatemodel) throws nosuchfieldexception, illegalaccessexception {\n        entitywithnoset entitywithnoset = new entitywithnoset();\n        field.set(entitywithnoset, generatemodel.source.gettestfield());\n    }\n\n    @benchmark\n    public void teststaticmethodhandle(generatemodel generatemodel) throws throwable {\n        entitywithnoset entitywithnoset = new entitywithnoset();\n        staticmethod.invoke(entitywithnoset, generatemodel.source.gettestfield());\n    }\n\n    @benchmark\n    public void testnostaticmethodhandle(generatemodel generatemodel) throws throwable {\n        entitywithnoset entitywithnoset = new entitywithnoset();\n        methodaccessor.getcache(entitywithnoset.class + "testfield").invoke(entitywithnoset, generatemodel.source.gettestfield());\n    }\n\n    public static void main(string[] args) throws runnerexception {\n        options options = new optionsbuilder()\n                .include(mhbenchmark.class.getsimplename())\n                .result("./result-mh.json")\n                .resultformat(resultformattype.json)\n                .build();\n        new runner(options).run();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n\n所需要的初始化后的methodhandle为\n\npublic final class methodaccessor {\n    private static final logger logger = loggerfactory.getlogger(methodaccessor.class);\n\n    private static final methodhandles.lookup lookup = methodhandles.lookup();\n\n    private static final concurrenthashmap<string, methodhandle> methodhandlecache = new concurrenthashmap<>();\n\n    static {\n        initmethodhandles("testfield");\n    }\n\n    private static void initmethodhandles(string fieldname) {\n        try {\n            string key = entitywithnoset.class + fieldname;\n            methodhandle cachehandle = methodhandlecache.get(key);\n            if (cachehandle != null) {\n                return;\n            }\n            field field = entitywithnoset.class.getdeclaredfield(fieldname);\n            field.setaccessible(true);\n            methodhandle methodhandle = lookup.unreflectsetter(field);\n            methodhandlecache.putifabsent(key, methodhandle);\n        } catch (exception e) {\n            logger.warn("methodhandle初始化异常", e);\n            throw new runtimeexception(e);\n        }\n    }\n\n    public static methodhandle getcache(string key) {\n        return methodhandlecache.get(key);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n所需要的初始化后的反射方法为\n\npublic class reflectinit {\n\n    public static field init(class<?> clazz, string fieldname) {\n        field field;\n        try {\n            field = clazz.getdeclaredfield(fieldname);\n            field.setaccessible(true);\n        } catch (nosuchfieldexception e) {\n            throw new runtimeexception(e);\n        }\n        return field;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n压测分别对非静态化methodhandle、非静态化反射、静态化methodhandle、静态化反射4种情况进行测试\n\n测试结果、纳秒为单位，数值越小越快：\n\nbenchmark                                              mode  cnt    score    error  units\nmethodhandletest.mhbenchmark.testnostaticmethodhandle  avgt   10  732.150 ± 40.476  ns/op\nmethodhandletest.mhbenchmark.testnostaticreflection    avgt   10  439.412 ±  8.547  ns/op\nmethodhandletest.mhbenchmark.teststaticmethodhandle    avgt   10    1.561 ±  0.014  ns/op\nmethodhandletest.mhbenchmark.teststaticreflection      avgt   10   25.693 ±  0.543  ns/op\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n# 小结\n\n可以看出非静态化使用methodhandle是不会比直接反射更快的，在使用时应该注意这一情况，在静态化之后，反射和methodhandle都得到了显著的效率提升，此时methodhandle效率更高。但观察代码我们可以发现，如文章[3:1]所说一致，静态化的方案虽然有效果，但重复代码需要写很多，每个需要动态赋值的变量都需要一个静态申明，在小规模场景使用还好，但这种情况越多代码就越难看了。\n\n# 可优化点\n\n通过调研stackoverflow上对于这种类外访问private变量并动态赋值的场景的文章[6][7]，我们了解到想要在jdk8环境下实现通用性的methodhandle处理需要用到一些hack方法，单纯结合lambdametafactory可能很难做到。\n\n在jdk9环境类外访问private变量的methodhandle可采用\n\nmethodhandles.privatelookupin(class, methodhandles.lookup)\n\n\n1\n\n1\n\n\n\n# 场景2-动态根据class带入参创建实例\n\n该场景的主要动机造异常轮子assert时，动态根据异常消息message和异常class构建出异常实例，从而达到抛出异常的目的，而取代通过new的方式抛出异常\n\n改造前\n\nassert.istrue(false,"测试消息");\n\n\n1\n\n1\n\n\n改造后\n\nassert.istrue(false,"测试消息", validexception.class);\n\n\n1\n\n1\n\n\n一个典型的子类为validexception\n\npublic class validexception extends abstractexception {\n\n    private static final long serialversionuid = 1l;\n\n    private static final string default_valid_errcode = "test";\n\n    public validexception() {\n        super(default_valid_errcode);\n    }\n\n    public validexception(string errmessage) {\n        super(default_valid_errcode, errmessage);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n他的父类为abstractexception\n\npublic abstract class abstractexception extends runtimeexception {\n\n    private static final long serialversionuid = 1l;\n\n    private string errmessage;\n\n    public abstractexception(string errmessage) {\n        super(errmessage);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n压测代码为\n\n@fork(1) // fork 1个进程进行测试\n@benchmarkmode(mode.averagetime) // 平均时间\n@warmup(iterations = 3) // jit预热\n@measurement(iterations = 10, time = 5) // 迭代10次,每次5s\n@outputtimeunit(timeunit.nanoseconds) // 结果所使用的时间单位\n@threads(10) // 线程10个\npublic class mhexceptiotest {\n\n    @state(scope.benchmark)\n    public static class mhnolambda{\n        methodhandle methodhandle;\n\n        @setup(level.trial)\n        public void prepare() throws nosuchmethodexception, illegalaccessexception {\n            methodtype methodtype = methodtype.methodtype(void.class, string.class);\n            methodhandle = methodhandles.publiclookup().findconstructor(validexception.class, methodtype);\n        }\n    }\n\n    @state(scope.benchmark)\n    public static class mhlambda{\n        function<string,abstractexception> function;\n\n        @setup(level.trial)\n        public void prepare(){\n            function = methodaccessor.createconstruct(validexception.class);\n        }\n    }\n\n    @state(scope.benchmark)\n    public static class constr{\n        constructor<validexception> constructor;\n\n        @setup(level.trial)\n        public void prepare() throws nosuchmethodexception {\n            constructor = validexception.class.getconstructor(string.class);\n        }\n    }\n\n\n    @benchmark\n    public <t extends abstractexception> abstractexception directnew(){\n        validexception validexception = new validexception("test");\n        return validexception;\n    }\n\n    @benchmark\n    public <t extends abstractexception> abstractexception mhnolamda(mhnolambda mhnolambda) throws throwable {\n        return (abstractexception) mhnolambda.methodhandle.invoke("test");\n    }\n\n    @benchmark\n    public <t extends abstractexception> abstractexception reflet(constr constr) throws nosuchmethodexception, invocationtargetexception, instantiationexception, illegalaccessexception {\n        validexception validexception = constr.constructor.newinstance("test");\n        return validexception;\n    }\n\n    @benchmark\n    public <t extends abstractexception> abstractexception mhlamda(mhlambda mhlambda){\n        return mhlambda.function.apply("test");\n    }\n\n    public static void main(string[] args) throws runnerexception {\n        options options = new optionsbuilder()\n                .include(mhexceptiotest.class.getsimplename())\n                .result("./result-mh-ex.json")\n                .resultformat(resultformattype.json)\n                .build();\n        new runner(options).run();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n\n\n对于反射和lambda化的methodhandle，本文进行了方法的初始化，反射代码可见压测代码块中\n\nmethodhandle+lambdametafactory封装的类，参考了stackoverflow[8]，代码为\n\npublic final class methodaccessor {\n\n    private static final logger logger = loggerfactory.getlogger(methodaccessor.class);\n\n    private static final methodhandles.lookup lookup = methodhandles.lookup();\n\n    private static final methodtype methodtype = methodtype.methodtype(void.class, string.class);\n\n    private static final concurrenthashmap<string, function<string, abstractexception>> cachefunction = new concurrenthashmap<>();\n\n    /**\n     *\n     * @param cls     动态推断的class\n     * @param message 需要抛出的信息\n     * @param <t>     class类型\n     * @return abstractexception或其子类\n     */\n    public static <t extends abstractexception> abstractexception getexception(class<t> cls, string message) {\n        try {\n            function<string, abstractexception> function = cachefunction.get(cls.tostring());\n            if (function != null) {\n                return applymessage(function, message);\n            }\n            function = methodaccessor.createconstruct(cls);\n            cachefunction.putifabsent(cls.tostring(), function);\n            return applymessage(function, message);\n        } catch (throwable throwable) {\n            throw new runtimeexception("获取cache exception异常", throwable);\n        }\n    }\n\n    /**\n     * 根据异常class，动态通过lambdametafactory寻找构造函数\n     *\n     * @param cls 异常class\n     * @param <t> 异常class类型\n     * @return function<string, abstractexception>\n     */\n    @suppresswarnings("unchecked")\n    public static <t> function<string, abstractexception> createconstruct(class<t> cls) {\n        try {\n            methodhandle methodhandle = lookup.findconstructor(cls, methodtype);\n            callsite site = lambdametafactory.metafactory(\n                    lookup,\n                    "apply",\n                    methodtype.methodtype(function.class),\n                    methodhandle.type().generic(),\n                    methodhandle,\n                    methodhandle.type());\n            return (function<string, abstractexception>) site.gettarget().invokeexact();\n        } catch (throwable throwable) {\n            logger.warn("lambdametafactory create construct异常:", throwable);\n            throw new runtimeexception(throwable);\n        }\n    }\n\n    /**\n     * 根据function函数和异常message，调用对应构造函数方法\n     *\n     * @param function function函数\n     * @param message  异常消息\n     * @return abstractexception\n     */\n    public static abstractexception applymessage(function<string, abstractexception> function, string message) {\n        try {\n            return function.apply(message);\n        } catch (throwable throwable) {\n            logger.warn("lambdametafactory function apply异常:", throwable);\n            throw new runtimeexception(throwable);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n\n压测分别对直接new set、lambda methodhandle、无lambda methodhandle、反射4种情况进行测试\n\n测试结果、纳秒为单位，数值越小越快：\n\nbenchmark                                      mode  cnt     score     error  units\nmhexceptionbenchmark.mhexceptiotest.directnew  avgt   10  2421.192 ± 165.195  ns/op\nmhexceptionbenchmark.mhexceptiotest.mhlamda    avgt   10  2589.443 ± 204.428  ns/op\nmhexceptionbenchmark.mhexceptiotest.mhnolamda  avgt   10  2664.148 ± 217.869  ns/op\nmhexceptionbenchmark.mhexceptiotest.reflet     avgt   10  2710.181 ± 304.747  ns/op\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n# 小结\n\n可以看出在创建实例的场景下，其实mh无论是否lambda化，都与反射和原生方法差别不大。还会编写大量的lambdametafactory使用的代码。本质上是因为异常类实例化的消耗绝大多数在于堆栈收集上，仅仅是创建实例场景比较有限，优势也不会太明显。一个值得一读的异常性能文章是[9]exceptional-performance。值得注意的是，虽然本文的场景2中methodhandle的性能并没有提高多少，但依据社区测试经验[10]，大多数情况下，一个正确使用的methodhandle在性能上依旧会比反射领先，可作为基础组件的不二之选。\n\n\n# 参考文章\n\n----------------------------------------\n\n 1.  https://zhuanlan.zhihu.com/p/30936412 ↩︎\n\n 2.  https://stackoverflow.com/questions/19557829/faster-alternatives-to-javas-reflection ↩︎\n\n 3.  https://www.optaplanner.org/blog/2018/01/09/javareflectionbutmuchfaster.html ↩︎ ↩︎\n\n 4.  https://zhuanlan.zhihu.com/p/84149346 ↩︎\n\n 5.  https://www.optaplanner.org/localized/zh/index.html ↩︎\n\n 6.  https://stackoverflow.com/questions/28184065/java-8-access-private-member-with-lambda ↩︎\n\n 7.  https://stackoverflow.com/questions/69068124/lambdametafactory-and-private-methods ↩︎\n\n 8.  https://stackoverflow.com/questions/53675777/how-to-instantiate-an-object-using-lambdametafactory ↩︎\n\n 9.  https://shipilev.net/blog/2014/exceptional-performance/ ↩︎\n\n 10. https://stackoverflow.com/questions/19557829/faster-alternatives-to-javas-reflection ↩︎',charsets:{cjk:!0},lastUpdated:"2023/01/31, 18:41:29",lastUpdatedTimestamp:1675161689e3},{title:"优雅的参数校验与全局异常-代码规范的天生落地",frontmatter:{title:"优雅的参数校验与全局异常-代码规范的天生落地",date:"2023-02-01T11:30:04.000Z",categories:["开源项目","Rpamis","Exception","Dubbo","Spring"],tags:["Exception","返回体","优雅校验","Validated","Valid","Advice","Dubbo","Filter","Http"],author:{name:"benym",link:"https://github.com/benym"},permalink:"/pages/1c47ed/"},regularPath:"/08.%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/01.Rpamis/02.Exception/02.%E4%BC%98%E9%9B%85%E7%9A%84%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C%E4%B8%8E%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8.html",relativePath:"08.开源项目/01.Rpamis/02.Exception/02.优雅的参数校验与全局异常.md",key:"v-2be0cdda",path:"/pages/1c47ed/",headers:[{level:2,title:"背景",slug:"背景",normalizedTitle:"背景",charIndex:2},{level:2,title:"JSR303规范及主流实现",slug:"jsr303规范及主流实现",normalizedTitle:"jsr303规范及主流实现",charIndex:232},{level:2,title:"参数校验-快速开始",slug:"参数校验-快速开始",normalizedTitle:"参数校验-快速开始",charIndex:967},{level:3,title:"基本校验",slug:"基本校验",normalizedTitle:"基本校验",charIndex:1402},{level:3,title:"嵌套校验",slug:"嵌套校验",normalizedTitle:"嵌套校验",charIndex:3002},{level:3,title:"分组校验",slug:"分组校验",normalizedTitle:"分组校验",charIndex:4287},{level:3,title:"自定义校验",slug:"自定义校验",normalizedTitle:"自定义校验",charIndex:6549},{level:3,title:"Spring Validation与Dubbo Validation",slug:"spring-validation与dubbo-validation",normalizedTitle:"spring validation与dubbo validation",charIndex:13428},{level:3,title:"实践对比",slug:"实践对比",normalizedTitle:"实践对比",charIndex:14065},{level:2,title:"全局异常-快速开始",slug:"全局异常-快速开始",normalizedTitle:"全局异常-快速开始",charIndex:14291},{level:3,title:"统一返回体",slug:"统一返回体",normalizedTitle:"统一返回体",charIndex:86},{level:3,title:"全局异常捕获",slug:"全局异常捕获",normalizedTitle:"全局异常捕获",charIndex:24873},{level:4,title:"为什么用Http Code",slug:"为什么用http-code",normalizedTitle:"为什么用http code",charIndex:24883},{level:4,title:"Web Controller",slug:"web-controller",normalizedTitle:"web controller",charIndex:26752},{level:4,title:"自定义异常",slug:"自定义异常",normalizedTitle:"自定义异常",charIndex:75},{level:4,title:"Dubbo RPC",slug:"dubbo-rpc",normalizedTitle:"dubbo rpc",charIndex:42550},{level:3,title:"异常使用",slug:"异常使用",normalizedTitle:"异常使用",charIndex:42723},{level:4,title:"统一使用方法",slug:"统一使用方法",normalizedTitle:"统一使用方法",charIndex:51095},{level:3,title:"实践对比",slug:"实践对比-2",normalizedTitle:"实践对比",charIndex:14065},{level:3,title:"可控性分析",slug:"可控性分析",normalizedTitle:"可控性分析",charIndex:51753},{level:3,title:"可扩展性分析",slug:"可扩展性分析",normalizedTitle:"可扩展性分析",charIndex:52140},{level:3,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:2981}],headersStr:"背景 JSR303规范及主流实现 参数校验-快速开始 基本校验 嵌套校验 分组校验 自定义校验 Spring Validation与Dubbo Validation 实践对比 全局异常-快速开始 统一返回体 全局异常捕获 为什么用Http Code Web Controller 自定义异常 Dubbo RPC 异常使用 统一使用方法 实践对比 可控性分析 可扩展性分析 参考文章",content:'# 背景\n\n代码规范是项目质量的基石，能够帮助开发者和管理者更好的管理/维护项目、专注于推动快速成长的业务、留出更多时间攻坚重难点系统设计。全局异常+自定义异常+参数校验+统一返回体组合是互联网中Java开发规范、使用代码扫描工具后的提升效率的必然落地方式。\n\n针对开发规范的细节考量，本文主要描述业界常用的基于@Valid和@Validated的前置校验，结合全局异常与Http Code，帮助读者理解高效且优雅的参数校验，及通用场景下的全局异常机制。\n\n\n# JSR303规范及主流实现\n\n数据的正确性校验是研发过程中不可或缺的步骤，开发者需要保证数据在进入系统后的基本正确性。\n\n在通常的开发过程中前端可以帮助校验用户的数据请求，为了保证服务端数据的安全，避免非法请求绕过前端，直接采用脚本等方式向服务端发起请求。服务端同样需要进行数据校验。\n\n根据校验先后的不同可以选择的方法也可以不同，比如在Controller前的@Valid和@Validated校验，这类校验通常用于实体、字段的校验规则，如非空判断、长度判断、正则匹配、el表达式判断等。再者就是复杂业务或网关层面的校验，通常会使用责任链模式进行特定实现。当不使用该两种方法时，开发者通常会使用if else语法进行校验，但当校验过多且复杂时，成片的if else会造成代码臃肿，可复用性差的问题，导致研发效率的低下。\n\nJSR(Java Specification Requests)是Java规范的提案，JSR-303[1]是JavaEE6中的一项子规范，叫做Bean Validation[2]，该提案于2009年正式面向公众，后续的JSR-349、JSR-380均在此提案上进行增强。该规范只提供了校验的注解，位于javax.validation.constraints包下，在官网指定的实现贡献者有3个\n\n\n\n其中Hibernate Validator使用最为广泛。\n\n这里列出一些基本的constraint，在最新的hibernate validator中包括但不限于以下注解，更多实现可直达官网[3]了解。\n\nBean Validation中内置的constraint\n\n\n\nHibernate Validator附加的constraint\n\n\n\n\n# 参数校验-快速开始\n\nSpringBoot项目无需引入额外依赖，自带所需依赖，非SpringBoot项目需要引入如下2个依赖，参数校验依赖于get/set方法\n\n<dependency>\n    <groupId>javax.validation</groupId>\n    <artifactId>validation-api</artifactId>\n    <version>2.0.1.Final</version>\n</dependency>\n<dependency>\n    <groupId>org.hibernate.validator</groupId>\n    <artifactId>hibernate-validator</artifactId>\n    <version>6.1.5.Final</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 基本校验\n\n以一个User实体为例\n\npublic class User {\n\n    @NotNull(message = "用户名不能为空")\n    private String userName;\n\n    @NotNull(message = "密码不能为空")\n    @Pattern(regexp = "^[a-zA-Z0-9|_]+$", message = "密码必须由字母、数字、下划线组成")\n    @Size(min = 6, max = 12, message = "密码长度必须在6-12字符之间")\n    private String passWord;\n\n    @Range(min = 1, max = 150, message = "年龄必须在1-150区间")\n    private Integer age;\n    \n    @NotEmpty(message = "用户的兴趣不能为空")\n    private List<String> interest;\n    \n    // 省略get/set\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n假设要求传入的Json字段(@RequestBody)中，用户名、密码、年龄都有特定的规则\n\n对应的Controller应该为\n\n@RestController\n@RequestMapping("/test")\npublic class TestController {\n\n    @PostMapping("/validate")\n    public String test(@Valid @RequestBody User user) {\n        System.out.println(1);\n        return "success";\n    }\n\n    @PostMapping("/validate2")\n    public String test2(@Validated @RequestBody User user) {\n        System.out.println(1);\n        return "success";\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n使用@Valid或@Validated均可\n\n此时当Postman参数传递不符合预期时，将无法进入Controller中(前置拦截，体现在Debug时，进不到test方法体内System.out行)，同时接口返回400，带Spring封装的基础返回体\n\n\n\n控制台抛出对应异常\n\n\n\n结合上图结果和代码我们可以观察到，Spring自带的基础返回体没有将我们想要的message显示出来，仅仅是在控制台有日志打印，只有显示指定@NotNull、@NotBlank、@NotEmpty等非空注解时，参数才为必传。在本例中age字段虽然有@Range，但他不是必传的选项。只有当入参Json包含age字段时，@Range才会生效。\n\n由于参数校验结果的特点以及各公司对返回体的定制化需求，参数校验通常与统一返回体、全局异常处理结合。\n\n提示\n\n最新的Spring6、SpringBoot3中，已提供了org.springframework.http.ProblemDetail来实现Http错误的返回信息和问题细节，避免自定义新的错误返回格式，可参考文章4[4]和文章5[5]。\n\n\n# 嵌套校验\n\n嵌套校验支持用户将@Valid和@Validated混合使用，可用于更复杂的校验\n\n还是以User为例，新增一个friends字段，代表用户的朋友们，同时加上@Valid注解代表如果friends入参有传，则需要对Friend类的内部字段进行校验，如果没有传递则无需校验。\n\npublic class User {\n\n    @NotNull(message = "用户名不能为空")\n    private String userName;\n\n    @NotNull(message = "密码不能为空")\n    @Pattern(regexp = "^[a-zA-Z0-9|_]+$", message = "密码必须由字母、数字、下划线组成")\n    @Size(min = 6, max = 12, message = "密码长度必须在6-12字符之间")\n    private String passWord;\n\n    @Range(min = 1, max = 150, message = "年龄必须在1-150区间")\n    private Integer age;\n\n    @Valid\n    private List<Friend> friends;\n    \n    // 省略get/set\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nFriend类\n\npublic class Friend {\n\n    @NotNull(message = "朋友名称不能为空")\n    private String userName;\n\n    @Range(min = 1, max = 150, message = "年龄必须在1-150区间")\n    private Integer age;\n    \n    // 省略get/set\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n假设此时参数传递为\n\n{\n    "userName" : "11",\n    "passWord" : "test123_2",\n    "age" : 11,\n    "friends" : [\n        {\n            "age" : "22"\n        },\n        {\n            "userName" : "33"\n        }\n    ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n表示该用户有2个friend，其中一个只写了名字，其中一个只写了年龄，由代码可知年龄是非必填字段，对应的控制台日志为\n\n\n\n符合校验预期，当此时friend字段没有传递时，则不进行校验\n\n\n# 分组校验\n\n分组校验是Spring Validation的特性，校验时在Controller层对实体的书写必须使用@Validated，分组校验提高了实体校验注解的可复用能力，只需要指定校验分组即可让同一实体适配多种场景。\n\n@RestController\n@RequestMapping("/test")\npublic class TestController {\n\n    @PostMapping("/validate2")\n    public String test2(@Validated @RequestBody User user) {\n        System.out.println(1);\n        return "success";\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n首先需要定义常见的CRUD分组场景，取任意名字均可，接口无需实现\n\npublic class ValidatedAction {\n    \n    public interface Insert {\n    }\n\n    public interface Update {\n    }\n\n    public interface Search {\n    }\n\n    public interface Delete {\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n为刚才的User内的字段增加分组，如在新增时需要填写用户名、密码，在删除时需要填写id和密码\n\npublic class User {\n\n    @NotNull(message = "id不能为空", groups = {ValidatedAction.Delete.class})\n    private String id;\n\n    @NotNull(message = "用户名不能为空", groups = {ValidatedAction.Insert.class})\n    private String userName;\n\n    @NotNull(message = "密码不能为空", groups = {ValidatedAction.Insert.class, ValidatedAction.Delete.class})\n    @Pattern(regexp = "^[a-zA-Z0-9|_]+$", message = "密码必须由字母、数字、下划线组成")\n    @Size(min = 6, max = 12, message = "密码长度必须在6-12字符之间")\n    private String passWord;\n\n    @Range(min = 1, max = 150, message = "年龄必须在1-150区间")\n    private Integer age;\n\n    @Valid\n    private List<Friend> friends;\n    \n    // 省略get/set\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n修改Controller接口，指定校验分组，一个为新增分组校验，一个为删除分组校验，同时需要加上javax中自带的Default分组，避免实体中没有写group的校验注解失效\n\n@RestController\n@RequestMapping("/test")\npublic class TestController {\n\n    @PostMapping("/validate")\n    public String test(@Validated({ValidatedAction.Insert.class, Default.class}) @RequestBody User user) {\n        System.out.println(1);\n        return "success";\n    }\n\n    @PostMapping("/validateDelete")\n    public String test2(@Validated({ValidatedAction.Delete.class, Default.class}) @RequestBody User user) {\n        System.out.println(1);\n        return "success";\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n新增时Postman传参为\n\n\n\n由于新增时，非空参数仅有用户名和密码，所以正常返回，此时分组为Delete的id并没有参与非空校验\n\n删除时Postman传参为\n\n\n\n由于删除时，非空参数包含id，此时传参中没有id则会在控制台输出对应提示\n\n\n\n\n# 自定义校验\n\nhibernate提供的校验注解在简单字段的场景已经基本够用了，如果提供的校验注解无法满足要求，这个时候可以考虑自定义注解，将校验与Controller完全隔离。\n\n本文主要考虑4种较为通用的场景下自定义注解的实现方法\n\n * 场景1：字段为基础类型，约束传递的字段只能在枚举code的约束范围内，虽然定义字段为枚举字段可以简单实现传输枚举对象名完成枚举约束，但通常我们不将字段本身定义为枚举直接暴露给前端。期望能够通过直接引用枚举类，达成约束。\n * 场景2：字段为String，约束传递的字段只能是一组特定的String字符串\n * 场景3：字段为Integer，约束传递的字段只能是一组特定的Integer值\n * 场景4：字段为List<String>，约束传递的字段只能是一组特定的String字符串\n\n自定义的过程比较简单\n\n第一步：新增一个你的自定义注解，这里为SpecifiesValueValidator\n\n自定义注解的写法可完全照搬@NotNull等注解，稍微改动下@Constraint的validatedBy属性为当前自定义注解类，同时加上可重复性校验注解(非必须)@Repeatable(SpecifiesValueValidator.List.class)，用于支持多个自定义注解使用在同一字段。\n\n@Target({METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER})\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Constraint(validatedBy = {SpecifiesValueValidatorImpl.class})\n@Repeatable(SpecifiesValueValidator.List.class)\npublic @interface SpecifiesValueValidator {\n    /**\n     * 默认校验消息\n     *\n     * @return String\n     */\n    String message() default "入参必须为指定值";\n\n    /**\n     * 分组校验\n     *\n     * @return Class<?>[]\n     */\n    Class<?>[] groups() default {};\n\n    /**\n     * 负载\n     *\n     * @return Class<? extends Payload>[]\n     */\n    Class<? extends Payload>[] payload() default {};\n\n    /**\n     * 指定特定String值\n     *\n     * @return String[]\n     */\n    String[] strGroup() default {};\n\n    /**\n     * 指定特定int值\n     *\n     * @return int[]\n     */\n    int[] intGroup() default {};\n\n    /**\n     * 指定枚举类型\n     *\n     * @return Class<?>\n     */\n    Class<?> enumClass() default Class.class;\n\n    /**\n     * 可重复校验\n     */\n    @Target({METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER})\n    @Retention(RetentionPolicy.RUNTIME)\n    @Documented\n    @interface List {\n        SpecifiesValueValidator[] value();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\n第二步：实现javax.validation.ConstraintValidator接口\n\n泛型第一个参数为自定义注解，第二个参数为被加上注解的字段值\n\n这里在请求初始化时将规定的合法值加载进内存，校验的过程逻辑非常简单，符合返回true，反之false即可\n\npublic class SpecifiesValueValidatorImpl implements ConstraintValidator<SpecifiesValueValidator, Object> {\n\n    private Class<?> enumClass;\n\n    private HashSet<String> strSet;\n\n    private Set<Integer> intSet;\n\n    @Override\n    public void initialize(SpecifiesValueValidator constraintAnnotation) {\n        String[] strGroup = constraintAnnotation.strGroup();\n        strSet = new HashSet<>(Arrays.asList(strGroup));\n        int[] intGroup = constraintAnnotation.intGroup();\n        intSet = Arrays.stream(intGroup).boxed().collect(Collectors.toSet());\n        enumClass = constraintAnnotation.enumClass();\n    }\n\n    /**\n     * 此时value为被注解的字段类型\n     *\n     * @param value   object to validate\n     * @param context context in which the constraint is evaluated\n     * @return boolean\n     */\n    @Override\n    public boolean isValid(Object value, ConstraintValidatorContext context) {\n        try {\n            if (null == value) {\n                return true;\n            }\n            if (enumClass.isEnum()) {\n                return validEnum(value, enumClass);\n            }\n            if (value instanceof String && strSet.contains(value)) {\n                return true;\n            }\n            if (value instanceof Integer && intSet.contains(value)) {\n                return true;\n            }\n            if (value instanceof List) {\n                return validList(value, strSet);\n            }\n        } catch (NoSuchMethodException e) {\n            throw ExceptionFactory.sysException(enumClass + "枚举类没有getCode方法", e);\n        } catch (Exception e) {\n            throw ExceptionFactory.sysException("特定值校验器异常", e);\n        }\n        return false;\n    }\n\n    public static boolean validEnum(Object value, Class<?> enumClass) throws InvocationTargetException, IllegalAccessException, NoSuchMethodException {\n        // 获取传入的枚举class的所有定义的枚举，反射获取code判断是否和入参相同\n        Object[] enumConstants = enumClass.getEnumConstants();\n        for (Object enumConstant : enumConstants) {\n            Method method = enumClass.getDeclaredMethod("getCode");\n            Object invokeResult = method.invoke(enumConstant);\n            if (invokeResult.equals(value)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static boolean validList(Object value, Set<String> strSet) {\n        for (Object v : (List<?>) value) {\n            String cast = (String) v;\n            if (!strSet.contains(cast)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n\n\n以UserSpValid类为例\n\npublic class UserSpValid {\n\n\n    @NotNull(message = "手机品牌不能为空")\n    @SpecifiesValueValidator(message = "手机品牌需符合枚举", enumClass = PhoneBrandEnums.class)\n    private String phoneBrand;\n\n    @SpecifiesValueValidator(message = "用户状态需要符合规则", intGroup = {1, 2, 3})\n    private Integer status;\n\n    @SpecifiesValueValidator(message = "用户的学校需要符合规则", strGroup = {"11", "22", "33"})\n    private String shchool;\n\n    @SpecifiesValueValidator(message = "传输list需要符合规则", strGroup = {"456","789"})\n    private List<String> testList;\n    \n    // 省略get/set\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n其中枚举PhoneBrandEnums为\n\npublic enum PhoneBrandEnums implements StatusCode {\n\n    /**\n     * 苹果\n     */\n    IPHONE("0", "苹果手机"),\n    /**\n     * 华为\n     */\n    HUAWEI("1", "华为手机"),\n    /**\n     * 小米\n     */\n    XIAOMI("2", "小米手机");\n\n    private String code;\n\n    private String message;\n\n    PhoneBrandEnums(String code, String message) {\n        this.code = code;\n        this.message = message;\n    }\n\n    @Override\n    public String getCode() {\n        return code;\n    }\n\n    @Override\n    public String getMessage() {\n        return message;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n为了方便校验枚举类型，通常需要实现接口(这里为StatusCode)，因为枚举校验实现中需要getDeclaredMethod("getCode")之后进行inovke\n\n对应的Controller写法和之前没有变化\n\n@PostMapping("/validateSp")\npublic String test3(@Validated @RequestBody UserSpValid user) {\n    System.out.println(1);\n    return "success";\n}\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n当Postman传输如下参数时，校验器将对参数进行校验，比如此时的phoneBrand字段必须是枚举中的值\n\n\n\n显然以上参数都是无法通过校验的，对应的控制台打印为\n\n\n\n\n# Spring Validation与Dubbo Validation\n\nSpring Validation主要提供了编程式的校验验证，以及@Validated注解，支持了@Valid混用等多种场景，由于本文篇幅原因使用方法及原理这里不做过多介绍，mvc处理最终会调用hibernate validator的校验，Spring只是在处理过程中包装了一层，可以通过文章6进行了解[6]。\n\nDubbo Validation主要提供RPC时对参数的校验，本质上也依赖于javax与hibernate的包，在客户端和服务端均可单独开启校验，对于需要开启校验的接口加上validation="true"即可，dubbo2.1.x以上版本均支持，最佳实践可参考官方文档[7]\n\n在客户端验证参数\n\n<dubbo:reference id="validationService" interface="org.apache.dubbo.examples.validation.api.ValidationService" validation="true" />\n\n\n1\n\n1\n\n\n在服务端验证参数\n\n<dubbo:service interface="org.apache.dubbo.examples.validation.api.ValidationService" ref="validationService" validation="true" />\n\n\n1\n\n1\n\n\n\n# 实践对比\n\n简单结合自定义校验和基本校验，观察两者代码量上的区别\n\n未使用参数校验注解\n\n\n\n使用参数校验注解\n\n\n\n显然，没有使用参数校验开发者会写大量的校验代码，场景越复杂，需要考虑非空判断的地方也就越多，很容易写出高复杂度的代码，增加后期维护的难度，难以通过代码检查工具的扫描。而使用参数校验能够极大地减轻开发者的校验压力，校验与实体绑定，Controller逻辑更加简洁、清晰，对应的Controller代码只需要关注实体转化和业务。\n\n\n# 全局异常-快速开始\n\n上文中JSR303校验方法的引入有一个缺点，即错误信息仅体现在控制台日志中，无法反馈给前端。我们希望将错误信息包装在统一的返回体中，此时便需要定义全局异常。\n\n全局异常的好处在于：\n\n 1. 天生适配异常情况下统一返回体的需求，让优雅的参数校验更加易用\n 2. 结合Http Code释放前、后端代码压力，减轻前后端对接业务code沟通成本。促进前端请求/处理数据代码和后端返回代码模板化，让开发者专注推动业务，减少联调周期，清晰前后端问题处理边界\n 3. 允许开发者在系统内任意位置通过简单的throw new XXException，完成异常情况下统一返回体的包装。无论代码层级多深，轻松实现统一返回，彻底告别系统内部除RPC接口，想要返回给前端异常信息仍然需要手动包装统一返回体，手动一层一层返回的情况，减少系统内非必要判空和传输体体积\n 4. 精简代码，降低大量try catch引起的代码简洁性问题\n 5. 全局兜底日志，结合唯一请求等信息，不再出现忘记打印日志，重新部署代码再排查问题的情况\n 6. 配合自定义异常，做到抛特定异常=打特定日志=返回对应Http Code+统一返回体，全面覆盖通用场景\n\n作为前置知识，这里首先讲解统一返回体\n\n\n# 统一返回体\n\n绝大多数公司都会定义自己的统一返回体，以一个简单的返回体为例，包含错误代码errCode，简要错误errMessage，详细信息detailMessage，数据data，4个字段，通常会结合泛型书写一些请求成功和请求失败的重载方法。\n\npublic class Response<T> implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    private String errCode;\n\n    private String errMessage;\n\n    private String detailMessage;\n\n    private T data;\n\n    public Response() {\n\n    }\n\n    public Response(String errCode, String errMessage, String detailMessage) {\n        this.errCode = errCode;\n        this.errMessage = errMessage;\n        this.detailMessage = detailMessage;\n    }\n\n    public Response(String errCode, String errMessage) {\n        this(errCode, errMessage, "");\n    }\n\n    public Response(T data) {\n        errCode = "";\n        errMessage = "";\n        setData(data);\n    }\n\n    public Response(StatusCode statusCode) {\n        errCode = statusCode.getCode();\n        errMessage = statusCode.getMessage();\n    }\n\n    public static <T> Response<T> success() {\n        return new Response<>(ResponseCode.SUCCESS);\n    }\n\n    public static <T> Response<T> success(T data, String errCode, String errMessage) {\n        Response<T> response = new Response<>();\n        response.setData(data);\n        response.setErrCode(errCode);\n        response.setErrMessage(errMessage);\n        return response;\n    }\n\n    public static <T> Response<T> success(T data) {\n        return success(data, ResponseCode.SUCCESS.getCode(), ResponseCode.SUCCESS.getMessage());\n    }\n\n    public static <T> Response<T> success(T data, String errMessage) {\n        return success(data, ResponseCode.SUCCESS.getCode(), errMessage);\n    }\n\n\n    public static <T> Response<T> fail(String errCode, String errMessage) {\n        Response<T> response = new Response<>();\n        response.setErrCode(errCode);\n        response.setErrMessage(errMessage);\n        return response;\n    }\n\n    public static <T> Response<T> fail() {\n        return fail(ResponseCode.FAILED.getCode(), ResponseCode.FAILED.getMessage());\n    }\n\n    public static <T> Response<T> fail(StatusCode statusCode) {\n        return fail(statusCode.getCode(), statusCode.getMessage());\n    }\n\n    public static <T> Response<T> fail(StatusCode statusCode, String detailMessage) {\n        Response<T> response = new Response<>();\n        response.setErrCode(statusCode.getCode());\n        response.setErrMessage(statusCode.getMessage());\n        response.setDetailMessage(detailMessage);\n        return response;\n    }\n\n    public static <T> Response<T> fail(T data, String errCode, String errMessage) {\n        Response<T> response = new Response<>();\n        response.setData(data);\n        response.setErrCode(errCode);\n        response.setErrMessage(errMessage);\n        return response;\n    }\n    // 省略get/set等\n    \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n\n\n用Controller、Service、Dao经典的MVC分层，看看下面这个典型的请求例子\n\nController\n\n@RestController\n@RequestMapping("/test")\npublic class TestController {\n\n    @Autowired\n    private TestService testService;\n\n    @PostMapping("/getUser")\n    public Response<User> test6(@RequestBody User user) {\n        User user1 = testService.getUser(user.getId());\n        return Response.success(user1);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nService\n\npublic interface TestService {\n    User getUser(String id);\n}\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n@Service\npublic class TestServiceImpl implements TestService {\n\n    @Autowired\n    private TestDao testDao;\n\n    @Override\n    public User getUser(String id) {\n        // 写一些业务逻辑，比如转换id等等\n        return testDao.getUserById(id);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nDao\n\npublic interface TestDao {\n    User getUserById(String id);\n}\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n@Repository\npublic class TestDaoImpl implements TestDao {\n\n    @Autowired\n    private UserMapper userMapper;\n\n    @Override\n    public User getUserById(String id) {\n        User userByUserId = null;\n        try {\n            // 其他逻辑\n            userByUserId = userMapper.getUserByUserId(id);\n        } catch (Exception e) {\n            throw new RuntimeException("报错了");\n        }\n        return userByUserId;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n正常请求接口，这看上去没有什么问题，但如果上述查询数据库的代码出现异常了，这句"报错了"的消息前端是不知道的，有的时候我们希望将这些已知的异常捕获住并返回一个特定的消息告诉前端。这时候，有同学可能会这样修改\n\nController\n\n@PostMapping("/getUserWrap")\npublic Response<User> test7(@RequestBody User user) {\n    Response<User> userWrap = testService.getUserWrap(user.getId());\n    return userWrap;\n}\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\nService\n\npublic interface TestService {\n    \n    Response<User> getUserWrap(String id);\n}\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n@Service\npublic class TestServiceImpl implements TestService {\n\n    @Autowired\n    private TestDao testDao;\n\n    @Override\n    public Response<User> getUserWrap(String id) {\n        // 写一些业务逻辑，比如转换id等等\n        return testDao.getUserByIdWrap(id);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nDao\n\npublic interface TestDao {\n\n    Response<User> getUserByIdWrap(String id);\n}\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n@Repository\npublic class TestDaoImpl implements TestDao {\n\n    @Autowired\n    private UserMapper userMapper;\n\n    @Override\n    public Response<User> getUserByIdWrap(String id) {\n        User userByUserId = null;\n        try {\n            // 其他逻辑\n            userByUserId = userMapper.getUserByUserId(id);\n        } catch (Exception e) {\n            // 这里同样可以用Response.fail()方法，手动set的写法是考虑有些返回体没有重载方法\n            // 如果有重载方法则Response.fail(ResponseCode.FAILED.getCode(),"报错了")替代下面3行\n            Response<User> response = new Response<>();\n            response.setErrCode(ResponseCode.FAILED.getCode());\n            response.setErrMessage("报错了");\n            return response;\n        }\n        return Response.success(userByUserId);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n这种方式给内层的所有方法加上统一返回体，虽然满足了返回给前端异常消息的需求，但需要在最内层开始一层一层返回。如果包装的返回体没有提供便捷的重载方法，甚至需要手动set出错误体，同时对于可复用的Dao层，其余方法在调用他时还需要再从统一返回体中取出真正的对象。长期下去会产生大量的冗余代码，降低了效率，显得不够整洁。\n\n或许你看到这里觉得仅仅只是给Service、Dao加上了一下返回体包装，如果加上返回体的重载方法，这样返回也还好。那么我们继续看下面这个例子，即返回体地狱。\n\n一个Service不仅仅依赖于一次SQL查询，那么他可能会使用多个Dao或一个Dao中的多个方法，为上文中的Controller添加save方法，同时改变Service、Dao支持saveOrUpdate操作为如下\n\nController\n\n@PostMapping("/save")\npublic Response<Boolean> test8(@RequestBody User user) {\n    Response<Boolean> result = testService.saveOrUpdate(user);\n    return result;\n}\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\nService\n\npublic interface TestService {\n\n    Response<Boolean> saveOrUpdate(User user);\n}\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n@Service\npublic class TestServiceImpl implements TestService {\n\n    @Autowired\n    private TestDao testDao;\n\n    @Override\n    public Response<Boolean> saveOrUpdate(User user) {\n        Response<Boolean> response = new Response<>();\n        // 传输id不为空为update，否则为新增\n        if (StringUtils.isEmpty(user.getId())) {\n            try {\n                int insertRow = testDao.insert(user);\n                if (insertRow < 1) {\n                    response.setErrCode(ResponseCode.FAILED.getCode());\n                    response.setErrMessage("新增失败");\n                    return response;\n                } else {\n                    response.setErrCode(ResponseCode.SUCCESS.getCode());\n                    response.setErrMessage("新增成功");\n                    return response;\n                }\n            } catch (Exception e) {\n                response.setErrCode(ResponseCode.FAILED.getCode());\n                response.setErrMessage("新增时异常");\n                return response;\n            }\n        } else {\n            try {\n                int insertRow = testDao.update(user);\n                if (insertRow < 1) {\n                    response.setErrCode(ResponseCode.FAILED.getCode());\n                    response.setErrMessage("更新失败");\n                    return response;\n                } else {\n                    response.setErrCode(ResponseCode.SUCCESS.getCode());\n                    response.setErrMessage("更新成功");\n                    return response;\n                }\n            } catch (Exception e) {\n                response.setErrCode(ResponseCode.FAILED.getCode());\n                response.setErrMessage("更新时异常");\n                return response;\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\nDao\n\npublic interface TestDao {\n    \n\tint insert(User user);\n\n    int update(User user);\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n@Repository\npublic class TestDaoImpl implements TestDao {\n\n    @Autowired\n    private UserMapper userMapper;\n\n    @Override\n    public int insert(User user) {\n        return userMapper.insert(user);\n    }\n\n    @Override\n    public int update(User user) {\n        return userMapper.update(user);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n其中Dao层的处理专门模拟了没有进行try catch处理的情况。\n\n这时候的Service需要做的很多，对每一个Dao层结果处理都需要进行try catch然后包装返回体，打印错误日志，这里真实的业务实际上只是如下4行，但由于Dao层处理的不规范，加上不得不包装返回体的原因，这里需要写很多代码，而这些代码仅仅只是为了满足让前端感知错误消息这一需求\n\nif (StringUtils.isEmpty(user.getId())) {\n    int insertRow = testDao.insert(user);\n} else {\n    int updateRow = testDao.update(user);\n}\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n上述方法如果也没有结合参数校验注解，将会使得Controller层也会出现同样的情况，同时还有可能增加Service在业务校验上包装返回体提示的代码，这样开发者无法专注于真正的业务逻辑，更多的是在处理如何进行友好返回。\n\n后文将解释全局异常的出现是如何克服该问题。\n\n\n# 全局异常捕获\n\n# 为什么用Http Code\n\n本文的全局异常与Http Code、自定义异常紧密结合。\n\n在最新的阿里官方发布(2022.2.3)的《阿里巴巴Java开发手册》[8]中，强制规范提到返回给前端的响应信息必须包含HTTP状态码，errCode，errorMessage，用户提示信息4个部分。\n\n\n\n其中Http状态码!=errCode，在调研过程中我们发现有不少的公司全统一采用了Http Code=200的情况，通过errCode来表示业务的状态码，关于这一点网上的讨论非常激烈[9]。总结起来就是，部分网友认为Http为网络层协议，表达网络含义，不应该表达业务。另外有人表示这是历史原因，以前返回非200状态码会被运营商拦截，当然现在没有这个情况了。还有说HTTP Code不够业务使用，所以得用errCode表示。听起来都有道理。\n\n就落地而言，如果仅仅使用errCode虽然看起来各自的产品运行得没有问题，但实际上这里存在一个隐藏的时间成本，涉及到前后端联调沟通、接口问题排查边界、接口请求处理代码模版的问题。\n\n以下面这个真实案例开始\n\n在公司内的前端涉及到对接多个系统，当所有接口无论错误或正确都返回Http Code=200时，前端通过errCode区分这次结果到底是正确还是错误，可能写出的代码为\n\nif(errCode=="20000") {\n    status = 200\n    data = response\n}\nif(errCode = "200001") {\n    status = 500\n    msg = response.errors\n}\nif(dataList = true && dataList.length>0) {\n    status = 200\n    data = response\n}\nswitch (status) {\n    case 200: // 做处理\n    case 500: // 做处理\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n以上代码的status为前端拿到的该请求的Http Code，可以显然看出，前端需要对后端传输的errCode进行区分，然后才能知道这次的Http Code到底应该转化为多少，因为后端统一都是传的200。如果前端仅仅只对接一个系统，那么可能后端定义的errCode是固定不变的，则前端可以写出固定的处理请求的模版覆盖提示场景、异常场景、正确请求场景。\n\n弊端解释：\n\n 1. 上述情况仅仅是一种理想的状态，现实是各个后端系统所定义的异常枚举类都不相同，统一各个系统采用一份异常枚举类是不现实的，导致前端在对接每个系统的时候都需要沟通系统各自枚举Code的含义，如果枚举Code耦合或差异大，无疑会写出成片需要特殊转换，毫无规律的处理代码。还可能出现Http Code返回200，但接口内返回500这种存在二义性的场景。造成联调成本的上升。\n 2. 当一个接口出现问题时，开发者从F12中海量的接口请求很难一眼看出到底哪个接口出现了问题，是前端的问题？还是后端的问题？在Http Code为200的场景下，经常会发生前端排查半天发现是后端的问题，后端排查半天发现是前端传参的问题。排查问题的边界难以确定，一个问题甚至同时需要前后端多个人力一起来看。\n 3. 全200情况下，errCode对前端观测的无用性，如果有完善的接口监控系统，那么在全200情况下将无法识别接口到底成功还是失败，定制化开发监控平台会增加成本。从上面的实例代码也能看出，前端对于后端的errCode仅仅是做出了一次转化，到底这个errCode代表什么前端不知道，属于后端需要观测的范围。\n\n显然单纯采用errCode会增加前后端开发负担。\n\n对于业务服务而言，我们最为常用的Http Code应该为如下3个，对于401未授权,404未找到等状态码，应该交给网关服务\n\n * 200-请求成功：代表着本次请求是成功的\n * 400-请求参数有误：代表着本次请求的参数有误，需要前端处理\n * 500-服务器内部错误：代表着本次请求的服务端错误，需要后端处理\n\n如图200，400，500，其中400和500显示红色，请求很多的情况下也能明显可见\n\n\n\n\n\n\n\n在后文自定义异常栏，我们将展示Http Code和自定义异常的结合。\n\n# Web Controller\n\n全局异常是Spring3.2开始就有的方法，主要提供了@RestControllerAdvice和@ControllerAdvice2个注解定义全局异常。@RestControllerAdvice=@ControllerAdvice+@ResponseBody。一般定义一个@RestControllerAdvice即可。同时采用@ExceptionHandler指定处理哪种异常。\n\n一个简单的全局异常例子为，捕获系统内所有的异常，并返回1\n\n@RestControllerAdvice\npublic class ExceptionErrorHandler {\n\n    @ExceptionHandler(Exception.class)\n    public Object handleException(Exception exception) {\n        // 自定义处理\n        return "1";\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n当然了，在真实的系统中，我们需要对异常进行分类对不同种异常做出不一样的处理。\n\n首先加入对参数校验异常的兼容，主要有如下3个\n\n * MethodArgumentNotValidException\n\n使用javax、hibernate参数校验注解会抛出BindException，而BindException会将错误信息绑定在BindingResult中，我们可以直接捕获BindException对BindingResult进行处理，但这样处理起来是没有格式化的，也可以采用MethodArgumentNotValidException通过内部方法直接返回格式化之后的BindingResult的相关信息。\n\n具体处理的对象为@Valid、@Validated、以及@NotNull、@NotEmpty等注解注释的实体或方法\n\n * HttpMessageNotReadableException\n\n处理Http消息不可读的异常，当如参数传入为String类型字段，但接收方为Integer类型。使用@RequestBody规定传输Json，但前端并没有传递参数或前端传输为表单类型。后端只支持Get，但前端发送Post等类似场景会抛出该异常。\n\n * MissingServletRequestParameterException\n\n处理缺少参数异常，即后端指定有@RequestParam必传参数，前端没有传递该参数时将会抛出该异常。\n\n对应的全局异常处理为\n\n@RestControllerAdvice\n@Order(Ordered.HIGHEST_PRECEDENCE)\npublic class ExceptionErrorHandler {\n\n    private static final Logger logger = LoggerFactory.getLogger(ExceptionErrorHandler.class);\n\n    @ExceptionHandler(MethodArgumentNotValidException.class)\n    public ResponseEntity<Response<Object>> handleBindException(MethodArgumentNotValidException validException) {\n        final Trace trace = TraceIdUtils.getTrace();\n        String validateMessage = Objects.requireNonNull(validException.getBindingResult().getFieldError()).getDefaultMessage();\n        logger.warn("请求Id:{}, SpanId:{}, 参数校验失败:{}", trace.getTraceId(), trace.getSpanId(), validateMessage);\n        if (logger.isDebugEnabled()) {\n            logger.debug(validException.getMessage(), validException);\n        }\n        final Response<Object> failResponse = Response.fail(ResponseCode.VALIDATE_ERROR, validateMessage);\n        return new ResponseEntity<>(failResponse, HttpStatus.BAD_REQUEST);\n    }\n\n    @ExceptionHandler(HttpMessageNotReadableException.class)\n    public ResponseEntity<Response<Object>> handleNotReadException(HttpMessageNotReadableException notReadableException) {\n        final Trace trace = TraceIdUtils.getTrace();\n        logger.warn("请求Id:{}, SpanId:{}, 错误码:{}, 错误信息:{}, 详细信息:{}", trace.getTraceId(), trace.getSpanId(),\n                ResponseCode.READ_JSON_ERROR.getCode(), ResponseCode.READ_JSON_ERROR.getMessage(), notReadableException.getMessage());\n        if (logger.isDebugEnabled()) {\n            logger.debug(notReadableException.getMessage(), notReadableException);\n        }\n        final Response<Object> failResponse = Response.fail(ResponseCode.READ_JSON_ERROR, ResponseCode.READ_JSON_ERROR.getMessage());\n        return new ResponseEntity<>(failResponse, HttpStatus.BAD_REQUEST);\n    }\n\n    @ExceptionHandler(MissingServletRequestParameterException.class)\n    public ResponseEntity<Response<Object>> handleParameterException(MissingServletRequestParameterException misException) {\n        final Trace trace = TraceIdUtils.getTrace();\n        String missParams = String.format("%s参数, 类型%s缺失", misException.getParameterName(),misException.getParameterType());\n        logger.warn("请求Id:{} ,SpanId:{} ,详细信息:{}",trace.getTraceId(), trace.getSpanId(), missParams);\n        if (logger.isDebugEnabled()) {\n            logger.debug(misException.getMessage(), misException);\n        }\n        final Response<Object> failResponse = Response.fail(ResponseCode.INVALID_PARAMETER, missParams);\n        return new ResponseEntity<>(failResponse, HttpStatus.BAD_REQUEST);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n此处的@Order指定了该异常处理的时机，避免在SpringMVC项目中全局异常还没处理，请求就返回跳转页面的情况。new ResponseEntity<>()由org.springframework.http提供，支持包装HttpCode和统一返回体，这里的HttpStatus.BAD_REQUEST，体现在页面上即状态码400，当然也可采用@ResponseStatus()注解。\n\n全局异常处理的逻辑非常简单，拿到异常后将异常消息包装进返回体即可。同时我们可以结合任意分布式链路跟踪系统，打印唯一请求id及错误消息，在debug模式下开启堆栈的跟踪。做到前后端均有兜底感知。\n\n加入全局异常后，我们再次请求参数校验时的例子，可以发现参数不正确时的异常包装，与控制台的唯一请求日志\n\n\n\n\n\n此时的消息为校验实体注解上所编写的消息。\n\n# 自定义异常\n\n在全局异常捕获了参数校验异常后，我们就可以省去关于Http请求的代码校验，仅需要使用注解即可自动包装返回体和提示语给前端。此时只要前端或后端看到状态码400，就明确知道这是前端的传参问题。\n\n当然了，除了参数校验异常，业务上也需要自定义异常，根据开发手册和SonrLint的提示，这一步是必备的。\n\n本文的自定义异常定义参考了，阿里COLA[10]整洁架构中cola-component-exception的异常定义\n\n分为1+5类：\n\n * AbstractException：抽象异常类\n\npublic abstract class AbstractException extends RuntimeException {\n\n    private static final long serialVersionUID = 1L;\n\n    private String errCode;\n\n    private String errMessage;\n\n    protected AbstractException(String errMessage) {\n        super(errMessage);\n    }\n\n    protected AbstractException(String errMessage, Throwable throwable) {\n        super(errMessage, throwable);\n    }\n\n    protected AbstractException(String errCode, String errMessage) {\n        super(errMessage);\n        this.setErrCode(errCode);\n        this.setErrMessage(errMessage);\n    }\n\n    protected AbstractException(String errCode, String errMessage, Throwable throwable) {\n        super(errMessage, throwable);\n        this.setErrCode(errCode);\n        this.setErrMessage(errMessage);\n    }\n\n    protected AbstractException(StatusCode statusCode) {\n        this(statusCode.getCode(), statusCode.getMessage());\n    }\n\n    protected AbstractException(StatusCode statusCode, Throwable throwable) {\n        super(statusCode.getMessage(), throwable);\n    }\n\n    public String getErrCode() {\n        return errCode;\n    }\n\n    public void setErrCode(String errCode) {\n        this.errCode = errCode;\n    }\n\n    public String getErrMessage() {\n        return errMessage;\n    }\n\n    public void setErrMessage(String errMessage) {\n        this.errMessage = errMessage;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n * ValidException：业务类校验异常，固定errCode\n\npublic class ValidException extends AbstractException {\n\n    private static final long serialVersionUID = 1L;\n\n    private static final ResponseCode DEFAULT_VALID_ERRCODE = ResponseCode.VALID_EXCEPTION_CODE;\n\n    public ValidException(String errMessage) {\n        super(DEFAULT_VALID_ERRCODE.getCode(), errMessage);\n    }\n\n    public ValidException(String errCode, String errMessage) {\n        super(errCode, errMessage);\n    }\n\n    public ValidException(StatusCode statusCode) {\n        super(statusCode.getCode(), statusCode.getMessage());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n * BizException：业务类异常(含堆栈)，固定errCode\n\npublic class BizException extends AbstractException {\n\n    private static final long serialVersionUID = 1L;\n\n    private static final ResponseCode DEAULT_BIZ_ERRCODE = ResponseCode.BIZ_EXCEPTION_CODE;\n\n    public BizException(String errMessage, Throwable e) {\n        super(DEAULT_BIZ_ERRCODE.getCode(), errMessage, e);\n    }\n\n    public BizException(StatusCode statusCode, Throwable e) {\n        super(statusCode.getCode(), statusCode.getMessage(), e);\n    }\n\n    public BizException(String errCode, String errMessage, Throwable e) {\n        super(errCode, errMessage, e);\n    }\n\n    public BizException(Throwable e) {\n        super(DEAULT_BIZ_ERRCODE, e);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n * BizNoStackException：业务类异常(不带堆栈信息)，固定errCode\n\npublic class BizNoStackException extends AbstractException implements Serializable {\n\n    private static final long serialVersionUID = 2628908675799105091L;\n\n    private static final ResponseCode DEAULT_BIZ_ERRCODE = ResponseCode.BIZ_NOSTACK_EXCEPTION;\n\n\n    public BizNoStackException(String errMessage) {\n        super(DEAULT_BIZ_ERRCODE.getCode(), errMessage);\n    }\n\n    public BizNoStackException(String errCode, String errMessage) {\n        super(errCode, errMessage);\n    }\n\n    public BizNoStackException(StatusCode statusCode) {\n        super(statusCode.getCode(), statusCode.getMessage());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * SysException：系统级异常(带堆栈)，固定errCode\n\npublic class SysException extends AbstractException {\n\n    private static final long serialVersionUID = 1L;\n\n    private static final ResponseCode DEFAULT_SYS_ERRCODE = ResponseCode.SYS_EXCEPTION_CODE;\n\n    public SysException(String errMessage, Throwable e) {\n        super(DEFAULT_SYS_ERRCODE.getCode(), errMessage, e);\n    }\n\n    public SysException(StatusCode statusCode, Throwable e) {\n        super(statusCode.getCode(), statusCode.getMessage(), e);\n    }\n\n    public SysException(String errCode, String errMessage, Throwable e) {\n        super(errCode, errMessage, e);\n    }\n\n    public SysException(Throwable e) {\n        super(DEFAULT_SYS_ERRCODE, e);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n * RpasException：任意异常类(宽松条件)\n\npublic class RpasException extends RuntimeException {\n\n    private static final long serialVersionUID = 1L;\n\n    private String errCode;\n\n    private String errMessage;\n\n    private String detailMessage;\n\n    public RpasException() {\n        super();\n    }\n\n    public RpasException(String errCode, String errMessage, String detailMessage) {\n        super(errMessage);\n        this.errCode = errCode;\n        this.errMessage = errMessage;\n        this.detailMessage = detailMessage;\n    }\n\n    public RpasException(String errCode, String errMessage) {\n        this(errCode, errMessage, null);\n    }\n\n    public RpasException(StatusCode statusCode) {\n        this(statusCode.getCode(), statusCode.getMessage(), null);\n    }\n\n    public RpasException(StatusCode statusCode, String detailMessage) {\n        this(statusCode.getCode(), statusCode.getMessage(), detailMessage);\n    }\n\n    public String getErrCode() {\n        return errCode;\n    }\n\n    public String getErrMessage() {\n        return errMessage;\n    }\n\n    public String getDetailMessage() {\n        return detailMessage;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n我们希望各类异常与Http Code进行绑定，同时固定状态码，达成抛特定异常=打特定日志=返回对应Http Code+统一返回体的效果。总结起来如下场景\n\n 1. 日志级别WARN:对于前置校验类异常，正常来说状态码为400，代表前端参数错误，400状态下前端不能直接拿到返回体，需要前端异常捕获配合才能打印msg，该类型异常已知，不需要人工处理\n 2. 日志级别WARN:对于业务类校验异常ValidException(不带堆栈)，状态码为200，表示请求正常只是业务拦截，该类型异常已知，不需要人工处理\n 3. 日志级别WARN：对于业务类异常BizException(带堆栈)、BizNoStackException(不带堆栈)，状态码200，表示请求正常只是业务拦截，该类型异常已知，不需要人工处理\n 4. 日志级别ERROR:对于已知可能发生的系统级异常SysException(带堆栈)，状态码为500，表示出现系统异常，开发者手动抛出该异常说明，该系统级异常已知，需要人工处理\n 5. 日志级别ERROR:对于未知的发生的系统级异常Exception(带堆栈)，状态码500，表示出现未知的没有被try catch的异常，需要人工处理\n 6. 日志级别WARN:用于非固定状态码任意位置的异常RpasException(可带堆栈、也可不带)，状态码200，由于该类接受任意状态码，目的是兼容前端对接业务状态码场景，可用于兼容存量项目做全局异常\n\n根据上述场景总结，我们可以写出对应的全局异常代码如下\n\n@ExceptionHandler(ValidException.class)\npublic ResponseEntity<Response<Object>> handleValidException(ValidException validException) {\n    final Trace trace = TraceIdUtils.getTrace();\n    String errCode = validException.getErrCode();\n    String message = validException.getMessage();\n    logger.warn("请求Id:{}, SpanId:{}, 参数校验异常:{}, 错误码:{}", trace.getTraceId(), trace.getSpanId(), message, errCode);\n    final Response<Object> failResponse = Response.fail(errCode, message);\n    return new ResponseEntity<>(failResponse, HttpStatus.OK);\n}\n\n@ExceptionHandler(BizException.class)\npublic ResponseEntity<Response<Object>> handleBizException(BizException bizException) {\n    final Trace trace = TraceIdUtils.getTrace();\n    String errCode = bizException.getErrCode();\n    String message = bizException.getMessage();\n    logger.warn("请求Id:{}, SpanId:{}, 业务异常:{}, 错误码:{}, 详细信息:", trace.getTraceId(), trace.getSpanId(), message, errCode, bizException);\n    if (logger.isDebugEnabled()) {\n        logger.debug(message, bizException);\n    }\n    final Response<Object> failResponse = Response.fail(errCode, message);\n    return new ResponseEntity<>(failResponse, HttpStatus.OK);\n}\n\n@ExceptionHandler(BizNoStackException.class)\npublic ResponseEntity<Response<Object>> handleBizNoStackException(BizNoStackException bizNoStackException) {\n    final Trace trace = TraceIdUtils.getTrace();\n    String errCode = bizNoStackException.getErrCode();\n    String message = bizNoStackException.getMessage();\n    logger.warn("请求Id:{}, SpanId:{}, 业务异常(无堆栈):{}, 错误码:{}", trace.getTraceId(), trace.getSpanId(), message, errCode);\n    final Response<Object> failResponse = Response.fail(errCode, message);\n    return new ResponseEntity<>(failResponse, HttpStatus.OK);\n}\n\n@ExceptionHandler(SysException.class)\npublic ResponseEntity<Response<Object>> handleSysException(SysException sysException) {\n    final Trace trace = TraceIdUtils.getTrace();\n    String errCode = sysException.getErrCode();\n    String message = sysException.getMessage();\n    logger.error("请求Id:{}, SpanId:{}, 系统异常:{}, 错误码:{}, 详细信息:", trace.getTraceId(), trace.getSpanId(), message, errCode, sysException);\n    if (logger.isDebugEnabled()) {\n        logger.debug(message, sysException);\n    }\n    final Response<Object> failResponse = Response.fail(errCode, message);\n    return new ResponseEntity<>(failResponse, HttpStatus.INTERNAL_SERVER_ERROR);\n}\n\n@ExceptionHandler(RpasException.class)\npublic ResponseEntity<Response<Object>> handleRpasException(RpasException rpasException) {\n    final Trace trace = TraceIdUtils.getTrace();\n    String errCode = rpasException.getErrCode();\n    String message = rpasException.getMessage();\n    String detailMessage = rpasException.getDetailMessage();\n    logger.error("请求Id:{}, SpanId:{}, 系统内部异常:{}, 错误码:{}, 详细信息:{}", trace.getTraceId(), trace.getSpanId(), message, errCode, detailMessage);\n    if (logger.isDebugEnabled()) {\n        logger.debug(message, rpasException);\n    }\n    final Response<Object> failResponse = Response.fail(errCode, detailMessage);\n    return new ResponseEntity<>(failResponse, HttpStatus.OK);\n}\n\n@ExceptionHandler(Exception.class)\npublic ResponseEntity<Response<Object>> handleException(Exception exception) {\n    final Trace trace = TraceIdUtils.getTrace();\n    logger.error("请求ID:{}, SpanId:{}, 未知异常:{}, 详细信息:", trace.getTraceId(), trace.getSpanId(), exception.getMessage(), exception);\n    if (logger.isDebugEnabled()) {\n        logger.debug(exception.getMessage(), exception);\n    }\n    final Response<Object> failResponse = Response.fail(ResponseCode.UNKNOWN_EXCEPTION_CODE, exception.getMessage());\n    return new ResponseEntity<>(failResponse, HttpStatus.INTERNAL_SERVER_ERROR);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\n其中，最底下的Exception异常捕获将获取到系统内所有的未知/未捕获的异常，进行错误信息打印和统一返回体的包装，不会在出现漏打日志和异常未被捕获的情况。全局异常的处理顺序从上至下，被上层异常处理过的不会再被之后的异常处理。\n\n在有了完备的异常机制之后，前端仅需要记忆200、400、500的Http Code含义即可，能够书写出固定的请求模板代码，在对接各个系统之间进行复用，极大地减轻了联调的压力，而errCode转变为原本的作用，帮助后端人员快速定位后端服务问题，前/后端也能快速通过状态码看出本次请求出现问题的一方是谁。\n\n提示\n\n需要注意的是，@RestControllerAdvice定义的全局异常机制，只适用于以Controller为入口的请求，在进入Controller之后所调用的所有方法任意位置出现异常，均可生效\n\n# Dubbo RPC\n\n除了Controller为入口的全局异常以外，在提供给第三方接口时，我们通常会用到RPC。对于RPC的异常我们同样需要进行全局异常处理，避免产生提供方接口报错，未进行异常捕获，调用方也未进行异常捕获，将提供方的异常日志打印到调用方，调用方排查半天发现是提供方的问题的情况。\n\n在《阿里巴巴Java开发手册》，也提到过可参考的异常使用方法\n\n\n\n以Dubbo为例，我们可以定义一个Filter进行异常捕获，此时的Filter接口位于org.apache.dubbo.rpc.Filter\n\n@Activate(group = {CommonConstants.PROVIDER})\n@Order(Ordered.HIGHEST_PRECEDENCE)\npublic class DubboExceptionFilter implements Filter {\n\n    private static final Logger logger = LoggerFactory.getLogger(DubboExceptionFilter.class);\n\n    @Override\n    public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {\n        String params = JSONUtil.toJsonStr(invocation.getArguments());\n        logger.info("Global dubbo exception filter, interface:{}, methodName:{}, params:{}",\n                invoker.getInterface(), invocation.getMethodName(), params);\n        Result result = invoker.invoke(invocation);\n        if (result.hasException()) {\n            try {\n                ExceptionHandlerMethodResolver resolver = new ExceptionHandlerMethodResolver(this.getClass());\n                // 获取RPC过程中出现的具体异常\n                Exception exception = (Exception) result.getException();\n                // 从@ExceptionHandler注解方法中找到value为exception方法的特定对象\n                Method method = resolver.resolveMethod(exception);\n                // 找到具体的异常处理类，执行对应处理，这里即返回RemoteResult\n                assert method != null;\n                Object value = method.invoke(this, exception);\n                result.setValue(value);\n                return result;\n            } catch (Throwable e) {\n                logger.error("Dubbo exception filter error, Casued by ", e);\n            }\n        }\n        return result;\n    }\n\n    @ExceptionHandler(ValidException.class)\n    public Object handleValidException(ValidException exception) {\n        final Trace trace = TraceIdUtils.getTrace();\n        logger.warn("catch dubbo validExpcetion, requestId:{}, spanId:{}, exception is:",\n                trace.getTraceId(), trace.getSpanId(), exception);\n        Optional<ValidException> opValid = Optional.ofNullable(exception);\n        String errCode = opValid.map(AbstractException::getErrCode)\n                .orElse(ResponseCode.VALID_EXCEPTION_CODE.getCode());\n        String errMessage = opValid.map(AbstractException::getErrMessage)\n                .orElse(ResponseCode.VALID_EXCEPTION_CODE.getMessage());\n        return Response.fail(errCode, errMessage);\n    }\n\n    @ExceptionHandler(BizException.class)\n    public Object handleBizException(BizException exception) {\n        final Trace trace = TraceIdUtils.getTrace();\n        logger.warn("catch dubbo bizExpcetion, requestId:{}, spanId:{}, exception is:",\n                trace.getTraceId(), trace.getSpanId(), exception);\n        Optional<BizException> opBiz = Optional.ofNullable(exception);\n        String errCode = opBiz.map(AbstractException::getErrCode)\n                .orElse(ResponseCode.BIZ_EXCEPTION_CODE.getCode());\n        String errMessage = opBiz.map(AbstractException::getErrMessage)\n                .orElse(ResponseCode.BIZ_EXCEPTION_CODE.getMessage());\n        return Response.fail(errCode, errMessage);\n    }\n\n    @ExceptionHandler(BizNoStackException.class)\n    public Object handleBizNoStackException(BizNoStackException exception) {\n        final Trace trace = TraceIdUtils.getTrace();\n        logger.warn("catch dubbo bizNoStackException, requestId:{}, spanId:{}, exception is:",\n                trace.getTraceId(), trace.getSpanId(), exception);\n        Optional<BizNoStackException> opValid = Optional.ofNullable(exception);\n        String errCode = opValid.map(AbstractException::getErrCode)\n                .orElse(ResponseCode.VALID_EXCEPTION_CODE.getCode());\n        String errMessage = opValid.map(AbstractException::getErrMessage)\n                .orElse(ResponseCode.VALID_EXCEPTION_CODE.getMessage());\n        return Response.fail(errCode, errMessage);\n    }\n\n    @ExceptionHandler(SysException.class)\n    public Object handleSysException(SysException exception) {\n        final Trace trace = TraceIdUtils.getTrace();\n        logger.error("catch dubbo sysExpcetion, requestId:{}, spanId:{}, exception is:",\n                trace.getTraceId(), trace.getSpanId(), exception);\n        Optional<SysException> opSys = Optional.ofNullable(exception);\n        String errCode = opSys.map(AbstractException::getErrCode)\n                .orElse(ResponseCode.SYS_EXCEPTION_CODE.getCode());\n        String errMessage = opSys.map(AbstractException::getErrMessage)\n                .orElse(ResponseCode.SYS_EXCEPTION_CODE.getMessage());\n        return Response.fail(errCode, errMessage);\n    }\n\n    @ExceptionHandler(RpasException.class)\n    public Object handleRpasException(RpasException exception) {\n        final Trace trace = TraceIdUtils.getTrace();\n        logger.error("catch dubbo rpasExpcetion, requestId:{}, spanId:{}, exception is:",\n                trace.getTraceId(), trace.getSpanId(), exception);\n        Optional<RpasException> opRpas = Optional.ofNullable(exception);\n        String errCode = opRpas.map(RpasException::getErrCode)\n                .orElse(ResponseCode.RPAS_EXCEPTION_CODE.getCode());\n        String errMessage = opRpas.map(RpasException::getErrMessage)\n                .orElse(ResponseCode.RPAS_EXCEPTION_CODE.getMessage());\n        return Response.fail(errCode, errMessage);\n    }\n\n    @ExceptionHandler(Exception.class)\n    public Object handleException(Exception exception) {\n        final Trace trace = TraceIdUtils.getTrace();\n        logger.error("catch dubbo unknown Expcetion, requestId:{}, spanId:{}, exception is:",\n                trace.getTraceId(), trace.getSpanId(), exception);\n        Optional<Exception> opExcetion = Optional.ofNullable(exception);\n        String errCode = ResponseCode.UNKNOWN_EXCEPTION_CODE.getCode();\n        String errMessage = opExcetion.map(Exception::getMessage)\n                .orElse(ResponseCode.UNKNOWN_EXCEPTION_CODE.getMessage());\n        return Response.fail(errCode, errMessage);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n\n\n采用@Activate定义Dubbo Filter扩展点，各异常类的处理与之前的全局异常类似，对于每个RPC请求都会打印请求的接口信息、方法名、参数信息，主要实现在于invoke方法内\n\n在这个方法中，会首先进行原生的RPC调用拿到调用的结果，如果出现异常则获取当前Class下的异常处理类，之后将异常处理的结果(包装统一返回体)重新set进原本出现异常的Result中，这样便完成了异常的捕获和异常消息的传递。本文拓展的Dubbo Filter对默认Filter处理无影响。\n\n提供方接入该Dubbo SPI后，调用方无需在对RPC异常进行处理，无论发生什么异常，提供方均会包装返回体返回，调用方只需关系本次统一返回体中的标示位是否成功即可。\n\n在这里有一个经常会遇到的问题：受检异常问题\n\n这个问题的表现在于，假设没有RPC全局异常机制，系统内定义了自定义异常，在提供方的实现方法中抛出自定义异常如throw new BizException()，此时我们预期的是调用方收到的是BizExcption消息，但Dubbo返回的是RuntimeException\n\n这个问题的出现在于Dubbo默认的com.alibaba.dubbo.rpc.filter.ExceptionFilter处理中对于不认识的异常，均会返回RuntimeException，虽然在Dubbo服务化最佳实践[11]中推荐采用将自定义异常放入到API包内进行识别，但现实中自定义异常往往跟项目不在一个Package，这样做比较繁琐。\n\n网上的解决方法一般还有在接口处申明throw XXXException或是直接Copy Dubbo本身的ExceptionFilter进行覆盖，关闭原本的ExceptionFilter的形式，其实都不太好。\n\n这个问题其实在高版本Dubbo是不存在的，因为由@Activate实现，dubbo版本<=2.5.x时可以通过简单的Xml配置或application配置解决\n\nXml\n\n<dubbo:provider filter="DubboExceptionFilter"/>\n\n\n1\n\n1\n\n\napplication.yml\n\ndubbo:\n  provider:\n    filter: com.benym.rpamis.common.core.exception.DubboExceptionFilter\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n\n# 异常使用\n\n本文使用的技术遵循《阿里巴巴Java开发手册》规范，应用内直接抛出异常，跨应用采用RPC返回体包装\n\n对于SpringBoot项目而言\n\n * 接入全局异常\n\n在启动类上扫描exception基类包即可\n\n@ComponentScan({"你的启动类基础package路径","com.benym.rpamis.common.exception"})\n\n\n1\n\n1\n\n * 接入RPC全局异常\n\n通用于Dubbo SPI接入方法，在resource目录下新建META-INFO/dubbo/com.alibaba.dubbo.rpc.Filter(捐赠前)或META-INFO/dubbo/com.apache.dubbo.rpc.Filter(捐赠后)，并在文件中填写DubboExceptionFilter(可自定义名字)\n\nDubboExceptionFilter=com.benym.rpamis.common.core.exception.DubboExceptionFilter\n\n\n1\n\n1\n\n\n同时在Provider的Xml或application.yml中配置\n\nXml\n\n<dubbo:provider filter="DubboExceptionFilter"/>\n\n\n1\n\n1\n\n\napplication.yml\n\ndubbo:\n  provider:\n    filter: com.benym.rpas.common.core.exception.DubboExceptionFilter\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n对于SpringMVC项目而言\n\n * 接入全局异常\n\n在Xml文件中配置即可\n\n<context:component-scan base-package="你的启动类基础package路径, com.benym.rpas.common.exception"/>\n\n\n1\n\n1\n\n * 接入RPC全局异常\n\n同SpringBoot接入方式\n\n# 统一使用方法\n\n全局异常：\n\n任意Controller后位置使用\n\nthrow new ValidException("测试自定义异常");\nthrow new BizException("测试自定义异常", e);\nthrow new BizNoStackException("测试自定义异常");\nthrow new SysException("测试自定义异常",e);\nthrow new RpasException(ResponseCode.SUCCESS.getCode(),"测试自定义异常");\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n对于ValidException、BizNoStackException，抛出时没有异常堆栈入口，errCode固定，传输StatusCode子类时可改变errCode，日志不打印堆栈\n\n对于BizException、SysException，抛出时强制带异常堆栈，errCode固定，传输StatusCode子类时可改变errCode，日志打印堆栈\n\n对于RpasException，抛出时可带堆栈，也可不带，errCode不固定，传输StatusCode子类时可改变errCode，日志默认不带堆栈，可在debug模式下开启，状态码200\n\nRPC全局异常：\n\n无额外使用方法，接入后即可生效\n\n\n# 实践对比\n\n以之前的返回体地狱示例为例\n\n接入前\n\n\n\n接入后\n\n\n\n由此可见接入后的业务逻辑更加清晰，且MVC三层职责明确，代码量减少明显\n\n\n# 可控性分析\n\n全局异常及全局RPC异常仅在开启后生效。\n\n全局异常：\n\n * 捕获的入口位于Controller，正常来说需要接受返回值，全局异常捕获自定义异常及参数校验注解，对未接入过该异常包的项目无任何影响。如原本项目中已存在自定义异常，请酌情使用任意一个即可。\n * 全局异常仅在出现异常时生效，最大的Exception能够捕获所有没有捕获的异常，接入前出现未捕获异常和接入后出现未捕获异常，接口均返回500，对前端处理逻辑无影响。\n * 抛出自定义异常后，状态码对接需要由对接errCode->Http Code，具体异常原因提示，需要前端异常处理后再显示。\n\nRPC全局异常：\n\n * 捕获的入口为Dubbo RPC接口，如调用方需要识别异常来进行重试等操作需要改变代码\n * 如调用方采用识别isSuccess标识，判断接口调用是否成功，则无需改变代码\n\n\n# 可扩展性分析\n\n所有的自定义异常都具有StatusCode为入口改变异常枚举Code的方法，为了适配多系统间不统一的状态码\n\n可采用实现StatusCode接口+RpasException的形式，快速接入全局异常，且不会对存量项目造成额外的影响。\n\n\n# 参考文章\n\n----------------------------------------\n\n 1.  https://jcp.org/en/jsr/detail?id=303 ↩︎\n\n 2.  https://beanvalidation.org/ ↩︎\n\n 3.  https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#validator-gettingstarted ↩︎\n\n 4.  https://www.toutiao.com/article/7158309490746589727/?upstream_biz=toutiao_pc&_share_channel=wechat&source=m_redirect&wid=1667972352288 ↩︎\n\n 5.  https://docs.spring.io/spring-framework/docs/6.0.0-RC2/javadoc-api/org/springframework/http/ProblemDetail.html ↩︎\n\n 6.  https://segmentfault.com/a/1190000023471742 ↩︎\n\n 7.  https://cn.dubbo.apache.org/zh/docs/advanced/parameter-validation/ ↩︎\n\n 8.  https://github.com/alibaba/p3c ↩︎\n\n 9.  https://www.zhihu.com/question/513865370 ↩︎\n\n 10. https://github.com/alibaba/COLA ↩︎\n\n 11. https://cn.dubbo.apache.org/zh/docsv2.7/user/best-practice/ ↩︎',normalizedContent:'# 背景\n\n代码规范是项目质量的基石，能够帮助开发者和管理者更好的管理/维护项目、专注于推动快速成长的业务、留出更多时间攻坚重难点系统设计。全局异常+自定义异常+参数校验+统一返回体组合是互联网中java开发规范、使用代码扫描工具后的提升效率的必然落地方式。\n\n针对开发规范的细节考量，本文主要描述业界常用的基于@valid和@validated的前置校验，结合全局异常与http code，帮助读者理解高效且优雅的参数校验，及通用场景下的全局异常机制。\n\n\n# jsr303规范及主流实现\n\n数据的正确性校验是研发过程中不可或缺的步骤，开发者需要保证数据在进入系统后的基本正确性。\n\n在通常的开发过程中前端可以帮助校验用户的数据请求，为了保证服务端数据的安全，避免非法请求绕过前端，直接采用脚本等方式向服务端发起请求。服务端同样需要进行数据校验。\n\n根据校验先后的不同可以选择的方法也可以不同，比如在controller前的@valid和@validated校验，这类校验通常用于实体、字段的校验规则，如非空判断、长度判断、正则匹配、el表达式判断等。再者就是复杂业务或网关层面的校验，通常会使用责任链模式进行特定实现。当不使用该两种方法时，开发者通常会使用if else语法进行校验，但当校验过多且复杂时，成片的if else会造成代码臃肿，可复用性差的问题，导致研发效率的低下。\n\njsr(java specification requests)是java规范的提案，jsr-303[1]是javaee6中的一项子规范，叫做bean validation[2]，该提案于2009年正式面向公众，后续的jsr-349、jsr-380均在此提案上进行增强。该规范只提供了校验的注解，位于javax.validation.constraints包下，在官网指定的实现贡献者有3个\n\n\n\n其中hibernate validator使用最为广泛。\n\n这里列出一些基本的constraint，在最新的hibernate validator中包括但不限于以下注解，更多实现可直达官网[3]了解。\n\nbean validation中内置的constraint\n\n\n\nhibernate validator附加的constraint\n\n\n\n\n# 参数校验-快速开始\n\nspringboot项目无需引入额外依赖，自带所需依赖，非springboot项目需要引入如下2个依赖，参数校验依赖于get/set方法\n\n<dependency>\n    <groupid>javax.validation</groupid>\n    <artifactid>validation-api</artifactid>\n    <version>2.0.1.final</version>\n</dependency>\n<dependency>\n    <groupid>org.hibernate.validator</groupid>\n    <artifactid>hibernate-validator</artifactid>\n    <version>6.1.5.final</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 基本校验\n\n以一个user实体为例\n\npublic class user {\n\n    @notnull(message = "用户名不能为空")\n    private string username;\n\n    @notnull(message = "密码不能为空")\n    @pattern(regexp = "^[a-za-z0-9|_]+$", message = "密码必须由字母、数字、下划线组成")\n    @size(min = 6, max = 12, message = "密码长度必须在6-12字符之间")\n    private string password;\n\n    @range(min = 1, max = 150, message = "年龄必须在1-150区间")\n    private integer age;\n    \n    @notempty(message = "用户的兴趣不能为空")\n    private list<string> interest;\n    \n    // 省略get/set\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n假设要求传入的json字段(@requestbody)中，用户名、密码、年龄都有特定的规则\n\n对应的controller应该为\n\n@restcontroller\n@requestmapping("/test")\npublic class testcontroller {\n\n    @postmapping("/validate")\n    public string test(@valid @requestbody user user) {\n        system.out.println(1);\n        return "success";\n    }\n\n    @postmapping("/validate2")\n    public string test2(@validated @requestbody user user) {\n        system.out.println(1);\n        return "success";\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n使用@valid或@validated均可\n\n此时当postman参数传递不符合预期时，将无法进入controller中(前置拦截，体现在debug时，进不到test方法体内system.out行)，同时接口返回400，带spring封装的基础返回体\n\n\n\n控制台抛出对应异常\n\n\n\n结合上图结果和代码我们可以观察到，spring自带的基础返回体没有将我们想要的message显示出来，仅仅是在控制台有日志打印，只有显示指定@notnull、@notblank、@notempty等非空注解时，参数才为必传。在本例中age字段虽然有@range，但他不是必传的选项。只有当入参json包含age字段时，@range才会生效。\n\n由于参数校验结果的特点以及各公司对返回体的定制化需求，参数校验通常与统一返回体、全局异常处理结合。\n\n提示\n\n最新的spring6、springboot3中，已提供了org.springframework.http.problemdetail来实现http错误的返回信息和问题细节，避免自定义新的错误返回格式，可参考文章4[4]和文章5[5]。\n\n\n# 嵌套校验\n\n嵌套校验支持用户将@valid和@validated混合使用，可用于更复杂的校验\n\n还是以user为例，新增一个friends字段，代表用户的朋友们，同时加上@valid注解代表如果friends入参有传，则需要对friend类的内部字段进行校验，如果没有传递则无需校验。\n\npublic class user {\n\n    @notnull(message = "用户名不能为空")\n    private string username;\n\n    @notnull(message = "密码不能为空")\n    @pattern(regexp = "^[a-za-z0-9|_]+$", message = "密码必须由字母、数字、下划线组成")\n    @size(min = 6, max = 12, message = "密码长度必须在6-12字符之间")\n    private string password;\n\n    @range(min = 1, max = 150, message = "年龄必须在1-150区间")\n    private integer age;\n\n    @valid\n    private list<friend> friends;\n    \n    // 省略get/set\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nfriend类\n\npublic class friend {\n\n    @notnull(message = "朋友名称不能为空")\n    private string username;\n\n    @range(min = 1, max = 150, message = "年龄必须在1-150区间")\n    private integer age;\n    \n    // 省略get/set\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n假设此时参数传递为\n\n{\n    "username" : "11",\n    "password" : "test123_2",\n    "age" : 11,\n    "friends" : [\n        {\n            "age" : "22"\n        },\n        {\n            "username" : "33"\n        }\n    ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n表示该用户有2个friend，其中一个只写了名字，其中一个只写了年龄，由代码可知年龄是非必填字段，对应的控制台日志为\n\n\n\n符合校验预期，当此时friend字段没有传递时，则不进行校验\n\n\n# 分组校验\n\n分组校验是spring validation的特性，校验时在controller层对实体的书写必须使用@validated，分组校验提高了实体校验注解的可复用能力，只需要指定校验分组即可让同一实体适配多种场景。\n\n@restcontroller\n@requestmapping("/test")\npublic class testcontroller {\n\n    @postmapping("/validate2")\n    public string test2(@validated @requestbody user user) {\n        system.out.println(1);\n        return "success";\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n首先需要定义常见的crud分组场景，取任意名字均可，接口无需实现\n\npublic class validatedaction {\n    \n    public interface insert {\n    }\n\n    public interface update {\n    }\n\n    public interface search {\n    }\n\n    public interface delete {\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n为刚才的user内的字段增加分组，如在新增时需要填写用户名、密码，在删除时需要填写id和密码\n\npublic class user {\n\n    @notnull(message = "id不能为空", groups = {validatedaction.delete.class})\n    private string id;\n\n    @notnull(message = "用户名不能为空", groups = {validatedaction.insert.class})\n    private string username;\n\n    @notnull(message = "密码不能为空", groups = {validatedaction.insert.class, validatedaction.delete.class})\n    @pattern(regexp = "^[a-za-z0-9|_]+$", message = "密码必须由字母、数字、下划线组成")\n    @size(min = 6, max = 12, message = "密码长度必须在6-12字符之间")\n    private string password;\n\n    @range(min = 1, max = 150, message = "年龄必须在1-150区间")\n    private integer age;\n\n    @valid\n    private list<friend> friends;\n    \n    // 省略get/set\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n修改controller接口，指定校验分组，一个为新增分组校验，一个为删除分组校验，同时需要加上javax中自带的default分组，避免实体中没有写group的校验注解失效\n\n@restcontroller\n@requestmapping("/test")\npublic class testcontroller {\n\n    @postmapping("/validate")\n    public string test(@validated({validatedaction.insert.class, default.class}) @requestbody user user) {\n        system.out.println(1);\n        return "success";\n    }\n\n    @postmapping("/validatedelete")\n    public string test2(@validated({validatedaction.delete.class, default.class}) @requestbody user user) {\n        system.out.println(1);\n        return "success";\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n新增时postman传参为\n\n\n\n由于新增时，非空参数仅有用户名和密码，所以正常返回，此时分组为delete的id并没有参与非空校验\n\n删除时postman传参为\n\n\n\n由于删除时，非空参数包含id，此时传参中没有id则会在控制台输出对应提示\n\n\n\n\n# 自定义校验\n\nhibernate提供的校验注解在简单字段的场景已经基本够用了，如果提供的校验注解无法满足要求，这个时候可以考虑自定义注解，将校验与controller完全隔离。\n\n本文主要考虑4种较为通用的场景下自定义注解的实现方法\n\n * 场景1：字段为基础类型，约束传递的字段只能在枚举code的约束范围内，虽然定义字段为枚举字段可以简单实现传输枚举对象名完成枚举约束，但通常我们不将字段本身定义为枚举直接暴露给前端。期望能够通过直接引用枚举类，达成约束。\n * 场景2：字段为string，约束传递的字段只能是一组特定的string字符串\n * 场景3：字段为integer，约束传递的字段只能是一组特定的integer值\n * 场景4：字段为list<string>，约束传递的字段只能是一组特定的string字符串\n\n自定义的过程比较简单\n\n第一步：新增一个你的自定义注解，这里为specifiesvaluevalidator\n\n自定义注解的写法可完全照搬@notnull等注解，稍微改动下@constraint的validatedby属性为当前自定义注解类，同时加上可重复性校验注解(非必须)@repeatable(specifiesvaluevalidator.list.class)，用于支持多个自定义注解使用在同一字段。\n\n@target({method, field, annotation_type, constructor, parameter})\n@documented\n@retention(retentionpolicy.runtime)\n@constraint(validatedby = {specifiesvaluevalidatorimpl.class})\n@repeatable(specifiesvaluevalidator.list.class)\npublic @interface specifiesvaluevalidator {\n    /**\n     * 默认校验消息\n     *\n     * @return string\n     */\n    string message() default "入参必须为指定值";\n\n    /**\n     * 分组校验\n     *\n     * @return class<?>[]\n     */\n    class<?>[] groups() default {};\n\n    /**\n     * 负载\n     *\n     * @return class<? extends payload>[]\n     */\n    class<? extends payload>[] payload() default {};\n\n    /**\n     * 指定特定string值\n     *\n     * @return string[]\n     */\n    string[] strgroup() default {};\n\n    /**\n     * 指定特定int值\n     *\n     * @return int[]\n     */\n    int[] intgroup() default {};\n\n    /**\n     * 指定枚举类型\n     *\n     * @return class<?>\n     */\n    class<?> enumclass() default class.class;\n\n    /**\n     * 可重复校验\n     */\n    @target({method, field, annotation_type, constructor, parameter})\n    @retention(retentionpolicy.runtime)\n    @documented\n    @interface list {\n        specifiesvaluevalidator[] value();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\n第二步：实现javax.validation.constraintvalidator接口\n\n泛型第一个参数为自定义注解，第二个参数为被加上注解的字段值\n\n这里在请求初始化时将规定的合法值加载进内存，校验的过程逻辑非常简单，符合返回true，反之false即可\n\npublic class specifiesvaluevalidatorimpl implements constraintvalidator<specifiesvaluevalidator, object> {\n\n    private class<?> enumclass;\n\n    private hashset<string> strset;\n\n    private set<integer> intset;\n\n    @override\n    public void initialize(specifiesvaluevalidator constraintannotation) {\n        string[] strgroup = constraintannotation.strgroup();\n        strset = new hashset<>(arrays.aslist(strgroup));\n        int[] intgroup = constraintannotation.intgroup();\n        intset = arrays.stream(intgroup).boxed().collect(collectors.toset());\n        enumclass = constraintannotation.enumclass();\n    }\n\n    /**\n     * 此时value为被注解的字段类型\n     *\n     * @param value   object to validate\n     * @param context context in which the constraint is evaluated\n     * @return boolean\n     */\n    @override\n    public boolean isvalid(object value, constraintvalidatorcontext context) {\n        try {\n            if (null == value) {\n                return true;\n            }\n            if (enumclass.isenum()) {\n                return validenum(value, enumclass);\n            }\n            if (value instanceof string && strset.contains(value)) {\n                return true;\n            }\n            if (value instanceof integer && intset.contains(value)) {\n                return true;\n            }\n            if (value instanceof list) {\n                return validlist(value, strset);\n            }\n        } catch (nosuchmethodexception e) {\n            throw exceptionfactory.sysexception(enumclass + "枚举类没有getcode方法", e);\n        } catch (exception e) {\n            throw exceptionfactory.sysexception("特定值校验器异常", e);\n        }\n        return false;\n    }\n\n    public static boolean validenum(object value, class<?> enumclass) throws invocationtargetexception, illegalaccessexception, nosuchmethodexception {\n        // 获取传入的枚举class的所有定义的枚举，反射获取code判断是否和入参相同\n        object[] enumconstants = enumclass.getenumconstants();\n        for (object enumconstant : enumconstants) {\n            method method = enumclass.getdeclaredmethod("getcode");\n            object invokeresult = method.invoke(enumconstant);\n            if (invokeresult.equals(value)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static boolean validlist(object value, set<string> strset) {\n        for (object v : (list<?>) value) {\n            string cast = (string) v;\n            if (!strset.contains(cast)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n\n\n以userspvalid类为例\n\npublic class userspvalid {\n\n\n    @notnull(message = "手机品牌不能为空")\n    @specifiesvaluevalidator(message = "手机品牌需符合枚举", enumclass = phonebrandenums.class)\n    private string phonebrand;\n\n    @specifiesvaluevalidator(message = "用户状态需要符合规则", intgroup = {1, 2, 3})\n    private integer status;\n\n    @specifiesvaluevalidator(message = "用户的学校需要符合规则", strgroup = {"11", "22", "33"})\n    private string shchool;\n\n    @specifiesvaluevalidator(message = "传输list需要符合规则", strgroup = {"456","789"})\n    private list<string> testlist;\n    \n    // 省略get/set\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n其中枚举phonebrandenums为\n\npublic enum phonebrandenums implements statuscode {\n\n    /**\n     * 苹果\n     */\n    iphone("0", "苹果手机"),\n    /**\n     * 华为\n     */\n    huawei("1", "华为手机"),\n    /**\n     * 小米\n     */\n    xiaomi("2", "小米手机");\n\n    private string code;\n\n    private string message;\n\n    phonebrandenums(string code, string message) {\n        this.code = code;\n        this.message = message;\n    }\n\n    @override\n    public string getcode() {\n        return code;\n    }\n\n    @override\n    public string getmessage() {\n        return message;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n为了方便校验枚举类型，通常需要实现接口(这里为statuscode)，因为枚举校验实现中需要getdeclaredmethod("getcode")之后进行inovke\n\n对应的controller写法和之前没有变化\n\n@postmapping("/validatesp")\npublic string test3(@validated @requestbody userspvalid user) {\n    system.out.println(1);\n    return "success";\n}\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n当postman传输如下参数时，校验器将对参数进行校验，比如此时的phonebrand字段必须是枚举中的值\n\n\n\n显然以上参数都是无法通过校验的，对应的控制台打印为\n\n\n\n\n# spring validation与dubbo validation\n\nspring validation主要提供了编程式的校验验证，以及@validated注解，支持了@valid混用等多种场景，由于本文篇幅原因使用方法及原理这里不做过多介绍，mvc处理最终会调用hibernate validator的校验，spring只是在处理过程中包装了一层，可以通过文章6进行了解[6]。\n\ndubbo validation主要提供rpc时对参数的校验，本质上也依赖于javax与hibernate的包，在客户端和服务端均可单独开启校验，对于需要开启校验的接口加上validation="true"即可，dubbo2.1.x以上版本均支持，最佳实践可参考官方文档[7]\n\n在客户端验证参数\n\n<dubbo:reference id="validationservice" interface="org.apache.dubbo.examples.validation.api.validationservice" validation="true" />\n\n\n1\n\n1\n\n\n在服务端验证参数\n\n<dubbo:service interface="org.apache.dubbo.examples.validation.api.validationservice" ref="validationservice" validation="true" />\n\n\n1\n\n1\n\n\n\n# 实践对比\n\n简单结合自定义校验和基本校验，观察两者代码量上的区别\n\n未使用参数校验注解\n\n\n\n使用参数校验注解\n\n\n\n显然，没有使用参数校验开发者会写大量的校验代码，场景越复杂，需要考虑非空判断的地方也就越多，很容易写出高复杂度的代码，增加后期维护的难度，难以通过代码检查工具的扫描。而使用参数校验能够极大地减轻开发者的校验压力，校验与实体绑定，controller逻辑更加简洁、清晰，对应的controller代码只需要关注实体转化和业务。\n\n\n# 全局异常-快速开始\n\n上文中jsr303校验方法的引入有一个缺点，即错误信息仅体现在控制台日志中，无法反馈给前端。我们希望将错误信息包装在统一的返回体中，此时便需要定义全局异常。\n\n全局异常的好处在于：\n\n 1. 天生适配异常情况下统一返回体的需求，让优雅的参数校验更加易用\n 2. 结合http code释放前、后端代码压力，减轻前后端对接业务code沟通成本。促进前端请求/处理数据代码和后端返回代码模板化，让开发者专注推动业务，减少联调周期，清晰前后端问题处理边界\n 3. 允许开发者在系统内任意位置通过简单的throw new xxexception，完成异常情况下统一返回体的包装。无论代码层级多深，轻松实现统一返回，彻底告别系统内部除rpc接口，想要返回给前端异常信息仍然需要手动包装统一返回体，手动一层一层返回的情况，减少系统内非必要判空和传输体体积\n 4. 精简代码，降低大量try catch引起的代码简洁性问题\n 5. 全局兜底日志，结合唯一请求等信息，不再出现忘记打印日志，重新部署代码再排查问题的情况\n 6. 配合自定义异常，做到抛特定异常=打特定日志=返回对应http code+统一返回体，全面覆盖通用场景\n\n作为前置知识，这里首先讲解统一返回体\n\n\n# 统一返回体\n\n绝大多数公司都会定义自己的统一返回体，以一个简单的返回体为例，包含错误代码errcode，简要错误errmessage，详细信息detailmessage，数据data，4个字段，通常会结合泛型书写一些请求成功和请求失败的重载方法。\n\npublic class response<t> implements serializable {\n\n    private static final long serialversionuid = 1l;\n\n    private string errcode;\n\n    private string errmessage;\n\n    private string detailmessage;\n\n    private t data;\n\n    public response() {\n\n    }\n\n    public response(string errcode, string errmessage, string detailmessage) {\n        this.errcode = errcode;\n        this.errmessage = errmessage;\n        this.detailmessage = detailmessage;\n    }\n\n    public response(string errcode, string errmessage) {\n        this(errcode, errmessage, "");\n    }\n\n    public response(t data) {\n        errcode = "";\n        errmessage = "";\n        setdata(data);\n    }\n\n    public response(statuscode statuscode) {\n        errcode = statuscode.getcode();\n        errmessage = statuscode.getmessage();\n    }\n\n    public static <t> response<t> success() {\n        return new response<>(responsecode.success);\n    }\n\n    public static <t> response<t> success(t data, string errcode, string errmessage) {\n        response<t> response = new response<>();\n        response.setdata(data);\n        response.seterrcode(errcode);\n        response.seterrmessage(errmessage);\n        return response;\n    }\n\n    public static <t> response<t> success(t data) {\n        return success(data, responsecode.success.getcode(), responsecode.success.getmessage());\n    }\n\n    public static <t> response<t> success(t data, string errmessage) {\n        return success(data, responsecode.success.getcode(), errmessage);\n    }\n\n\n    public static <t> response<t> fail(string errcode, string errmessage) {\n        response<t> response = new response<>();\n        response.seterrcode(errcode);\n        response.seterrmessage(errmessage);\n        return response;\n    }\n\n    public static <t> response<t> fail() {\n        return fail(responsecode.failed.getcode(), responsecode.failed.getmessage());\n    }\n\n    public static <t> response<t> fail(statuscode statuscode) {\n        return fail(statuscode.getcode(), statuscode.getmessage());\n    }\n\n    public static <t> response<t> fail(statuscode statuscode, string detailmessage) {\n        response<t> response = new response<>();\n        response.seterrcode(statuscode.getcode());\n        response.seterrmessage(statuscode.getmessage());\n        response.setdetailmessage(detailmessage);\n        return response;\n    }\n\n    public static <t> response<t> fail(t data, string errcode, string errmessage) {\n        response<t> response = new response<>();\n        response.setdata(data);\n        response.seterrcode(errcode);\n        response.seterrmessage(errmessage);\n        return response;\n    }\n    // 省略get/set等\n    \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n\n\n用controller、service、dao经典的mvc分层，看看下面这个典型的请求例子\n\ncontroller\n\n@restcontroller\n@requestmapping("/test")\npublic class testcontroller {\n\n    @autowired\n    private testservice testservice;\n\n    @postmapping("/getuser")\n    public response<user> test6(@requestbody user user) {\n        user user1 = testservice.getuser(user.getid());\n        return response.success(user1);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nservice\n\npublic interface testservice {\n    user getuser(string id);\n}\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n@service\npublic class testserviceimpl implements testservice {\n\n    @autowired\n    private testdao testdao;\n\n    @override\n    public user getuser(string id) {\n        // 写一些业务逻辑，比如转换id等等\n        return testdao.getuserbyid(id);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\ndao\n\npublic interface testdao {\n    user getuserbyid(string id);\n}\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n@repository\npublic class testdaoimpl implements testdao {\n\n    @autowired\n    private usermapper usermapper;\n\n    @override\n    public user getuserbyid(string id) {\n        user userbyuserid = null;\n        try {\n            // 其他逻辑\n            userbyuserid = usermapper.getuserbyuserid(id);\n        } catch (exception e) {\n            throw new runtimeexception("报错了");\n        }\n        return userbyuserid;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n正常请求接口，这看上去没有什么问题，但如果上述查询数据库的代码出现异常了，这句"报错了"的消息前端是不知道的，有的时候我们希望将这些已知的异常捕获住并返回一个特定的消息告诉前端。这时候，有同学可能会这样修改\n\ncontroller\n\n@postmapping("/getuserwrap")\npublic response<user> test7(@requestbody user user) {\n    response<user> userwrap = testservice.getuserwrap(user.getid());\n    return userwrap;\n}\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\nservice\n\npublic interface testservice {\n    \n    response<user> getuserwrap(string id);\n}\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n@service\npublic class testserviceimpl implements testservice {\n\n    @autowired\n    private testdao testdao;\n\n    @override\n    public response<user> getuserwrap(string id) {\n        // 写一些业务逻辑，比如转换id等等\n        return testdao.getuserbyidwrap(id);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\ndao\n\npublic interface testdao {\n\n    response<user> getuserbyidwrap(string id);\n}\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n@repository\npublic class testdaoimpl implements testdao {\n\n    @autowired\n    private usermapper usermapper;\n\n    @override\n    public response<user> getuserbyidwrap(string id) {\n        user userbyuserid = null;\n        try {\n            // 其他逻辑\n            userbyuserid = usermapper.getuserbyuserid(id);\n        } catch (exception e) {\n            // 这里同样可以用response.fail()方法，手动set的写法是考虑有些返回体没有重载方法\n            // 如果有重载方法则response.fail(responsecode.failed.getcode(),"报错了")替代下面3行\n            response<user> response = new response<>();\n            response.seterrcode(responsecode.failed.getcode());\n            response.seterrmessage("报错了");\n            return response;\n        }\n        return response.success(userbyuserid);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n这种方式给内层的所有方法加上统一返回体，虽然满足了返回给前端异常消息的需求，但需要在最内层开始一层一层返回。如果包装的返回体没有提供便捷的重载方法，甚至需要手动set出错误体，同时对于可复用的dao层，其余方法在调用他时还需要再从统一返回体中取出真正的对象。长期下去会产生大量的冗余代码，降低了效率，显得不够整洁。\n\n或许你看到这里觉得仅仅只是给service、dao加上了一下返回体包装，如果加上返回体的重载方法，这样返回也还好。那么我们继续看下面这个例子，即返回体地狱。\n\n一个service不仅仅依赖于一次sql查询，那么他可能会使用多个dao或一个dao中的多个方法，为上文中的controller添加save方法，同时改变service、dao支持saveorupdate操作为如下\n\ncontroller\n\n@postmapping("/save")\npublic response<boolean> test8(@requestbody user user) {\n    response<boolean> result = testservice.saveorupdate(user);\n    return result;\n}\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\nservice\n\npublic interface testservice {\n\n    response<boolean> saveorupdate(user user);\n}\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n@service\npublic class testserviceimpl implements testservice {\n\n    @autowired\n    private testdao testdao;\n\n    @override\n    public response<boolean> saveorupdate(user user) {\n        response<boolean> response = new response<>();\n        // 传输id不为空为update，否则为新增\n        if (stringutils.isempty(user.getid())) {\n            try {\n                int insertrow = testdao.insert(user);\n                if (insertrow < 1) {\n                    response.seterrcode(responsecode.failed.getcode());\n                    response.seterrmessage("新增失败");\n                    return response;\n                } else {\n                    response.seterrcode(responsecode.success.getcode());\n                    response.seterrmessage("新增成功");\n                    return response;\n                }\n            } catch (exception e) {\n                response.seterrcode(responsecode.failed.getcode());\n                response.seterrmessage("新增时异常");\n                return response;\n            }\n        } else {\n            try {\n                int insertrow = testdao.update(user);\n                if (insertrow < 1) {\n                    response.seterrcode(responsecode.failed.getcode());\n                    response.seterrmessage("更新失败");\n                    return response;\n                } else {\n                    response.seterrcode(responsecode.success.getcode());\n                    response.seterrmessage("更新成功");\n                    return response;\n                }\n            } catch (exception e) {\n                response.seterrcode(responsecode.failed.getcode());\n                response.seterrmessage("更新时异常");\n                return response;\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\ndao\n\npublic interface testdao {\n    \n\tint insert(user user);\n\n    int update(user user);\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n@repository\npublic class testdaoimpl implements testdao {\n\n    @autowired\n    private usermapper usermapper;\n\n    @override\n    public int insert(user user) {\n        return usermapper.insert(user);\n    }\n\n    @override\n    public int update(user user) {\n        return usermapper.update(user);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n其中dao层的处理专门模拟了没有进行try catch处理的情况。\n\n这时候的service需要做的很多，对每一个dao层结果处理都需要进行try catch然后包装返回体，打印错误日志，这里真实的业务实际上只是如下4行，但由于dao层处理的不规范，加上不得不包装返回体的原因，这里需要写很多代码，而这些代码仅仅只是为了满足让前端感知错误消息这一需求\n\nif (stringutils.isempty(user.getid())) {\n    int insertrow = testdao.insert(user);\n} else {\n    int updaterow = testdao.update(user);\n}\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n上述方法如果也没有结合参数校验注解，将会使得controller层也会出现同样的情况，同时还有可能增加service在业务校验上包装返回体提示的代码，这样开发者无法专注于真正的业务逻辑，更多的是在处理如何进行友好返回。\n\n后文将解释全局异常的出现是如何克服该问题。\n\n\n# 全局异常捕获\n\n# 为什么用http code\n\n本文的全局异常与http code、自定义异常紧密结合。\n\n在最新的阿里官方发布(2022.2.3)的《阿里巴巴java开发手册》[8]中，强制规范提到返回给前端的响应信息必须包含http状态码，errcode，errormessage，用户提示信息4个部分。\n\n\n\n其中http状态码!=errcode，在调研过程中我们发现有不少的公司全统一采用了http code=200的情况，通过errcode来表示业务的状态码，关于这一点网上的讨论非常激烈[9]。总结起来就是，部分网友认为http为网络层协议，表达网络含义，不应该表达业务。另外有人表示这是历史原因，以前返回非200状态码会被运营商拦截，当然现在没有这个情况了。还有说http code不够业务使用，所以得用errcode表示。听起来都有道理。\n\n就落地而言，如果仅仅使用errcode虽然看起来各自的产品运行得没有问题，但实际上这里存在一个隐藏的时间成本，涉及到前后端联调沟通、接口问题排查边界、接口请求处理代码模版的问题。\n\n以下面这个真实案例开始\n\n在公司内的前端涉及到对接多个系统，当所有接口无论错误或正确都返回http code=200时，前端通过errcode区分这次结果到底是正确还是错误，可能写出的代码为\n\nif(errcode=="20000") {\n    status = 200\n    data = response\n}\nif(errcode = "200001") {\n    status = 500\n    msg = response.errors\n}\nif(datalist = true && datalist.length>0) {\n    status = 200\n    data = response\n}\nswitch (status) {\n    case 200: // 做处理\n    case 500: // 做处理\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n以上代码的status为前端拿到的该请求的http code，可以显然看出，前端需要对后端传输的errcode进行区分，然后才能知道这次的http code到底应该转化为多少，因为后端统一都是传的200。如果前端仅仅只对接一个系统，那么可能后端定义的errcode是固定不变的，则前端可以写出固定的处理请求的模版覆盖提示场景、异常场景、正确请求场景。\n\n弊端解释：\n\n 1. 上述情况仅仅是一种理想的状态，现实是各个后端系统所定义的异常枚举类都不相同，统一各个系统采用一份异常枚举类是不现实的，导致前端在对接每个系统的时候都需要沟通系统各自枚举code的含义，如果枚举code耦合或差异大，无疑会写出成片需要特殊转换，毫无规律的处理代码。还可能出现http code返回200，但接口内返回500这种存在二义性的场景。造成联调成本的上升。\n 2. 当一个接口出现问题时，开发者从f12中海量的接口请求很难一眼看出到底哪个接口出现了问题，是前端的问题？还是后端的问题？在http code为200的场景下，经常会发生前端排查半天发现是后端的问题，后端排查半天发现是前端传参的问题。排查问题的边界难以确定，一个问题甚至同时需要前后端多个人力一起来看。\n 3. 全200情况下，errcode对前端观测的无用性，如果有完善的接口监控系统，那么在全200情况下将无法识别接口到底成功还是失败，定制化开发监控平台会增加成本。从上面的实例代码也能看出，前端对于后端的errcode仅仅是做出了一次转化，到底这个errcode代表什么前端不知道，属于后端需要观测的范围。\n\n显然单纯采用errcode会增加前后端开发负担。\n\n对于业务服务而言，我们最为常用的http code应该为如下3个，对于401未授权,404未找到等状态码，应该交给网关服务\n\n * 200-请求成功：代表着本次请求是成功的\n * 400-请求参数有误：代表着本次请求的参数有误，需要前端处理\n * 500-服务器内部错误：代表着本次请求的服务端错误，需要后端处理\n\n如图200，400，500，其中400和500显示红色，请求很多的情况下也能明显可见\n\n\n\n\n\n\n\n在后文自定义异常栏，我们将展示http code和自定义异常的结合。\n\n# web controller\n\n全局异常是spring3.2开始就有的方法，主要提供了@restcontrolleradvice和@controlleradvice2个注解定义全局异常。@restcontrolleradvice=@controlleradvice+@responsebody。一般定义一个@restcontrolleradvice即可。同时采用@exceptionhandler指定处理哪种异常。\n\n一个简单的全局异常例子为，捕获系统内所有的异常，并返回1\n\n@restcontrolleradvice\npublic class exceptionerrorhandler {\n\n    @exceptionhandler(exception.class)\n    public object handleexception(exception exception) {\n        // 自定义处理\n        return "1";\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n当然了，在真实的系统中，我们需要对异常进行分类对不同种异常做出不一样的处理。\n\n首先加入对参数校验异常的兼容，主要有如下3个\n\n * methodargumentnotvalidexception\n\n使用javax、hibernate参数校验注解会抛出bindexception，而bindexception会将错误信息绑定在bindingresult中，我们可以直接捕获bindexception对bindingresult进行处理，但这样处理起来是没有格式化的，也可以采用methodargumentnotvalidexception通过内部方法直接返回格式化之后的bindingresult的相关信息。\n\n具体处理的对象为@valid、@validated、以及@notnull、@notempty等注解注释的实体或方法\n\n * httpmessagenotreadableexception\n\n处理http消息不可读的异常，当如参数传入为string类型字段，但接收方为integer类型。使用@requestbody规定传输json，但前端并没有传递参数或前端传输为表单类型。后端只支持get，但前端发送post等类似场景会抛出该异常。\n\n * missingservletrequestparameterexception\n\n处理缺少参数异常，即后端指定有@requestparam必传参数，前端没有传递该参数时将会抛出该异常。\n\n对应的全局异常处理为\n\n@restcontrolleradvice\n@order(ordered.highest_precedence)\npublic class exceptionerrorhandler {\n\n    private static final logger logger = loggerfactory.getlogger(exceptionerrorhandler.class);\n\n    @exceptionhandler(methodargumentnotvalidexception.class)\n    public responseentity<response<object>> handlebindexception(methodargumentnotvalidexception validexception) {\n        final trace trace = traceidutils.gettrace();\n        string validatemessage = objects.requirenonnull(validexception.getbindingresult().getfielderror()).getdefaultmessage();\n        logger.warn("请求id:{}, spanid:{}, 参数校验失败:{}", trace.gettraceid(), trace.getspanid(), validatemessage);\n        if (logger.isdebugenabled()) {\n            logger.debug(validexception.getmessage(), validexception);\n        }\n        final response<object> failresponse = response.fail(responsecode.validate_error, validatemessage);\n        return new responseentity<>(failresponse, httpstatus.bad_request);\n    }\n\n    @exceptionhandler(httpmessagenotreadableexception.class)\n    public responseentity<response<object>> handlenotreadexception(httpmessagenotreadableexception notreadableexception) {\n        final trace trace = traceidutils.gettrace();\n        logger.warn("请求id:{}, spanid:{}, 错误码:{}, 错误信息:{}, 详细信息:{}", trace.gettraceid(), trace.getspanid(),\n                responsecode.read_json_error.getcode(), responsecode.read_json_error.getmessage(), notreadableexception.getmessage());\n        if (logger.isdebugenabled()) {\n            logger.debug(notreadableexception.getmessage(), notreadableexception);\n        }\n        final response<object> failresponse = response.fail(responsecode.read_json_error, responsecode.read_json_error.getmessage());\n        return new responseentity<>(failresponse, httpstatus.bad_request);\n    }\n\n    @exceptionhandler(missingservletrequestparameterexception.class)\n    public responseentity<response<object>> handleparameterexception(missingservletrequestparameterexception misexception) {\n        final trace trace = traceidutils.gettrace();\n        string missparams = string.format("%s参数, 类型%s缺失", misexception.getparametername(),misexception.getparametertype());\n        logger.warn("请求id:{} ,spanid:{} ,详细信息:{}",trace.gettraceid(), trace.getspanid(), missparams);\n        if (logger.isdebugenabled()) {\n            logger.debug(misexception.getmessage(), misexception);\n        }\n        final response<object> failresponse = response.fail(responsecode.invalid_parameter, missparams);\n        return new responseentity<>(failresponse, httpstatus.bad_request);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n此处的@order指定了该异常处理的时机，避免在springmvc项目中全局异常还没处理，请求就返回跳转页面的情况。new responseentity<>()由org.springframework.http提供，支持包装httpcode和统一返回体，这里的httpstatus.bad_request，体现在页面上即状态码400，当然也可采用@responsestatus()注解。\n\n全局异常处理的逻辑非常简单，拿到异常后将异常消息包装进返回体即可。同时我们可以结合任意分布式链路跟踪系统，打印唯一请求id及错误消息，在debug模式下开启堆栈的跟踪。做到前后端均有兜底感知。\n\n加入全局异常后，我们再次请求参数校验时的例子，可以发现参数不正确时的异常包装，与控制台的唯一请求日志\n\n\n\n\n\n此时的消息为校验实体注解上所编写的消息。\n\n# 自定义异常\n\n在全局异常捕获了参数校验异常后，我们就可以省去关于http请求的代码校验，仅需要使用注解即可自动包装返回体和提示语给前端。此时只要前端或后端看到状态码400，就明确知道这是前端的传参问题。\n\n当然了，除了参数校验异常，业务上也需要自定义异常，根据开发手册和sonrlint的提示，这一步是必备的。\n\n本文的自定义异常定义参考了，阿里cola[10]整洁架构中cola-component-exception的异常定义\n\n分为1+5类：\n\n * abstractexception：抽象异常类\n\npublic abstract class abstractexception extends runtimeexception {\n\n    private static final long serialversionuid = 1l;\n\n    private string errcode;\n\n    private string errmessage;\n\n    protected abstractexception(string errmessage) {\n        super(errmessage);\n    }\n\n    protected abstractexception(string errmessage, throwable throwable) {\n        super(errmessage, throwable);\n    }\n\n    protected abstractexception(string errcode, string errmessage) {\n        super(errmessage);\n        this.seterrcode(errcode);\n        this.seterrmessage(errmessage);\n    }\n\n    protected abstractexception(string errcode, string errmessage, throwable throwable) {\n        super(errmessage, throwable);\n        this.seterrcode(errcode);\n        this.seterrmessage(errmessage);\n    }\n\n    protected abstractexception(statuscode statuscode) {\n        this(statuscode.getcode(), statuscode.getmessage());\n    }\n\n    protected abstractexception(statuscode statuscode, throwable throwable) {\n        super(statuscode.getmessage(), throwable);\n    }\n\n    public string geterrcode() {\n        return errcode;\n    }\n\n    public void seterrcode(string errcode) {\n        this.errcode = errcode;\n    }\n\n    public string geterrmessage() {\n        return errmessage;\n    }\n\n    public void seterrmessage(string errmessage) {\n        this.errmessage = errmessage;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n * validexception：业务类校验异常，固定errcode\n\npublic class validexception extends abstractexception {\n\n    private static final long serialversionuid = 1l;\n\n    private static final responsecode default_valid_errcode = responsecode.valid_exception_code;\n\n    public validexception(string errmessage) {\n        super(default_valid_errcode.getcode(), errmessage);\n    }\n\n    public validexception(string errcode, string errmessage) {\n        super(errcode, errmessage);\n    }\n\n    public validexception(statuscode statuscode) {\n        super(statuscode.getcode(), statuscode.getmessage());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n * bizexception：业务类异常(含堆栈)，固定errcode\n\npublic class bizexception extends abstractexception {\n\n    private static final long serialversionuid = 1l;\n\n    private static final responsecode deault_biz_errcode = responsecode.biz_exception_code;\n\n    public bizexception(string errmessage, throwable e) {\n        super(deault_biz_errcode.getcode(), errmessage, e);\n    }\n\n    public bizexception(statuscode statuscode, throwable e) {\n        super(statuscode.getcode(), statuscode.getmessage(), e);\n    }\n\n    public bizexception(string errcode, string errmessage, throwable e) {\n        super(errcode, errmessage, e);\n    }\n\n    public bizexception(throwable e) {\n        super(deault_biz_errcode, e);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n * biznostackexception：业务类异常(不带堆栈信息)，固定errcode\n\npublic class biznostackexception extends abstractexception implements serializable {\n\n    private static final long serialversionuid = 2628908675799105091l;\n\n    private static final responsecode deault_biz_errcode = responsecode.biz_nostack_exception;\n\n\n    public biznostackexception(string errmessage) {\n        super(deault_biz_errcode.getcode(), errmessage);\n    }\n\n    public biznostackexception(string errcode, string errmessage) {\n        super(errcode, errmessage);\n    }\n\n    public biznostackexception(statuscode statuscode) {\n        super(statuscode.getcode(), statuscode.getmessage());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * sysexception：系统级异常(带堆栈)，固定errcode\n\npublic class sysexception extends abstractexception {\n\n    private static final long serialversionuid = 1l;\n\n    private static final responsecode default_sys_errcode = responsecode.sys_exception_code;\n\n    public sysexception(string errmessage, throwable e) {\n        super(default_sys_errcode.getcode(), errmessage, e);\n    }\n\n    public sysexception(statuscode statuscode, throwable e) {\n        super(statuscode.getcode(), statuscode.getmessage(), e);\n    }\n\n    public sysexception(string errcode, string errmessage, throwable e) {\n        super(errcode, errmessage, e);\n    }\n\n    public sysexception(throwable e) {\n        super(default_sys_errcode, e);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n * rpasexception：任意异常类(宽松条件)\n\npublic class rpasexception extends runtimeexception {\n\n    private static final long serialversionuid = 1l;\n\n    private string errcode;\n\n    private string errmessage;\n\n    private string detailmessage;\n\n    public rpasexception() {\n        super();\n    }\n\n    public rpasexception(string errcode, string errmessage, string detailmessage) {\n        super(errmessage);\n        this.errcode = errcode;\n        this.errmessage = errmessage;\n        this.detailmessage = detailmessage;\n    }\n\n    public rpasexception(string errcode, string errmessage) {\n        this(errcode, errmessage, null);\n    }\n\n    public rpasexception(statuscode statuscode) {\n        this(statuscode.getcode(), statuscode.getmessage(), null);\n    }\n\n    public rpasexception(statuscode statuscode, string detailmessage) {\n        this(statuscode.getcode(), statuscode.getmessage(), detailmessage);\n    }\n\n    public string geterrcode() {\n        return errcode;\n    }\n\n    public string geterrmessage() {\n        return errmessage;\n    }\n\n    public string getdetailmessage() {\n        return detailmessage;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n我们希望各类异常与http code进行绑定，同时固定状态码，达成抛特定异常=打特定日志=返回对应http code+统一返回体的效果。总结起来如下场景\n\n 1. 日志级别warn:对于前置校验类异常，正常来说状态码为400，代表前端参数错误，400状态下前端不能直接拿到返回体，需要前端异常捕获配合才能打印msg，该类型异常已知，不需要人工处理\n 2. 日志级别warn:对于业务类校验异常validexception(不带堆栈)，状态码为200，表示请求正常只是业务拦截，该类型异常已知，不需要人工处理\n 3. 日志级别warn：对于业务类异常bizexception(带堆栈)、biznostackexception(不带堆栈)，状态码200，表示请求正常只是业务拦截，该类型异常已知，不需要人工处理\n 4. 日志级别error:对于已知可能发生的系统级异常sysexception(带堆栈)，状态码为500，表示出现系统异常，开发者手动抛出该异常说明，该系统级异常已知，需要人工处理\n 5. 日志级别error:对于未知的发生的系统级异常exception(带堆栈)，状态码500，表示出现未知的没有被try catch的异常，需要人工处理\n 6. 日志级别warn:用于非固定状态码任意位置的异常rpasexception(可带堆栈、也可不带)，状态码200，由于该类接受任意状态码，目的是兼容前端对接业务状态码场景，可用于兼容存量项目做全局异常\n\n根据上述场景总结，我们可以写出对应的全局异常代码如下\n\n@exceptionhandler(validexception.class)\npublic responseentity<response<object>> handlevalidexception(validexception validexception) {\n    final trace trace = traceidutils.gettrace();\n    string errcode = validexception.geterrcode();\n    string message = validexception.getmessage();\n    logger.warn("请求id:{}, spanid:{}, 参数校验异常:{}, 错误码:{}", trace.gettraceid(), trace.getspanid(), message, errcode);\n    final response<object> failresponse = response.fail(errcode, message);\n    return new responseentity<>(failresponse, httpstatus.ok);\n}\n\n@exceptionhandler(bizexception.class)\npublic responseentity<response<object>> handlebizexception(bizexception bizexception) {\n    final trace trace = traceidutils.gettrace();\n    string errcode = bizexception.geterrcode();\n    string message = bizexception.getmessage();\n    logger.warn("请求id:{}, spanid:{}, 业务异常:{}, 错误码:{}, 详细信息:", trace.gettraceid(), trace.getspanid(), message, errcode, bizexception);\n    if (logger.isdebugenabled()) {\n        logger.debug(message, bizexception);\n    }\n    final response<object> failresponse = response.fail(errcode, message);\n    return new responseentity<>(failresponse, httpstatus.ok);\n}\n\n@exceptionhandler(biznostackexception.class)\npublic responseentity<response<object>> handlebiznostackexception(biznostackexception biznostackexception) {\n    final trace trace = traceidutils.gettrace();\n    string errcode = biznostackexception.geterrcode();\n    string message = biznostackexception.getmessage();\n    logger.warn("请求id:{}, spanid:{}, 业务异常(无堆栈):{}, 错误码:{}", trace.gettraceid(), trace.getspanid(), message, errcode);\n    final response<object> failresponse = response.fail(errcode, message);\n    return new responseentity<>(failresponse, httpstatus.ok);\n}\n\n@exceptionhandler(sysexception.class)\npublic responseentity<response<object>> handlesysexception(sysexception sysexception) {\n    final trace trace = traceidutils.gettrace();\n    string errcode = sysexception.geterrcode();\n    string message = sysexception.getmessage();\n    logger.error("请求id:{}, spanid:{}, 系统异常:{}, 错误码:{}, 详细信息:", trace.gettraceid(), trace.getspanid(), message, errcode, sysexception);\n    if (logger.isdebugenabled()) {\n        logger.debug(message, sysexception);\n    }\n    final response<object> failresponse = response.fail(errcode, message);\n    return new responseentity<>(failresponse, httpstatus.internal_server_error);\n}\n\n@exceptionhandler(rpasexception.class)\npublic responseentity<response<object>> handlerpasexception(rpasexception rpasexception) {\n    final trace trace = traceidutils.gettrace();\n    string errcode = rpasexception.geterrcode();\n    string message = rpasexception.getmessage();\n    string detailmessage = rpasexception.getdetailmessage();\n    logger.error("请求id:{}, spanid:{}, 系统内部异常:{}, 错误码:{}, 详细信息:{}", trace.gettraceid(), trace.getspanid(), message, errcode, detailmessage);\n    if (logger.isdebugenabled()) {\n        logger.debug(message, rpasexception);\n    }\n    final response<object> failresponse = response.fail(errcode, detailmessage);\n    return new responseentity<>(failresponse, httpstatus.ok);\n}\n\n@exceptionhandler(exception.class)\npublic responseentity<response<object>> handleexception(exception exception) {\n    final trace trace = traceidutils.gettrace();\n    logger.error("请求id:{}, spanid:{}, 未知异常:{}, 详细信息:", trace.gettraceid(), trace.getspanid(), exception.getmessage(), exception);\n    if (logger.isdebugenabled()) {\n        logger.debug(exception.getmessage(), exception);\n    }\n    final response<object> failresponse = response.fail(responsecode.unknown_exception_code, exception.getmessage());\n    return new responseentity<>(failresponse, httpstatus.internal_server_error);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\n其中，最底下的exception异常捕获将获取到系统内所有的未知/未捕获的异常，进行错误信息打印和统一返回体的包装，不会在出现漏打日志和异常未被捕获的情况。全局异常的处理顺序从上至下，被上层异常处理过的不会再被之后的异常处理。\n\n在有了完备的异常机制之后，前端仅需要记忆200、400、500的http code含义即可，能够书写出固定的请求模板代码，在对接各个系统之间进行复用，极大地减轻了联调的压力，而errcode转变为原本的作用，帮助后端人员快速定位后端服务问题，前/后端也能快速通过状态码看出本次请求出现问题的一方是谁。\n\n提示\n\n需要注意的是，@restcontrolleradvice定义的全局异常机制，只适用于以controller为入口的请求，在进入controller之后所调用的所有方法任意位置出现异常，均可生效\n\n# dubbo rpc\n\n除了controller为入口的全局异常以外，在提供给第三方接口时，我们通常会用到rpc。对于rpc的异常我们同样需要进行全局异常处理，避免产生提供方接口报错，未进行异常捕获，调用方也未进行异常捕获，将提供方的异常日志打印到调用方，调用方排查半天发现是提供方的问题的情况。\n\n在《阿里巴巴java开发手册》，也提到过可参考的异常使用方法\n\n\n\n以dubbo为例，我们可以定义一个filter进行异常捕获，此时的filter接口位于org.apache.dubbo.rpc.filter\n\n@activate(group = {commonconstants.provider})\n@order(ordered.highest_precedence)\npublic class dubboexceptionfilter implements filter {\n\n    private static final logger logger = loggerfactory.getlogger(dubboexceptionfilter.class);\n\n    @override\n    public result invoke(invoker<?> invoker, invocation invocation) throws rpcexception {\n        string params = jsonutil.tojsonstr(invocation.getarguments());\n        logger.info("global dubbo exception filter, interface:{}, methodname:{}, params:{}",\n                invoker.getinterface(), invocation.getmethodname(), params);\n        result result = invoker.invoke(invocation);\n        if (result.hasexception()) {\n            try {\n                exceptionhandlermethodresolver resolver = new exceptionhandlermethodresolver(this.getclass());\n                // 获取rpc过程中出现的具体异常\n                exception exception = (exception) result.getexception();\n                // 从@exceptionhandler注解方法中找到value为exception方法的特定对象\n                method method = resolver.resolvemethod(exception);\n                // 找到具体的异常处理类，执行对应处理，这里即返回remoteresult\n                assert method != null;\n                object value = method.invoke(this, exception);\n                result.setvalue(value);\n                return result;\n            } catch (throwable e) {\n                logger.error("dubbo exception filter error, casued by ", e);\n            }\n        }\n        return result;\n    }\n\n    @exceptionhandler(validexception.class)\n    public object handlevalidexception(validexception exception) {\n        final trace trace = traceidutils.gettrace();\n        logger.warn("catch dubbo validexpcetion, requestid:{}, spanid:{}, exception is:",\n                trace.gettraceid(), trace.getspanid(), exception);\n        optional<validexception> opvalid = optional.ofnullable(exception);\n        string errcode = opvalid.map(abstractexception::geterrcode)\n                .orelse(responsecode.valid_exception_code.getcode());\n        string errmessage = opvalid.map(abstractexception::geterrmessage)\n                .orelse(responsecode.valid_exception_code.getmessage());\n        return response.fail(errcode, errmessage);\n    }\n\n    @exceptionhandler(bizexception.class)\n    public object handlebizexception(bizexception exception) {\n        final trace trace = traceidutils.gettrace();\n        logger.warn("catch dubbo bizexpcetion, requestid:{}, spanid:{}, exception is:",\n                trace.gettraceid(), trace.getspanid(), exception);\n        optional<bizexception> opbiz = optional.ofnullable(exception);\n        string errcode = opbiz.map(abstractexception::geterrcode)\n                .orelse(responsecode.biz_exception_code.getcode());\n        string errmessage = opbiz.map(abstractexception::geterrmessage)\n                .orelse(responsecode.biz_exception_code.getmessage());\n        return response.fail(errcode, errmessage);\n    }\n\n    @exceptionhandler(biznostackexception.class)\n    public object handlebiznostackexception(biznostackexception exception) {\n        final trace trace = traceidutils.gettrace();\n        logger.warn("catch dubbo biznostackexception, requestid:{}, spanid:{}, exception is:",\n                trace.gettraceid(), trace.getspanid(), exception);\n        optional<biznostackexception> opvalid = optional.ofnullable(exception);\n        string errcode = opvalid.map(abstractexception::geterrcode)\n                .orelse(responsecode.valid_exception_code.getcode());\n        string errmessage = opvalid.map(abstractexception::geterrmessage)\n                .orelse(responsecode.valid_exception_code.getmessage());\n        return response.fail(errcode, errmessage);\n    }\n\n    @exceptionhandler(sysexception.class)\n    public object handlesysexception(sysexception exception) {\n        final trace trace = traceidutils.gettrace();\n        logger.error("catch dubbo sysexpcetion, requestid:{}, spanid:{}, exception is:",\n                trace.gettraceid(), trace.getspanid(), exception);\n        optional<sysexception> opsys = optional.ofnullable(exception);\n        string errcode = opsys.map(abstractexception::geterrcode)\n                .orelse(responsecode.sys_exception_code.getcode());\n        string errmessage = opsys.map(abstractexception::geterrmessage)\n                .orelse(responsecode.sys_exception_code.getmessage());\n        return response.fail(errcode, errmessage);\n    }\n\n    @exceptionhandler(rpasexception.class)\n    public object handlerpasexception(rpasexception exception) {\n        final trace trace = traceidutils.gettrace();\n        logger.error("catch dubbo rpasexpcetion, requestid:{}, spanid:{}, exception is:",\n                trace.gettraceid(), trace.getspanid(), exception);\n        optional<rpasexception> oprpas = optional.ofnullable(exception);\n        string errcode = oprpas.map(rpasexception::geterrcode)\n                .orelse(responsecode.rpas_exception_code.getcode());\n        string errmessage = oprpas.map(rpasexception::geterrmessage)\n                .orelse(responsecode.rpas_exception_code.getmessage());\n        return response.fail(errcode, errmessage);\n    }\n\n    @exceptionhandler(exception.class)\n    public object handleexception(exception exception) {\n        final trace trace = traceidutils.gettrace();\n        logger.error("catch dubbo unknown expcetion, requestid:{}, spanid:{}, exception is:",\n                trace.gettraceid(), trace.getspanid(), exception);\n        optional<exception> opexcetion = optional.ofnullable(exception);\n        string errcode = responsecode.unknown_exception_code.getcode();\n        string errmessage = opexcetion.map(exception::getmessage)\n                .orelse(responsecode.unknown_exception_code.getmessage());\n        return response.fail(errcode, errmessage);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n\n\n采用@activate定义dubbo filter扩展点，各异常类的处理与之前的全局异常类似，对于每个rpc请求都会打印请求的接口信息、方法名、参数信息，主要实现在于invoke方法内\n\n在这个方法中，会首先进行原生的rpc调用拿到调用的结果，如果出现异常则获取当前class下的异常处理类，之后将异常处理的结果(包装统一返回体)重新set进原本出现异常的result中，这样便完成了异常的捕获和异常消息的传递。本文拓展的dubbo filter对默认filter处理无影响。\n\n提供方接入该dubbo spi后，调用方无需在对rpc异常进行处理，无论发生什么异常，提供方均会包装返回体返回，调用方只需关系本次统一返回体中的标示位是否成功即可。\n\n在这里有一个经常会遇到的问题：受检异常问题\n\n这个问题的表现在于，假设没有rpc全局异常机制，系统内定义了自定义异常，在提供方的实现方法中抛出自定义异常如throw new bizexception()，此时我们预期的是调用方收到的是bizexcption消息，但dubbo返回的是runtimeexception\n\n这个问题的出现在于dubbo默认的com.alibaba.dubbo.rpc.filter.exceptionfilter处理中对于不认识的异常，均会返回runtimeexception，虽然在dubbo服务化最佳实践[11]中推荐采用将自定义异常放入到api包内进行识别，但现实中自定义异常往往跟项目不在一个package，这样做比较繁琐。\n\n网上的解决方法一般还有在接口处申明throw xxxexception或是直接copy dubbo本身的exceptionfilter进行覆盖，关闭原本的exceptionfilter的形式，其实都不太好。\n\n这个问题其实在高版本dubbo是不存在的，因为由@activate实现，dubbo版本<=2.5.x时可以通过简单的xml配置或application配置解决\n\nxml\n\n<dubbo:provider filter="dubboexceptionfilter"/>\n\n\n1\n\n1\n\n\napplication.yml\n\ndubbo:\n  provider:\n    filter: com.benym.rpamis.common.core.exception.dubboexceptionfilter\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n\n# 异常使用\n\n本文使用的技术遵循《阿里巴巴java开发手册》规范，应用内直接抛出异常，跨应用采用rpc返回体包装\n\n对于springboot项目而言\n\n * 接入全局异常\n\n在启动类上扫描exception基类包即可\n\n@componentscan({"你的启动类基础package路径","com.benym.rpamis.common.exception"})\n\n\n1\n\n1\n\n * 接入rpc全局异常\n\n通用于dubbo spi接入方法，在resource目录下新建meta-info/dubbo/com.alibaba.dubbo.rpc.filter(捐赠前)或meta-info/dubbo/com.apache.dubbo.rpc.filter(捐赠后)，并在文件中填写dubboexceptionfilter(可自定义名字)\n\ndubboexceptionfilter=com.benym.rpamis.common.core.exception.dubboexceptionfilter\n\n\n1\n\n1\n\n\n同时在provider的xml或application.yml中配置\n\nxml\n\n<dubbo:provider filter="dubboexceptionfilter"/>\n\n\n1\n\n1\n\n\napplication.yml\n\ndubbo:\n  provider:\n    filter: com.benym.rpas.common.core.exception.dubboexceptionfilter\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n对于springmvc项目而言\n\n * 接入全局异常\n\n在xml文件中配置即可\n\n<context:component-scan base-package="你的启动类基础package路径, com.benym.rpas.common.exception"/>\n\n\n1\n\n1\n\n * 接入rpc全局异常\n\n同springboot接入方式\n\n# 统一使用方法\n\n全局异常：\n\n任意controller后位置使用\n\nthrow new validexception("测试自定义异常");\nthrow new bizexception("测试自定义异常", e);\nthrow new biznostackexception("测试自定义异常");\nthrow new sysexception("测试自定义异常",e);\nthrow new rpasexception(responsecode.success.getcode(),"测试自定义异常");\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n对于validexception、biznostackexception，抛出时没有异常堆栈入口，errcode固定，传输statuscode子类时可改变errcode，日志不打印堆栈\n\n对于bizexception、sysexception，抛出时强制带异常堆栈，errcode固定，传输statuscode子类时可改变errcode，日志打印堆栈\n\n对于rpasexception，抛出时可带堆栈，也可不带，errcode不固定，传输statuscode子类时可改变errcode，日志默认不带堆栈，可在debug模式下开启，状态码200\n\nrpc全局异常：\n\n无额外使用方法，接入后即可生效\n\n\n# 实践对比\n\n以之前的返回体地狱示例为例\n\n接入前\n\n\n\n接入后\n\n\n\n由此可见接入后的业务逻辑更加清晰，且mvc三层职责明确，代码量减少明显\n\n\n# 可控性分析\n\n全局异常及全局rpc异常仅在开启后生效。\n\n全局异常：\n\n * 捕获的入口位于controller，正常来说需要接受返回值，全局异常捕获自定义异常及参数校验注解，对未接入过该异常包的项目无任何影响。如原本项目中已存在自定义异常，请酌情使用任意一个即可。\n * 全局异常仅在出现异常时生效，最大的exception能够捕获所有没有捕获的异常，接入前出现未捕获异常和接入后出现未捕获异常，接口均返回500，对前端处理逻辑无影响。\n * 抛出自定义异常后，状态码对接需要由对接errcode->http code，具体异常原因提示，需要前端异常处理后再显示。\n\nrpc全局异常：\n\n * 捕获的入口为dubbo rpc接口，如调用方需要识别异常来进行重试等操作需要改变代码\n * 如调用方采用识别issuccess标识，判断接口调用是否成功，则无需改变代码\n\n\n# 可扩展性分析\n\n所有的自定义异常都具有statuscode为入口改变异常枚举code的方法，为了适配多系统间不统一的状态码\n\n可采用实现statuscode接口+rpasexception的形式，快速接入全局异常，且不会对存量项目造成额外的影响。\n\n\n# 参考文章\n\n----------------------------------------\n\n 1.  https://jcp.org/en/jsr/detail?id=303 ↩︎\n\n 2.  https://beanvalidation.org/ ↩︎\n\n 3.  https://docs.jboss.org/hibernate/stable/validator/reference/en-us/html_single/#validator-gettingstarted ↩︎\n\n 4.  https://www.toutiao.com/article/7158309490746589727/?upstream_biz=toutiao_pc&_share_channel=wechat&source=m_redirect&wid=1667972352288 ↩︎\n\n 5.  https://docs.spring.io/spring-framework/docs/6.0.0-rc2/javadoc-api/org/springframework/http/problemdetail.html ↩︎\n\n 6.  https://segmentfault.com/a/1190000023471742 ↩︎\n\n 7.  https://cn.dubbo.apache.org/zh/docs/advanced/parameter-validation/ ↩︎\n\n 8.  https://github.com/alibaba/p3c ↩︎\n\n 9.  https://www.zhihu.com/question/513865370 ↩︎\n\n 10. https://github.com/alibaba/cola ↩︎\n\n 11. https://cn.dubbo.apache.org/zh/docsv2.7/user/best-practice/ ↩︎',charsets:{cjk:!0},lastUpdated:"2023/02/10, 19:05:43",lastUpdatedTimestamp:1676027143e3},{title:"异常工具类-ExceptionFactory",frontmatter:{title:"异常工具类-ExceptionFactory",date:"2023-02-09T11:21:55.000Z",permalink:"/pages/4c5812/",tags:[null],author:{name:"benym",link:"https://github.com/benym"},article:!1},regularPath:"/08.%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/01.Rpamis/02.Exception/03.%E5%BC%82%E5%B8%B8%E5%B7%A5%E5%85%B7%E7%B1%BB-ExceptionFactory.html",relativePath:"08.开源项目/01.Rpamis/02.Exception/03.异常工具类-ExceptionFactory.md",key:"v-2fa97bee",path:"/pages/4c5812/",headersStr:null,content:"提示\n\n正在路上",normalizedContent:"提示\n\n正在路上",charsets:{cjk:!0},lastUpdated:"2023/02/08, 19:23:37",lastUpdatedTimestamp:1675855417e3},{title:"异常工具类-Assert",frontmatter:{title:"异常工具类-Assert",date:"2023-02-09T11:22:12.000Z",permalink:"/pages/cb1099/",tags:[null],author:{name:"benym",link:"https://github.com/benym"},article:!1},regularPath:"/08.%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/01.Rpamis/02.Exception/04.%E5%BC%82%E5%B8%B8%E5%B7%A5%E5%85%B7%E7%B1%BB-Assert.html",relativePath:"08.开源项目/01.Rpamis/02.Exception/04.异常工具类-Assert.md",key:"v-7f6fd396",path:"/pages/cb1099/",headersStr:null,content:"提示\n\n正在路上",normalizedContent:"提示\n\n正在路上",charsets:{cjk:!0},lastUpdated:"2023/02/08, 19:23:37",lastUpdatedTimestamp:1675855417e3},{title:"概览",frontmatter:{title:"概览",date:"2022-04-16T16:07:41.000Z",permalink:"/pages/2c6c1b/",categories:["索引","开源项目"],article:!1,tags:[null],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/09.%E7%B4%A2%E5%BC%95/01.%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/01.%E6%A6%82%E8%A7%88.html",relativePath:"09.索引/01.开源项目/01.概览.md",key:"v-2e449d2e",path:"/pages/2c6c1b/",headersStr:null,content:"提示\n\n正在路上...",normalizedContent:"提示\n\n正在路上...",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"关于",frontmatter:{title:"关于",permalink:"/about/",sidebar:!1,article:!1,date:"2022-04-17T23:30:08.000Z",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/10.%E5%85%B3%E4%BA%8E/01.%E5%85%B3%E4%BA%8E.html",relativePath:"10.关于/01.关于.md",key:"v-030ee6e9",path:"/about/",headers:[{level:2,title:"🍧开源项目",slug:"🍧开源项目",normalizedTitle:"🍧开源项目",charIndex:2},{level:2,title:"🎈未来",slug:"🎈未来",normalizedTitle:"🎈未来",charIndex:551}],headersStr:"🍧开源项目 🎈未来",content:"# 🍧开源项目\n\nHNECV\n\n⛱️Heterogeneous Network Embedding via Cloud model and Variational inference. CAAI. 2021. 代码实现\n\nRpas\n\n🚀为开发者提供快速、统一的项目结构生成，统一的包管理工具，并提供开发效能工具\n\n- name: HNECV\n  desc: ⛱️Heterogeneous Network Embedding via Cloud model and Variational inference. CAAI. 2021. 代码实现\n  link: https://github.com/benym/HNECV\n  bgColor: '#FF6A00'\n  textColor: '#FFFFFF'\n- name: Rpas\n  desc: 🚀为开发者提供快速、统一的项目结构生成，统一的包管理工具，并提供开发效能工具\n  link: https://github.com/benym/rpas\n  bgColor: '#0052D9'\n  textColor: '#FFFFFF'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 🎈未来\n\n提示\n\n文章内容仅是我个人的小总结，资历尚浅，如有误还请指正。 希望未来能够总结出更多更好的文章~",normalizedContent:"# 🍧开源项目\n\nhnecv\n\n⛱️heterogeneous network embedding via cloud model and variational inference. caai. 2021. 代码实现\n\nrpas\n\n🚀为开发者提供快速、统一的项目结构生成，统一的包管理工具，并提供开发效能工具\n\n- name: hnecv\n  desc: ⛱️heterogeneous network embedding via cloud model and variational inference. caai. 2021. 代码实现\n  link: https://github.com/benym/hnecv\n  bgcolor: '#ff6a00'\n  textcolor: '#ffffff'\n- name: rpas\n  desc: 🚀为开发者提供快速、统一的项目结构生成，统一的包管理工具，并提供开发效能工具\n  link: https://github.com/benym/rpas\n  bgcolor: '#0052d9'\n  textcolor: '#ffffff'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 🎈未来\n\n提示\n\n文章内容仅是我个人的小总结，资历尚浅，如有误还请指正。 希望未来能够总结出更多更好的文章~",charsets:{cjk:!0},lastUpdated:"2023/01/17, 15:45:17",lastUpdatedTimestamp:1673941517e3},{title:"Python-基础",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"02.Python/01.Python-基础",imgUrl:"https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/guideline.png",description:"Python基础目录集合"}},title:"Python-基础",sidebar:!0,article:!1,comment:!1,editLink:!1,date:"2022-04-12T23:21:16.000Z",permalink:"/pages/ad6515/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/11.%E7%9B%AE%E5%BD%95/02.Python/01.Python%E5%9F%BA%E7%A1%80.html",relativePath:"11.目录/02.Python/01.Python基础.md",key:"v-da4b7ec6",path:"/pages/ad6515/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"Java",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"01.Java",imgUrl:"https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/guideline.png",description:"Java目录集合"}},title:"Java",sidebar:!0,article:!1,comment:!1,editLink:!1,date:"2022-04-17T19:33:21.000Z",permalink:"/pages/059f1f/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/11.%E7%9B%AE%E5%BD%95/01.Java/01.Java.html",relativePath:"11.目录/01.Java/01.Java.md",key:"v-28bacbcf",path:"/pages/059f1f/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"Python-机器学习",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"02.Python/02.Python-机器学习",imgUrl:"https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/guideline.png",description:"Python机器学习目录集合"}},title:"Python-机器学习",sidebar:!0,article:!1,comment:!1,editLink:!1,date:"2022-04-12T23:21:16.000Z",permalink:"/pages/82c271/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/11.%E7%9B%AE%E5%BD%95/02.Python/02.Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.html",relativePath:"11.目录/02.Python/02.Python机器学习.md",key:"v-efc06c1e",path:"/pages/82c271/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/12/31, 16:52:27",lastUpdatedTimestamp:1672476747e3},{title:"剑指Offer",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"06.算法/01.剑指Offer",imgUrl:"https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/guideline.png",description:"剑指Offer目录合集"}},title:"剑指Offer",sidebar:!0,article:!1,comment:!1,editLink:!1,date:"2022-04-13T22:21:16.000Z",permalink:"/pages/f91e0d/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/11.%E7%9B%AE%E5%BD%95/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer.html",relativePath:"11.目录/06.算法/01.剑指Offer.md",key:"v-acde98ae",path:"/pages/f91e0d/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"06.算法/02.LeetCode",imgUrl:"https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/guideline.png",description:"LeetCode目录合集"}},title:"LeetCode",sidebar:!0,article:!1,comment:!1,editLink:!1,date:"2022-04-13T22:21:16.000Z",permalink:"/pages/b59559/",author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/11.%E7%9B%AE%E5%BD%95/06.%E7%AE%97%E6%B3%95/02.LeetCode.html",relativePath:"11.目录/06.算法/02.LeetCode.md",key:"v-088dc5dd",path:"/pages/b59559/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"归档",frontmatter:{archivesPage:!0,title:"归档",permalink:"/archives/",article:!1},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-d6d9f736",path:"/archives/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/11/26, 15:08:01",lastUpdatedTimestamp:1669446481e3},{title:"标签",frontmatter:{tagsPage:!0,title:"标签",permalink:"/tags/",article:!1},regularPath:"/@pages/tagsPage.html",relativePath:"@pages/tagsPage.md",key:"v-4bef49e5",path:"/tags/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/16, 18:08:32",lastUpdatedTimestamp:1650103712e3},{title:"Home",frontmatter:{home:!0,heroImage:"https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/guideline-two.png",heroText:"🚀知识管理&博客",tagline:"The Knowledge Base is Deployed with a Cloud-Native Architecture",actionText:"从这里开始 →",actionLink:"/pages/225727/",bannerBg:"none",features:[{title:"Java",details:"Java、Python相关知识",link:"/pages/225727/",imgUrl:"https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/site1back.png"},{title:"分布式与中间件",details:"Kafka、Redis、分布式相关知识",link:"/pages/847591/",imgUrl:"https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/site2back.png"},{title:"框架与数据库",details:"Spring生态框架与MySQL相关知识",link:"/pages/a657d3/",imgUrl:"https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/site3back.png"}],postList:"simple",simplePostListLength:15},regularPath:"/",relativePath:"index.md",key:"v-011f227e",path:"/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/01/17, 17:44:55",lastUpdatedTimestamp:1673948695e3},{title:"LeetCode-面试题25-合并两个排序的链表",frontmatter:{title:"LeetCode-面试题25-合并两个排序的链表",date:"2020-04-19T18:18:16.000Z",description:"合并两个排序的链表",tags:["链表","Python","Java","Easy","剑指Offer"],keywords:"链表,Java,Python,Easy,剑指Offer",permalink:"/pages/7b5838/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/22.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9825-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8.html",relativePath:"06.算法/01.剑指Offer/22.LeetCode-面试题25-合并两个排序的链表.md",key:"v-a82b2222",path:"/pages/7b5838/",headers:[{level:2,title:"LeetCode-面试题25-合并两个排序的链表",slug:"leetcode-面试题25-合并两个排序的链表",normalizedTitle:"leetcode-面试题25-合并两个排序的链表",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:152},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:295},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:1071}],headersStr:"LeetCode-面试题25-合并两个排序的链表 解题思路 Java代码 Python代码",content:"# LeetCode-面试题25-合并两个排序的链表\n\n输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。\n\n示例：\n\n输入：1->2->4, 1->3->4\n输出：1->1->2->3->4->4\n\n\n1\n2\n\n1\n2\n\n\n限制：\n\n0 <= 链表长度 <= 1000\n\n\n# 解题思路\n\n总共需要3个指针，一个指向链表1，一个指向链表2，一个指向头结点\n\n首先判断两个链表的值，小的头部赋值给MergeHead，然后进行下一步的递归判断，在合并的过程中可能出现链表长短不一的情况，如果l2链表为空返回l1剩下的头部，如果l1链表为空，返回l2剩下的头部\n\n\n# Java代码\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        if(l1==null)\n            return l2;\n        else if(l2==null)\n            return l1;\n        ListNode MergeHead = null;\n        if(l1.val>l2.val){\n            MergeHead = l2;\n            MergeHead.next = mergeTwoLists(l1,l2.next);\n        }\n        else{\n            MergeHead = l1;\n            MergeHead.next = mergeTwoLists(l1.next,l2);\n        }\n        return MergeHead;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# Python代码\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:\n        if not l1: return l2\n        elif not l2: return l1\n        MergeHead = None\n        if l1.val<l2.val:\n            MergeHead = l1\n            MergeHead.next = self.mergeTwoLists(l1.next,l2)\n        else:\n            MergeHead = l2\n            MergeHead.next = self.mergeTwoLists(l1,l2.next)\n        return MergeHead\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n",normalizedContent:"# leetcode-面试题25-合并两个排序的链表\n\n输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。\n\n示例：\n\n输入：1->2->4, 1->3->4\n输出：1->1->2->3->4->4\n\n\n1\n2\n\n1\n2\n\n\n限制：\n\n0 <= 链表长度 <= 1000\n\n\n# 解题思路\n\n总共需要3个指针，一个指向链表1，一个指向链表2，一个指向头结点\n\n首先判断两个链表的值，小的头部赋值给mergehead，然后进行下一步的递归判断，在合并的过程中可能出现链表长短不一的情况，如果l2链表为空返回l1剩下的头部，如果l1链表为空，返回l2剩下的头部\n\n\n# java代码\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode(int x) { val = x; }\n * }\n */\nclass solution {\n    public listnode mergetwolists(listnode l1, listnode l2) {\n        if(l1==null)\n            return l2;\n        else if(l2==null)\n            return l1;\n        listnode mergehead = null;\n        if(l1.val>l2.val){\n            mergehead = l2;\n            mergehead.next = mergetwolists(l1,l2.next);\n        }\n        else{\n            mergehead = l1;\n            mergehead.next = mergetwolists(l1.next,l2);\n        }\n        return mergehead;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# python代码\n\n# definition for singly-linked list.\n# class listnode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = none\n\nclass solution:\n    def mergetwolists(self, l1: listnode, l2: listnode) -> listnode:\n        if not l1: return l2\n        elif not l2: return l1\n        mergehead = none\n        if l1.val<l2.val:\n            mergehead = l1\n            mergehead.next = self.mergetwolists(l1.next,l2)\n        else:\n            mergehead = l2\n            mergehead.next = self.mergetwolists(l1,l2.next)\n        return mergehead\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4},{title:"LeetCode-面试题26-树的子结构",frontmatter:{title:"LeetCode-面试题26-树的子结构",date:"2020-04-20T13:33:50.000Z",description:"树的子结构",tags:["树","Python","Java","Medium","剑指Offer"],keywords:"树,Java,Python,Medium,剑指Offer",permalink:"/pages/022144/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},regularPath:"/06.%E7%AE%97%E6%B3%95/01.%E5%89%91%E6%8C%87Offer/23.LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9826-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84.html",relativePath:"06.算法/01.剑指Offer/23.LeetCode-面试题26-树的子结构.md",key:"v-49b2d391",path:"/pages/022144/",headers:[{level:2,title:"LeetCode-面试题26-树的子结构",slug:"leetcode-面试题26-树的子结构",normalizedTitle:"leetcode-面试题26-树的子结构",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:385},{level:3,title:"Java代码",slug:"java代码",normalizedTitle:"java代码",charIndex:648},{level:3,title:"Python代码",slug:"python代码",normalizedTitle:"python代码",charIndex:1731}],headersStr:"LeetCode-面试题26-树的子结构 解题思路 Java代码 Python代码",content:"# LeetCode-面试题26-树的子结构\n\n输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)\n\nB是A的子结构， 即 A中有出现和B相同的结构和节点值。\n\n例如: 给定的树 A:\n\n     3\n    / \\\n   4   5\n  / \\\n 1   2\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n给定的树 B：\n\n   4 \n  /\n 1\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。\n\n示例1：\n\n输入：A = [1,2,3], B = [3,1]\n输出：false\n\n\n1\n2\n\n1\n2\n\n\n示例2：\n\n输入：A = [3,4,5,1,2], B = [4,1]\n输出：true\n\n\n1\n2\n\n1\n2\n\n\n限制：\n\n0 <= 节点个数 <= 10000\n\n\n# 解题思路\n\n首先需要判断A和B根节点是否相同，如果相同则开启子树的匹配，如果不相同则需要判断A树的左右节点是否和B树根节点相同，再判断子树结构。\n\n子树的判断用递归的思路来考虑，如果传入的A的根节点和B的根节点值不相同，则以A的根节点开始的子树肯定没有B子树相同的节点。如果他们的值是相同的则需要递归考虑，它们各自的左右节点的值是不是相同。\n\n递归的终止条件是到达了树A或者树B的叶子节点，当树B的叶子节点为空的时候说明，B子树已经遍历完了，A包含B。而当A的叶子节点为空时，说明遍历完A也没有找到B子树，A不包含B\n\n\n# Java代码\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public boolean isSubStructure(TreeNode A, TreeNode B) {\n        boolean result = false;\n        if(A!=null&&B!=null){\n            if(A.val==B.val)\n                result = isSubTree(A,B);\n            if(!result)\n                result = isSubStructure(A.left,B);\n            if(!result)\n                result = isSubStructure(A.right,B);\n        }\n        return result;\n    }\n\n    public boolean isSubTree(TreeNode root1,TreeNode root2){\n        if(root2==null)\n            return true;\n        if(root1==null)\n            return false;\n        if(root1.val!=root2.val)\n            return false;\n        return isSubTree(root1.left,root2.left)&&isSubTree(root1.right,root2.right);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# Python代码\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def isSubStructure(self, A: TreeNode, B: TreeNode) -> bool:\n        result = False\n        if A and B:\n            if A.val==B.val:\n                result = self.helper(A,B)\n            if not result:\n                result = self.isSubStructure(A.left,B)\n            if not result:\n                result = self.isSubStructure(A.right,B)\n        return result\n\n    def helper(self,A:TreeNode,B:TreeNode)->bool:\n        if not B: return True\n        if not A: return False\n        if A.val!=B.val: return False\n        return self.helper(A.left,B.left) and self.helper(A.right,B.right)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n",normalizedContent:"# leetcode-面试题26-树的子结构\n\n输入两棵二叉树a和b，判断b是不是a的子结构。(约定空树不是任意一个树的子结构)\n\nb是a的子结构， 即 a中有出现和b相同的结构和节点值。\n\n例如: 给定的树 a:\n\n     3\n    / \\\n   4   5\n  / \\\n 1   2\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n给定的树 b：\n\n   4 \n  /\n 1\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n返回 true，因为 b 与 a 的一个子树拥有相同的结构和节点值。\n\n示例1：\n\n输入：a = [1,2,3], b = [3,1]\n输出：false\n\n\n1\n2\n\n1\n2\n\n\n示例2：\n\n输入：a = [3,4,5,1,2], b = [4,1]\n输出：true\n\n\n1\n2\n\n1\n2\n\n\n限制：\n\n0 <= 节点个数 <= 10000\n\n\n# 解题思路\n\n首先需要判断a和b根节点是否相同，如果相同则开启子树的匹配，如果不相同则需要判断a树的左右节点是否和b树根节点相同，再判断子树结构。\n\n子树的判断用递归的思路来考虑，如果传入的a的根节点和b的根节点值不相同，则以a的根节点开始的子树肯定没有b子树相同的节点。如果他们的值是相同的则需要递归考虑，它们各自的左右节点的值是不是相同。\n\n递归的终止条件是到达了树a或者树b的叶子节点，当树b的叶子节点为空的时候说明，b子树已经遍历完了，a包含b。而当a的叶子节点为空时，说明遍历完a也没有找到b子树，a不包含b\n\n\n# java代码\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public boolean issubstructure(treenode a, treenode b) {\n        boolean result = false;\n        if(a!=null&&b!=null){\n            if(a.val==b.val)\n                result = issubtree(a,b);\n            if(!result)\n                result = issubstructure(a.left,b);\n            if(!result)\n                result = issubstructure(a.right,b);\n        }\n        return result;\n    }\n\n    public boolean issubtree(treenode root1,treenode root2){\n        if(root2==null)\n            return true;\n        if(root1==null)\n            return false;\n        if(root1.val!=root2.val)\n            return false;\n        return issubtree(root1.left,root2.left)&&issubtree(root1.right,root2.right);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# python代码\n\n# definition for a binary tree node.\n# class treenode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = none\n#         self.right = none\n\nclass solution:\n    def issubstructure(self, a: treenode, b: treenode) -> bool:\n        result = false\n        if a and b:\n            if a.val==b.val:\n                result = self.helper(a,b)\n            if not result:\n                result = self.issubstructure(a.left,b)\n            if not result:\n                result = self.issubstructure(a.right,b)\n        return result\n\n    def helper(self,a:treenode,b:treenode)->bool:\n        if not b: return true\n        if not a: return false\n        if a.val!=b.val: return false\n        return self.helper(a.left,b.left) and self.helper(a.right,b.right)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n",charsets:{cjk:!0},lastUpdated:"2022/11/18, 11:15:10",lastUpdatedTimestamp:166874131e4}],themeConfig:{nav:[{text:"首页",link:"/"},{text:"Java",link:"/pages/225727/",items:[{text:"Java",items:[{text:"Java-基础",link:"/pages/225727/"},{text:"Java-集合",link:"/pages/9786e5/"},{text:"Java-多线程与并发",link:"/pages/487c60/"},{text:"Java-JVM",link:"/pages/0a146e/"},{text:"Java-IO",link:"/pages/4aef64/"}]},{text:"Python",link:"/pages/0de67d/",items:[{text:"Python-基础",link:"/pages/0de67d/"},{text:"Python-机器学习",link:"/pages/43f8b9/"}]}]},{text:"分布式与中间件",link:"",items:[{text:"Kafka",link:"/pages/b53b0f/"},{text:"Redis",link:"/pages/847591/"},{text:"分布式事务",link:"/pages/aaed8c/"}]},{text:"数据库",link:"/pages/0f7e8e/",items:[{text:"MySQL",link:"/pages/0f7e8e/"}]},{text:"框架",items:[{text:"Spring",items:[{text:"SpringIOC",link:"/pages/6e0b99/"},{text:"SpringAOP",link:"/pages/a657d3/"}]}]},{text:"算法",link:"/pages/83cdcf/",items:[{text:"剑指Offer",link:"/pages/83cdcf/"},{text:"LeetCode",link:"/pages/b2b5b5/"},{text:"排序算法",link:"/pages/8d006a/"}]},{text:"实践",link:"/pages/f6b758/"},{text:"开源项目",link:"/pages/3147fe/",items:[{text:"Rpamis",items:[{text:"Utils",link:"/pages/3147fe/"},{text:"Exception",link:"/pages/b127c7/"}]}]},{text:"索引",link:"/pages/2c6c1b/",items:[{text:"概览",link:"/pages/2c6c1b/"},{text:"归档",link:"/archives/"},{text:"标签",link:"/tags/"}]},{text:"目录",link:"/pages/059f1f/"},{text:"关于",link:"/about/"}],sidebarDepth:2,logo:"https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/guideline-two-left.png",repo:"benym/benym-book/",searchMaxSuggestions:10,lastUpdated:"上次更新",docsDir:"docs",editLinks:!0,editLinkText:"编辑",sidebar:{"/00.导航/":[["01.概览.md","概览","/pages/7848bb/"]],catalogue:{Java:"/pages/059f1f/","Python基础":"/pages/ad6515/","Python机器学习":"/pages/82c271/","剑指Offer":"/pages/f91e0d/",LeetCode:"/pages/b59559/"},"/01.Java/":[{title:"Java",collapsable:!1,children:[{title:"Java-基础",collapsable:!1,children:[["01.Java/01.Java-基础/01.Java反射获取类对象的三种方式.md","Java反射获取类对象的三种方式","/pages/225727/"],["01.Java/01.Java-基础/02.动态代理使用方法.md","动态代理","/pages/ddcc22/"]]},{title:"Java-集合",collapsable:!1,children:[["01.Java/02.Java-集合/01.ArrayList的扩容机制.md","ArrayList的扩容机制","/pages/9786e5/"]]},{title:"Java-多线程与并发",collapsable:!1,children:[["01.Java/03.Java-多线程与并发/01.Java多线程实现的几种方式.md","Java多线程实现的几种方式","/pages/487c60/"],["01.Java/03.Java-多线程与并发/02.多线程打印数字-多种实现.md","多线程交替打印数字—多种实现","/pages/5047a0/"],["01.Java/03.Java-多线程与并发/03.CountDownLatch使用方法.md","CountDownLatch使用方法","/pages/bccbee/"],["01.Java/03.Java-多线程与并发/04.CyclicBarrier使用方法.md","CyclicBarrier使用方法","/pages/3898a4/"],["01.Java/03.Java-多线程与并发/05.Semaphore使用方法.md","Semaphore使用方法","/pages/8e40cc/"],["01.Java/03.Java-多线程与并发/06.CompletableFuture常用用法及问题排查.md","CompletableFuture常用用法及踩坑","/pages/b1318d/"]]},{title:"Java-JVM",collapsable:!1,children:[["01.Java/04.Java-JVM/01.自定义类加载器.md","自定义类加载器","/pages/0a146e/"],["01.Java/04.Java-JVM/02.JMH-基准测试框架.md","JMH-基准测试框架","/pages/ffed02/"]]},{title:"Java-IO",collapsable:!1,children:[["01.Java/05.Java-IO/01.概览.md","概览","/pages/4aef64/"]]}]}],"/02.Python/":[{title:"Python-基础",collapsable:!1,children:[["01.Python-基础/01.assert语句的运用.md","assert语句的运用","/pages/0de67d/"],["01.Python-基础/02.list(列表)、tuple(元组)、dict(字典)的回顾.md","list(列表)、tuple（元组）、dict（字典）的回顾","/pages/50bf39/"],["01.Python-基础/03.Python中的Docstring.md","Python中的Docstring","/pages/31bd37/"],["01.Python-基础/04.Python中的多态.md","Python中的多态","/pages/866a91/"],["01.Python-基础/05.Python中的集合.md","Python中的集合","/pages/c47343/"],["01.Python-基础/06.Python中的列表.md","Python中的列表","/pages/c498f9/"],["01.Python-基础/07.Python中的序列以及切片的解释.md","Python中的序列以及切片的解释","/pages/0d6aa8/"],["01.Python-基础/08.Python中的引用和切片.md","Python中的引用和切片","/pages/037f6f/"],["01.Python-基础/09.Python中的元组.md","Python中的元组","/pages/e8270d/"],["01.Python-基础/10.Python中对列表和元组的切片操作.md","Python中对列表和元组的切片操作","/pages/bf2ef2/"],["01.Python-基础/11.Python中完整for循环的实际运用.md","Python中完整for循环的实际运用","/pages/7c7c36/"],["01.Python-基础/12.Python中字典(key-value).md","Python中字典(key-value)","/pages/76ac47/"],["01.Python-基础/13.Python中字符串的一些方法回顾(拆分与合并).md","Python中字符串的一些方法回顾(拆分与合并)","/pages/5386bd/"],["01.Python-基础/14.Python中字符串的一些方法回顾(切片回顾).md","Python中字符串的一些方法回顾(切片回顾)","/pages/c7192a/"],["01.Python-基础/15.Python中字符串的一些方法回顾(文本对齐、去除空白).md","Python中字符串的一些方法回顾(文本对齐、去除空白)","/pages/a7c3f3/"],["01.Python-基础/16.Python中字符串的一些方法回顾.md","Python中字符串的一些方法回顾","/pages/800d04/"],["01.Python-基础/17.Python中字符串的一些基本操作.md","Python中字符串的一些基本操作","/pages/76881f/"],["01.Python-基础/18.多种方法快速交换两个变量的值.md","多种方法快速交换两个变量的值","/pages/e5cf66/"],["01.Python-基础/19.利用Python进行文件的自动备份.md","利用Python进行文件的自动备份","/pages/369a5f/"],["01.Python-基础/20.利用Python进行文件的自动备份(第二版).md","利用Python进行文件的自动备份(第二版)","/pages/04f569/"],["01.Python-基础/21.利用Python进行文件的自动备份(第三版和第四版).md","利用Python进行文件的自动备份(第三版和第四版)","/pages/a8d563/"],["01.Python-基础/22.列表推导.md","列表推导","/pages/f7e4b1/"],["01.Python-基础/23.在函数中接受元组与字典.md","在函数中接受元组与字典","/pages/f954d1/"],["01.Python-基础/24.装饰器.md","装饰器","/pages/962777/"],["01.Python-基础/25.finally异常处理.md","finally异常处理","/pages/cd9b6e/"],["01.Python-基础/26.Python的main函数作用.md","Python的__name__ = '__main__' 的作用","/pages/f09b25/"],["01.Python-基础/27.Python的pickle模块.md","Python的pickle模块","/pages/ee2549/"],["01.Python-基础/28.Python对象的实例化.md","Python对象的实例化","/pages/7cedd2/"],["01.Python-基础/29.Python日志模块.md","Python日志模块","/pages/adffdd/"],["01.Python-基础/30.Python中的__new__方法的重写.md","Python中的__new__方法的重写","/pages/985752/"],["01.Python-基础/31.Python中的lambda函数.md","Python中的lambda函数","/pages/7235b8/"],["01.Python-基础/32.Python中的静态方法、实例方法、类方法的区别.md","Python中的静态方法、实例方法、类方法的区别","/pages/57af9e/"],["01.Python-基础/33.Python中的正则表达式.md","Python中的正则表达式","/pages/38b0ff/"],["01.Python-基础/34.Python中的正则表达式match和search.md","Python中的正则表达式match和search","/pages/ee44fe/"],["01.Python-基础/35.Python中面向对象比较简单的内部函数.md","Python中面向对象比较简单的内部函数","/pages/d79b2c/"],["01.Python-基础/36.with-open异常处理.md","with open异常处理","/pages/c20072/"],["01.Python-基础/37.Python单例设计模式.md","单例设计模式","/pages/ccdd54/"],["01.Python-基础/38.继承的运用.md","继承的运用","/pages/6a1778/"],["01.Python-基础/39.简单的异常处理.md","简单的异常处理","/pages/8d431d/"],["01.Python-基础/40.类变量与对象变量.md","类变量与对象变量","/pages/43bfe3/"],["01.Python-基础/41.输入输出——简单的回文判断.md","输入输出——简单的回文判断","/pages/0f3eea/"],["01.Python-基础/42.输入输出——回文字串的判断（加强版）.md","输入输出——回文字串的判断（加强版）","/pages/efd97d/"],["01.Python-基础/43.文件操作.md","文件操作","/pages/9d76ce/"],["01.Python-基础/44.用户自己引发的异常处理.md","用户自己引发的异常处理","/pages/74cf7d/"],["01.Python-基础/45.正则表达式检索与替换.md","正则表达式检索与替换","/pages/e8935b/"],["01.Python-基础/46.正则表达式中的compile函数.md","正则表达式中的compile函数","/pages/270272/"],["01.Python-基础/47.正则表达式中的compile函数(二).md","正则表达式中的compile函数(二)","/pages/bff928/"]]},{title:"Python-机器学习",collapsable:!1,children:[["02.Python-机器学习/01.Numpy库的首次使用.md","Numpy库的首次使用","/pages/43f8b9/"],["02.Python-机器学习/02.kNN（k-近邻算法）.md","kNN（k-近邻算法）","/pages/b2a5ff/"],["02.Python-机器学习/03.kNN识别手写图像.md","kNN识别手写图像","/pages/6c1c7d/"],["02.Python-机器学习/04.LogisticRegression(逻辑回归).md","LogisticRegression(逻辑回归)","/pages/dbeb49/"],["02.Python-机器学习/05.Ndarray对象.md","Ndarray对象","/pages/6ae370/"],["02.Python-机器学习/06.Numpy中的数组维度.md","Numpy中的数组维度","/pages/cdba0b/"],["02.Python-机器学习/07.Numpy中花式索引和shape用法.md","Numpy中花式索引和shape用法","/pages/92372b/"],["02.Python-机器学习/08.turtle绘图库.md","turtle绘图库","/pages/0779b1/"],["02.Python-机器学习/09.第一个使用Tensorflow的程序.md","第一个使用Tensorflow的程序","/pages/6cd0c4/"],["02.Python-机器学习/10.将下载下来的MNIST手写数字数据集转化成为图片.md","将下载下来的MNIST手写数字数据集转化成为图片","/pages/8b335a/"],["02.Python-机器学习/11.Tensorflow交互式使用.md","Tensorflow交互式使用","/pages/b8d563/"],["02.Python-机器学习/12.使用k-近邻算法改进约会网站的配对效果.md","使用k-近邻算法改进约会网站的配对效果","/pages/a76d65/"],["02.Python-机器学习/13.Numpy数据类型和arange方法_astype方法的使用.md","Numpy数据类型和arange方法、astype方法的使用","/pages/f66019/"],["02.Python-机器学习/14.一些TensorFlow的基本操作.md","一些TensorFlow的基本操作","/pages/f9a151/"]]}],"/03.分布式与中间件/":[{title:"Kafka",collapsable:!1,children:[["01.Kafka/01.概览.md","概览","/pages/b53b0f/"]]},{title:"Redis",collapsable:!1,children:[["02.Redis/01.Redis实现共享Session.md","Redis实现共享Session","/pages/847591/"],["02.Redis/02.自定义RedisTemplate.md","自定义RedisTemplate","/pages/b185b0/"],["02.Redis/03.Redis哨兵.md","Redis哨兵","/pages/3aa0a8/"],["02.Redis/04.Redis持久化RDB.md","Redis持久化RDB","/pages/2f1bf8/"],["02.Redis/05.Redis持久化AOF.md","Redis持久化AOF","/pages/c48db1/"],["02.Redis/06.Redis分片集群.md","Redis分片集群","/pages/20361f/"]]},{title:"分布式事务",collapsable:!1,children:[["03.分布式事务/01.事务的特性、CAP定理、BASE理论.md","事务的特性、CAP定理、BASE理论","/pages/aaed8c/"],["03.分布式事务/02.分布式事务XA、AT、TCC、SAGA.md","分布式事务XA、AT、TCC、SAGA","/pages/e8a7fb/"],["03.分布式事务/03.分布式事务AT模式的脏写问题.md","分布式事务AT模式的脏写问题","/pages/81dbd1/"],["03.分布式事务/04.分布式事务TCC模式的空回滚和业务悬挂问题.md","分布式事务TCC模式的空回滚和业务悬挂问题","/pages/f256e0/"]]}],"/04.数据库/":[{title:"MySQL",collapsable:!1,children:[["01.MySQL/01.MySQL索引原理及应用场景.md","MySQL索引原理及应用场景","/pages/0f7e8e/"]]}],"/05.框架/":[{title:"Spring",collapsable:!1,children:[{title:"SpringIOC",collapsable:!1,children:[["01.Spring/01.SpringIOC/01.概览.md","概览","/pages/6e0b99/"]]},{title:"SpringAOP",collapsable:!1,children:[["01.Spring/02.SpringAOP/01.利用AOP实现操作日志.md","利用AOP实现操作日志","/pages/a657d3/"]]}]}],"/06.算法/":[{title:"剑指Offer",collapsable:!1,children:[["01.剑指Offer/00.01背包问题详解.md","01背包问题详解","/pages/83cdcf/"],["01.剑指Offer/01.LeetCode-面试题17-打印从1到最大的n位数.md","LeetCode-面试题17-打印从1到最大的n位数","/pages/f411af/"],["01.剑指Offer/02.LeetCode-面试题03-不修改数组找出重复的数字.md","LeetCode-面试题03-不修改数组找出重复的数字","/pages/e68fc1/"],["01.剑指Offer/03.LeetCode-面试题03-数组中重复的数字.md","LeetCode-面试题03-数组中重复的数字","/pages/2f843e/"],["01.剑指Offer/04.LeetCode-面试题04-二维数组中的查找.md","LeetCode-面试题04-二维数组中的查找","/pages/84f558/"],["01.剑指Offer/05.LeetCode-面试题05-替换空格.md","LeetCode-面试题05-替换空格","/pages/b0f96d/"],["01.剑指Offer/06.LeetCode-面试题06-从尾到头打印链表.md","LeetCode-面试题06-从尾到头打印链表","/pages/642877/"],["01.剑指Offer/07.LeetCode-面试题09-用两个栈实现队列.md","LeetCode-面试题09-用两个栈实现队列","/pages/e5bc1f/"],["01.剑指Offer/08.LeetCode-面试题10-1-斐波那契数列.md","LeetCode-面试题10-1-斐波那契数列","/pages/6a6f3c/"],["01.剑指Offer/09.LeetCode-面试题10-2-青蛙跳台阶.md","LeetCode-面试题10-2-青蛙跳台阶","/pages/78c895/"],["01.剑指Offer/10.LeetCode-面试题11-旋转数组的最小数字.md","LeetCode-面试题11-旋转数组的最小数字","/pages/ea52d6/"],["01.剑指Offer/11.LeetCode-面试题13-机器人的运动范围.md","LeetCode-面试题13-机器人的运动范围","/pages/ab9430/"],["01.剑指Offer/12.LeetCode-面试题14-1-剪绳子.md","LeetCode-面试题14-1-剪绳子","/pages/2d7b5b/"],["01.剑指Offer/13.LeetCode-面试题14-2-剪绳子(大数).md","LeetCode-面试题14-2-剪绳子(大数)","/pages/7c3197/"],["01.剑指Offer/14.LeetCode-面试题15-二进制中1的个数.md","LeetCode-面试题15-二进制中1的个数","/pages/5abb63/"],["01.剑指Offer/15.LeetCode-面试题16-数值的整数次方.md","LeetCode-面试题16-数值的整数次方","/pages/4e2fa9/"],["01.剑指Offer/16.LeetCode-面试题18-删除链表的节点.md","LeetCode-面试题18-删除链表的节点","/pages/a7cb1c/"],["01.剑指Offer/17.LeetCode-面试题19-正则表达式匹配.md","LeetCode-面试题19-正则表达式匹配","/pages/489cb9/"],["01.剑指Offer/18.LeetCode-面试题20-表示数值的字符串.md","LeetCode-面试题20-表示数值的字符串","/pages/6845e4/"],["01.剑指Offer/19.LeetCode-面试题21-调整数组顺序使奇数位于偶数前面.md","LeetCode-面试题21-调整数组顺序使奇数位于偶数前面","/pages/d28ff3/"],["01.剑指Offer/20.LeetCode-面试题22-链表中倒数第k个节点.md","LeetCode-面试题22-链表中倒数第k个节点","/pages/663c3e/"],["01.剑指Offer/21.LeetCode-面试题24-反转链表.md","LeetCode-面试题24-反转链表","/pages/2dfb9f/"],["01.剑指Offer/22.LeetCode-面试题25-合并两个排序的链表.md","LeetCode-面试题25-合并两个排序的链表","/pages/7b5838/"],["01.剑指Offer/23.LeetCode-面试题26-树的子结构.md","LeetCode-面试题26-树的子结构","/pages/022144/"],["01.剑指Offer/24.LeetCode-面试题27-二叉树的镜像.md","LeetCode-面试题27-二叉树的镜像","/pages/107b94/"],["01.剑指Offer/25.LeetCode-面试题29-顺时针打印矩阵.md","LeetCode-面试题29-顺时针打印矩阵","/pages/0b663a/"],["01.剑指Offer/26.LeetCode-面试题31-栈的压入弹出序列.md","LeetCode-面试题31-栈的压入弹出序列","/pages/baac38/"],["01.剑指Offer/27.LeetCode-面试题32-1-从上到下打印二叉树.md","LeetCode-面试题32-1-从上到下打印二叉树","/pages/f4c63f/"],["01.剑指Offer/28.LeetCode-面试题32-2-从上到下打印二叉树 .md","LeetCode-面试题32-2-从上到下打印二叉树","/pages/7e90de/"],["01.剑指Offer/29.LeetCode-面试题32-3-从上到下打印二叉树.md","LeetCode-面试题32-3-从上到下打印二叉树","/pages/a2ebc7/"],["01.剑指Offer/30.LeetCode-面试题35-复杂链表的复制.md","LeetCode-面试题35-复杂链表的复制","/pages/9050fc/"],["01.剑指Offer/31.LeetCode-面试题36-二叉搜索树与双向链表.md","LeetCode-面试题36-二叉搜索树与双向链表","/pages/e44b62/"],["01.剑指Offer/32.LeetCode-面试题37-序列化二叉树.md","LeetCode-面试题37-序列化二叉树","/pages/1643b9/"],["01.剑指Offer/33.LeetCode-面试题38-字符串的排列.md","LeetCode-面试题38-字符串的排列","/pages/01dd29/"],["01.剑指Offer/34.LeetCode-面试题39-数组中出现次数超过一半的数字.md","LeetCode-面试题39-数组中出现次数超过一半的数字","/pages/c61856/"],["01.剑指Offer/35.LeetCode-面试题40-最小的k个数.md","LeetCode-面试题40-最小的k个数","/pages/504abd/"],["01.剑指Offer/36.LeetCode-面试题41-数据流中的中位数.md","LeetCode-面试题41-数据流中的中位数","/pages/888f97/"],["01.剑指Offer/37.LeetCode-面试题42-连续子数组的最大和.md","LeetCode-面试题42-连续子数组的最大和","/pages/95eb09/"],["01.剑指Offer/38.LeetCode-面试题43-1到n整数中1出现的次数.md","LeetCode-面试题43-1到n整数中1出现的次数","/pages/e9ceb8/"],["01.剑指Offer/39.LeetCode-面试题44-数字序列中某一位的数字.md","LeetCode-面试题44-数字序列中某一位的数字","/pages/11765a/"],["01.剑指Offer/40.LeetCode-面试题45-把数组排成最小的数.md","LeetCode-面试题45-把数组排成最小的数","/pages/0856b2/"],["01.剑指Offer/41.LeetCode-面试题47-礼物的最大价值.md","LeetCode-面试题47-礼物的最大价值","/pages/85c8fd/"],["01.剑指Offer/42.LeetCode-面试题48-最长不含重复字符的子字符串.md","LeetCode-面试题48-最长不含重复字符的子字符串","/pages/7fd908/"],["01.剑指Offer/43.LeetCode-面试题49-丑数.md","LeetCode-面试题49-丑数","/pages/0b0978/"],["01.剑指Offer/44.LeetCode-面试题50-第一次只出现一次的字符.md","LeetCode-面试题50-第一次只出现一次的字符","/pages/105b9d/"],["01.剑指Offer/45.LeetCode-面试题51-数组中的逆序对.md","LeetCode-面试题51-数组中的逆序对","/pages/3fafb8/"],["01.剑指Offer/46.LeetCode-面试题53-1-在排序数组中查找数字I.md","LeetCode-面试题53-1-在排序数组中查找数字I","/pages/c7c072/"],["01.剑指Offer/47.LeetCode-面试题33-二叉搜索树的后序遍历序列.md","LeetCode-面试题33-二叉搜索树的后序遍历序列","/pages/fe51d2/"],["01.剑指Offer/48.LeetCode-面试题54-二叉搜索树的第k大节点.md","LeetCode-面试题54-二叉搜索树的第k大节点","/pages/23d089/"],["01.剑指Offer/49.LeetCode-面试题55-1-二叉树的深度.md","LeetCode-面试题55-1-二叉树的深度","/pages/485921/"],["01.剑指Offer/50.LeetCode-面试题12-矩阵中的路径.md","LeetCode-面试题12-矩阵中的路径","/pages/254f95/"],["01.剑指Offer/51.LeetCode-面试题30-包含min函数的栈.md","LeetCode-面试题30-包含min函数的栈","/pages/c9ae12/"],["01.剑指Offer/52.LeetCode-面试题34-二叉树中和为某一值的路径.md","LeetCode-面试题34-二叉树中和为某一值的路径","/pages/e52256/"],["01.剑指Offer/53.LeetCode-面试题46-把数字翻译成字符串.md","LeetCode-面试题46-把数字翻译成字符串","/pages/73554a/"],["01.剑指Offer/54.LeetCode-面试题55-2-平衡二叉树.md","LeetCode-面试题55-2-平衡二叉树","/pages/8564b7/"],["01.剑指Offer/55.LeetCode-面试题56-1-数组中数字出现的次数1.md","LeetCode-面试题56-1-数组中数字出现的次数","/pages/0dd136/"],["01.剑指Offer/56.LeetCode-面试题56-2-数组中数字出现的次数2.md","LeetCode-面试题56-2-数组中数字出现的次数2","/pages/322274/"],["01.剑指Offer/57.LeetCode-面试题57-1-和为s的两个数字.md","LeetCode-面试题57-和为s的两个数字","/pages/64b7a6/"],["01.剑指Offer/58.LeetCode-面试题58-1-翻转单词顺序.md","LeetCode-面试题58-1-翻转单词顺序","/pages/9fdad5/"],["01.剑指Offer/59.LeetCode-面试题58-2-左旋转字符串.md","LeetCode-面试题58-2-左旋转字符串","/pages/7c648d/"],["01.剑指Offer/60.LeetCode-面试题59-2-队列的最大值.md","LeetCode-面试题59-2-队列的最大值","/pages/0c523d/"],["01.剑指Offer/61.LeetCode-面试题60-n个骰子的点数 - 副本.md","LeetCode-面试题60-n个骰子的点数","/pages/517e93/"],["01.剑指Offer/62.LeetCode-面试题61-扑克牌中的顺子.md","LeetCode-面试题61-扑克牌中的顺子","/pages/a7687d/"],["01.剑指Offer/63.LeetCode-面试题62-圆圈中最后剩下的数字.md","LeetCode-面试题62-圆圈中最后剩下的数字","/pages/9ca7ff/"],["01.剑指Offer/64.LeetCode-面试题63-股票的最大利润.md","LeetCode-面试题63-股票的最大利润","/pages/610009/"],["01.剑指Offer/65.LeetCode-面试题64-求1+2+到+n.md","LeetCode-面试题64-求1+2+到+n","/pages/4abc2f/"],["01.剑指Offer/66.LeetCode-面试题65-不用加减乘除做加法.md","LeetCode-面试题65-不用加减乘除做加法","/pages/808f6a/"],["01.剑指Offer/67.LeetCode-面试题66-构建乘积数组.md","LeetCode-面试题66-构建乘积数组","/pages/bcd8dc/"],["01.剑指Offer/68.LeetCode-面试题67-把字符串转化成整数.md","LeetCode-面试题67-把字符串转化成整数","/pages/bd49ec/"],["01.剑指Offer/69.LeetCode-面试题68-1-二叉搜索树的最近公共祖先.md","LeetCode-面试题68-1-二叉搜索树的最近公共祖先","/pages/2295ef/"],["01.剑指Offer/70.LeetCode-面试题68-2-二叉搜索树的最近公共祖先.md","LeetCode-面试题68-2-二叉搜索树的最近公共祖先","/pages/10adcf/"],["01.剑指Offer/71.LeetCode-面试题07-重建二叉树.md","LeetCode-面试题07-重建二叉树","/pages/88652a/"],["01.剑指Offer/72.LeetCode-面试题52-两个链表的第一个公共节点.md","LeetCode-面试题52-两个链表的第一个公共节点","/pages/a0e6b3/"],["01.剑指Offer/73.LeetCode-面试题53-2-0到n-1中缺失的数字.md","LeetCode-面试题53-2-0到n-1中缺失的数字","/pages/f558cf/"],["01.剑指Offer/74.LeetCode-面试题57-2-和为s的连续正数序列.md","LeetCode-面试题57-2-和为s的连续正数序列","/pages/a09b75/"],["01.剑指Offer/75.LeetCode-面试题59-1-滑动窗口的最大值.md","LeetCode-面试题59-1-滑动窗口的最大值","/pages/e91bb1/"],["01.剑指Offer/76.LeetCode-面试题28-对称的二叉树.md","LeetCode-面试题28-对称的二叉树","/pages/28dd80/"]]},{title:"LeetCode",collapsable:!1,children:[["02.LeetCode/01.LeetCode-54-螺旋矩阵.md","LeetCode-54-螺旋矩阵","/pages/b2b5b5/"],["02.LeetCode/02.LeetCode-67-二进制求和.md","LeetCode-67-二进制求和","/pages/7d3b6e/"],["02.LeetCode/03.LeetCode-83-删除排序链表中的重复元素.md","LeetCode-83-删除排序链表中的重复元素","/pages/fb7a5f/"],["02.LeetCode/04.LeetCode-415-字符串相加.md","LeetCode-415-字符串相加","/pages/9c3f56/"],["02.LeetCode/05.LeetCode-498-对角线遍历.md","LeetCode-498-对角线遍历","/pages/45d832/"],["02.LeetCode/06.LeetCode-724-寻找数组的中心索引.md","LeetCode-724-寻找数组的中心索引","/pages/f095b3/"],["02.LeetCode/07.动态规划问题——最长上升子序列(LIS)(一).md","动态规划问题——最长上升子序列(LIS)(一)","/pages/6ddb3f/"],["02.LeetCode/08.动态规划问题——最长上升子序列(LIS)(二).md","动态规划问题——最长上升子序列(LIS)(二)","/pages/1f5b98/"],["02.LeetCode/09.动态规划问题——最长上升子序列(LIS)(三).md","动态规划问题——最长上升子序列(LIS)(三)","/pages/f98f70/"],["02.LeetCode/10.LeetCode-144-二叉树的前序遍历.md","LeetCode-144-二叉树的前序遍历","/pages/b03f05/"],["02.LeetCode/11.LeetCode-94-二叉树的中序遍历.md","LeetCode-94-二叉树的中序遍历","/pages/4517f3/"],["02.LeetCode/12.LeetCode-145-二叉树的后序遍历.md","LeetCode-145-二叉树的后序遍历","/pages/bc617d/"],["02.LeetCode/13.LeetCode-53-最大子序和.md","LeetCode-53-最大子序和","/pages/1ac9e8/"],["02.LeetCode/14.LeetCode-392-判断子序列.md","LeetCode-392-判断子序列","/pages/20a5df/"],["02.LeetCode/15.LeetCode-303-区域和检索-数组不可变.md","LeetCode-303-区域和检索-数组不可变","/pages/d42c3d/"],["02.LeetCode/16.LeetCode-2-两数相加.md","LeetCode-2-两数相加","/pages/95fe08/"],["02.LeetCode/17.LeetCode-3-无重复字符的最长字串.md","LeetCode-3-无重复字符的最长字串","/pages/30e6dd/"],["02.LeetCode/18.LeetCode-4-寻找两个正序数组的中位数.md","LeetCode-4-寻找两个正序数组的中位数","/pages/e945ea/"],["02.LeetCode/19.LeetCode-5-最长回文字串.md","LeetCode-5-最长回文字串","/pages/c3c526/"],["02.LeetCode/20.LeetCode-11-盛最多水的容器.md","LeetCode-11-盛最多水的容器","/pages/1104ba/"],["02.LeetCode/21.LeetCode-15-三数之和.md","LeetCode-15-三数之和","/pages/5a4da3/"],["02.LeetCode/22.LeetCode-17-电话号码的字母组合.md","LeetCode-17-电话号码的字母组合","/pages/23ca91/"],["02.LeetCode/23.LeetCode-19-删除链表的倒数第N个节点.md","LeetCode-19-删除链表的倒数第N个节点","/pages/2b5a76/"],["02.LeetCode/24.LeetCode-20-有效的括号.md","LeetCode-20-有效的括号","/pages/b7ac0a/"],["02.LeetCode/25.LeetCode-21-合并两个有序链表.md","LeetCode-21-合并两个有序链表","/pages/d0dd86/"],["02.LeetCode/26.LeetCode-22-括号生成.md","LeetCode-22-括号生成","/pages/a6eaf0/"],["02.LeetCode/27.LeetCode-23-合并K个排序链表.md","LeetCode-23-合并K个排序链表","/pages/e24301/"],["02.LeetCode/28.LeetCode-31-下一个排列.md","LeetCode-31-下一个排列","/pages/d9a097/"],["02.LeetCode/29.LeetCode-32-最长有效括号.md","LeetCode-32-最长有效括号","/pages/bcf8b4/"],["02.LeetCode/30.LeetCode-33-搜索旋转排序数组.md","LeetCode-33-搜索旋转排序数组","/pages/1b9196/"],["02.LeetCode/31.LeetCode-34-在排序数组中查找元素的第一个和最后一个位置.md","LeetCode-34-在排序数组中查找元素的第一个和最后一个位置","/pages/1f0b71/"],["02.LeetCode/32.LeetCode-39-组合总数.md","LeetCode-39-组合总数","/pages/731f67/"],["02.LeetCode/33.LeetCode-46-全排列.md","LeetCode-46-全排列","/pages/292c69/"],["02.LeetCode/34.LeetCode-47-全排列2.md","LeetCode-47-全排列2","/pages/ed20fe/"],["02.LeetCode/35.LeetCode-51-N皇后.md","LeetCode-51-N皇后","/pages/cd98da/"],["02.LeetCode/36.LeetCode-55-跳跃游戏.md","LeetCode-55-跳跃游戏","/pages/010874/"],["02.LeetCode/37.LeetCode-56-合并区间.md","LeetCode-56-合并区间","/pages/232d3c/"],["02.LeetCode/38.LeetCode-62-不同路径.md","LeetCode-62-不同路径","/pages/193e4b/"],["02.LeetCode/39.LeetCode-64-最小路径和.md","LeetCode-64-最小路径和","/pages/b04e8c/"],["02.LeetCode/40.LeetCode-70-爬楼梯.md","LeetCode-70-爬楼梯","/pages/b9a49e/"],["02.LeetCode/41.LeetCode-72-编辑距离.md","LeetCode-72-编辑距离","/pages/dfda01/"],["02.LeetCode/42.LeetCode-75-颜色分类.md","LeetCode-75-颜色分类","/pages/a35d7b/"],["02.LeetCode/43.LeetCode-76-最小覆盖字串.md","LeetCode-76-最小覆盖字串","/pages/a90162/"],["02.LeetCode/44.LeetCode-77-组合.md","LeetCode-77-组合","/pages/c30be8/"],["02.LeetCode/45.LeetCode-78-子集.md","LeetCode-78-子集","/pages/60626a/"],["02.LeetCode/46.LeetCode-84-柱状图中最大的矩形.md","LeetCode-84-柱状图中最大的矩形","/pages/16f784/"],["02.LeetCode/47.LeetCode-102-二叉树的层序遍历.md","LeetCode-102-二叉树的层序遍历","/pages/bcc13b/"],["02.LeetCode/48.LeetCode-104-二叉树的最大深度.md","LeetCode-104-二叉树的最大深度","/pages/95771c/"],["02.LeetCode/49.LeetCode-105-从前序与中序遍历构造二叉树.md","LeetCode-105-从前序与中序遍历构造二叉树","/pages/c5dd58/"],["02.LeetCode/50.LeetCode-107-二叉树的层次遍历2.md","LeetCode-107-二叉树的层次遍历2","/pages/4d6c7d/"],["02.LeetCode/51.LeetCode-114-二叉树展开为链表.md","LeetCode-114-二叉树展开为链表","/pages/f626bf/"],["02.LeetCode/52.LeetCode-121-买卖股票的最佳时机.md","LeetCode-121-买卖股票的最佳时机","/pages/6f907a/"],["02.LeetCode/53.LeetCode-128-最长连续序列.md","LeetCode-128-最长连续序列","/pages/1c92f0/"],["02.LeetCode/54.LeetCode-136-只出现一次的数字.md","LeetCode-136-只出现一次的数字","/pages/7a9856/"],["02.LeetCode/55.LeetCode-142-环形链表2.md","LeetCode-142-环形链表2","/pages/21e57b/"],["02.LeetCode/56.LeetCode-143-重排链表.md","LeetCode-143-重排链表","/pages/825806/"],["02.LeetCode/57.LeetCode-146-LRU缓存机制.md","LeetCode-146-LRU缓存机制","/pages/0d05d2/"],["02.LeetCode/58.LeetCode-152-乘积最大子数组.md","LeetCode-152-乘积最大子数组","/pages/87a481/"],["02.LeetCode/59.LeetCode-198-打家劫舍.md","LeetCode-198-打家劫舍","/pages/bd9776/"],["02.LeetCode/60.LeetCode-199-二叉树的右视图.md","LeetCode-199-二叉树的右视图","/pages/2aa937/"],["02.LeetCode/61.LeetCode-206-反转链表.md","LeetCode-206-反转链表","/pages/7c576f/"],["02.LeetCode/62.LeetCode-207-课程表.md","LeetCode-207-课程表","/pages/44df2f/"],["02.LeetCode/63.LeetCode-215-数组中的第K个最大元素.md","LeetCode-215-数组中的第K个最大元素","/pages/f586d8/"],["02.LeetCode/64.LeetCode-221-最大正方形.md","LeetCode-221-最大正方形","/pages/3b7ec6/"],["02.LeetCode/65.LeetCode-226-翻转二叉树.md","LeetCode-226-翻转二叉树","/pages/2bee97/"],["02.LeetCode/66.LeetCode-236-二叉树的最近公共祖先.md","LeetCode-236-二叉树的最近公共祖先","/pages/ceb226/"],["02.LeetCode/67.LeetCode-279-完全平方数.md","LeetCode-279-完全平方数","/pages/aa9694/"],["02.LeetCode/68.LeetCode-287-寻找重复数.md","LeetCode-287-寻找重复数","/pages/d6c0fb/"],["02.LeetCode/69.LeetCode-300-最长上升子序列.md","LeetCode-300-最长上升子序列","/pages/444ab2/"],["02.LeetCode/70.LeetCode-309-最佳买卖股票时机含冷冻期.md","LeetCode-309-最佳买卖股票时机含冷冻期","/pages/3b3388/"],["02.LeetCode/71.LeetCode-322-零钱兑换.md","LeetCode-322-零钱兑换","/pages/9868ec/"],["02.LeetCode/72.LeetCode-328-奇偶链表.md","LeetCode-328-奇偶链表","/pages/74a1b6/"],["02.LeetCode/73.LeetCode-347-前K个高频元素.md","LeetCode-347-前K个高频元素","/pages/5abc8f/"],["02.LeetCode/74.LeetCode-394-字符串解码.md","LeetCode-394-字符串解码","/pages/0af455/"],["02.LeetCode/75.LeetCode-406-根据身高重建队列.md","LeetCode-406-根据身高重建队列","/pages/8d243f/"],["02.LeetCode/76.LeetCode-413-等差数列划分.md","LeetCode-413-等差数列划分","/pages/cd66f6/"],["02.LeetCode/77.LeetCode-416-分割等和子集.md","LeetCode-416-分割等和子集","/pages/87a353/"],["02.LeetCode/78.LeetCode-438-找到字符串中所有字母异位词.md","LeetCode-438-找到字符串中所有字母异位词","/pages/e8a730/"],["02.LeetCode/79.LeetCode-448-找到所有数组中消失的数字.md","LeetCode-448-找到所有数组中消失的数字","/pages/d2f3f5/"],["02.LeetCode/80.LeetCode-461-汉明距离.md","LeetCode-461-汉明距离","/pages/ad566a/"],["02.LeetCode/81.LeetCode-494-目标和.md","LeetCode-494-目标和","/pages/ed7689/"],["02.LeetCode/82.LeetCode-538-把二叉搜索树转换为累加树.md","LeetCode-538-把二叉搜索树转换为累加树","/pages/9d7aee/"],["02.LeetCode/83.LeetCode-543-二叉树的直径.md","LeetCode-543-二叉树的直径","/pages/a78f8c/"],["02.LeetCode/84.LeetCode-560-和为K的子数组.md","LeetCode-560-和为K的子数组","/pages/c7dca6/"],["02.LeetCode/85.LeetCode-567-字符串的排列.md","LeetCode-567-字符串的排列","/pages/5997b7/"],["02.LeetCode/86.LeetCode-581-最短无序连续子数组.md","LeetCode-581-最短无序连续子数组","/pages/9686ce/"],["02.LeetCode/87.LeetCode-617-合并二叉树.md","LeetCode-617-合并二叉树","/pages/f24660/"],["02.LeetCode/88.LeetCode-704-二分查找.md","LeetCode-704-二分查找","/pages/326143/"],["02.LeetCode/89.LeetCode-739-每日温度.md","LeetCode-739-每日温度","/pages/d7d595/"],["02.LeetCode/90.LeetCode-747-至少是其他数字两倍的最大数.md","LeetCode-747-至少是其他数字两倍的最大数","/pages/0343b2/"],["02.LeetCode/91.LeetCode-890-查找和替换模式.md","LeetCode-890-查找和替换模式","/pages/a29fa8/"],["02.LeetCode/92.LeetCode-1143-最长公共子序列.md","LeetCode-1143-最长公共子序列","/pages/77c839/"],["02.LeetCode/93.LeetCode-1247-交换字符使得字符串相同.md","LeetCode-1247-交换字符使得字符串相同","/pages/961a11/"],["02.LeetCode/94.LeetCode-1367-二叉树中的列表.md","LeetCode-1367-二叉树中的列表","/pages/053bcf/"],["02.LeetCode/95.LeetCode-字符串排序.md","LeetCode-字符串排序","/pages/a64c8b/"],["02.LeetCode/96.LeetCode-面试题02-02-返回倒数第k个节点.md","LeetCode-面试题02.02-返回倒数第k个节点","/pages/7899ff/"],["02.LeetCode/97.LeetCode-面试题17-16-按摩师.md","LeetCode-面试题17.16-按摩师","/pages/0c5197/"],["02.LeetCode/98.获取满足指数的最长字符串.md","获取满足指数的最长字符串","/pages/5969d4/"],["02.LeetCode/99.数组的最多素数个数.md","数组的最多素数个数","/pages/13f871/"],["02.LeetCode/100.最小字典序字符串.md","最小字典序字符串","/pages/bac26b/"],["02.LeetCode/101.LeetCode-1-两数之和.md","LeetCode-1-两数之和","/pages/005df6/"],["02.LeetCode/102.LeetCode-16-最接近的三数之和.md","LeetCode-16-最接近的三数之和","/pages/ce722a/"],["02.LeetCode/103.LeetCode-679-24点游戏.md","LeetCode-679-24点游戏","/pages/ebc391/"],["02.LeetCode/104.LeetCode-141-环形链表.md","LeetCode-141-环形链表","/pages/edad8f/"],["02.LeetCode/105.LeetCode-155-最小栈.md","LeetCode-155-最小栈","/pages/2fc7af/"],["02.LeetCode/106.LeetCode-160-相交链表.md","LeetCode-160-相交链表","/pages/19f71b/"],["02.LeetCode/107.判断一棵二叉树是否为二叉搜索树和完全二叉树.md","判断一棵二叉树是否为二叉搜索树和完全二叉树","/pages/6d1dda/"],["02.LeetCode/108.LeetCode-169-多数元素.md","LeetCode-169-多数元素","/pages/657ad4/"],["02.LeetCode/109.LeetCode-234-回文链表.md","LeetCode-234-回文链表","/pages/4923ab/"],["02.LeetCode/110.LeetCode-238-除自身以外数组的乘积.md","LeetCode-238-除自身以外数组的乘积","/pages/c56f5d/"],["02.LeetCode/111.LeetCode-283-移动零.md","LeetCode-283-移动零","/pages/b249d6/"],["02.LeetCode/112.LeetCode-338-比特位计数.md","LeetCode-338-比特位计数","/pages/4a24f6/"],["02.LeetCode/113.LeetCode-797-所有可能的路径.md","LeetCode-797-所有可能的路径","/pages/0b83ab/"]]},{title:"排序算法",collapsable:!1,children:[["03.排序算法/00.常见排序算法总结.md","常见排序算法总结","/pages/8d006a/"],["03.排序算法/01.冒泡排序.md","冒泡排序","/pages/3fd3f6/"],["03.排序算法/02.基数排序.md","基数排序","/pages/5ee1b6/"],["03.排序算法/03.堆排序.md","堆排序","/pages/c0468a/"],["03.排序算法/04.希尔排序.md","希尔排序","/pages/05578a/"],["03.排序算法/05.归并排序.md","归并排序","/pages/246724/"],["03.排序算法/06.快速排序.md","快速排序","/pages/c1fce8/"],["03.排序算法/07.插入排序.md","插入排序","/pages/db04fa/"],["03.排序算法/08.桶排序.md","桶排序","/pages/7a5e99/"],["03.排序算法/09.选择排序.md","选择排序","/pages/ee0279/"]]}],"/07.实践/":[{title:"hexo",collapsable:!1,children:[["01.hexo/01.将hexo自定义域名升级https.md","将hexo自定义域名升级https","/pages/f6b758/"],["01.hexo/02.hexo到Typecho的迁移日志.md","hexo到Typecho的迁移日志","/pages/a07112/"]]},{title:"思考与方案",collapsable:!1,children:[["02.思考与方案/01.海量数据TopK问题.md","海量数据TopK问题","/pages/2c256c/"],["02.思考与方案/02.关于DO,VO,DTO,QueryParam的思考.md","关于DO,VO,DTO,QueryParam的思考","/pages/45617b/"],["02.思考与方案/03.异步消息通知.md","异步消息通知—异步改造","/pages/3572ad/"],["02.思考与方案/04.二叉搜索树及AVL树详解.md","二叉搜索树及AVL树详解","/pages/2efaaf/"]]}],"/08.开源项目/":[{title:"Rpamis",collapsable:!1,children:[{title:"Utils",collapsable:!1,children:[["01.Rpamis/01.Utils/01.无惧性能烦恼-12款Bean拷贝工具压测大比拼.md","无惧性能烦恼-12款Bean拷贝工具压测大比拼","/pages/3147fe/"],["01.Rpamis/01.Utils/02.Bean工具类-RpasBeanUtils.md","Bean工具类-RpasBeanUtils","/pages/cedee6/"]]},{title:"Exception",collapsable:!1,children:[["01.Rpamis/02.Exception/01.MethodHandle结合LambdaMetafactory-使用方法及性能测试.md","MethodHandle结合LambdaMetafactory-使用方法及性能测试","/pages/b127c7/"],["01.Rpamis/02.Exception/02.优雅的参数校验与全局异常.md","优雅的参数校验与全局异常-代码规范的天生落地","/pages/1c47ed/"],["01.Rpamis/02.Exception/03.异常工具类-ExceptionFactory.md","异常工具类-ExceptionFactory","/pages/4c5812/"],["01.Rpamis/02.Exception/04.异常工具类-Assert.md","异常工具类-Assert","/pages/cb1099/"]]}]}],"/09.索引/":[{title:"开源项目",collapsable:!1,children:[["01.开源项目/01.概览.md","概览","/pages/2c6c1b/"]]}],"/10.关于/":[["01.关于.md","关于","/about/"]],"/11.目录/":[{title:"Java",collapsable:!1,children:[["01.Java/01.Java.md","Java","/pages/059f1f/"]]},{title:"Python",collapsable:!1,children:[["02.Python/01.Python基础.md","Python-基础","/pages/ad6515/"],["02.Python/02.Python机器学习.md","Python-机器学习","/pages/82c271/"]]},{title:"算法",collapsable:!1,children:[["06.算法/01.剑指Offer.md","剑指Offer","/pages/f91e0d/"],["06.算法/02.LeetCode.md","LeetCode","/pages/b59559/"]]}]},updateBar:{showToArticle:!0},category:!1,tag:!0,archive:!0,author:{name:"benym",href:"https://github.com/benym"},blogger:{avatar:"https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/sitelogo3.jpg/zipstyle",name:"benym",slogan:"惟其艰难，才更显勇毅🍂惟其笃行，才弥足珍贵"},social:{icons:[{iconClass:"icon-youjian",title:"邮件",link:"mailto:675260709@qq.com"},{iconClass:"icon-github",title:"GitHub",link:"https://github.com/benym"},{iconClass:"icon-zhihu",title:"知乎",link:"https://www.zhihu.com/people/xu-ge-yuan-ba-68"}]},footer:{createYear:2018,copyrightInfo:'benym | <a href="https://github.com/benym/benym-book/blob/master/LICENSE" target="_blank">MIT License</a> | <a href="https://beian.miit.gov.cn/#/Integrated/index" target="_blank">渝ICP备18012574号</a>'},extendFrontmatter:{author:{name:"benym",link:"https://github.com/benym"}},blogInfo:{blogCreate:"2018-03-01",indexView:!0,pageView:!0,readingTime:!0,eachFileWords:[{name:"概览",filePath:"/home/runner/work/benym-book/benym-book/docs/00.导航/01.概览.md",wordsCount:30,readingTime:"1",title:"概览",article:!1,tags:[null],date:"2022-04-17T18:56:31.000Z",permalink:"/pages/7848bb/",author:{name:"benym",link:"https://github.com/benym"}},{name:"Java反射获取类对象的三种方式",filePath:"/home/runner/work/benym-book/benym-book/docs/01.Java/01.Java/01.Java-基础/01.Java反射获取类对象的三种方式.md",wordsCount:253,readingTime:"1m",title:"Java反射获取类对象的三种方式",date:"2020-06-29T19:36:09.000Z",description:"总结",categories:["Java"],tags:["反射","Java"],keywords:"反射,Java",permalink:"/pages/225727/",author:{name:"benym",link:"https://github.com/benym"}},{name:"动态代理使用方法",filePath:"/home/runner/work/benym-book/benym-book/docs/01.Java/01.Java/01.Java-基础/02.动态代理使用方法.md",wordsCount:"3.7k",readingTime:"15.1m",title:"动态代理",date:"2021-10-19T14:46:15.000Z",description:"总结",categories:["Java"],tags:["动态代理","Java"],keywords:"Java,动态代理,JDK,Cglib",permalink:"/pages/ddcc22/",author:{name:"benym",link:"https://github.com/benym"}},{name:"ArrayList的扩容机制",filePath:"/home/runner/work/benym-book/benym-book/docs/01.Java/01.Java/02.Java-集合/01.ArrayList的扩容机制.md",wordsCount:"2k",readingTime:"9.1m",title:"ArrayList的扩容机制",date:"2020-07-07T10:20:55.000Z",description:"总结",categories:["Java"],tags:["Java"],keywords:"Java",permalink:"/pages/9786e5/",author:{name:"benym",link:"https://github.com/benym"}},{name:"Java多线程实现的几种方式",filePath:"/home/runner/work/benym-book/benym-book/docs/01.Java/01.Java/03.Java-多线程与并发/01.Java多线程实现的几种方式.md",wordsCount:657,readingTime:"2.7m",title:"Java多线程实现的几种方式",date:"2020-06-28T10:25:41.000Z",description:"总结",categories:["Java"],tags:["多线程","Java"],keywords:"多线程,Java",permalink:"/pages/487c60/",author:{name:"benym",link:"https://github.com/benym"}},{name:"多线程打印数字-多种实现",filePath:"/home/runner/work/benym-book/benym-book/docs/01.Java/01.Java/03.Java-多线程与并发/02.多线程打印数字-多种实现.md",wordsCount:"1.1k",readingTime:"4.8m",title:"多线程交替打印数字—多种实现",date:"2022-01-14T21:18:48.000Z",categories:["Java"],tags:["Java","多线程"],permalink:"/pages/5047a0/",author:{name:"benym",link:"https://github.com/benym"}},{name:"CountDownLatch使用方法",filePath:"/home/runner/work/benym-book/benym-book/docs/01.Java/01.Java/03.Java-多线程与并发/03.CountDownLatch使用方法.md",wordsCount:785,readingTime:"3.1m",title:"CountDownLatch使用方法",date:"2022-01-18T16:18:48.000Z",categories:["Java"],tags:["Java","JUC"],permalink:"/pages/bccbee/",author:{name:"benym",link:"https://github.com/benym"}},{name:"CyclicBarrier使用方法",filePath:"/home/runner/work/benym-book/benym-book/docs/01.Java/01.Java/03.Java-多线程与并发/04.CyclicBarrier使用方法.md",wordsCount:"1.7k",readingTime:"8.4m",title:"CyclicBarrier使用方法",date:"2022-01-18T17:28:48.000Z",categories:["Java"],tags:["Java","JUC"],permalink:"/pages/3898a4/",author:{name:"benym",link:"https://github.com/benym"}},{name:"Semaphore使用方法",filePath:"/home/runner/work/benym-book/benym-book/docs/01.Java/01.Java/03.Java-多线程与并发/05.Semaphore使用方法.md",wordsCount:"2.6k",readingTime:"10.6m",title:"Semaphore使用方法",date:"2022-01-18T22:35:48.000Z",categories:["Java"],tags:["Java","JUC"],permalink:"/pages/8e40cc/",author:{name:"benym",link:"https://github.com/benym"}},{name:"CompletableFuture常用用法及问题排查",filePath:"/home/runner/work/benym-book/benym-book/docs/01.Java/01.Java/03.Java-多线程与并发/06.CompletableFuture常用用法及问题排查.md",wordsCount:"1.8k",readingTime:"7.5m",title:"CompletableFuture常用用法及踩坑",categories:["Java"],tags:["Java","JUC","CompletableFuture"],date:"2022-06-06T21:05:25.000Z",permalink:"/pages/b1318d/",author:{name:"benym",link:"https://github.com/benym"}},{name:"自定义类加载器",filePath:"/home/runner/work/benym-book/benym-book/docs/01.Java/01.Java/04.Java-JVM/01.自定义类加载器.md",wordsCount:"2k",readingTime:"8.5m",title:"自定义类加载器",date:"2021-11-18T19:48:15.000Z",description:"总结",categories:["Java"],tags:["类加载器","ClassLoader","双亲委派模型","Java"],keywords:"Java,类加载器,ClassLoader,双亲委派模型",permalink:"/pages/0a146e/",author:{name:"benym",link:"https://github.com/benym"}},{name:"JMH-基准测试框架",filePath:"/home/runner/work/benym-book/benym-book/docs/01.Java/01.Java/04.Java-JVM/02.JMH-基准测试框架.md",wordsCount:"3.5k",readingTime:"14.7m",title:"JMH-基准测试框架",date:"2022-12-29T14:16:15.000Z",description:"总结",categories:["Java","JVM"],tags:["Java","JVM","JMH","BenchMark"],permalink:"/pages/ffed02/",author:{name:"benym",link:"https://github.com/benym"}},{name:"概览",filePath:"/home/runner/work/benym-book/benym-book/docs/01.Java/01.Java/05.Java-IO/01.概览.md",wordsCount:30,readingTime:"1",title:"概览",article:!1,tags:[null],date:"2022-04-17T18:55:36.000Z",permalink:"/pages/4aef64/",author:{name:"benym",link:"https://github.com/benym"}},{name:"assert语句的运用",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/01.Python-基础/01.assert语句的运用.md",wordsCount:117,readingTime:"1",title:"assert语句的运用",date:"2018-07-24T18:41:28.000Z",categories:["Python-基础"],tags:["Python基础","assert"],permalink:"/pages/0de67d/",author:{name:"benym",link:"https://github.com/benym"}},{name:"list(列表)、tuple(元组)、dict(字典)的回顾",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/01.Python-基础/02.list(列表)、tuple(元组)、dict(字典)的回顾.md",wordsCount:483,readingTime:"2.2m",title:"list(列表)、tuple（元组）、dict（字典）的回顾",date:"2018-07-25T20:57:55.000Z",categories:["Python-基础"],tags:["Python基础","Python集合"],permalink:"/pages/50bf39/",author:{name:"benym",link:"https://github.com/benym"}},{name:"Python中的Docstring",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/01.Python-基础/03.Python中的Docstring.md",wordsCount:209,readingTime:"1",title:"Python中的Docstring",date:"2018-06-27T17:14:51.000Z",categories:["Python-基础"],tags:["Python基础"],permalink:"/pages/31bd37/",author:{name:"benym",link:"https://github.com/benym"}},{name:"Python中的多态",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/01.Python-基础/04.Python中的多态.md",wordsCount:385,readingTime:"1.6m",title:"Python中的多态",date:"2018-08-08T19:41:53.000Z",categories:["Python-基础"],tags:["Python多态","Python基础"],permalink:"/pages/866a91/",author:{name:"benym",link:"https://github.com/benym"}},{name:"Python中的集合",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/01.Python-基础/05.Python中的集合.md",wordsCount:181,readingTime:"1",title:"Python中的集合",date:"2018-07-07T17:34:06.000Z",categories:["Python-基础"],tags:["Python基础","Python集合"],permalink:"/pages/c47343/",author:{name:"benym",link:"https://github.com/benym"}},{name:"Python中的列表",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/01.Python-基础/06.Python中的列表.md",wordsCount:285,readingTime:"1.2m",title:"Python中的列表",date:"2018-07-07T17:19:37.000Z",categories:["Python-基础"],tags:["Python基础"],permalink:"/pages/c498f9/",author:{name:"benym",link:"https://github.com/benym"}},{name:"Python中的序列以及切片的解释",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/01.Python-基础/07.Python中的序列以及切片的解释.md",wordsCount:296,readingTime:"1.4m",title:"Python中的序列以及切片的解释",date:"2018-07-07T17:07:39.000Z",categories:["Python-基础"],tags:["Python基础","Python切片"],permalink:"/pages/0d6aa8/",author:{name:"benym",link:"https://github.com/benym"}},{name:"Python中的引用和切片",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/01.Python-基础/08.Python中的引用和切片.md",wordsCount:392,readingTime:"1.5m",title:"Python中的引用和切片",date:"2018-07-07T16:04:03.000Z",categories:["Python-基础"],tags:["Python基础","引用","切片"],permalink:"/pages/037f6f/",author:{name:"benym",link:"https://github.com/benym"}},{name:"Python中的元组",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/01.Python-基础/09.Python中的元组.md",wordsCount:326,readingTime:"1.3m",title:"Python中的元组",date:"2018-07-07T17:15:01.000Z",categories:["Python-基础"],tags:["Python基础","元组"],permalink:"/pages/e8270d/",author:{name:"benym",link:"https://github.com/benym"}},{name:"Python中对列表和元组的切片操作",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/01.Python-基础/10.Python中对列表和元组的切片操作.md",wordsCount:134,readingTime:"1",title:"Python中对列表和元组的切片操作",date:"2018-07-26T20:04:26.000Z",categories:["Python-基础"],tags:["Python基础","切片"],permalink:"/pages/bf2ef2/",author:{name:"benym",link:"https://github.com/benym"}},{name:"Python中完整for循环的实际运用",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/01.Python-基础/11.Python中完整for循环的实际运用.md",wordsCount:189,readingTime:"1",title:"Python中完整for循环的实际运用",date:"2018-07-26T09:56:03.000Z",categories:["Python-基础"],tags:["Python基础"],permalink:"/pages/7c7c36/",author:{name:"benym",link:"https://github.com/benym"}},{name:"Python中字典(key-value)",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/01.Python-基础/12.Python中字典(key-value).md",wordsCount:308,readingTime:"1.3m",title:"Python中字典(key-value)",date:"2018-07-07T17:25:27.000Z",categories:["Python-基础"],tags:["Python基础","字典"],permalink:"/pages/76ac47/",author:{name:"benym",link:"https://github.com/benym"}},{name:"Python中字符串的一些方法回顾(拆分与合并)",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/01.Python-基础/13.Python中字符串的一些方法回顾(拆分与合并).md",wordsCount:299,readingTime:"1.1m",title:"Python中字符串的一些方法回顾(拆分与合并)",date:"2018-07-26T19:40:01.000Z",categories:["Python-基础"],tags:["Python基础"],permalink:"/pages/5386bd/",author:{name:"benym",link:"https://github.com/benym"}},{name:"Python中字符串的一些方法回顾(切片回顾)",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/01.Python-基础/14.Python中字符串的一些方法回顾(切片回顾).md",wordsCount:281,readingTime:"1.1m",title:"Python中字符串的一些方法回顾(切片回顾)",date:"2018-07-26T19:40:48.000Z",categories:["Python-基础"],tags:["Python基础","切片"],permalink:"/pages/c7192a/",author:{name:"benym",link:"https://github.com/benym"}},{name:"Python中字符串的一些方法回顾(文本对齐、去除空白)",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/01.Python-基础/15.Python中字符串的一些方法回顾(文本对齐、去除空白).md",wordsCount:276,readingTime:"1m",title:"Python中字符串的一些方法回顾(文本对齐、去除空白)",date:"2018-07-26T19:39:41.000Z",categories:["Python-基础"],tags:["Python基础","strip"],permalink:"/pages/a7c3f3/",author:{name:"benym",link:"https://github.com/benym"}},{name:"Python中字符串的一些方法回顾",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/01.Python-基础/16.Python中字符串的一些方法回顾.md",wordsCount:273,readingTime:"1.1m",title:"Python中字符串的一些方法回顾",date:"2018-07-25T21:29:40.000Z",categories:["Python-基础"],tags:["Python基础","字符串"],permalink:"/pages/800d04/",author:{name:"benym",link:"https://github.com/benym"}},{name:"Python中字符串的一些基本操作",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/01.Python-基础/17.Python中字符串的一些基本操作.md",wordsCount:284,readingTime:"1.1m",title:"Python中字符串的一些基本操作",date:"2018-07-07T17:04:05.000Z",categories:["Python-基础"],tags:["Python基础","字符串"],permalink:"/pages/76881f/",author:{name:"benym",link:"https://github.com/benym"}},{name:"多种方法快速交换两个变量的值",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/01.Python-基础/18.多种方法快速交换两个变量的值.md",wordsCount:222,readingTime:"1",title:"多种方法快速交换两个变量的值",date:"2018-07-24T09:33:48.000Z",categories:["Python-基础"],tags:["Python基础"],permalink:"/pages/e5cf66/",author:{name:"benym",link:"https://github.com/benym"}},{name:"利用Python进行文件的自动备份",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/01.Python-基础/19.利用Python进行文件的自动备份.md",wordsCount:576,readingTime:"2.4m",title:"利用Python进行文件的自动备份",date:"2018-07-22T16:04:32.000Z",categories:["Python-基础"],tags:["Python基础"],permalink:"/pages/369a5f/",author:{name:"benym",link:"https://github.com/benym"}},{name:"利用Python进行文件的自动备份(第二版)",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/01.Python-基础/20.利用Python进行文件的自动备份(第二版).md",wordsCount:585,readingTime:"2.6m",title:"利用Python进行文件的自动备份(第二版)",date:"2018-07-23T18:49:11.000Z",categories:["Python-基础"],tags:["Python基础","备份"],permalink:"/pages/04f569/",author:{name:"benym",link:"https://github.com/benym"}},{name:"利用Python进行文件的自动备份(第三版和第四版)",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/01.Python-基础/21.利用Python进行文件的自动备份(第三版和第四版).md",wordsCount:381,readingTime:"1.9m",title:"利用Python进行文件的自动备份(第三版和第四版)",date:"2018-07-23T18:54:24.000Z",categories:["Python"],tags:["基本教程"],permalink:"/pages/a8d563/",author:{name:"benym",link:"https://github.com/benym"}},{name:"列表推导",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/01.Python-基础/22.列表推导.md",wordsCount:249,readingTime:"1",title:"列表推导",date:"2018-07-24T18:33:13.000Z",categories:["Python-基础"],tags:["Python基础","列表"],permalink:"/pages/f7e4b1/",author:{name:"benym",link:"https://github.com/benym"}},{name:"在函数中接受元组与字典",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/01.Python-基础/23.在函数中接受元组与字典.md",wordsCount:282,readingTime:"1.1m",title:"在函数中接受元组与字典",date:"2018-07-24T18:36:49.000Z",categories:["Python-基础"],tags:["Python基础"],permalink:"/pages/f954d1/",author:{name:"benym",link:"https://github.com/benym"}},{name:"装饰器",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/01.Python-基础/24.装饰器.md",wordsCount:451,readingTime:"2.1m",title:"装饰器",date:"2018-07-24T18:45:48.000Z",categories:["Python-基础"],tags:["Python基础"],permalink:"/pages/962777/",author:{name:"benym",link:"https://github.com/benym"}},{name:"finally异常处理",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/01.Python-基础/25.finally异常处理.md",wordsCount:167,readingTime:"1",title:"finally异常处理",date:"2018-07-23T19:51:46.000Z",categories:["Python-基础"],tags:["Python异常处理"],permalink:"/pages/cd9b6e/",author:{name:"benym",link:"https://github.com/benym"}},{name:"Python的main函数作用",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/01.Python-基础/26.Python的main函数作用.md",wordsCount:445,readingTime:"1.7m",title:"Python的__name__ = '__main__' 的作用",date:"2018-07-24T11:05:44.000Z",categories:["Python-基础"],tags:["Python基础"],permalink:"/pages/f09b25/",author:{name:"benym",link:"https://github.com/benym"}},{name:"Python的pickle模块",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/01.Python-基础/27.Python的pickle模块.md",wordsCount:281,readingTime:"1.2m",title:"Python的pickle模块",date:"2018-07-23T19:45:46.000Z",categories:["Python-基础"],tags:["Python基础"],permalink:"/pages/ee2549/",author:{name:"benym",link:"https://github.com/benym"}},{name:"Python对象的实例化",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/01.Python-基础/28.Python对象的实例化.md",wordsCount:124,readingTime:"1",title:"Python对象的实例化",date:"2018-07-23T19:03:33.000Z",categories:["Python-基础"],tags:["Python基础"],permalink:"/pages/7cedd2/",author:{name:"benym",link:"https://github.com/benym"}},{name:"Python日志模块",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/01.Python-基础/29.Python日志模块.md",wordsCount:208,readingTime:"1m",title:"Python日志模块",date:"2018-07-23T20:03:18.000Z",categories:["Python-基础"],tags:["Python基础"],permalink:"/pages/adffdd/",author:{name:"benym",link:"https://github.com/benym"}},{name:"Python中的__new__方法的重写",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/01.Python-基础/30.Python中的__new__方法的重写.md",wordsCount:172,readingTime:"1",title:"Python中的__new__方法的重写",date:"2018-08-08T20:56:28.000Z",description:"__new__方法的重写，单例模式前置？",categories:"Python-基础",tags:"Python基础",permalink:"/pages/985752/",author:{name:"benym",link:"https://github.com/benym"}},{name:"Python中的lambda函数",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/01.Python-基础/31.Python中的lambda函数.md",wordsCount:318,readingTime:"1.4m",title:"Python中的lambda函数",date:"2018-07-24T18:27:03.000Z",categories:["Python-基础"],tags:["Python基础"],permalink:"/pages/7235b8/",author:{name:"benym",link:"https://github.com/benym"}},{name:"Python中的静态方法、实例方法、类方法的区别",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/01.Python-基础/32.Python中的静态方法、实例方法、类方法的区别.md",wordsCount:462,readingTime:"1.8m",title:"Python中的静态方法、实例方法、类方法的区别",date:"2018-08-08T20:34:25.000Z",description:"静态方法，实例方法，类方法的区别",categories:"Python-基础",tags:"Python-基础",permalink:"/pages/57af9e/",author:{name:"benym",link:"https://github.com/benym"}},{name:"Python中的正则表达式",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/01.Python-基础/33.Python中的正则表达式.md",wordsCount:519,readingTime:"2.3m",title:"Python中的正则表达式",date:"2018-08-07T20:00:45.000Z",categories:["Python-基础"],tags:["Python基础"],permalink:"/pages/38b0ff/",author:{name:"benym",link:"https://github.com/benym"}},{name:"Python中的正则表达式match和search",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/01.Python-基础/34.Python中的正则表达式match和search.md",wordsCount:210,readingTime:"1",title:"Python中的正则表达式match和search",date:"2018-08-07T20:16:00.000Z",categories:["Python-基础"],tags:["Python基础"],permalink:"/pages/ee44fe/",author:{name:"benym",link:"https://github.com/benym"}},{name:"Python中面向对象比较简单的内部函数",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/01.Python-基础/35.Python中面向对象比较简单的内部函数.md",wordsCount:185,readingTime:"1",title:"Python中面向对象比较简单的内部函数",date:"2018-08-06T21:40:11.000Z",categories:["Python-基础"],tags:["Python基础"],permalink:"/pages/d79b2c/",author:{name:"benym",link:"https://github.com/benym"}},{name:"with-open异常处理",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/01.Python-基础/36.with-open异常处理.md",wordsCount:101,readingTime:"1",title:"with open异常处理",date:"2018-07-23T19:55:48.000Z",categories:["Python-基础"],tags:["Python异常处理"],permalink:"/pages/c20072/",author:{name:"benym",link:"https://github.com/benym"}},{name:"Python单例设计模式",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/01.Python-基础/37.Python单例设计模式.md",wordsCount:291,readingTime:"1.2m",title:"单例设计模式",date:"2018-08-08T21:15:36.000Z",categories:"Python-基础",tags:"Python面向对象",permalink:"/pages/ccdd54/",author:{name:"benym",link:"https://github.com/benym"}},{name:"继承的运用",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/01.Python-基础/38.继承的运用.md",wordsCount:239,readingTime:"1.3m",title:"继承的运用",date:"2018/7/23 19:19:24",categories:["Python"],tags:["Python面向对象"],permalink:"/pages/6a1778/",author:{name:"benym",link:"https://github.com/benym"}},{name:"简单的异常处理",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/01.Python-基础/39.简单的异常处理.md",wordsCount:96,readingTime:"1",title:"简单的异常处理",date:"2018-07-23T19:51:46.000Z",categories:["Python-基础"],tags:["Python异常处理"],permalink:"/pages/8d431d/",author:{name:"benym",link:"https://github.com/benym"}},{name:"类变量与对象变量",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/01.Python-基础/40.类变量与对象变量.md",wordsCount:502,readingTime:"2.3m",title:"类变量与对象变量",date:"2018-07-23T19:08:50.000Z",categories:["Python-基础"],tags:["Python面向对象"],permalink:"/pages/43bfe3/",author:{name:"benym",link:"https://github.com/benym"}},{name:"输入输出——简单的回文判断",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/01.Python-基础/41.输入输出——简单的回文判断.md",wordsCount:247,readingTime:"1m",title:"输入输出——简单的回文判断",date:"2018-07-23T19:30:11.000Z",categories:["Python-基础"],tags:["Python面向对象"],permalink:"/pages/0f3eea/",author:{name:"benym",link:"https://github.com/benym"}},{name:"输入输出——回文字串的判断（加强版）",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/01.Python-基础/42.输入输出——回文字串的判断（加强版）.md",wordsCount:220,readingTime:"1m",title:"输入输出——回文字串的判断（加强版）",date:"2018-07-23T19:36:35.000Z",categories:["Python-基础"],tags:["Python面向对象"],permalink:"/pages/efd97d/",author:{name:"benym",link:"https://github.com/benym"}},{name:"文件操作",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/01.Python-基础/43.文件操作.md",wordsCount:200,readingTime:"1",title:"文件操作",date:"2018-07-23T19:36:35.000Z",categories:["Python-基础"],tags:["Python面向对象"],permalink:"/pages/9d76ce/",author:{name:"benym",link:"https://github.com/benym"}},{name:"用户自己引发的异常处理",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/01.Python-基础/44.用户自己引发的异常处理.md",wordsCount:212,readingTime:"1m",title:"用户自己引发的异常处理",date:"2018-07-23T19:58:26.000Z",categories:["Python-基础"],tags:["Python异常处理"],permalink:"/pages/74cf7d/",author:{name:"benym",link:"https://github.com/benym"}},{name:"正则表达式检索与替换",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/01.Python-基础/45.正则表达式检索与替换.md",wordsCount:162,readingTime:"1",title:"正则表达式检索与替换",date:"2018-08-07T20:43:26.000Z",categories:["Python-基础"],tags:["Python正则表达式"],permalink:"/pages/e8935b/",author:{name:"benym",link:"https://github.com/benym"}},{name:"正则表达式中的compile函数",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/01.Python-基础/46.正则表达式中的compile函数.md",wordsCount:530,readingTime:"2.2m",title:"正则表达式中的compile函数",date:"2018-08-07T20:47:00.000Z",categories:["Python-基础"],tags:["Python正则表达式"],permalink:"/pages/270272/",author:{name:"benym",link:"https://github.com/benym"}},{name:"正则表达式中的compile函数(二)",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/01.Python-基础/47.正则表达式中的compile函数(二).md",wordsCount:295,readingTime:"1.3m",title:"正则表达式中的compile函数(二)",date:"2018-08-07T21:16:21.000Z",description:"compile函数(二)",categories:["Python-基础"],tags:["Python正则表达式"],permalink:"/pages/bff928/",author:{name:"benym",link:"https://github.com/benym"}},{name:"Numpy库的首次使用",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/02.Python-机器学习/01.Numpy库的首次使用.md",wordsCount:362,readingTime:"1.8m",title:"Numpy库的首次使用",date:"2018-08-09T20:53:08.000Z",categories:["Python-机器学习"],tags:["Numpy","机器学习","矩阵"],permalink:"/pages/43f8b9/",author:{name:"benym",link:"https://github.com/benym"}},{name:"kNN（k-近邻算法）",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/02.Python-机器学习/02.kNN（k-近邻算法）.md",wordsCount:880,readingTime:"3.5m",title:"kNN（k-近邻算法）",date:"2018-08-09T21:43:52.000Z",description:"用k-近邻算法实现简单的分类",categories:"Python-机器学习",tags:["k-近邻算法","Python","机器学习"],keywords:"机器学习,Python,k-近邻算法",permalink:"/pages/b2a5ff/",author:{name:"benym",link:"https://github.com/benym"}},{name:"kNN识别手写图像",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/02.Python-机器学习/03.kNN识别手写图像.md",wordsCount:961,readingTime:"4.5m",title:"kNN识别手写图像",date:"2018-08-16T21:03:00.000Z",categories:"Python-机器学习",tags:["k-近邻算法","Python","机器学习","Numpy"],permalink:"/pages/6c1c7d/",author:{name:"benym",link:"https://github.com/benym"}},{name:"LogisticRegression(逻辑回归)",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/02.Python-机器学习/04.LogisticRegression(逻辑回归).md",wordsCount:"1.9k",readingTime:"8.7m",title:"LogisticRegression(逻辑回归)",date:"2018-10-21T16:27:14.000Z",description:"逻辑回归原理以及代码实现",categories:"Python-机器学习",tags:["逻辑回归","Python","机器学习"],keywords:"机器学习,Python,逻辑回归",permalink:"/pages/dbeb49/",author:{name:"benym",link:"https://github.com/benym"}},{name:"Ndarray对象",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/02.Python-机器学习/05.Ndarray对象.md",wordsCount:458,readingTime:"2m",title:"Ndarray对象",date:"2018-08-22T20:55:17.000Z",description:"Numpy中的array",categories:"Python-机器学习",tags:["Numpy","Python"],keywords:"Numpy,Python,array",permalink:"/pages/6ae370/",author:{name:"benym",link:"https://github.com/benym"}},{name:"Numpy中的数组维度",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/02.Python-机器学习/06.Numpy中的数组维度.md",wordsCount:291,readingTime:"1.3m",title:"Numpy中的数组维度",date:"2018-08-22T22:15:17.000Z",description:"reshape方法定义维度",categories:"Python-机器学习",tags:["Numpy","Python"],keywords:"Numpy,Python,维度",permalink:"/pages/cdba0b/",author:{name:"benym",link:"https://github.com/benym"}},{name:"Numpy中花式索引和shape用法",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/02.Python-机器学习/07.Numpy中花式索引和shape用法.md",wordsCount:317,readingTime:"1.4m",title:"Numpy中花式索引和shape用法",date:"2018-08-20T16:33:09.000Z",description:"对矩阵或者数组的花式索引，以及shape的用法",categories:"Python-机器学习",tags:["Numpy","Python"],keywords:"Python,Numpy",permalink:"/pages/92372b/",author:{name:"benym",link:"https://github.com/benym"}},{name:"turtle绘图库",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/02.Python-机器学习/08.turtle绘图库.md",wordsCount:347,readingTime:"1.5m",title:"turtle绘图库",date:"2018-08-08T17:11:18.000Z",description:"使用绘图库绘制图形",categories:["Python-机器学习"],tags:["Python库"],permalink:"/pages/0779b1/",author:{name:"benym",link:"https://github.com/benym"}},{name:"第一个使用Tensorflow的程序",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/02.Python-机器学习/09.第一个使用Tensorflow的程序.md",wordsCount:619,readingTime:"2.3m",title:"第一个使用Tensorflow的程序",date:"2018-08-24T21:41:52.000Z",description:"简单的创建第一个TensorFlow程序",categories:"Python-机器学习",tags:["Tensorflow","Python","机器学习"],permalink:"/pages/6cd0c4/",author:{name:"benym",link:"https://github.com/benym"}},{name:"将下载下来的MNIST手写数字数据集转化成为图片",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/02.Python-机器学习/10.将下载下来的MNIST手写数字数据集转化成为图片.md",wordsCount:544,readingTime:"3m",title:"将下载下来的MNIST手写数字数据集转化成为图片",date:"2018-08-26T20:32:57.000Z",description:"MNIST数据集",categories:"Python-机器学习",tags:["Python","机器学习"],keywords:"机器学习,Python,MNIST",permalink:"/pages/8b335a/",author:{name:"benym",link:"https://github.com/benym"}},{name:"Tensorflow交互式使用",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/02.Python-机器学习/11.Tensorflow交互式使用.md",wordsCount:276,readingTime:"1.3m",title:"Tensorflow交互式使用",date:"2018-08-26T16:52:59.000Z",categories:"Python-机器学习",tags:["Tensorflow","Python","机器学习"],keywords:"机器学习,Python,Tensorflow",permalink:"/pages/b8d563/",author:{name:"benym",link:"https://github.com/benym"}},{name:"使用k-近邻算法改进约会网站的配对效果",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/02.Python-机器学习/12.使用k-近邻算法改进约会网站的配对效果.md",wordsCount:"1.7k",readingTime:"7.9m",title:"使用k-近邻算法改进约会网站的配对效果",date:"2018-08-11T11:47:52.000Z",categories:"Python-机器学习",tags:["k-近邻算法","Python","机器学习","matplotlib"],permalink:"/pages/a76d65/",author:{name:"benym",link:"https://github.com/benym"}},{name:"Numpy数据类型和arange方法_astype方法的使用",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/02.Python-机器学习/13.Numpy数据类型和arange方法_astype方法的使用.md",wordsCount:514,readingTime:"2.2m",title:"Numpy数据类型和arange方法、astype方法的使用",date:"2018-08-22T20:55:17.000Z",description:"Numpy中的数据类型",categories:"Python-机器学习",tags:["Numpy","Python"],keywords:"Numpy,Python,arange,astype",permalink:"/pages/f66019/",author:{name:"benym",link:"https://github.com/benym"}},{name:"一些TensorFlow的基本操作",filePath:"/home/runner/work/benym-book/benym-book/docs/02.Python/02.Python-机器学习/14.一些TensorFlow的基本操作.md",wordsCount:576,readingTime:"2.5m",title:"一些TensorFlow的基本操作",date:"2018-08-26T16:55:33.000Z",categories:"Python-机器学习",tags:["Tensorflow","Python","机器学习"],keywords:"机器学习,Python,Tensorflow",permalink:"/pages/f9a151/",author:{name:"benym",link:"https://github.com/benym"}},{name:"概览",filePath:"/home/runner/work/benym-book/benym-book/docs/03.分布式与中间件/01.Kafka/01.概览.md",wordsCount:30,readingTime:"1",title:"概览",article:!1,tags:[null],date:"2022-04-17T18:56:03.000Z",permalink:"/pages/b53b0f/",author:{name:"benym",link:"https://github.com/benym"}},{name:"Redis实现共享Session",filePath:"/home/runner/work/benym-book/benym-book/docs/03.分布式与中间件/02.Redis/01.Redis实现共享Session.md",wordsCount:"1.1k",readingTime:"5m",title:"Redis实现共享Session",date:"2020-06-25T16:30:43.000Z",description:"使用总结",tags:["Redis","Java"],keywords:"Redis,Java",permalink:"/pages/847591/",categories:["分布式与中间件","Redis"],author:{name:"benym",link:"https://github.com/benym"}},{name:"自定义RedisTemplate",filePath:"/home/runner/work/benym-book/benym-book/docs/03.分布式与中间件/02.Redis/02.自定义RedisTemplate.md",wordsCount:"1.3k",readingTime:"6m",title:"自定义RedisTemplate",date:"2020-06-25T15:36:22.000Z",description:"使用总结",tags:["Redis","Java"],keywords:"Redis,Java",permalink:"/pages/b185b0/",categories:["分布式与中间件","Redis"],author:{name:"benym",link:"https://github.com/benym"}},{name:"Redis哨兵",filePath:"/home/runner/work/benym-book/benym-book/docs/03.分布式与中间件/02.Redis/03.Redis哨兵.md",wordsCount:990,readingTime:"3.7m",title:"Redis哨兵",date:"2022-01-07T20:15:23.000Z",tags:["Java","Redis"],permalink:"/pages/3aa0a8/",categories:["分布式与中间件","Redis"],author:{name:"benym",link:"https://github.com/benym"}},{name:"Redis持久化RDB",filePath:"/home/runner/work/benym-book/benym-book/docs/03.分布式与中间件/02.Redis/04.Redis持久化RDB.md",wordsCount:"1.2k",readingTime:"4.3m",title:"Redis持久化RDB",date:"2022-01-09T14:20:38.000Z",tags:["Java","Redis"],permalink:"/pages/2f1bf8/",categories:["分布式与中间件","Redis"],author:{name:"benym",link:"https://github.com/benym"}},{name:"Redis持久化AOF",filePath:"/home/runner/work/benym-book/benym-book/docs/03.分布式与中间件/02.Redis/05.Redis持久化AOF.md",wordsCount:"1.3k",readingTime:"5m",title:"Redis持久化AOF",date:"2022-01-09T15:47:38.000Z",tags:["Java","Redis"],permalink:"/pages/c48db1/",categories:["分布式与中间件","Redis"],author:{name:"benym",link:"https://github.com/benym"}},{name:"Redis分片集群",filePath:"/home/runner/work/benym-book/benym-book/docs/03.分布式与中间件/02.Redis/06.Redis分片集群.md",wordsCount:"1k",readingTime:"3.9m",title:"Redis分片集群",date:"2022-01-26T21:02:48.000Z",tags:["Java","Redis"],permalink:"/pages/20361f/",categories:["分布式与中间件","Redis"],author:{name:"benym",link:"https://github.com/benym"}},{name:"事务的特性、CAP定理、BASE理论",filePath:"/home/runner/work/benym-book/benym-book/docs/03.分布式与中间件/03.分布式事务/01.事务的特性、CAP定理、BASE理论.md",wordsCount:685,readingTime:"2.4m",title:"事务的特性、CAP定理、BASE理论",date:"2022-02-20T21:25:48.000Z",categories:["Java"],tags:["Java","事务"],permalink:"/pages/aaed8c/",author:{name:"benym",link:"https://github.com/benym"}},{name:"分布式事务XA、AT、TCC、SAGA",filePath:"/home/runner/work/benym-book/benym-book/docs/03.分布式与中间件/03.分布式事务/02.分布式事务XA、AT、TCC、SAGA.md",wordsCount:"2.6k",readingTime:"10m",title:"分布式事务XA、AT、TCC、SAGA",date:"2022-02-20T21:40:48.000Z",categories:["Java"],tags:["Java","事务","分布式事务","Seata","XA","TCC","AT","SAGA"],permalink:"/pages/e8a7fb/",author:{name:"benym",link:"https://github.com/benym"}},{name:"分布式事务AT模式的脏写问题",filePath:"/home/runner/work/benym-book/benym-book/docs/03.分布式与中间件/03.分布式事务/03.分布式事务AT模式的脏写问题.md",wordsCount:"1.8k",readingTime:"6.8m",title:"分布式事务AT模式的脏写问题",date:"2022-02-23T22:24:48.000Z",categories:["Java"],tags:["Java","事务","分布式事务","AT"],permalink:"/pages/81dbd1/",author:{name:"benym",link:"https://github.com/benym"}},{name:"分布式事务TCC模式的空回滚和业务悬挂问题",filePath:"/home/runner/work/benym-book/benym-book/docs/03.分布式与中间件/03.分布式事务/04.分布式事务TCC模式的空回滚和业务悬挂问题.md",wordsCount:"2k",readingTime:"8.2m",title:"分布式事务TCC模式的空回滚和业务悬挂问题",date:"2022-02-26T12:43:48.000Z",categories:["Java"],tags:["Java","事务","分布式事务","TCC"],permalink:"/pages/f256e0/",author:{name:"benym",link:"https://github.com/benym"}},{name:"MySQL索引原理及应用场景",filePath:"/home/runner/work/benym-book/benym-book/docs/04.数据库/01.MySQL/01.MySQL索引原理及应用场景.md",wordsCount:"6.6k",readingTime:"26.9m",title:"MySQL索引原理及应用场景",description:"MySQL索引总结",categories:["MySQL"],tags:["MySQL","索引","B+树"],keywords:"MySQL,索引,B+树",date:"2022-08-02T18:56:07.000Z",permalink:"/pages/0f7e8e/",author:{name:"benym",link:"https://github.com/benym"}},{name:"概览",filePath:"/home/runner/work/benym-book/benym-book/docs/05.框架/01.Spring/01.SpringIOC/01.概览.md",wordsCount:30,readingTime:"1",title:"概览",article:!1,tags:[null],date:"2022-04-17T18:56:09.000Z",permalink:"/pages/6e0b99/",author:{name:"benym",link:"https://github.com/benym"}},{name:"利用AOP实现操作日志",filePath:"/home/runner/work/benym-book/benym-book/docs/05.框架/01.Spring/02.SpringAOP/01.利用AOP实现操作日志.md",wordsCount:"1.1k",readingTime:"4.8m",title:"利用AOP实现操作日志",date:"2020-06-26T10:54:58.000Z",description:"使用总结",categories:["SpringAOP"],tags:["AOP","Java"],keywords:"AOP,Java",permalink:"/pages/a657d3/",author:{name:"benym",link:"https://github.com/benym"}},{name:"01背包问题详解",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/00.01背包问题详解.md",wordsCount:"5.1k",readingTime:"21.4m",title:"01背包问题详解",date:"2020-08-25T15:26:04.000Z",description:"01背包问题详解",tags:["数组","DP","背包问题","Java","Medium"],keywords:"数组,DP,背包问题,Java,Medium,LeetCode",permalink:"/pages/83cdcf/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题17-打印从1到最大的n位数",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/01.LeetCode-面试题17-打印从1到最大的n位数.md",wordsCount:579,readingTime:"2.6m",title:"LeetCode-面试题17-打印从1到最大的n位数",date:"2020-04-14T18:45:52.000Z",tags:["大数问题","Java","Medium","剑指Offer"],permalink:"/pages/f411af/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题03-不修改数组找出重复的数字",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/02.LeetCode-面试题03-不修改数组找出重复的数字.md",wordsCount:609,readingTime:"2.5m",title:"LeetCode-面试题03-不修改数组找出重复的数字",date:"2020-04-03T11:18:56.000Z",tags:["数组","剑指Offer","Java","Python","Easy"],permalink:"/pages/e68fc1/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题03-数组中重复的数字",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/03.LeetCode-面试题03-数组中重复的数字.md",wordsCount:567,readingTime:"2.2m",title:"LeetCode-面试题03-数组中重复的数字",date:"2020-04-02T22:08:11.000Z",tags:["数组","剑指Offer","Java","Python","Easy"],permalink:"/pages/2f843e/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题04-二维数组中的查找",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/04.LeetCode-面试题04-二维数组中的查找.md",wordsCount:639,readingTime:"2.9m",title:"LeetCode-面试题04-二维数组中的查找",date:"2020-04-03T14:59:24.000Z",tags:["数组","剑指Offer","Java","Python","Easy"],permalink:"/pages/84f558/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题05-替换空格",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/05.LeetCode-面试题05-替换空格.md",wordsCount:207,readingTime:"1",title:"LeetCode-面试题05-替换空格",date:"2020-04-03T16:12:56.000Z",tags:["字符串","剑指Offer","Java","Python","Easy"],permalink:"/pages/b0f96d/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题06-从尾到头打印链表",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/06.LeetCode-面试题06-从尾到头打印链表.md",wordsCount:314,readingTime:"1.5m",title:"LeetCode-面试题06-从尾到头打印链表",date:"2020-04-03T17:54:23.000Z",description:"从尾到头打印链表",tags:["链表","剑指Offer","Java","Python","Easy"],keywords:"链表,Java,Python,Easy,剑指Offer",permalink:"/pages/642877/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题09-用两个栈实现队列",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/07.LeetCode-面试题09-用两个栈实现队列.md",wordsCount:478,readingTime:"2.2m",title:"LeetCode-面试题09-用两个栈实现队列",date:"2020-04-07T22:04:26.000Z",description:"用两个栈实现队列",tags:["队列","Java","Python","Easy","剑指Offer"],keywords:"队列,Java,Python,Easy,剑指Offer",permalink:"/pages/e5bc1f/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题10-1-斐波那契数列",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/08.LeetCode-面试题10-1-斐波那契数列.md",wordsCount:479,readingTime:"2.2m",title:"LeetCode-面试题10-1-斐波那契数列",date:"2020-04-08T21:51:39.000Z",description:"斐波那契数列",tags:["数据结构","Java","Python","Easy","剑指Offer"],keywords:"数据结构,Java,Python,Easy,剑指Offer",permalink:"/pages/6a6f3c/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题10-2-青蛙跳台阶",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/09.LeetCode-面试题10-2-青蛙跳台阶.md",wordsCount:435,readingTime:"1.9m",title:"LeetCode-面试题10-2-青蛙跳台阶",date:"2020-04-08T22:34:29.000Z",description:"青蛙跳台阶",tags:["数据结构","Java","Python","Easy","剑指Offer"],keywords:"数据结构,Java,Python,Easy,剑指Offer",permalink:"/pages/78c895/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题11-旋转数组的最小数字",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/10.LeetCode-面试题11-旋转数组的最小数字.md",wordsCount:641,readingTime:"2.8m",title:"LeetCode-面试题11-旋转数组的最小数字",date:"2020-04-10T16:53:08.000Z",description:"旋转数组的最小数字",tags:["数组","Java","Python","Easy","剑指Offer"],keywords:"数组,Java,Python,Easy,剑指Offer",permalink:"/pages/ea52d6/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题13-机器人的运动范围",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/11.LeetCode-面试题13-机器人的运动范围.md",wordsCount:762,readingTime:"3.4m",title:"LeetCode-面试题13-机器人的运动范围",date:"2020-04-12T21:04:54.000Z",description:"机器人的运动范围",tags:["DFS","BFS","Java","Python","Medium","剑指Offer"],keywords:"搜索,Java,Python,Medium,剑指Offer",permalink:"/pages/ab9430/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题14-1-剪绳子",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/12.LeetCode-面试题14-1-剪绳子.md",wordsCount:883,readingTime:"3.8m",title:"LeetCode-面试题14-1-剪绳子",date:"2020-04-13T14:56:35.000Z",description:"剪绳子",tags:["DP","贪心算法","Java","Python","Medium","剑指Offer"],keywords:"动态规划,贪心算法,Java,Python,Medium,剑指Offer",permalink:"/pages/2d7b5b/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题14-2-剪绳子(大数)",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/13.LeetCode-面试题14-2-剪绳子(大数).md",wordsCount:425,readingTime:"1.9m",title:"LeetCode-面试题14-2-剪绳子(大数)",date:"2020-04-13T14:56:35.000Z",description:"剪绳子(大数)",tags:["DP","贪心算法","Java","Python","Medium","剑指Offer"],keywords:"动态规划,贪心算法,Java,Python,Medium,剑指Offer",permalink:"/pages/7c3197/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题15-二进制中1的个数",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/14.LeetCode-面试题15-二进制中1的个数.md",wordsCount:412,readingTime:"1.7m",title:"LeetCode-面试题15-二进制中1的个数",date:"2020-04-14T10:59:53.000Z",description:"二进制中1的个数",tags:["位运算","Java","Python","Easy","剑指Offer"],keywords:"位运算,Java,Python,Easy,剑指Offer",permalink:"/pages/5abb63/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题16-数值的整数次方",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/15.LeetCode-面试题16-数值的整数次方.md",wordsCount:553,readingTime:"2.4m",title:"LeetCode-面试题16-数值的整数次方",date:"2020-04-14T17:15:23.000Z",description:"数值的整数次方",tags:["位运算","Java","Python","Medium","剑指Offer"],keywords:"位运算,Java,Python,Medium,剑指Offer",permalink:"/pages/4e2fa9/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题18-删除链表的节点",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/16.LeetCode-面试题18-删除链表的节点.md",wordsCount:501,readingTime:"2.2m",title:"LeetCode-面试题18-删除链表的节点",date:"2020-04-15T18:07:21.000Z",description:"删除链表的节点",tags:["链表","Java","Python","Easy","剑指Offer"],keywords:"链表,Java,Python,Easy,剑指Offer",permalink:"/pages/a7cb1c/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题19-正则表达式匹配",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/17.LeetCode-面试题19-正则表达式匹配.md",wordsCount:"1.3k",readingTime:"5.6m",title:"LeetCode-面试题19-正则表达式匹配",date:"2020-04-16T14:56:55.000Z",description:"正则表达式匹配",tags:["DP","字符串","Python","Java","Hard","剑指Offer"],keywords:"DP,字符串,Java,Python,Hard,剑指Offer",permalink:"/pages/489cb9/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题20-表示数值的字符串",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/18.LeetCode-面试题20-表示数值的字符串.md",wordsCount:676,readingTime:"3.2m",title:"LeetCode-面试题20-表示数值的字符串",date:"2020-04-17T12:21:56.000Z",description:"表示数值的字符串",tags:["字符串","Python","Java","Medium","剑指Offer"],keywords:"字符串,Java,Python,Medium,剑指Offer",permalink:"/pages/6845e4/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题21-调整数组顺序使奇数位于偶数前面",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/19.LeetCode-面试题21-调整数组顺序使奇数位于偶数前面.md",wordsCount:508,readingTime:"2.2m",title:"LeetCode-面试题21-调整数组顺序使奇数位于偶数前面",date:"2020-04-17T17:58:38.000Z",description:"调整数组顺序使奇数位于偶数前面",tags:["数组","Python","Java","Easy","剑指Offer"],keywords:"数组,Java,Python,Easy,剑指Offer",permalink:"/pages/d28ff3/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题22-链表中倒数第k个节点",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/20.LeetCode-面试题22-链表中倒数第k个节点.md",wordsCount:511,readingTime:"2.3m",title:"LeetCode-面试题22-链表中倒数第k个节点",date:"2020-04-18T22:59:57.000Z",description:"链表中倒数第k个节点",tags:["链表","Python","Java","Easy","剑指Offer"],keywords:"链表,Java,Python,Easy,剑指Offer",permalink:"/pages/663c3e/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题24-反转链表",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/21.LeetCode-面试题24-反转链表.md",wordsCount:322,readingTime:"1.5m",title:"LeetCode-面试题24-反转链表",date:"2020-04-19T17:44:28.000Z",description:"反转链表",tags:["链表","Python","Java","Easy","剑指Offer"],keywords:"链表,Java,Python,Easy,剑指Offer",permalink:"/pages/2dfb9f/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题25-合并两个排序的链表",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/22.LeetCode-面试题25-合并两个排序的链表.md",wordsCount:394,readingTime:"1.8m",title:"LeetCode-面试题25-合并两个排序的链表",date:"2020-04-19T18:18:16.000Z",description:"合并两个排序的链表",tags:["链表","Python","Java","Easy","剑指Offer"],keywords:"链表,Java,Python,Easy,剑指Offer",permalink:"/pages/7b5838/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题26-树的子结构",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/23.LeetCode-面试题26-树的子结构.md",wordsCount:649,readingTime:"3m",title:"LeetCode-面试题26-树的子结构",date:"2020-04-20T13:33:50.000Z",description:"树的子结构",tags:["树","Python","Java","Medium","剑指Offer"],keywords:"树,Java,Python,Medium,剑指Offer",permalink:"/pages/022144/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题27-二叉树的镜像",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/24.LeetCode-面试题27-二叉树的镜像.md",wordsCount:505,readingTime:"2.3m",title:"LeetCode-面试题27-二叉树的镜像",date:"2020-04-20T15:43:20.000Z",description:"二叉树的镜像",tags:["树","Python","Java","Easy","剑指Offer"],keywords:"树,Java,Python,Easy,剑指Offer",permalink:"/pages/107b94/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题29-顺时针打印矩阵",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/25.LeetCode-面试题29-顺时针打印矩阵.md",wordsCount:"1.1k",readingTime:"4.7m",title:"LeetCode-面试题29-顺时针打印矩阵",date:"2020-04-21T12:00:13.000Z",description:"顺时针打印矩阵",tags:["矩阵","Python","Java","Easy","剑指Offer"],keywords:"矩阵,Java,Python,Easy,剑指Offer",permalink:"/pages/0b663a/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题31-栈的压入弹出序列",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/26.LeetCode-面试题31-栈的压入弹出序列.md",wordsCount:553,readingTime:"2.4m",title:"LeetCode-面试题31-栈的压入弹出序列",date:"2020-04-21T15:50:42.000Z",description:"栈的压入弹出序列",tags:["栈","Python","Java","Medium","剑指Offer"],keywords:"栈,Java,Python,Medium,剑指Offer",permalink:"/pages/baac38/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题32-1-从上到下打印二叉树",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/27.LeetCode-面试题32-1-从上到下打印二叉树.md",wordsCount:378,readingTime:"1.8m",title:"LeetCode-面试题32-1-从上到下打印二叉树",date:"2020-04-22T10:47:48.000Z",description:"从上到下打印二叉树",tags:["BFS","树","Python","Java","Medium","剑指Offer"],keywords:"BFS,树,Java,Python,Medium,剑指Offer",permalink:"/pages/f4c63f/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题32-2-从上到下打印二叉树 ",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/28.LeetCode-面试题32-2-从上到下打印二叉树 .md",wordsCount:751,readingTime:"3.3m",title:"LeetCode-面试题32-2-从上到下打印二叉树",date:"2020-04-22T15:15:30.000Z",description:"从上到下打印二叉树",tags:["BFS","树","Python","Java","Easy","剑指Offer"],keywords:"BFS,树,Java,Python,Easy,剑指Offer",permalink:"/pages/7e90de/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题32-3-从上到下打印二叉树",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/29.LeetCode-面试题32-3-从上到下打印二叉树.md",wordsCount:588,readingTime:"2.4m",title:"LeetCode-面试题32-3-从上到下打印二叉树",date:"2020-04-22T16:08:35.000Z",description:"从上到下打印二叉树",tags:["BFS","树","Java","Medium","剑指Offer"],keywords:"BFS,树,Java,Medium,剑指Offer",permalink:"/pages/a2ebc7/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题35-复杂链表的复制",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/30.LeetCode-面试题35-复杂链表的复制.md",wordsCount:882,readingTime:"4m",title:"LeetCode-面试题35-复杂链表的复制",date:"2020-04-23T21:13:47.000Z",description:"复杂链表的复制",tags:["链表","Java","Python","Medium","剑指Offer"],keywords:"链表,Java,Python,Medium,剑指Offer",permalink:"/pages/9050fc/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题36-二叉搜索树与双向链表",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/31.LeetCode-面试题36-二叉搜索树与双向链表.md",wordsCount:734,readingTime:"3m",title:"LeetCode-面试题36-二叉搜索树与双向链表",date:"2020-04-24T21:29:26.000Z",description:"二叉搜索树与双向链表",tags:["树","DFS","Java","Medium","剑指Offer"],keywords:"树,DFS,Java,Medium,剑指Offer",permalink:"/pages/e44b62/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题37-序列化二叉树",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/32.LeetCode-面试题37-序列化二叉树.md",wordsCount:914,readingTime:"4.3m",title:"LeetCode-面试题37-序列化二叉树",date:"2020-04-26T17:30:44.000Z",description:"序列化二叉树",tags:["树","Python","Java","Hard","剑指Offer"],keywords:"树,Python,Java,Hard,剑指Offer",permalink:"/pages/1643b9/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题38-字符串的排列",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/33.LeetCode-面试题38-字符串的排列.md",wordsCount:827,readingTime:"3.9m",title:"LeetCode-面试题38-字符串的排列",date:"2020-04-27T18:01:14.000Z",description:"字符串的排列",tags:["字符串","全排列","DFS","回溯","Python","Java","Medium","剑指Offer"],keywords:"字符串,全排列,DFS,回溯,Python,Java,Medium,剑指Offer",permalink:"/pages/01dd29/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题39-数组中出现次数超过一半的数字",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/34.LeetCode-面试题39-数组中出现次数超过一半的数字.md",wordsCount:375,readingTime:"1.6m",title:"LeetCode-面试题39-数组中出现次数超过一半的数字",date:"2020-04-29T20:14:13.000Z",description:"数组中出现次数超过一半的数字",tags:["数组","Python","Java","Easy","剑指Offer"],keywords:"数组,Python,Java,Easy,剑指Offer",permalink:"/pages/c61856/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题40-最小的k个数",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/35.LeetCode-面试题40-最小的k个数.md",wordsCount:761,readingTime:"3.4m",title:"LeetCode-面试题40-最小的k个数",date:"2020-05-04T17:38:24.000Z",description:"最小的k个数",tags:["数组","Python","Java","Medium","剑指Offer"],keywords:"数组,Python,Java,Medium,剑指Offer",permalink:"/pages/504abd/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题41-数据流中的中位数",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/36.LeetCode-面试题41-数据流中的中位数.md",wordsCount:674,readingTime:"2.7m",title:"LeetCode-面试题41-数据流中的中位数",date:"2020-05-04T18:37:01.000Z",description:"数据流中的中位数",tags:["数组","Java","Hard","剑指Offer"],keywords:"数组,Java,Hard,剑指Offer",permalink:"/pages/888f97/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题42-连续子数组的最大和",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/37.LeetCode-面试题42-连续子数组的最大和.md",wordsCount:559,readingTime:"2.4m",title:"LeetCode-面试题42-连续子数组的最大和",date:"2020-05-05T18:08:46.000Z",description:"连续子数组的最大和",tags:["数组","Java","Python","DP","Easy","剑指Offer"],keywords:"数组,Java,Python,Easy,剑指Offer",permalink:"/pages/95eb09/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题43-1到n整数中1出现的次数",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/38.LeetCode-面试题43-1到n整数中1出现的次数.md",wordsCount:631,readingTime:"2.7m",title:"LeetCode-面试题43-1到n整数中1出现的次数",date:"2020-05-05T21:26:10.000Z",description:"1到n整数中1出现的次数",tags:["大数问题","Java","Python","Hard","剑指Offer"],keywords:"数组,Java,Python,Hard,剑指Offer",permalink:"/pages/e9ceb8/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题44-数字序列中某一位的数字",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/39.LeetCode-面试题44-数字序列中某一位的数字.md",wordsCount:871,readingTime:"3.7m",title:"LeetCode-面试题44-数字序列中某一位的数字",date:"2020-05-06T15:15:55.000Z",description:"数字序列中某一位的数字",tags:["大数问题","数组","Java","Python","Medium","剑指Offer"],keywords:"大数问题,数组,Java,Python,Medium,剑指Offer",permalink:"/pages/11765a/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题45-把数组排成最小的数",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/40.LeetCode-面试题45-把数组排成最小的数.md",wordsCount:597,readingTime:"2.6m",title:"LeetCode-面试题45-把数组排成最小的数",date:"2020-05-06T18:51:48.000Z",description:"把数组排成最小的数",tags:["大数问题","数组","Java","Python","Medium","剑指Offer"],keywords:"大数问题,数组,Java,Python,Medium,剑指Offer",permalink:"/pages/0856b2/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题47-礼物的最大价值",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/41.LeetCode-面试题47-礼物的最大价值.md",wordsCount:615,readingTime:"2.8m",title:"LeetCode-面试题47-礼物的最大价值",date:"2020-05-07T21:12:39.000Z",description:"礼物的最大价值",tags:["DP","数组","Java","Python","Medium","剑指Offer"],keywords:"DP,数组,Java,Python,Medium,剑指Offer",permalink:"/pages/85c8fd/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题48-最长不含重复字符的子字符串",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/42.LeetCode-面试题48-最长不含重复字符的子字符串.md",wordsCount:825,readingTime:"3.4m",title:"LeetCode-面试题48-最长不含重复字符的子字符串",date:"2020-05-08T10:25:53.000Z",description:"最长不含重复字符的子字符串",tags:["DP","双指针","字符串","Java","Python","Medium","剑指Offer"],keywords:"DP,双指针,字符串,Java,Python,Medium,剑指Offer",permalink:"/pages/7fd908/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题49-丑数",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/43.LeetCode-面试题49-丑数.md",wordsCount:"1.4k",readingTime:"5.9m",title:"LeetCode-面试题49-丑数",date:"2020-05-08T17:10:42.000Z",description:"丑数",tags:["DP","Java","Medium","剑指Offer"],keywords:"DP,Java,Medium,剑指Offer",permalink:"/pages/0b0978/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题50-第一次只出现一次的字符",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/44.LeetCode-面试题50-第一次只出现一次的字符.md",wordsCount:343,readingTime:"1.6m",title:"LeetCode-面试题50-第一次只出现一次的字符",date:"2020-05-08T19:23:20.000Z",description:"第一次只出现一次的字符",tags:["Python","Java","Easy","剑指Offer"],keywords:"Java,Python,Easy,剑指Offer",permalink:"/pages/105b9d/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题51-数组中的逆序对",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/45.LeetCode-面试题51-数组中的逆序对.md",wordsCount:761,readingTime:"3.3m",title:"LeetCode-面试题51-数组中的逆序对",date:"2020-05-09T18:33:02.000Z",description:"数组中的逆序对",tags:["数组","分治","Java","Python","Hard","剑指Offer"],keywords:"数组,分治,Java,Python,Hard,剑指Offer",permalink:"/pages/3fafb8/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题53-1-在排序数组中查找数字I",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/46.LeetCode-面试题53-1-在排序数组中查找数字I.md",wordsCount:672,readingTime:"3.3m",title:"LeetCode-面试题53-1-在排序数组中查找数字I",date:"2020-05-12T14:24:43.000Z",description:"在排序数组中查找数字I",tags:["数组","Java","Easy","剑指Offer"],keywords:"数组,Java,Easy,剑指Offer",permalink:"/pages/c7c072/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题33-二叉搜索树的后序遍历序列",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/47.LeetCode-面试题33-二叉搜索树的后序遍历序列.md",wordsCount:542,readingTime:"2.4m",title:"LeetCode-面试题33-二叉搜索树的后序遍历序列",date:"2020-04-22T16:37:05.000Z",description:"从上到下打印二叉树",tags:["树","Java","Python","Medium","剑指Offer"],keywords:"树,Java,Python,Medium,剑指Offer",permalink:"/pages/fe51d2/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题54-二叉搜索树的第k大节点",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/48.LeetCode-面试题54-二叉搜索树的第k大节点.md",wordsCount:591,readingTime:"2.7m",title:"LeetCode-面试题54-二叉搜索树的第k大节点",date:"2020-05-12T16:34:23.000Z",description:"二叉搜索树的第k大节点",tags:["树","DFS","Java","Python","Easy","剑指Offer"],keywords:"树,Java,Easy,剑指Offer",permalink:"/pages/23d089/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题55-1-二叉树的深度",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/49.LeetCode-面试题55-1-二叉树的深度.md",wordsCount:407,readingTime:"1.9m",title:"LeetCode-面试题55-1-二叉树的深度",date:"2020-05-14T18:54:51.000Z",description:"二叉树的深度",tags:["树","DFS","BFS","Java","Python","Easy","剑指Offer"],keywords:"树,DFS,BFS,Java,Easy,剑指Offer",permalink:"/pages/485921/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题12-矩阵中的路径",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/50.LeetCode-面试题12-矩阵中的路径.md",wordsCount:860,readingTime:"3.9m",title:"LeetCode-面试题12-矩阵中的路径",date:"2020-04-10T21:57:56.000Z",description:"矩阵中的路径",tags:["数组","回溯","Java","Python","Medium","剑指Offer"],keywords:"数组,回溯,Java,Python,Medium,剑指Offer",permalink:"/pages/254f95/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题30-包含min函数的栈",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/51.LeetCode-面试题30-包含min函数的栈.md",wordsCount:428,readingTime:"1.9m",title:"LeetCode-面试题30-包含min函数的栈",date:"2020-04-21T14:42:06.000Z",description:"包含min函数的栈",tags:["栈","Java","Easy","剑指Offer"],keywords:"栈,Java,Easy,剑指Offer",permalink:"/pages/c9ae12/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题34-二叉树中和为某一值的路径",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/52.LeetCode-面试题34-二叉树中和为某一值的路径.md",wordsCount:549,readingTime:"2.5m",title:"LeetCode-面试题34-二叉树中和为某一值的路径",date:"2020-04-22T18:32:02.000Z",description:"二叉树中和为某一值的路径",tags:["树","回溯","DFS","Java","Python","Medium","剑指Offer"],keywords:"树,回溯,DFS,Java,Python,Medium,剑指Offer",permalink:"/pages/e52256/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题46-把数字翻译成字符串",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/53.LeetCode-面试题46-把数字翻译成字符串.md",wordsCount:672,readingTime:"3m",title:"LeetCode-面试题46-把数字翻译成字符串",date:"2020-05-07T15:56:27.000Z",description:"把数字翻译成字符串",tags:["DP","回溯","数组","Java","Python","Medium","剑指Offer"],keywords:"DP,回溯,数组,Java,Python,Medium,剑指Offer",permalink:"/pages/73554a/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题55-2-平衡二叉树",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/54.LeetCode-面试题55-2-平衡二叉树.md",wordsCount:581,readingTime:"2.7m",title:"LeetCode-面试题55-2-平衡二叉树",date:"2020-05-18T12:58:06.000Z",description:"平衡二叉树",tags:["树","DFS","Java","Python","Easy","剑指Offer"],keywords:"树,DFS,Java,Python,Easy,剑指Offer",permalink:"/pages/8564b7/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题56-1-数组中数字出现的次数1",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/55.LeetCode-面试题56-1-数组中数字出现的次数1.md",wordsCount:546,readingTime:"2.2m",title:"LeetCode-面试题56-1-数组中数字出现的次数",date:"2020-05-18T16:06:08.000Z",description:"数组中数字出现的次数",tags:["数组","Java","Medium","剑指Offer"],keywords:"数组,Java,Medium,剑指Offer",permalink:"/pages/0dd136/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题56-2-数组中数字出现的次数2",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/56.LeetCode-面试题56-2-数组中数字出现的次数2.md",wordsCount:667,readingTime:"2.9m",title:"LeetCode-面试题56-2-数组中数字出现的次数2",date:"2020-05-18T17:13:05.000Z",description:"数组中数字出现的次数2",tags:["数组","Java","Python","Medium","剑指Offer"],keywords:"数组,Java,Python,Medium,剑指Offer",permalink:"/pages/322274/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题57-1-和为s的两个数字",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/57.LeetCode-面试题57-1-和为s的两个数字.md",wordsCount:388,readingTime:"1.8m",title:"LeetCode-面试题57-和为s的两个数字",date:"2020-05-19T09:15:38.000Z",description:"和为s的两个数字",tags:["数组","Java","Python","Easy","剑指Offer"],keywords:"数组,Java,Python,Easy,剑指Offer",permalink:"/pages/64b7a6/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题58-1-翻转单词顺序",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/58.LeetCode-面试题58-1-翻转单词顺序.md",wordsCount:598,readingTime:"2.4m",title:"LeetCode-面试题58-1-翻转单词顺序",date:"2020-05-19T11:09:40.000Z",description:"翻转单词顺序",tags:["字符串","Java","Python","Easy","剑指Offer"],keywords:"字符串,Java,Python,Easy,剑指Offer",permalink:"/pages/9fdad5/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题58-2-左旋转字符串",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/59.LeetCode-面试题58-2-左旋转字符串.md",wordsCount:337,readingTime:"1.5m",title:"LeetCode-面试题58-2-左旋转字符串",date:"2020-05-19T14:47:01.000Z",description:"左旋转字符串",tags:["字符串","Java","Python","Easy","剑指Offer"],keywords:"字符串,Java,Python,Easy,剑指Offer",permalink:"/pages/7c648d/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题59-2-队列的最大值",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/60.LeetCode-面试题59-2-队列的最大值.md",wordsCount:805,readingTime:"3.4m",title:"LeetCode-面试题59-2-队列的最大值",date:"2020-05-19T16:39:45.000Z",description:"队列的最大值",tags:["队列","Java","Medium","剑指Offer"],keywords:"队列,Java,Medium,剑指Offer",permalink:"/pages/0c523d/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题60-n个骰子的点数 - 副本",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/61.LeetCode-面试题60-n个骰子的点数 - 副本.md",wordsCount:961,readingTime:"4.1m",title:"LeetCode-面试题60-n个骰子的点数",date:"2020-05-20T13:15:38.000Z",description:"n个骰子的点数",tags:["数组","DP","Java","Medium","剑指Offer"],keywords:"数组,DP,Java,Medium,剑指Offer",permalink:"/pages/517e93/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题61-扑克牌中的顺子",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/62.LeetCode-面试题61-扑克牌中的顺子.md",wordsCount:334,readingTime:"1.5m",title:"LeetCode-面试题61-扑克牌中的顺子",date:"2020-05-20T15:46:36.000Z",description:"扑克牌中的顺子",tags:["数组","Java","Easy","剑指Offer"],keywords:"数组,Java,Easy,剑指Offer",permalink:"/pages/a7687d/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题62-圆圈中最后剩下的数字",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/63.LeetCode-面试题62-圆圈中最后剩下的数字.md",wordsCount:506,readingTime:"2.2m",title:"LeetCode-面试题62-圆圈中最后剩下的数字",date:"2020-05-20T16:08:25.000Z",description:"圆圈中最后剩下的数字",tags:["数组","Java","Easy","剑指Offer"],keywords:"数组,Java,Easy,剑指Offer",permalink:"/pages/9ca7ff/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题63-股票的最大利润",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/64.LeetCode-面试题63-股票的最大利润.md",wordsCount:338,readingTime:"1.4m",title:"LeetCode-面试题63-股票的最大利润",date:"2020-05-20T16:58:09.000Z",description:"股票的最大利润",tags:["数组","Java","Easy","剑指Offer"],keywords:"数组,Java,Easy,剑指Offer",permalink:"/pages/610009/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题64-求1+2+到+n",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/65.LeetCode-面试题64-求1+2+到+n.md",wordsCount:268,readingTime:"1.2m",title:"LeetCode-面试题64-求1+2+到+n",date:"2020-05-20T18:20:48.000Z",description:"求1+2+...+n",tags:["Java","Python","Medium","剑指Offer"],keywords:"Java,Python,Medium,剑指Offer",permalink:"/pages/4abc2f/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题65-不用加减乘除做加法",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/66.LeetCode-面试题65-不用加减乘除做加法.md",wordsCount:317,readingTime:"1.3m",title:"LeetCode-面试题65-不用加减乘除做加法",date:"2020-05-20T20:06:48.000Z",description:"不用加减乘除做加法",tags:["位运算","Java","Easy","剑指Offer"],keywords:"位运算,Java,Easy,剑指Offer",permalink:"/pages/808f6a/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题66-构建乘积数组",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/67.LeetCode-面试题66-构建乘积数组.md",wordsCount:526,readingTime:"2.6m",title:"LeetCode-面试题66-构建乘积数组",date:"2020-05-21T15:08:46.000Z",description:"构建乘积数组",tags:["数组","Java","Easy","剑指Offer"],keywords:"数组,Java,Easy,剑指Offer",permalink:"/pages/bcd8dc/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题67-把字符串转化成整数",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/68.LeetCode-面试题67-把字符串转化成整数.md",wordsCount:975,readingTime:"3.7m",title:"LeetCode-面试题67-把字符串转化成整数",date:"2020-05-21T16:22:23.000Z",description:"把字符串转化成整数",tags:["字符串","Java","Medium","剑指Offer"],keywords:"字符串,Java,Medium,剑指Offer",permalink:"/pages/bd49ec/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题68-1-二叉搜索树的最近公共祖先",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/69.LeetCode-面试题68-1-二叉搜索树的最近公共祖先.md",wordsCount:675,readingTime:"2.9m",title:"LeetCode-面试题68-1-二叉搜索树的最近公共祖先",date:"2020-05-29T10:05:04.000Z",description:"二叉搜索树的最近公共祖先",tags:["二叉树","Java","Python","Easy","剑指Offer"],keywords:"二叉树,Java,Python,Easy,剑指Offer",permalink:"/pages/2295ef/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题68-2-二叉搜索树的最近公共祖先",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/70.LeetCode-面试题68-2-二叉搜索树的最近公共祖先.md",wordsCount:551,readingTime:"2.3m",title:"LeetCode-面试题68-2-二叉搜索树的最近公共祖先",date:"2020-05-29T10:35:42.000Z",description:"二叉搜索树的最近公共祖先",tags:["二叉树","Java","Easy","剑指Offer"],keywords:"二叉树,Java,Easy,剑指Offer",permalink:"/pages/10adcf/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题07-重建二叉树",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/71.LeetCode-面试题07-重建二叉树.md",wordsCount:800,readingTime:"3.6m",title:"LeetCode-面试题07-重建二叉树",date:"2020-04-04T14:08:05.000Z",description:"重建二叉树",tags:["树","Java","Python","Medium","剑指Offer"],keywords:"树,Java,Python,Medium,剑指Offer",permalink:"/pages/88652a/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题52-两个链表的第一个公共节点",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/72.LeetCode-面试题52-两个链表的第一个公共节点.md",wordsCount:935,readingTime:"4.1m",title:"LeetCode-面试题52-两个链表的第一个公共节点",date:"2020-05-12T12:55:26.000Z",description:"两个链表的第一个公共节点",tags:["链表","Java","Python","Easy","剑指Offer"],keywords:"链表,Java,Python,Easy,剑指Offer",permalink:"/pages/a0e6b3/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题53-2-0到n-1中缺失的数字",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/73.LeetCode-面试题53-2-0到n-1中缺失的数字.md",wordsCount:"1.2k",readingTime:"4.9m",title:"LeetCode-面试题53-2-0到n-1中缺失的数字",date:"2020-05-12T16:10:46.000Z",description:"0到n-1中缺失的数字",tags:["数组","Java","Easy","剑指Offer"],keywords:"数组,Java,Easy,剑指Offer",permalink:"/pages/f558cf/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题57-2-和为s的连续正数序列",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/74.LeetCode-面试题57-2-和为s的连续正数序列.md",wordsCount:613,readingTime:"2.7m",title:"LeetCode-面试题57-2-和为s的连续正数序列",date:"2020-05-19T10:00:38.000Z",description:"和为s的两个数字",tags:["数组","滑动窗口","Java","Python","Easy","剑指Offer"],keywords:"数组,滑动窗口,Java,Python,Easy,剑指Offer",permalink:"/pages/a09b75/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题59-1-滑动窗口的最大值",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/75.LeetCode-面试题59-1-滑动窗口的最大值.md",wordsCount:"1.2k",readingTime:"5m",title:"LeetCode-面试题59-1-滑动窗口的最大值",date:"2020-05-19T15:13:10.000Z",description:"滑动窗口的最大值",tags:["数组","滑动窗口","Java","Hard","剑指Offer"],keywords:"数组,Java,滑动窗口,Hard,剑指Offer",permalink:"/pages/e91bb1/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题28-对称的二叉树",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/01.剑指Offer/76.LeetCode-面试题28-对称的二叉树.md",wordsCount:872,readingTime:"4m",title:"LeetCode-面试题28-对称的二叉树",date:"2020-04-20T17:21:41.000Z",description:"对称的二叉树",tags:["树","Python","Java","Easy","剑指Offer"],keywords:"树,Java,Python,Easy,剑指Offer",permalink:"/pages/28dd80/",article:!0,categories:["算法","剑指Offer"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-54-螺旋矩阵",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/01.LeetCode-54-螺旋矩阵.md",wordsCount:919,readingTime:"4.1m",title:"LeetCode-54-螺旋矩阵",date:"2020-03-30T19:21:08.000Z",tags:["二维数组","Java","Python","Medium"],permalink:"/pages/b2b5b5/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-67-二进制求和",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/02.LeetCode-67-二进制求和.md",wordsCount:406,readingTime:"1.8m",title:"LeetCode-67-二进制求和",date:"2020-04-14T14:25:51.000Z",tags:["字符串","Java","Python","Easy"],permalink:"/pages/7d3b6e/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-83-删除排序链表中的重复元素",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/03.LeetCode-83-删除排序链表中的重复元素.md",wordsCount:355,readingTime:"1.6m",title:"LeetCode-83-删除排序链表中的重复元素",date:"2020-04-15T18:22:08.000Z",tags:["链表","Java","Python","Easy"],permalink:"/pages/fb7a5f/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-415-字符串相加",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/04.LeetCode-415-字符串相加.md",wordsCount:436,readingTime:"2m",title:"LeetCode-415-字符串相加",date:"2020-04-15T15:44:22.000Z",tags:["字符串","大数问题","Java","Python","Easy"],permalink:"/pages/9c3f56/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-498-对角线遍历",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/05.LeetCode-498-对角线遍历.md",wordsCount:746,readingTime:"3.5m",title:"LeetCode-498-对角线遍历",date:"2020-03-26T14:25:12.000Z",tags:["二维数组","Java","Python","Medium"],permalink:"/pages/45d832/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-724-寻找数组的中心索引",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/06.LeetCode-724-寻找数组的中心索引.md",wordsCount:539,readingTime:"2.4m",title:"LeetCode-724-寻找数组的中心索引",date:"2020-03-19T16:33:43.000Z",tags:["数组","Java","Python","Easy"],permalink:"/pages/f095b3/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"动态规划问题——最长上升子序列(LIS)(一)",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/07.动态规划问题——最长上升子序列(LIS)(一).md",wordsCount:812,readingTime:"3.8m",title:"动态规划问题——最长上升子序列(LIS)(一)",date:"2018-08-25T15:43:49.000Z",tags:["算法","Java","Python","DP"],permalink:"/pages/6ddb3f/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"动态规划问题——最长上升子序列(LIS)(二)",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/08.动态规划问题——最长上升子序列(LIS)(二).md",wordsCount:"1.1k",readingTime:"4.6m",title:"动态规划问题——最长上升子序列(LIS)(二)",date:"2018-08-25T17:44:35.000Z",description:null,tags:["算法","Java","Python","DP"],permalink:"/pages/1f5b98/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"动态规划问题——最长上升子序列(LIS)(三)",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/09.动态规划问题——最长上升子序列(LIS)(三).md",wordsCount:"1k",readingTime:"4.8m",title:"动态规划问题——最长上升子序列(LIS)(三)",date:"2018-08-26T14:23:08.000Z",description:null,tags:["算法","Java","Python","DP"],permalink:"/pages/f98f70/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-144-二叉树的前序遍历",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/10.LeetCode-144-二叉树的前序遍历.md",wordsCount:605,readingTime:"3m",title:"LeetCode-144-二叉树的前序遍历",date:"2020-05-13T13:01:06.000Z",description:"二叉树的前序遍历",tags:["树","BFS","Java","Medium"],keywords:"树,BFS,Java,Medium",permalink:"/pages/b03f05/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"最小字典序字符串",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/100.最小字典序字符串.md",wordsCount:644,readingTime:"2.6m",title:"最小字典序字符串",date:"2020-08-10T10:22:22.000Z",description:"最小字典序字符串",tags:["字符串","Java","Medium"],keywords:"字符串,Java,Medium,LeetCode",permalink:"/pages/bac26b/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-1-两数之和",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/101.LeetCode-1-两数之和.md",wordsCount:478,readingTime:"2.1m",title:"LeetCode-1-两数之和",date:"2020-06-16T09:30:40.000Z",description:"两数之和",tags:["数组","Java","Easy","LeetCode"],keywords:"数组,Java,Easy,LeetCode",permalink:"/pages/005df6/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-16-最接近的三数之和",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/102.LeetCode-16-最接近的三数之和.md",wordsCount:457,readingTime:"2.3m",title:"LeetCode-16-最接近的三数之和",date:"2020-09-08T10:20:20.000Z",description:"最接近的三数之和",tags:["数组","Java","Medium","LeetCode"],keywords:"数组,Java,Medium,LeetCode",permalink:"/pages/ce722a/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-679-24点游戏",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/103.LeetCode-679-24点游戏.md",wordsCount:"1.1k",readingTime:"4.5m",title:"LeetCode-679-24点游戏",date:"2020-09-20T10:32:30.000Z",description:"24点游戏",tags:["数组","Java","Hard","LeetCode"],keywords:"数组,Java,Hard,LeetCode",permalink:"/pages/ebc391/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-141-环形链表",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/104.LeetCode-141-环形链表.md",wordsCount:689,readingTime:"3.1m",title:"LeetCode-141-环形链表",date:"2020-06-10T16:16:00.000Z",description:"环形链表",tags:["链表","Java","Easy","LeetCode"],keywords:"链表,Java,Easy,LeetCode",permalink:"/pages/edad8f/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-155-最小栈",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/105.LeetCode-155-最小栈.md",wordsCount:604,readingTime:"2.8m",title:"LeetCode-155-最小栈",date:"2020-07-13T09:46:46.000Z",description:"最小栈",tags:["栈","Java","Easy"],keywords:"栈,Java,Easy,LeetCode",permalink:"/pages/2fc7af/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-160-相交链表",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/106.LeetCode-160-相交链表.md",wordsCount:954,readingTime:"4m",title:"LeetCode-160-相交链表",date:"2020-07-11T10:43:04.000Z",description:"相交链表",tags:["链表","Java","Easy"],keywords:"链表,Java,Easy,LeetCode",permalink:"/pages/19f71b/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"判断一棵二叉树是否为二叉搜索树和完全二叉树",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/107.判断一棵二叉树是否为二叉搜索树和完全二叉树.md",wordsCount:440,readingTime:"2.1m",title:"判断一棵二叉树是否为二叉搜索树和完全二叉树",date:"2020-09-10T16:30:22.000Z",description:"如题",tags:["树","Java","Easy","LeetCode"],keywords:"树,Java,Easy,LeetCode",permalink:"/pages/6d1dda/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-169-多数元素",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/108.LeetCode-169-多数元素.md",wordsCount:587,readingTime:"2.5m",title:"LeetCode-169-多数元素",date:"2020-07-15T10:43:02.000Z",description:"多数元素",tags:["Java","数组","Easy"],keywords:"Java,数组,Easy,LeetCode",permalink:"/pages/657ad4/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-234-回文链表",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/109.LeetCode-234-回文链表.md",wordsCount:590,readingTime:"2.6m",title:"LeetCode-234-回文链表",date:"2020-07-13T14:28:47.000Z",description:"回文链表",tags:["链表","Java","Easy"],keywords:"链表,Java,Easy,LeetCode",permalink:"/pages/4923ab/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-94-二叉树的中序遍历",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/11.LeetCode-94-二叉树的中序遍历.md",wordsCount:496,readingTime:"2.4m",title:"LeetCode-94-二叉树的中序遍历",date:"2020-05-13T11:01:06.000Z",description:"二叉树的中序遍历",tags:["树","DFS","Java","Medium"],keywords:"树,DFS,Java,Medium",permalink:"/pages/4517f3/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-238-除自身以外数组的乘积",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/110.LeetCode-238-除自身以外数组的乘积.md",wordsCount:980,readingTime:"3.9m",title:"LeetCode-238-除自身以外数组的乘积",date:"2021-08-25T09:59:56.000Z",description:"除自身以外数组的乘积",tags:["前缀和","Medium","Java","数组"],keywords:"Medium,Java,前缀和,数组",permalink:"/pages/c56f5d/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-283-移动零",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/111.LeetCode-283-移动零.md",wordsCount:476,readingTime:"2m",title:"LeetCode-283-移动零",date:"2021-08-24T10:16:39.000Z",description:"移动零",tags:["双指针","Easy","Java"],keywords:"Easy,Java,双指针",permalink:"/pages/b249d6/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-338-比特位计数",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/112.LeetCode-338-比特位计数.md",wordsCount:446,readingTime:"1.9m",title:"LeetCode-338-比特位计数",date:"2021-08-31T18:49:29.000Z",description:"比特位计数",tags:["DP","Easy","Java","数组"],keywords:"Easy,Java,数组,DP",permalink:"/pages/4a24f6/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-797-所有可能的路径",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/113.LeetCode-797-所有可能的路径.md",wordsCount:585,readingTime:"2.6m",title:"LeetCode-797-所有可能的路径",date:"2021-08-25T14:56:24.000Z",description:"所有可能的路径",tags:["回溯","Medium","Java","数组","DFS","图"],keywords:"Medium,Java,回溯,数组,图,DFS",permalink:"/pages/0b83ab/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-145-二叉树的后序遍历",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/12.LeetCode-145-二叉树的后序遍历.md",wordsCount:764,readingTime:"3.7m",title:"LeetCode-145-二叉树的后序遍历",date:"2020-05-13T15:05:04.000Z",description:"二叉树的后序遍历",tags:["树","BFS","Java","Hard"],keywords:"树,DFS,Java,Hard",permalink:"/pages/bc617d/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-53-最大子序和",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/13.LeetCode-53-最大子序和.md",wordsCount:476,readingTime:"2.2m",title:"LeetCode-53-最大子序和",date:"2020-05-30T10:28:18.000Z",description:"最大子序和",tags:["DP","贪心算法","Java","Python","Easy","LeetCode"],keywords:"DP,贪心算法,Java,Python,Easy,LeetCode",permalink:"/pages/1ac9e8/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-392-判断子序列",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/14.LeetCode-392-判断子序列.md",wordsCount:731,readingTime:"3.3m",title:"LeetCode-392-判断子序列",date:"2020-05-30T13:13:39.000Z",description:"判断子序列",tags:["DP","字符串","Java","Easy","LeetCode"],keywords:"DP,字符串,Java,Easy,LeetCode",permalink:"/pages/20a5df/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-303-区域和检索-数组不可变",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/15.LeetCode-303-区域和检索-数组不可变.md",wordsCount:582,readingTime:"2.7m",title:"LeetCode-303-区域和检索-数组不可变",date:"2020-05-31T10:12:38.000Z",description:"区域和检索-数组不可变",tags:["DP","数组","Java","Easy","LeetCode"],keywords:"DP,数组,Java,Easy,LeetCode",permalink:"/pages/d42c3d/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-2-两数相加",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/16.LeetCode-2-两数相加.md",wordsCount:767,readingTime:"3.2m",title:"LeetCode-2-两数相加",date:"2020-06-16T10:02:43.000Z",description:"两数相加",tags:["链表","Java","Medium","LeetCode"],keywords:"链表,Java,Medium,LeetCode",permalink:"/pages/95fe08/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-3-无重复字符的最长字串",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/17.LeetCode-3-无重复字符的最长字串.md",wordsCount:723,readingTime:"3.1m",title:"LeetCode-3-无重复字符的最长字串",date:"2020-06-16T14:56:12.000Z",description:"无重复字符的最长字串",tags:["字符串","Java","滑动窗口","Medium","LeetCode"],keywords:"字符串,Java,滑动窗口,Medium,LeetCode",permalink:"/pages/30e6dd/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-4-寻找两个正序数组的中位数",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/18.LeetCode-4-寻找两个正序数组的中位数.md",wordsCount:"1.6k",readingTime:"6.7m",title:"LeetCode-4-寻找两个正序数组的中位数",date:"2020-06-19T13:52:54.000Z",description:"寻找两个正序数组的中位数",tags:["数组","Java","Hard","LeetCode"],keywords:"数组,Java,Hard,LeetCode",permalink:"/pages/e945ea/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-5-最长回文字串",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/19.LeetCode-5-最长回文字串.md",wordsCount:"1.1k",readingTime:"5m",title:"LeetCode-5-最长回文字串",date:"2020-06-18T14:31:14.000Z",description:"最长回文字串",tags:["字符串","DP","Java","Medium","LeetCode"],keywords:"DP,字符串,Java,Medium,LeetCode",permalink:"/pages/c3c526/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-11-盛最多水的容器",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/20.LeetCode-11-盛最多水的容器.md",wordsCount:451,readingTime:"1.8m",title:"LeetCode-11-盛最多水的容器",date:"2020-06-19T14:57:16.000Z",description:"盛最多水的容器",tags:["数组","Java","Medium","LeetCode"],keywords:"数组,Java,Medium,LeetCode",permalink:"/pages/1104ba/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-15-三数之和",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/21.LeetCode-15-三数之和.md",wordsCount:519,readingTime:"2.3m",title:"LeetCode-15-三数之和",date:"2020-06-23T17:01:45.000Z",description:"三数之和",tags:["数组","Java","Medium","LeetCode"],keywords:"数组,Java,Medium,LeetCode",permalink:"/pages/5a4da3/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-17-电话号码的字母组合",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/22.LeetCode-17-电话号码的字母组合.md",wordsCount:449,readingTime:"1.9m",title:"LeetCode-17-电话号码的字母组合",date:"2020-06-24T15:51:32.000Z",description:"电话号码的字母组合",tags:["字符串","Java","Medium","LeetCode"],keywords:"字符串,Java,Medium,LeetCode",permalink:"/pages/23ca91/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-19-删除链表的倒数第N个节点",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/23.LeetCode-19-删除链表的倒数第N个节点.md",wordsCount:428,readingTime:"1.7m",title:"LeetCode-19-删除链表的倒数第N个节点",date:"2020-06-26T16:38:24.000Z",description:"删除链表的倒数第N个节点",tags:["链表","Java","Medium"],keywords:"链表,Java,Medium,LeetCode",permalink:"/pages/2b5a76/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-20-有效的括号",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/24.LeetCode-20-有效的括号.md",wordsCount:455,readingTime:"1.8m",title:"LeetCode-20-有效的括号",date:"2020-06-24T09:37:20.000Z",description:"有效的括号",tags:["字符串","Java","Python","Easy"],keywords:"字符串,Java,Python,Easy,LeetCode",permalink:"/pages/b7ac0a/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-21-合并两个有序链表",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/25.LeetCode-21-合并两个有序链表.md",wordsCount:794,readingTime:"3.5m",title:"LeetCode-21-合并两个有序链表",date:"2020-06-07T19:00:23.000Z",description:"合并两个有序链表",tags:["链表","Java","Python","Easy"],keywords:"链表,Java,Python,Easy,LeetCode",permalink:"/pages/d0dd86/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-22-括号生成",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/26.LeetCode-22-括号生成.md",wordsCount:483,readingTime:"2.1m",title:"LeetCode-22-括号生成",date:"2020-06-26T18:52:11.000Z",description:"括号生成",tags:["字符串","回溯","DFS","Java","Medium"],keywords:"字符串,回溯,DFS,Java,Medium,LeetCode",permalink:"/pages/a6eaf0/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-23-合并K个排序链表",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/27.LeetCode-23-合并K个排序链表.md",wordsCount:"1k",readingTime:"4.6m",title:"LeetCode-23-合并K个排序链表",date:"2020-06-07T20:09:48.000Z",description:"合并K个排序链表",tags:["链表","分治","Java","Hard"],keywords:"链表,分治,Java,Hard,LeetCode",permalink:"/pages/e24301/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-31-下一个排列",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/28.LeetCode-31-下一个排列.md",wordsCount:883,readingTime:"3.6m",title:"LeetCode-31-下一个排列",date:"2020-07-05T09:46:12.000Z",description:"下一个排列",tags:["数组","Java","Medium"],keywords:"数组,Java,Medium,LeetCode",permalink:"/pages/d9a097/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-32-最长有效括号",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/29.LeetCode-32-最长有效括号.md",wordsCount:"1.1k",readingTime:"4.5m",title:"LeetCode-32-最长有效括号",date:"2020-07-17T09:43:11.000Z",description:"最长有效括号",tags:["字符串","DP","Java","Hard"],keywords:"字符串,Java,Hard,LeetCode",permalink:"/pages/bcf8b4/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-33-搜索旋转排序数组",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/30.LeetCode-33-搜索旋转排序数组.md",wordsCount:993,readingTime:"4.1m",title:"LeetCode-33-搜索旋转排序数组",date:"2020-07-10T09:30:50.000Z",description:"搜索旋转排序数组",tags:["Java","数组","Medium"],keywords:"Java,数组,Medium,LeetCode",permalink:"/pages/1b9196/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-34-在排序数组中查找元素的第一个和最后一个位置",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/31.LeetCode-34-在排序数组中查找元素的第一个和最后一个位置.md",wordsCount:"1.1k",readingTime:"5.1m",title:"LeetCode-34-在排序数组中查找元素的第一个和最后一个位置",date:"2020-07-25T15:33:38.000Z",description:"在排序数组中查找元素的第一个和最后一个位置",tags:["数组","Java","Medium"],keywords:"数组,Java,Medium,LeetCode",permalink:"/pages/1f0b71/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-39-组合总数",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/32.LeetCode-39-组合总数.md",wordsCount:587,readingTime:"2.5m",title:"LeetCode-39-组合总数",date:"2020-07-05T11:01:10.000Z",description:"组合总数",tags:["数组","DFS","Java","Medium"],keywords:"数组,DFS,Java,Medium,LeetCode",permalink:"/pages/731f67/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-46-全排列",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/33.LeetCode-46-全排列.md",wordsCount:399,readingTime:"1.8m",title:"LeetCode-46-全排列",date:"2020-06-08T22:18:43.000Z",description:"全排列",tags:["回溯","数组","Java","Medium","LeetCode"],keywords:"回溯,数组,Java,Medium,LeetCode",permalink:"/pages/292c69/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-47-全排列2",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/34.LeetCode-47-全排列2.md",wordsCount:508,readingTime:"2.2m",title:"LeetCode-47-全排列2",date:"2020-06-09T18:33:18.000Z",description:"全排列2",tags:["回溯","数组","Java","Medium","LeetCode"],keywords:"回溯,数组,Java,Medium,LeetCode",permalink:"/pages/ed20fe/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-51-N皇后",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/35.LeetCode-51-N皇后.md",wordsCount:"1.3k",readingTime:"5.1m",title:"LeetCode-51-N皇后",date:"2020-06-08T19:55:16.000Z",description:"N皇后",tags:["二维数组","矩阵","回溯","Java","Hard"],keywords:"二维数组,矩阵,回溯,Java,Hard",permalink:"/pages/cd98da/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-55-跳跃游戏",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/36.LeetCode-55-跳跃游戏.md",wordsCount:473,readingTime:"1.9m",title:"LeetCode-55-跳跃游戏",date:"2020-07-06T17:18:19.000Z",description:"跳跃游戏",tags:["数组","贪心算法","Java","Medium"],keywords:"数组,贪心算法,Java,Medium,LeetCode",permalink:"/pages/010874/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-56-合并区间",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/37.LeetCode-56-合并区间.md",wordsCount:486,readingTime:"2.1m",title:"LeetCode-56-合并区间",date:"2020-08-02T16:28:08.000Z",description:"合并区间",tags:["数组","Java","Medium"],keywords:"数组,Java,Medium,LeetCode",permalink:"/pages/232d3c/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-62-不同路径",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/38.LeetCode-62-不同路径.md",wordsCount:522,readingTime:"2.3m",title:"LeetCode-62-不同路径",date:"2020-08-06T13:19:12.000Z",description:"不同路径",tags:["矩阵","DP","Java","Medium"],keywords:"矩阵,DP,Java,Medium,LeetCode",permalink:"/pages/193e4b/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-64-最小路径和",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/39.LeetCode-64-最小路径和.md",wordsCount:633,readingTime:"2.8m",title:"LeetCode-64-最小路径和",date:"2020-07-16T14:16:19.000Z",description:"最小路径和",tags:["数组","矩阵","DP","Java","Python","Medium"],keywords:"数组,矩阵,DP,Java,Python,Medium,LeetCode",permalink:"/pages/b04e8c/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-70-爬楼梯",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/40.LeetCode-70-爬楼梯.md",wordsCount:499,readingTime:"2.2m",title:"LeetCode-70-爬楼梯",date:"2020-06-20T20:58:35.000Z",description:"爬楼梯",tags:["数组","DP","Java","Easy"],keywords:"数组,DP,Java,Easy",permalink:"/pages/b9a49e/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-72-编辑距离",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/41.LeetCode-72-编辑距离.md",wordsCount:383,readingTime:"1.8m",title:"LeetCode-72-编辑距离",date:"2020-07-27T09:53:31.000Z",description:"编辑距离",tags:["字符串","Java","DP","Hard"],keywords:"字符串,Java,Hard,DP,LeetCode",permalink:"/pages/dfda01/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-75-颜色分类",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/42.LeetCode-75-颜色分类.md",wordsCount:839,readingTime:"3.5m",title:"LeetCode-75-颜色分类",date:"2020-08-06T09:47:45.000Z",description:"颜色分类",tags:["数组","Java","Medium"],keywords:"数组,Java,Medium,LeetCode",permalink:"/pages/a35d7b/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-76-最小覆盖字串",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/43.LeetCode-76-最小覆盖字串.md",wordsCount:688,readingTime:"3.1m",title:"LeetCode-76-最小覆盖字串",date:"2020-08-19T10:10:37.000Z",description:"最小覆盖字串",tags:["字符串","滑动窗口","Java","Hard"],keywords:"字符串,滑动窗口,Java,Hard,LeetCode",permalink:"/pages/a90162/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-77-组合",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/44.LeetCode-77-组合.md",wordsCount:351,readingTime:"1.6m",title:"LeetCode-77-组合",date:"2020-07-28T09:30:45.000Z",description:"组合",tags:["数组","回溯","Java","Medium"],keywords:"数组,Java,回溯,Medium,LeetCode",permalink:"/pages/c30be8/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-78-子集",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/45.LeetCode-78-子集.md",wordsCount:531,readingTime:"2.3m",title:"LeetCode-78-子集",date:"2020-07-27T15:29:47.000Z",description:"子集",tags:["数组","Java","回溯","Medium"],keywords:"数组,Java,Medium,LeetCode",permalink:"/pages/60626a/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-84-柱状图中最大的矩形",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/46.LeetCode-84-柱状图中最大的矩形.md",wordsCount:704,readingTime:"3.4m",title:"LeetCode-84-柱状图中最大的矩形",date:"2020-08-07T10:13:52.000Z",description:"柱状图中最大的矩形",tags:["数组","Java","Hard"],keywords:"数组,Java,Hard,LeetCode",permalink:"/pages/16f784/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-102-二叉树的层序遍历",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/47.LeetCode-102-二叉树的层序遍历.md",wordsCount:305,readingTime:"1.4m",title:"LeetCode-102-二叉树的层序遍历",date:"2020-07-15T14:14:24.000Z",description:"二叉树的层序遍历",tags:["树","Java","Medium"],keywords:"树,Java,Medium,LeetCode",permalink:"/pages/bcc13b/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-104-二叉树的最大深度",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/48.LeetCode-104-二叉树的最大深度.md",wordsCount:470,readingTime:"2.1m",title:"LeetCode-104-二叉树的最大深度",date:"2020-06-11T19:38:36.000Z",description:"二叉树的最大深度",tags:["树","DFS","Java","Easy"],keywords:"树,DFS,Java,Easy",permalink:"/pages/95771c/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-105-从前序与中序遍历构造二叉树",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/49.LeetCode-105-从前序与中序遍历构造二叉树.md",wordsCount:794,readingTime:"3.6m",title:"LeetCode-105-从前序与中序遍历构造二叉树",date:"2020-06-22T11:01:44.000Z",description:"从前序与中序遍历构造二叉树",tags:["树","Java","Medium"],keywords:"树,Java,Medium",permalink:"/pages/c5dd58/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-107-二叉树的层次遍历2",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/50.LeetCode-107-二叉树的层次遍历2.md",wordsCount:362,readingTime:"1.6m",title:"LeetCode-107-二叉树的层次遍历2",date:"2020-06-11T20:19:38.000Z",description:"二叉树的层次遍历2",tags:["树","BFS","Java","Easy"],keywords:"树,BFS,Java,Easy",permalink:"/pages/4d6c7d/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-114-二叉树展开为链表",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/51.LeetCode-114-二叉树展开为链表.md",wordsCount:544,readingTime:"2.3m",title:"LeetCode-114-二叉树展开为链表",date:"2020-07-14T13:55:35.000Z",description:"二叉树展开为链表",tags:["树","Java","Medium"],keywords:"树,Java,Medium,LeetCode",permalink:"/pages/f626bf/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-121-买卖股票的最佳时机",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/52.LeetCode-121-买卖股票的最佳时机.md",wordsCount:421,readingTime:"1.7m",title:"LeetCode-121-买卖股票的最佳时机",date:"2020-06-05T20:28:28.000Z",description:"买卖股票的最佳时机",tags:["DP","数组","Java","Easy","LeetCode"],keywords:"DP,数组,Java,Easy,LeetCode",permalink:"/pages/6f907a/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-128-最长连续序列",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/53.LeetCode-128-最长连续序列.md",wordsCount:640,readingTime:"2.6m",title:"LeetCode-128-最长连续序列",date:"2020-07-11T09:49:26.000Z",description:"最长连续序列",tags:["Java","数组","Hard"],keywords:"Java,数组,Hard,LeetCode",permalink:"/pages/1c92f0/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-136-只出现一次的数字",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/54.LeetCode-136-只出现一次的数字.md",wordsCount:380,readingTime:"1.6m",title:"LeetCode-136-只出现一次的数字",date:"2020-06-18T21:22:13.000Z",description:"只出现一次的数字",tags:["数组","Java","Python","Easy","LeetCode"],keywords:"数组,Java,Python,Easy,LeetCode",permalink:"/pages/7a9856/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-142-环形链表2",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/55.LeetCode-142-环形链表2.md",wordsCount:866,readingTime:"3.9m",title:"LeetCode-142-环形链表2",date:"2020-06-10T16:43:09.000Z",description:"环形链表2",tags:["链表","Java","Medium","LeetCode"],keywords:"链表,Java,Medium,LeetCode",permalink:"/pages/21e57b/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-143-重排链表",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/56.LeetCode-143-重排链表.md",wordsCount:"1.1k",readingTime:"4.8m",title:"LeetCode-143-重排链表",date:"2020-06-10T20:33:33.000Z",description:"重排链表",tags:["链表","Java","Medium","LeetCode"],keywords:"链表,Java,Medium,LeetCode",permalink:"/pages/825806/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-146-LRU缓存机制",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/57.LeetCode-146-LRU缓存机制.md",wordsCount:"2k",readingTime:"8.3m",title:"LeetCode-146-LRU缓存机制",date:"2020-08-04T09:32:57.000Z",description:"LRU缓存机制",tags:["数组","Java","Medium"],keywords:"数组,Java,Medium,LeetCode",permalink:"/pages/0d05d2/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-152-乘积最大子数组",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/58.LeetCode-152-乘积最大子数组.md",wordsCount:646,readingTime:"2.9m",title:"LeetCode-152-乘积最大子数组",date:"2020-07-12T10:15:54.000Z",description:"乘积最大子数组",tags:["Java","数组","DP","Medium"],keywords:"Java,数组,DP,Medium,LeetCode",permalink:"/pages/87a481/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-198-打家劫舍",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/59.LeetCode-198-打家劫舍.md",wordsCount:595,readingTime:"2.6m",title:"LeetCode-198-打家劫舍",date:"2020-06-06T15:03:23.000Z",description:"打家劫舍",tags:["DP","数组","Java","Python","Easy","LeetCode"],keywords:"DP,数组,Java,Python,Easy,LeetCode",permalink:"/pages/bd9776/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-199-二叉树的右视图",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/60.LeetCode-199-二叉树的右视图.md",wordsCount:529,readingTime:"2.4m",title:"LeetCode-199-二叉树的右视图",date:"2020-07-08T11:14:52.000Z",description:"二叉树的右视图",tags:["树","Java","BFS","DFS","Medium"],keywords:"树,Java,BFS,DFS,Medium,LeetCode",permalink:"/pages/2aa937/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-206-反转链表",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/61.LeetCode-206-反转链表.md",wordsCount:433,readingTime:"1.9m",title:"LeetCode-206-反转链表",date:"2020-07-17T13:23:02.000Z",description:"反转链表",tags:["链表","Java","Easy"],keywords:"链表,Java,Easy,LeetCode",permalink:"/pages/7c576f/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-207-课程表",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/62.LeetCode-207-课程表.md",wordsCount:885,readingTime:"3.6m",title:"LeetCode-207-课程表",date:"2020-07-18T11:25:07.000Z",description:"课程表",tags:["数组","图论算法","拓扑排序","BFS","DFS","Java","Medium"],keywords:"数组,图论算法,拓扑排序,BFS,DFS,Java,Medium,LeetCode",permalink:"/pages/44df2f/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-215-数组中的第K个最大元素",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/63.LeetCode-215-数组中的第K个最大元素.md",wordsCount:"1.2k",readingTime:"5m",title:"LeetCode-215-数组中的第K个最大元素",date:"2020-06-24T10:18:17.000Z",description:"数组中的第K个最大元素",tags:["数组","Java","Python","Medium","LeetCode"],keywords:"数组,Java,Python,Medium,LeetCode",permalink:"/pages/f586d8/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-221-最大正方形",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/64.LeetCode-221-最大正方形.md",wordsCount:847,readingTime:"3.8m",title:"LeetCode-221-最大正方形",date:"2020-08-11T11:22:30.000Z",description:"最大正方形",tags:["矩阵","DP","Java","Medium"],keywords:"矩阵,DP,Java,Medium,LeetCode",permalink:"/pages/3b7ec6/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-226-翻转二叉树",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/65.LeetCode-226-翻转二叉树.md",wordsCount:567,readingTime:"2.4m",title:"LeetCode-226-翻转二叉树",date:"2020-07-10T11:11:30.000Z",description:"翻转二叉树",tags:["树","Java","DFS","Easy"],keywords:"树,Java,DFS,Easy,LeetCode",permalink:"/pages/2bee97/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-236-二叉树的最近公共祖先",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/66.LeetCode-236-二叉树的最近公共祖先.md",wordsCount:"1.2k",readingTime:"5m",title:"LeetCode-236-二叉树的最近公共祖先",date:"2020-08-01T10:01:16.000Z",description:"二叉树的最近公共祖先",tags:["树","Java","Medium"],keywords:"树,Java,Medium,LeetCode",permalink:"/pages/ceb226/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-279-完全平方数",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/67.LeetCode-279-完全平方数.md",wordsCount:356,readingTime:"1.6m",title:"LeetCode-279-完全平方数",date:"2020-08-14T13:38:52.000Z",description:"完全平方数",tags:["数组","DP","Java","Medium"],keywords:"数组,DP,Java,Medium,LeetCode",permalink:"/pages/aa9694/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-287-寻找重复数",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/68.LeetCode-287-寻找重复数.md",wordsCount:438,readingTime:"1.8m",title:"LeetCode-287-寻找重复数",date:"2020-07-13T11:02:55.000Z",description:"寻找重复数",tags:["Java","数组","Medium"],keywords:"Java,数组,Medium,LeetCode",permalink:"/pages/d6c0fb/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-300-最长上升子序列",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/69.LeetCode-300-最长上升子序列.md",wordsCount:659,readingTime:"2.9m",title:"LeetCode-300-最长上升子序列",date:"2020-06-09T20:02:29.000Z",description:"最长上升子序列",tags:["DP","数组","Java","Medium","LeetCode"],keywords:"DP,数组,Java,Medium,LeetCode",permalink:"/pages/444ab2/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-309-最佳买卖股票时机含冷冻期",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/70.LeetCode-309-最佳买卖股票时机含冷冻期.md",wordsCount:616,readingTime:"2.6m",title:"LeetCode-309-最佳买卖股票时机含冷冻期",date:"2020-07-08T09:27:07.000Z",description:"最佳买卖股票时机含冷冻期",tags:["数组","Java","DP","Medium"],keywords:"数组,Java,DP,Medium,LeetCode",permalink:"/pages/3b3388/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-322-零钱兑换",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/71.LeetCode-322-零钱兑换.md",wordsCount:"1.5k",readingTime:"6.8m",title:"LeetCode-322-零钱兑换",date:"2020-08-21T10:00:46.000Z",description:"零钱兑换",tags:["数组","DP","回溯","Java","Medium"],keywords:"数组,DP,回溯,Java,Medium,LeetCode",permalink:"/pages/9868ec/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-328-奇偶链表",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/72.LeetCode-328-奇偶链表.md",wordsCount:577,readingTime:"2.3m",title:"LeetCode-328-奇偶链表",date:"2020-06-10T15:14:20.000Z",description:"奇偶链表",tags:["链表","Java","Medium","LeetCode"],keywords:"链表,Java,Medium,LeetCode",permalink:"/pages/74a1b6/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-347-前K个高频元素",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/73.LeetCode-347-前K个高频元素.md",wordsCount:508,readingTime:"2.2m",title:"LeetCode-347-前K个高频元素",date:"2020-07-15T09:14:34.000Z",description:"前K个高频元素",tags:["Java","数组","Medium"],keywords:"Java,数组,Medium,LeetCode",permalink:"/pages/5abc8f/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-394-字符串解码",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/74.LeetCode-394-字符串解码.md",wordsCount:806,readingTime:"3.3m",title:"LeetCode-394-字符串解码",date:"2020-08-03T11:11:29.000Z",description:"字符串解码",tags:["字符串","Java","Medium"],keywords:"字符串,Java,Medium,LeetCode",permalink:"/pages/0af455/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-406-根据身高重建队列",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/75.LeetCode-406-根据身高重建队列.md",wordsCount:384,readingTime:"1.7m",title:"LeetCode-406-根据身高重建队列",date:"2020-07-18T09:32:29.000Z",description:"根据身高重建队列",tags:["数组","Java","Medium"],keywords:"数组,Java,Medium,LeetCode",permalink:"/pages/8d243f/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-413-等差数列划分",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/76.LeetCode-413-等差数列划分.md",wordsCount:567,readingTime:"2.5m",title:"LeetCode-413-等差数列划分",date:"2020-06-18T20:13:57.000Z",description:"判断子序列",tags:["DP","数组","Java","Medium","LeetCode"],keywords:"DP,数组,Java,Medium,LeetCode",permalink:"/pages/cd66f6/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-416-分割等和子集",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/77.LeetCode-416-分割等和子集.md",wordsCount:512,readingTime:"2.2m",title:"LeetCode-416-分割等和子集",date:"2020-08-05T09:46:41.000Z",description:"分割等和子集",tags:["数组","DP","Java","Medium"],keywords:"数组,DP,Java,Medium,LeetCode",permalink:"/pages/87a353/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-438-找到字符串中所有字母异位词",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/78.LeetCode-438-找到字符串中所有字母异位词.md",wordsCount:"1.1k",readingTime:"4.5m",title:"LeetCode-438-找到字符串中所有字母异位词",date:"2020-08-18T09:57:26.000Z",description:"找到字符串中所有字母异位词",tags:["字符串","滑动窗口","Java","Medium"],keywords:"字符串,Java,滑动窗口,Medium,LeetCode",permalink:"/pages/e8a730/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-448-找到所有数组中消失的数字",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/79.LeetCode-448-找到所有数组中消失的数字.md",wordsCount:688,readingTime:"3.1m",title:"LeetCode-448-找到所有数组中消失的数字",date:"2020-08-03T09:52:29.000Z",description:"找到所有数组中消失的数字",tags:["数组","Java","Easy"],keywords:"数组,Java,Easy,LeetCode",permalink:"/pages/d2f3f5/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-461-汉明距离",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/80.LeetCode-461-汉明距离.md",wordsCount:370,readingTime:"1.5m",title:"LeetCode-461-汉明距离",date:"2020-07-20T09:22:22.000Z",description:"汉明距离",tags:["数组","Java","Easy"],keywords:"数组,Java,Easy,LeetCode",permalink:"/pages/ad566a/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-494-目标和",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/81.LeetCode-494-目标和.md",wordsCount:636,readingTime:"3m",title:"LeetCode-494-目标和",date:"2020-07-20T09:52:58.000Z",description:"目标和",tags:["数组","Java","回溯","DP","Medium"],keywords:"数组,Java,回溯,DP,Medium,LeetCode",permalink:"/pages/ed7689/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-538-把二叉搜索树转换为累加树",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/82.LeetCode-538-把二叉搜索树转换为累加树.md",wordsCount:507,readingTime:"2.1m",title:"LeetCode-538-把二叉搜索树转换为累加树",date:"2020-07-09T09:09:37.000Z",description:"把二叉搜索树转换为累加树",tags:["树","Java","Easy"],keywords:"树,Java,Easy,LeetCode",permalink:"/pages/9d7aee/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-543-二叉树的直径",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/83.LeetCode-543-二叉树的直径.md",wordsCount:354,readingTime:"1.5m",title:"LeetCode-543-二叉树的直径",date:"2020-08-07T09:29:27.000Z",description:"二叉树的直径",tags:["树","DFS","Java","Easy"],keywords:"树,DFS,Java,Easy,LeetCode",permalink:"/pages/a78f8c/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-560-和为K的子数组",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/84.LeetCode-560-和为K的子数组.md",wordsCount:775,readingTime:"3.3m",title:"LeetCode-560-和为K的子数组",date:"2020-07-31T17:52:50.000Z",description:"和为K的子数组",tags:["数组","Java","Medium"],keywords:"数组,Java,Medium,LeetCode",permalink:"/pages/c7dca6/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-567-字符串的排列",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/85.LeetCode-567-字符串的排列.md",wordsCount:622,readingTime:"2.9m",title:"LeetCode-567-字符串的排列",date:"2020-08-18T15:30:45.000Z",description:"字符串的排列",tags:["字符串","滑动窗口","Java","Medium"],keywords:"字符串,滑动窗口,Java,Medium,LeetCode",permalink:"/pages/5997b7/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-581-最短无序连续子数组",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/86.LeetCode-581-最短无序连续子数组.md",wordsCount:833,readingTime:"3.3m",title:"LeetCode-581-最短无序连续子数组",date:"2020-07-14T10:03:46.000Z",description:"最短无序连续子数组",tags:["Java","数组","Easy"],keywords:"Java,数组,Easy,LeetCode",permalink:"/pages/9686ce/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-617-合并二叉树",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/87.LeetCode-617-合并二叉树.md",wordsCount:641,readingTime:"2.8m",title:"LeetCode-617-合并二叉树",date:"2020-07-06T15:48:22.000Z",description:"合并二叉树",tags:["树","Java","Easy"],keywords:"树,Java,Easy,LeetCode",permalink:"/pages/f24660/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-704-二分查找",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/88.LeetCode-704-二分查找.md",wordsCount:418,readingTime:"1.9m",title:"LeetCode-704-二分查找",date:"2020-04-10T15:44:53.000Z",description:"二分查找",tags:["查找","Java","Python","Easy"],keywords:"查找,Java,Python,Easy",permalink:"/pages/326143/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-739-每日温度",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/89.LeetCode-739-每日温度.md",wordsCount:477,readingTime:"2m",title:"LeetCode-739-每日温度",date:"2020-07-16T09:33:43.000Z",description:"每日温度",tags:["数组","栈","Java","Medium"],keywords:"数组,栈,Java,Medium,LeetCode",permalink:"/pages/d7d595/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-747-至少是其他数字两倍的最大数",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/90.LeetCode-747-至少是其他数字两倍的最大数.md",wordsCount:472,readingTime:"2m",title:"LeetCode-747-至少是其他数字两倍的最大数",date:"2020-03-19T19:00:16.000Z",description:"至少是其他数字两倍的最大数",tags:["数组","Java","Python","Easy"],keywords:"数组,Java,Python,Easy",permalink:"/pages/0343b2/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-890-查找和替换模式",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/91.LeetCode-890-查找和替换模式.md",wordsCount:494,readingTime:"2.1m",title:"LeetCode-890-查找和替换模式",date:"2020-07-26T17:00:32.000Z",description:"查找和替换模式",tags:["数组","Java","Medium"],keywords:"数组,Java,Medium,LeetCode",permalink:"/pages/a29fa8/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-1143-最长公共子序列",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/92.LeetCode-1143-最长公共子序列.md",wordsCount:533,readingTime:"2.3m",title:"LeetCode-1143-最长公共子序列",date:"2020-08-14T10:02:20.000Z",description:"最长公共子序列",tags:["字符串","DP","Java","Medium"],keywords:"字符串,DP,Java,Medium,LeetCode",permalink:"/pages/77c839/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-1247-交换字符使得字符串相同",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/93.LeetCode-1247-交换字符使得字符串相同.md",wordsCount:676,readingTime:"2.8m",title:"LeetCode-1247-交换字符使得字符串相同",date:"2020-08-11T09:43:28.000Z",description:"交换字符使得字符串相同",tags:["字符串","Java","Medium"],keywords:"字符串,Java,Medium,LeetCode",permalink:"/pages/961a11/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-1367-二叉树中的列表",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/94.LeetCode-1367-二叉树中的列表.md",wordsCount:811,readingTime:"3.4m",title:"LeetCode-1367-二叉树中的列表",date:"2020-06-11T16:38:13.000Z",description:"二叉树中的列表",tags:["树","DFS","Java","Medium"],keywords:"树,DFS,Java,Medium",permalink:"/pages/053bcf/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-字符串排序",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/95.LeetCode-字符串排序.md",wordsCount:478,readingTime:"2.1m",title:"LeetCode-字符串排序",date:"2020-08-30T17:23:46.000Z",description:"零钱兑换",tags:["字符串","Java","Easy"],keywords:"字符串,Java,Easy,LeetCode",permalink:"/pages/a64c8b/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题02-02-返回倒数第k个节点",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/96.LeetCode-面试题02-02-返回倒数第k个节点.md",wordsCount:401,readingTime:"1.8m",title:"LeetCode-面试题02.02-返回倒数第k个节点",date:"2020-06-10T15:28:54.000Z",description:"返回倒数第k个节点",tags:["链表","Java","Easy","LeetCode"],keywords:"链表,Java,Easy,LeetCode",permalink:"/pages/7899ff/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode-面试题17-16-按摩师",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/97.LeetCode-面试题17-16-按摩师.md",wordsCount:534,readingTime:"2.3m",title:"LeetCode-面试题17.16-按摩师",date:"2020-06-06T13:50:17.000Z",description:"按摩师",tags:["DP","数组","Java","Easy","LeetCode"],keywords:"DP,数组,Java,Easy,LeetCode",permalink:"/pages/0c5197/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"获取满足指数的最长字符串",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/98.获取满足指数的最长字符串.md",wordsCount:622,readingTime:"2.4m",title:"获取满足指数的最长字符串",date:"2020-08-20T19:16:41.000Z",description:"笔试题",tags:["Java","Medium"],keywords:"Java,Medium",permalink:"/pages/5969d4/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"数组的最多素数个数",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/02.LeetCode/99.数组的最多素数个数.md",wordsCount:486,readingTime:"2.1m",title:"数组的最多素数个数",date:"2020-08-10T09:50:59.000Z",description:"数组的最多素数个数",tags:["数组","Java","Easy"],keywords:"数组,Java,Easy,LeetCode",permalink:"/pages/13f871/",categories:["算法","LeetCode"],author:{name:"benym",link:"https://github.com/benym"}},{name:"常见排序算法总结",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/03.排序算法/00.常见排序算法总结.md",wordsCount:389,readingTime:"1.8m",title:"常见排序算法总结",date:"2020-07-02T16:17:37.000Z",description:"排序算法总结",tags:["排序算法","Java"],keywords:"排序,Java",permalink:"/pages/8d006a/",categories:["算法","排序算法"],author:{name:"benym",link:"https://github.com/benym"}},{name:"冒泡排序",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/03.排序算法/01.冒泡排序.md",wordsCount:220,readingTime:"1m",title:"冒泡排序",date:"2020-06-28T16:02:20.000Z",description:"冒泡排序",tags:["排序算法","Java"],keywords:"排序,Java",permalink:"/pages/3fd3f6/",categories:["算法","排序算法"],author:{name:"benym",link:"https://github.com/benym"}},{name:"基数排序",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/03.排序算法/02.基数排序.md",wordsCount:637,readingTime:"2.8m",title:"基数排序",date:"2020-07-01T15:23:25.000Z",description:"基数排序",tags:["排序算法","Java"],keywords:"排序,Java",permalink:"/pages/5ee1b6/",categories:["算法","排序算法"],author:{name:"benym",link:"https://github.com/benym"}},{name:"堆排序",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/03.排序算法/03.堆排序.md",wordsCount:781,readingTime:"3.3m",title:"堆排序",date:"2020-07-01T15:23:25.000Z",description:"堆排序",tags:["排序算法","Java"],keywords:"排序,Java",permalink:"/pages/c0468a/",categories:["算法","排序算法"],author:{name:"benym",link:"https://github.com/benym"}},{name:"希尔排序",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/03.排序算法/04.希尔排序.md",wordsCount:375,readingTime:"1.6m",title:"希尔排序",date:"2020-06-28T17:16:04.000Z",description:"希尔排序",tags:["排序算法","Java"],keywords:"排序,Java",permalink:"/pages/05578a/",categories:["算法","排序算法"],author:{name:"benym",link:"https://github.com/benym"}},{name:"归并排序",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/03.排序算法/05.归并排序.md",wordsCount:396,readingTime:"1.8m",title:"归并排序",date:"2020-05-09T18:16:01.000Z",description:"归并排序",tags:["排序算法","Java","Easy"],keywords:"排序,JavaEasy",permalink:"/pages/246724/",categories:["算法","排序算法"],author:{name:"benym",link:"https://github.com/benym"}},{name:"快速排序",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/03.排序算法/06.快速排序.md",wordsCount:385,readingTime:"1.8m",title:"快速排序",date:"2020-05-04T16:33:58.000Z",description:"快速排序",tags:["排序算法","Java","Easy"],keywords:"排序,JavaEasy",permalink:"/pages/c1fce8/",categories:["算法","排序算法"],author:{name:"benym",link:"https://github.com/benym"}},{name:"插入排序",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/03.排序算法/07.插入排序.md",wordsCount:286,readingTime:"1.2m",title:"插入排序",date:"2020-06-28T16:46:47.000Z",description:"插入排序",tags:["排序算法","Java"],keywords:"排序,Java",permalink:"/pages/db04fa/",categories:["算法","排序算法"],author:{name:"benym",link:"https://github.com/benym"}},{name:"桶排序",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/03.排序算法/08.桶排序.md",wordsCount:939,readingTime:"4.1m",title:"桶排序",date:"2020-07-01T09:59:15.000Z",description:"桶排序",tags:["排序算法","Java"],keywords:"排序,Java",permalink:"/pages/7a5e99/",categories:["算法","排序算法"],author:{name:"benym",link:"https://github.com/benym"}},{name:"选择排序",filePath:"/home/runner/work/benym-book/benym-book/docs/06.算法/03.排序算法/09.选择排序.md",wordsCount:246,readingTime:"1.1m",title:"选择排序",date:"2020-06-28T16:16:47.000Z",description:"选择排序",tags:["排序算法","Java"],keywords:"排序,Java",permalink:"/pages/ee0279/",categories:["算法","排序算法"],author:{name:"benym",link:"https://github.com/benym"}},{name:"将hexo自定义域名升级https",filePath:"/home/runner/work/benym-book/benym-book/docs/07.实践/01.hexo/01.将hexo自定义域名升级https.md",wordsCount:845,readingTime:"3.4m",title:"将hexo自定义域名升级https",date:"2018-08-29T16:02:44.000Z",categories:["Hexo"],tags:["Hexo"],permalink:"/pages/f6b758/",author:{name:"benym",link:"https://github.com/benym"}},{name:"hexo到Typecho的迁移日志",filePath:"/home/runner/work/benym-book/benym-book/docs/07.实践/01.hexo/02.hexo到Typecho的迁移日志.md",wordsCount:978,readingTime:"3.5m",title:"hexo到Typecho的迁移日志",date:"2021-11-22T22:48:38.000Z",categories:["Hexo"],tags:["Hexo","Typecho","VuePress"],permalink:"/pages/a07112/",author:{name:"benym",link:"https://github.com/benym"}},{name:"海量数据TopK问题",filePath:"/home/runner/work/benym-book/benym-book/docs/07.实践/02.思考与方案/01.海量数据TopK问题.md",wordsCount:"1.1k",readingTime:"4m",title:"海量数据TopK问题",date:"2020-06-29T16:18:11.000Z",description:"总结",categories:["常见问题"],tags:["TopK","Java"],keywords:"TopK,Java",permalink:"/pages/2c256c/",author:{name:"benym",link:"https://github.com/benym"}},{name:"关于DO,VO,DTO,QueryParam的思考",filePath:"/home/runner/work/benym-book/benym-book/docs/07.实践/02.思考与方案/02.关于DO,VO,DTO,QueryParam的思考.md",wordsCount:"1.6k",readingTime:"6.6m",title:"关于DO,VO,DTO,QueryParam的思考",date:"2021-08-10T17:51:47.000Z",description:"Java接口规范化思考",categories:["Java"],tags:["SpringBoot","Java"],keywords:"SpringBoot,Java",permalink:"/pages/45617b/",author:{name:"benym",link:"https://github.com/benym"}},{name:"异步消息通知",filePath:"/home/runner/work/benym-book/benym-book/docs/07.实践/02.思考与方案/03.异步消息通知.md",wordsCount:"4.8k",readingTime:"20.9m",title:"异步消息通知—异步改造",date:"2021/11/02 17:00:15",description:"总结",categories:["Java"],tags:["异步","消息队列","线程池","事务","Java","Spring"],keywords:"Java,异步,消息队列,事务,Spring,线程池",permalink:"/pages/3572ad/",author:{name:"benym",link:"https://github.com/benym"}},{name:"二叉搜索树及AVL树详解",filePath:"/home/runner/work/benym-book/benym-book/docs/07.实践/02.思考与方案/04.二叉搜索树及AVL树详解.md",wordsCount:"2.7k",readingTime:"11.8m",title:"二叉搜索树及AVL树详解",date:"2022-01-28T15:42:48.000Z",categories:["Java"],tags:["Java","树","平衡二叉搜索树","二叉搜索树"],permalink:"/pages/2efaaf/",author:{name:"benym",link:"https://github.com/benym"}},{name:"无惧性能烦恼-12款Bean拷贝工具压测大比拼",filePath:"/home/runner/work/benym-book/benym-book/docs/08.开源项目/01.Rpamis/01.Utils/01.无惧性能烦恼-12款Bean拷贝工具压测大比拼.md",wordsCount:"4.8k",readingTime:"23.4m",title:"无惧性能烦恼-12款Bean拷贝工具压测大比拼",date:"2022-11-17T23:06:41.000Z",categories:["开源项目","Rpamis"],tags:["工具类","BeanUtil","压测","JMH"],permalink:"/pages/3147fe/",author:{name:"benym",link:"https://github.com/benym"}},{name:"Bean工具类-RpasBeanUtils",filePath:"/home/runner/work/benym-book/benym-book/docs/08.开源项目/01.Rpamis/01.Utils/02.Bean工具类-RpasBeanUtils.md",wordsCount:773,readingTime:"3.5m",title:"Bean工具类-RpasBeanUtils",date:"2022-11-25T14:58:41.000Z",categories:["开源项目","Rpamis"],tags:["工具类","BeanUtil","RpasBeanUtils"],author:{name:"benym",link:"https://github.com/benym"},permalink:"/pages/cedee6/"},{name:"MethodHandle结合LambdaMetafactory-使用方法及性能测试",filePath:"/home/runner/work/benym-book/benym-book/docs/08.开源项目/01.Rpamis/02.Exception/01.MethodHandle结合LambdaMetafactory-使用方法及性能测试.md",wordsCount:"3.2k",readingTime:"14.3m",title:"MethodHandle结合LambdaMetafactory-使用方法及性能测试",date:"2022-12-27T14:23:30.000Z",categories:["开源项目","Rpamis"],tags:["MethodHandles","LambdaMetafactory","压测","反射"],author:{name:"benym",link:"https://github.com/benym"},permalink:"/pages/b127c7/"},{name:"优雅的参数校验与全局异常",filePath:"/home/runner/work/benym-book/benym-book/docs/08.开源项目/01.Rpamis/02.Exception/02.优雅的参数校验与全局异常.md",wordsCount:"11.8k",readingTime:"50.7m",title:"优雅的参数校验与全局异常-代码规范的天生落地",date:"2023-02-01T11:30:04.000Z",categories:["开源项目","Rpamis","Exception","Dubbo","Spring"],tags:["Exception","返回体","优雅校验","Validated","Valid","Advice","Dubbo","Filter","Http"],author:{name:"benym",link:"https://github.com/benym"},permalink:"/pages/1c47ed/"},{name:"异常工具类-ExceptionFactory",filePath:"/home/runner/work/benym-book/benym-book/docs/08.开源项目/01.Rpamis/02.Exception/03.异常工具类-ExceptionFactory.md",wordsCount:33,readingTime:"1",title:"异常工具类-ExceptionFactory",date:"2023-02-09T11:21:55.000Z",permalink:"/pages/4c5812/",tags:[null],author:{name:"benym",link:"https://github.com/benym"},article:!1},{name:"异常工具类-Assert",filePath:"/home/runner/work/benym-book/benym-book/docs/08.开源项目/01.Rpamis/02.Exception/04.异常工具类-Assert.md",wordsCount:33,readingTime:"1",title:"异常工具类-Assert",date:"2023-02-09T11:22:12.000Z",permalink:"/pages/cb1099/",tags:[null],author:{name:"benym",link:"https://github.com/benym"},article:!1},{name:"概览",filePath:"/home/runner/work/benym-book/benym-book/docs/09.索引/01.开源项目/01.概览.md",wordsCount:37,readingTime:"1",title:"概览",date:"2022-04-16T16:07:41.000Z",permalink:"/pages/2c6c1b/",categories:["索引","开源项目"],article:!1,tags:[null],author:{name:"benym",link:"https://github.com/benym"}},{name:"关于",filePath:"/home/runner/work/benym-book/benym-book/docs/10.关于/01.关于.md",wordsCount:149,readingTime:"1",title:"关于",permalink:"/about/",sidebar:!1,article:!1,date:"2022-04-17T23:30:08.000Z",author:{name:"benym",link:"https://github.com/benym"}},{name:"Java",filePath:"/home/runner/work/benym-book/benym-book/docs/11.目录/01.Java/01.Java.md",wordsCount:54,readingTime:"1",pageComponent:{name:"Catalogue",data:{path:"01.Java",imgUrl:"https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/guideline.png",description:"Java目录集合"}},title:"Java",sidebar:!0,article:!1,comment:!1,editLink:!1,date:"2022-04-17T19:33:21.000Z",permalink:"/pages/059f1f/",author:{name:"benym",link:"https://github.com/benym"}},{name:"Python基础",filePath:"/home/runner/work/benym-book/benym-book/docs/11.目录/02.Python/01.Python基础.md",wordsCount:62,readingTime:"1",pageComponent:{name:"Catalogue",data:{path:"02.Python/01.Python-基础",imgUrl:"https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/guideline.png",description:"Python基础目录集合"}},title:"Python-基础",sidebar:!0,article:!1,comment:!1,editLink:!1,date:"2022-04-12T23:21:16.000Z",permalink:"/pages/ad6515/",author:{name:"benym",link:"https://github.com/benym"}},{name:"Python机器学习",filePath:"/home/runner/work/benym-book/benym-book/docs/11.目录/02.Python/02.Python机器学习.md",wordsCount:68,readingTime:"1",pageComponent:{name:"Catalogue",data:{path:"02.Python/02.Python-机器学习",imgUrl:"https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/guideline.png",description:"Python机器学习目录集合"}},title:"Python-机器学习",sidebar:!0,article:!1,comment:!1,editLink:!1,date:"2022-04-12T23:21:16.000Z",permalink:"/pages/82c271/",author:{name:"benym",link:"https://github.com/benym"}},{name:"剑指Offer",filePath:"/home/runner/work/benym-book/benym-book/docs/11.目录/06.算法/01.剑指Offer.md",wordsCount:63,readingTime:"1",pageComponent:{name:"Catalogue",data:{path:"06.算法/01.剑指Offer",imgUrl:"https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/guideline.png",description:"剑指Offer目录合集"}},title:"剑指Offer",sidebar:!0,article:!1,comment:!1,editLink:!1,date:"2022-04-13T22:21:16.000Z",permalink:"/pages/f91e0d/",author:{name:"benym",link:"https://github.com/benym"}},{name:"LeetCode",filePath:"/home/runner/work/benym-book/benym-book/docs/11.目录/06.算法/02.LeetCode.md",wordsCount:57,readingTime:"1",pageComponent:{name:"Catalogue",data:{path:"06.算法/02.LeetCode",imgUrl:"https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/guideline.png",description:"LeetCode目录合集"}},title:"LeetCode",sidebar:!0,article:!1,comment:!1,editLink:!1,date:"2022-04-13T22:21:16.000Z",permalink:"/pages/b59559/",author:{name:"benym",link:"https://github.com/benym"}}],mdFileCountType:"archives",totalWords:"archives",moutedEvent:".tags-wrapper",indexIteration:2500,pageIteration:2500}}};var xl=t(94),wl=t(95),Cl=t(11);var El={computed:{$filterPosts(){return this.$site.pages.filter(n=>{const{frontmatter:{pageComponent:e,article:t,home:a}}=n;return!(e||!1===t||!0===a)})},$sortPosts(){return(n=this.$filterPosts).sort((n,e)=>{const t=n.frontmatter.sticky,a=e.frontmatter.sticky;return t&&a?t==a?Object(Cl.a)(n,e):t-a:t&&!a?-1:!t&&a?1:Object(Cl.a)(n,e)}),n;var n},$sortPostsByDate(){return(n=this.$filterPosts).sort((n,e)=>Object(Cl.a)(n,e)),n;var n},$groupPosts(){return function(n){const e={},t={};for(let a=0,r=n.length;a<r;a++){const{frontmatter:{categories:r,tags:i}}=n[a];"array"===Object(Cl.n)(r)&&r.forEach(t=>{t&&(e[t]||(e[t]=[]),e[t].push(n[a]))}),"array"===Object(Cl.n)(i)&&i.forEach(e=>{e&&(t[e]||(t[e]=[]),t[e].push(n[a]))})}return{categories:e,tags:t}}(this.$sortPosts)},$categoriesAndTags(){return function(n){const e=[],t=[];for(let t in n.categories)e.push({key:t,length:n.categories[t].length});for(let e in n.tags)t.push({key:e,length:n.tags[e].length});return{categories:e,tags:t}}(this.$groupPosts)}}};Ht.component(xl.default),Ht.component(wl.default);function Ll(n){return n.toString().padStart(2,"0")}t(242);Ht.component("PageInfo",()=>t.e(6).then(t.bind(null,333))),Ht.component("WebInfo",()=>Promise.all([t.e(0),t.e(3)]).then(t.bind(null,331))),Ht.component("Badge",()=>Promise.all([t.e(0),t.e(4)]).then(t.bind(null,644))),Ht.component("CodeBlock",()=>Promise.resolve().then(t.bind(null,94))),Ht.component("CodeGroup",()=>Promise.resolve().then(t.bind(null,95)));t(243);var Tl={render:()=>null};var jl=[({Vue:n,options:e,router:t,siteData:a,isServer:r})=>{r||t.afterEach(()=>{var n;n=function(){setTimeout((function(){void 0===window._AdBlockInit&&function(){const n=document.getElementsByClassName("wwads-cn"),e=document.querySelector(".wwads-content");n[0]&&!e&&(n[0].innerHTML="<style>.wwads-horizontal,.wwads-vertical{background-color:#f4f8fa;padding:5px;min-height:120px;margin-top:20px;box-sizing:border-box;border-radius:3px;font-family:sans-serif;display:flex;min-width:150px;position:relative;overflow:hidden;}.wwads-horizontal{flex-wrap:wrap;justify-content:center}.wwads-vertical{flex-direction:column;align-items:center;padding-bottom:32px}.wwads-horizontal a,.wwads-vertical a{text-decoration:none}.wwads-horizontal .wwads-img,.wwads-vertical .wwads-img{margin:5px}.wwads-horizontal .wwads-content,.wwads-vertical .wwads-content{margin:5px}.wwads-horizontal .wwads-content{flex:130px}.wwads-vertical .wwads-content{margin-top:10px}.wwads-horizontal .wwads-text,.wwads-content .wwads-text{font-size:14px;line-height:1.4;color:#0e1011;-webkit-font-smoothing:antialiased}.wwads-horizontal .wwads-poweredby,.wwads-vertical .wwads-poweredby{display:block;font-size:11px;color:#a6b7bf;margin-top:1em}.wwads-vertical .wwads-poweredby{position:absolute;left:10px;bottom:10px}.wwads-horizontal .wwads-poweredby span,.wwads-vertical .wwads-poweredby span{transition:all 0.2s ease-in-out;margin-left:-1em}.wwads-horizontal .wwads-poweredby span:first-child,.wwads-vertical .wwads-poweredby span:first-child{opacity:0}.wwads-horizontal:hover .wwads-poweredby span,.wwads-vertical:hover .wwads-poweredby span{opacity:1;margin-left:0}.wwads-horizontal .wwads-hide,.wwads-vertical .wwads-hide{position:absolute;right:-23px;bottom:-23px;width:46px;height:46px;border-radius:23px;transition:all 0.3s ease-in-out;cursor:pointer;}.wwads-horizontal .wwads-hide:hover,.wwads-vertical .wwads-hide:hover{background:rgb(0 0 0 /0.05)}.wwads-horizontal .wwads-hide svg,.wwads-vertical .wwads-hide svg{position:absolute;left:10px;top:10px;fill:#a6b7bf}.wwads-horizontal .wwads-hide:hover svg,.wwads-vertical .wwads-hide:hover svg{fill:#3E4546}</style><a href='https://wwads.cn/page/whitelist-wwads' class='wwads-img' target='_blank' rel='nofollow'><img src='https://cdn.jsdelivr.net/gh/xugaoyi/image_store@master/blog/wwads.2a3pidhlh4ys.webp' width='130'></a><div class='wwads-content'><a href='https://wwads.cn/page/whitelist-wwads' class='wwads-text' target='_blank' rel='nofollow'>为了本站的长期运营，请将我们的网站加入广告拦截器的白名单，感谢您的支持！<span style='color: #11a8cd'>如何添加白名单?</span></a><a href='https://wwads.cn/page/end-user-privacy' class='wwads-poweredby' title='万维广告 ～ 让广告更优雅，且有用' target='_blank'><span>万维</span><span>广告</span></a></div><a class='wwads-hide' onclick='parentNode.remove()' title='隐藏广告'><svg xmlns='http://www.w3.org/2000/svg' width='6' height='7'><path d='M.879.672L3 2.793 5.121.672a.5.5 0 11.707.707L3.708 3.5l2.12 2.121a.5.5 0 11-.707.707l-2.12-2.12-2.122 2.12a.5.5 0 11-.707-.707l2.121-2.12L.172 1.378A.5.5 0 01.879.672z'></path></svg></a>")}()}),3e3)},"complete"===document.readyState||"interactive"===document.readyState?setTimeout(n,1):document.addEventListener("DOMContentLoaded",n),setTimeout(()=>{const n=document.querySelector(".pageB");if(!n)return;const e=n.querySelector(".wwads-hide");e&&(e.onclick=()=>{n.style.display="none"}),n.style.display="flex"},0)})},({Vue:n,options:e,router:t,siteData:a})=>{a.pages.map(n=>{const{frontmatter:{date:e,author:t}}=n;"string"==typeof e&&"Z"===e.charAt(e.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return`${n.getUTCFullYear()}-${Ll(n.getUTCMonth()+1)}-${Ll(n.getUTCDate())} ${Ll(n.getUTCHours())}:${Ll(n.getUTCMinutes())}:${Ll(n.getUTCSeconds())}`}(e)),t?n.author=t:a.themeConfig.author&&(n.author=a.themeConfig.author)}),n.mixin(El)},{},({Vue:n})=>{n.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},{},({router:n})=>{"undefined"!=typeof window&&(window._hmt=window._hmt||[],function(){var n=document.createElement("script");n.src="https://hm.baidu.com/hm.js?92af11dd09d5616401db6d088dec3a2f";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(n,e)}(),n.afterEach((function(n){_hmt.push(["_trackPageview",n.fullPath])})))},({Vue:n})=>{Tl.name&&n.component("ChartJS",Tl),Tl.name&&n.component("CodeDemo",Tl),Tl.name&&n.component("CodeGroup",Tl),Tl.name&&n.component("CodeGroupItem",Tl),Tl.name&&n.component("CodeTabs",Tl),Promise.all([t.e(0),t.e(317)]).then(t.t.bind(null,329,7)),Tl.name&&n.component("ECharts",Tl),Tl.name&&n.component("FlowChart",Tl),Tl.name&&n.component("Mermaid",Tl),Tl.name&&n.component("Presentation",Tl),Tl.name&&n.component("Tabs",Tl)}],Sl=["PageInfo"];class Al extends class{constructor(){this.store=new Ht({data:{state:{}}})}$get(n){return this.store.state[n]}$set(n,e){Ht.set(this.store.state,n,e)}$emit(...n){this.store.$emit(...n)}$on(...n){this.store.$on(...n)}}{}Object.assign(Al.prototype,{getPageAsyncComponent:os,getLayoutAsyncComponent:ss,getAsyncComponent:ls,getVueComponent:ds});var Pl={install(n){const e=new Al;n.$vuepress=e,n.prototype.$vuepress=e}};function _l(n,e){const t=e.toLowerCase();return n.options.routes.some(n=>n.path.toLowerCase()===t)}var Bl={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(n){const e=this.pageKey||this.$parent.$page.key;return us("pageKey",e),Ht.component(e)||Ht.component(e,os(e)),Ht.component(e)?n(e):n("")}},zl={functional:!0,props:{slotKey:String,required:!0},render:(n,{props:e,slots:t})=>n("div",{class:["content__"+e.slotKey]},t()[e.slotKey])},Il={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},Ol=(t(244),t(245),Object(bl.a)(Il,(function(){var n=this._self._c;return n("span",[n("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[n("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),n("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),n("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),Ml={functional:!0,render(n,{parent:e,children:t}){if(e._isMounted)return t;e.$once("hook:mounted",()=>{e.$forceUpdate()})}};Ht.config.productionTip=!1,Ht.use(Vo),Ht.use(Pl),Ht.mixin(function(n,e,t=Ht){!function(n){n.locales&&Object.keys(n.locales).forEach(e=>{n.locales[e].path=e});Object.freeze(n)}(e),t.$vuepress.$set("siteData",e);const a=new(n(t.$vuepress.$get("siteData"))),r=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(a)),i={};return Object.keys(r).reduce((n,e)=>(e.startsWith("$")&&(n[e]=r[e].get),n),i),{computed:i}}(n=>class{setPage(n){this.__page=n}get $site(){return n}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:n={}}=this.$site;let e,t;for(const a in n)"/"===a?t=n[a]:0===this.$page.path.indexOf(a)&&(e=n[a]);return e||t||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:n}=this.$page.frontmatter;return"string"==typeof n&&n}get $title(){const n=this.$page,{metaTitle:e}=this.$page.frontmatter;if("string"==typeof e)return e;const t=this.$siteTitle,a=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?a?a+" | "+t:t:a||"VuePress"}get $description(){const n=function(n){if(n){const e=n.filter(n=>"description"===n.name)[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(n,e){for(let t=0;t<n.length;t++){const a=n[t];if(a.path.toLowerCase()===e.toLowerCase())return a}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},kl)),Ht.component("Content",Bl),Ht.component("ContentSlotsDistributor",zl),Ht.component("OutboundLink",Ol),Ht.component("ClientOnly",Ml),Ht.component("Layout",ss("Layout")),Ht.component("NotFound",ss("NotFound")),Ht.prototype.$withBase=function(n){const e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.2",hash:"a129005"},async function(n){const e="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:kl.routerBase||kl.base,t=new Vo({base:e,mode:"history",fallback:!1,routes:yl,scrollBehavior:(n,e,t)=>t||(n.hash?!Ht.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})});!function(n){n.beforeEach((e,t,a)=>{if(_l(n,e.path))a();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){const t=e.path.replace(/\/$/,"")+".html";_l(n,t)?a(t):a()}else a();else{const t=e.path+"/",r=e.path+".html";_l(n,r)?a(r):_l(n,t)?a(t):a()}})}(t);const a={};try{await Promise.all(jl.filter(n=>"function"==typeof n).map(e=>e({Vue:Ht,options:a,router:t,siteData:kl,isServer:n})))}catch(n){console.error(n)}return{app:new Ht(Object.assign(a,{router:t,render:n=>n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},Sl.map(e=>n(e)))])})),router:t}}(!1).then(({app:n,router:e})=>{e.onReady(()=>{n.$mount("#app")})})}]);