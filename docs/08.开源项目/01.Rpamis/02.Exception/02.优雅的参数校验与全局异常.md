---
title: 优雅的参数校验与全局异常
date: 2023-01-31 11:30:04
categories: 
  - 开源项目
  - Rpamis
  - Exception
  - Dubbo
  - Spring
tags: 
  - Exception
  - 返回体
  - 优雅校验
  - Validated
  - Valid
  - Advice
  - Dubbo
  - Filter
  - Http
author: 
  name: benym
  link: https://github.com/benym
---

## 背景

数据的正确性校验是研发过程中不可或缺的步骤，开发者需要保证数据在进入系统后的基本正确性。

在通常的开发过程中前端可以帮助校验用户的数据请求，为了保证服务端数据的安全，避免非法请求绕过前端，直接采用脚本等方式向服务端发起请求。服务端同样需要进行数据校验。

根据校验先后的不同可以选择的方法也可以不同，比如在`Controller`前的`@Valid`和`@Validated`校验，这类校验通常用于实体、字段的校验规则，如非空判断、长度判断、正则匹配、el表达式判断等。再者就是复杂业务或网关层面的校验，通常会使用`责任链模式`进行特定实现。当不使用该两种方法时，开发者通常会使用`if else`语法进行校验，但当校验过多且复杂时，成片的`if else`会造成代码臃肿，可复用性差的问题，导致研发效率的低下。

针对这一问题，本文主要描述业界常用的基于`@Valid`和`@Validated`的前置校验，结合全局异常，帮助读者理解高效、优雅的参数校验方式，及通用场景下的全局异常机制。

## JSR303规范及主流实现

JSR(Java Specification Requests)是Java规范的提案，JSR-303[^1]是JavaEE6中的一项子规范，叫做Bean Validation[^2]，该提案于2009年正式面向公众，后续的JSR-349、JSR-380均在此提案上进行增强。该规范只提供了校验的注解，位于`javax.validation.constraints`包下，在官网指定的实现贡献者有3个

::: center
![Contributions](https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/hi-contribution.png)
:::

其中`Hibernate Validator`使用最为广泛。

这里列出一些基本的constraint，在最新的hibernate validator中包括但不限于以下注解，更多实现可直达官网[^3]了解。

Bean Validation中内置的constraint

::: center

![Bean Validation constraint](https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/BeanValidator.png):::

Hibernate Validator附加的constraint

::: center

![Hibernate Validator](https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/hibernate-validator.png)

:::

## 参数校验-快速开始

SpringBoot项目无需引入额外依赖，自带所需依赖，非SpringBoot项目需要引入如下2个依赖，参数校验依赖于get/set方法

```java
<dependency>
    <groupId>javax.validation</groupId>
    <artifactId>validation-api</artifactId>
    <version>2.0.1.Final</version>
</dependency>
<dependency>
    <groupId>org.hibernate.validator</groupId>
    <artifactId>hibernate-validator</artifactId>
    <version>6.1.5.Final</version>
</dependency>
```

### 基本校验

以一个`User`实体为例

```java
public class User {

    @NotNull(message = "用户名不能为空")
    private String userName;

    @NotNull(message = "密码不能为空")
    @Pattern(regexp = "^[a-zA-Z0-9|_]+$", message = "密码必须由字母、数字、下划线组成")
    @Size(min = 6, max = 12, message = "密码长度必须在6-12字符之间")
    private String passWord;

    @Range(min = 1, max = 150, message = "年龄必须在1-150区间")
    private Integer age;
    
    @NotEmpty(message = "用户的兴趣不能为空")
    private List<String> interest;
    
    // 省略get/set

}
```

假设要求传入的Json字段(@RequestBody)中，用户名、密码、年龄都有特定的规则

对应的`Controller`应该为

```java
@RestController
@RequestMapping("/test")
public class TestController {

    @PostMapping("/validate")
    public String test(@Valid @RequestBody User user) {
        System.out.println(1);
        return "success";
    }

    @PostMapping("/validate2")
    public String test2(@Validated @RequestBody User user) {
        System.out.println(1);
        return "success";
    }
}
```

使用`@Valid`或`@Validated`均可

此时当Postman参数传递不符合预期时，将无法进入Controller中(前置拦截，体现在Debug时，进不到test方法体内System.out行)，同时接口返回400，带Spring封装的基础返回体

::: center

![](https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/validate-return-spring.png)

:::

控制台抛出对应异常

::: center

![](https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/console-validate.png)

:::



结合上图结果和代码我们可以观察到，Spring自带的基础返回体没有将我们想要的message显示出来，仅仅是在控制台有日志打印，只有显示指定@NotNull、@NotBlank、@NotEmpty等非空注解时，参数才为必传。在本例中age字段虽然有@Range，但他不是必传的选项。只有当入参json包含age字段时，@Range才会生效。

由于参数校验结果的特点以及各公司对返回体的定制化需求，参数校验通常与统一返回体、全局异常处理结合。

::: tip

最新的Spring6、SpringBoot3中，已提供了`org.springframework.http.ProblemDetail`来实现Http错误的返回信息和问题细节，避免自定义新的错误返回格式，可参考文章4[^4]和文章5[^5]。

:::

### 嵌套校验

嵌套校验支持用户将`@Valid`和`@Validated`混合使用，可用于更复杂的校验

还是以`User`为例，新增一个`friends`字段，代表用户的朋友们，同时加上`@Valid`注解代表如果`friends`入参有传，则需要对`Friend`类的内部字段进行校验，如果没有传递则无需校验。

```java
public class User {

    @NotNull(message = "用户名不能为空")
    private String userName;

    @NotNull(message = "密码不能为空")
    @Pattern(regexp = "^[a-zA-Z0-9|_]+$", message = "密码必须由字母、数字、下划线组成")
    @Size(min = 6, max = 12, message = "密码长度必须在6-12字符之间")
    private String passWord;

    @Range(min = 1, max = 150, message = "年龄必须在1-150区间")
    private Integer age;

    @Valid
    private List<Friend> friends;
    
    // 省略get/set
}
```

`Friend`类

```java
public class Friend {

    @NotNull(message = "朋友名称不能为空")
    private String userName;

    @Range(min = 1, max = 150, message = "年龄必须在1-150区间")
    private Integer age;
    
    // 省略get/set
}
```

假设此时参数传递为

```json
{
    "userName" : "11",
    "passWord" : "test123_2",
    "age" : 11,
    "friends" : [
        {
            "age" : "22"
        },
        {
            "userName" : "33"
        }
    ]
}
```

表示该用户有2个`friend`，其中一个只写了名字，其中一个只写了年龄，由代码可知年龄是非必填字段，对应的控制台日志为

::: center

![](https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/validandvalidated.png)

:::

符合校验预期，当此时`friend`字段没有传递时，则不进行校验

###分组校验

分组校验是`Spring Validation`的特性，校验时在`Controller层`对实体的书写必须使用`@Validated`，分组校验提高了实体校验注解的可复用能力，只需要指定校验分组即可让同一实体适配多种场景。

```
@RestController
@RequestMapping("/test")
public class TestController {

    @PostMapping("/validate2")
    public String test2(@Validated @RequestBody User user) {
        System.out.println(1);
        return "success";
    }
}
```

首先需要定义常见的CRUD分组场景，取任意名字均可，接口无需实现

```java
public class ValidatedAction {
    
    public interface Insert {
    }

    public interface Update {
    }

    public interface Search {
    }

    public interface Delete {
    }
}
```

为刚才的`User`内的字段增加分组，如在新增时需要填写用户名、密码，在删除时需要填写id和密码

```java
public class User {

    @NotNull(message = "id不能为空", groups = {ValidatedAction.Delete.class})
    private String id;

    @NotNull(message = "用户名不能为空", groups = {ValidatedAction.Insert.class})
    private String userName;

    @NotNull(message = "密码不能为空", groups = {ValidatedAction.Insert.class, ValidatedAction.Delete.class})
    @Pattern(regexp = "^[a-zA-Z0-9|_]+$", message = "密码必须由字母、数字、下划线组成")
    @Size(min = 6, max = 12, message = "密码长度必须在6-12字符之间")
    private String passWord;

    @Range(min = 1, max = 150, message = "年龄必须在1-150区间")
    private Integer age;

    @Valid
    private List<Friend> friends;
    
    // 省略get/set
}
```

修改`Controller`接口，指定校验分组，一个为新增分组校验，一个为删除分组校验，同时需要加上`javax`中自带的`Default`分组，避免实体中没有写group的注解失效

```java
@RestController
@RequestMapping("/test")
public class TestController {

    @PostMapping("/validate")
    public String test(@Validated({ValidatedAction.Insert.class, Default.class}) @RequestBody User user) {
        System.out.println(1);
        return "success";
    }

    @PostMapping("/validateDelete")
    public String test2(@Validated({ValidatedAction.Delete.class, Default.class}) @RequestBody User user) {
        System.out.println(1);
        return "success";
    }
}
```

新增时Postman传参为

::: center

![](https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/validated-insert.png)

:::

由于新增时，非空参数仅有用户名和密码，所以正常返回，此时分组为Delete的id并没有参与非空校验

删除时Postman传参为

::: center

![](https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/validated-delete.png)

:::

由于删除时，非空参数包含id，此时传参中没有id则会在控制台输出对应提示

::: center

![](https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/validated-delete-console.png)

:::

### 自定义校验

`hibernate`提供的校验注解在简单字段的场景已经基本够用了，如果提供的校验注解无法满足要求，这个时候可以考虑自定义注解，将校验与Controller完全隔离。

本文主要考虑4种较为通用的场景下自定义注解的实现方法

- 场景1：字段为`基础类型`，约束传递的字段只能在枚举code的约束范围内，虽然定义字段为枚举字段可以简单实现传输枚举对象名完成枚举约束，但通常我们不将字段本身定义为枚举直接暴露给前端。期望能够通过直接引用枚举类，达成约束。
- 场景2：字段为`String`，约束传递的字段只能是一组特定的String字符串
- 场景3：字段为`Integer`，约束传递的字段只能是一组特定的Integer值
- 场景4：字段为`List<String>`，约束传递的字段只能是一组特定的String字符串

自定义的过程比较简单

第一步：新增一个你的自定义注解，这里为`SpecifiesValueValidator`

自定义注解的写法可完全照搬`@NotNull`等注解，稍微改动下`@Constraint`的`validatedBy`属性为当前自定义注解类，同时加上可重复性校验注解(非必须)`@Repeatable(SpecifiesValueValidator.List.class)`，用于支持多个自定义注解使用在同一字段。

```java
@Target({METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER})
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = {SpecifiesValueValidatorImpl.class})
@Repeatable(SpecifiesValueValidator.List.class)
public @interface SpecifiesValueValidator {
    /**
     * 默认校验消息
     *
     * @return String
     */
    String message() default "入参必须为指定值";

    /**
     * 分组校验
     *
     * @return Class<?>[]
     */
    Class<?>[] groups() default {};

    /**
     * 负载
     *
     * @return Class<? extends Payload>[]
     */
    Class<? extends Payload>[] payload() default {};

    /**
     * 指定特定String值
     *
     * @return String[]
     */
    String[] strGroup() default {};

    /**
     * 指定特定int值
     *
     * @return int[]
     */
    int[] intGroup() default {};

    /**
     * 指定枚举类型
     *
     * @return Class<?>
     */
    Class<?> enumClass() default Class.class;

    /**
     * 可重复校验
     */
    @Target({METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER})
    @Retention(RetentionPolicy.RUNTIME)
    @Documented
    @interface List {
        SpecifiesValueValidator[] value();
    }
}
```

第二步：实现`javax.validation.ConstraintValidator`接口

泛型第一个参数为自定义注解，第二个参数为被加上注解的字段值

这里在请求初始化时将规定的合法值加载进内存，校验的过程逻辑非常简单，符合返回true，反之false即可

```java
public class SpecifiesValueValidatorImpl implements ConstraintValidator<SpecifiesValueValidator, Object> {

    private Class<?> enumClass;

    private HashSet<String> strSet;

    private Set<Integer> intSet;

    @Override
    public void initialize(SpecifiesValueValidator constraintAnnotation) {
        String[] strGroup = constraintAnnotation.strGroup();
        strSet = new HashSet<>(Arrays.asList(strGroup));
        int[] intGroup = constraintAnnotation.intGroup();
        intSet = Arrays.stream(intGroup).boxed().collect(Collectors.toSet());
        enumClass = constraintAnnotation.enumClass();
    }

    /**
     * 此时value为被注解的字段类型
     *
     * @param value   object to validate
     * @param context context in which the constraint is evaluated
     * @return boolean
     */
    @Override
    public boolean isValid(Object value, ConstraintValidatorContext context) {
        try {
            if (null == value) {
                return true;
            }
            if (enumClass.isEnum()) {
                return validEnum(value, enumClass);
            }
            if (value instanceof String && strSet.contains(value)) {
                return true;
            }
            if (value instanceof Integer && intSet.contains(value)) {
                return true;
            }
            if (value instanceof List) {
                return validList(value, strSet);
            }
        } catch (NoSuchMethodException e) {
            throw ExceptionFactory.sysException(enumClass + "枚举类没有getCode方法", e);
        } catch (Exception e) {
            throw ExceptionFactory.sysException("特定值校验器异常", e);
        }
        return false;
    }

    public static boolean validEnum(Object value, Class<?> enumClass) throws InvocationTargetException, IllegalAccessException, NoSuchMethodException {
        // 获取传入的枚举class的所有定义的枚举，反射获取code判断是否和入参相同
        Object[] enumConstants = enumClass.getEnumConstants();
        for (Object enumConstant : enumConstants) {
            Method method = enumClass.getDeclaredMethod("getCode");
            Object invokeResult = method.invoke(enumConstant);
            if (invokeResult.equals(value)) {
                return true;
            }
        }
        return false;
    }

    public static boolean validList(Object value, Set<String> strSet) {
        for (Object v : (List<?>) value) {
            String cast = (String) v;
            if (!strSet.contains(cast)) {
                return false;
            }
        }
        return true;
    }
}
```

以`UserSpValid`类为例

```java
public class UserSpValid {


    @NotNull(message = "手机品牌不能为空")
    @SpecifiesValueValidator(message = "手机品牌需符合枚举", enumClass = PhoneBrandEnums.class)
    private String phoneBrand;

    @SpecifiesValueValidator(message = "用户状态需要符合规则", intGroup = {1, 2, 3})
    private Integer status;

    @SpecifiesValueValidator(message = "用户的学校需要符合规则", strGroup = {"11", "22", "33"})
    private String shchool;

    @SpecifiesValueValidator(message = "传输list需要符合规则", strGroup = {"456","789"})
    private List<String> testList;
    
    // 省略get/set
}
```

其中枚举`PhoneBrandEnums`为

```java
public enum PhoneBrandEnums implements StatusCode {

    /**
     * 苹果
     */
    IPHONE("0", "苹果手机"),
    /**
     * 华为
     */
    HUAWEI("1", "华为手机"),
    /**
     * 小米
     */
    XIAOMI("2", "小米手机");

    private String code;

    private String message;

    PhoneBrandEnums(String code, String message) {
        this.code = code;
        this.message = message;
    }

    @Override
    public String getCode() {
        return code;
    }

    @Override
    public String getMessage() {
        return message;
    }
}
```

为了方便校验枚举类型，通常需要实现接口(这里为`StatusCode`)，因为枚举校验实现中需要`getDeclaredMethod("getCode")`之后进行`inovke`

对应的`Controller`写法和之前没有变化

```java
@PostMapping("/validateSp")
public String test3(@Validated @RequestBody UserSpValid user) {
    System.out.println(1);
    return "success";
}
```

当postman传输如下参数时，校验器将对参数进行校验，比如此时的`phoneBrand`字段必须是枚举中的值

::: center

![](https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/valid-sp.png)

:::

显然以上参数都是无法通过校验的，对应的控制台打印为

::: center

![](https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/valid-sp-console.png)

:::

### Spring Validation与Dubbo Validation

`Spring Validation`主要提供了编程式的校验验证，以及`@Validated`注解，支持了`@Valid`混用等多种场景，由于本文篇幅原因使用方法及原理这里不做过多介绍，mvc处理最终会调用`hibernate validator`的校验，Spring只是在处理过程中包装了一层，可以通过文章6进行了解[^6]。

`Dubbo Validation`主要提供RPC时对参数的校验，本质上也依赖于`javax`与`hibernate`的包，在客户端和服务端均可单独开启校验，对于需要开启校验的接口加上`validation="true"`即可，dubbo2.1.x以上版本均支持，最佳实践可参考[官方文档](https://cn.dubbo.apache.org/zh/docs/advanced/parameter-validation/)

在客户端验证参数

```java
<dubbo:reference id="validationService" interface="org.apache.dubbo.examples.validation.api.ValidationService" validation="true" />
```

在服务端验证参数

```java
<dubbo:service interface="org.apache.dubbo.examples.validation.api.ValidationService" ref="validationService" validation="true" />
```

### 实践对比

简单结合自定义校验和基本校验，观察两者代码量上的区别

结合后的`UserAll`

```java
public class UserAll {

    @NotNull(message = "用户名不能为空", groups = {ValidatedAction.Insert.class})
    private String userName;

    @Range(min = 1, max = 150, message = "年龄必须在1-150区间")
    private Integer age;

    @NotEmpty(message = "用户的兴趣不能为空")
    private List<String> interest;

    @Valid
    private List<Friend> friends;

    @NotNull(message = "手机品牌不能为空")
    @SpecifiesValueValidator(message = "手机品牌需符合枚举", enumClass = PhoneBrandEnums.class)
    private String phoneBrand;
}
```

对应的`Controller`代码只需要关注实体转化和业务

```java
@PostMapping("/validateAll")
public String test4(@Validated @RequestBody UserAll user) {
    System.out.println(1);
    return "success";
}
```

未使用校验的`UserAllNoValid`

```java
public class UserAllNoValid {
    
    private String userName;
    
    private Integer age;
    
    private List<String> interest;
    
    private List<Friend> friends;
    
    private String phoneBrand;
}
```

对应的`Controller`代码

```java
@PostMapping("/validateAllNoValid")
public String test5(@RequestBody UserAllNoValid user) {
    if (StringUtils.isEmpty(user.getUserName())) {
        return "用户名不能为空";
    }
    if (user.getAge() < 1 || user.getAge() > 150) {
        return "年龄必须在1-150区间";
    }
    if (CollectionUtils.isEmpty(user.getInterest())) {
        return "用户的兴趣不能为空";
    }
    List<Friend> friends = user.getFriends();
    for (int i = 0; i < friends.size(); i++) {
        Friend friend = friends.get(i);
        if (!CollectionUtils.isEmpty(friends)) {
            String userName = friend.getUserName();
            if (StringUtils.isEmpty(userName)) {
                return "朋友的用户名不能为空";
            }
            if (!StringUtils.isEmpty(friend.getAge())) {
                if (friend.getAge() < 1 || friend.getAge() > 150) {
                    return "朋友的年龄必须在1-150区间";
                }
            }
        }
    }
    String phoneBrand = user.getPhoneBrand();
    boolean inEnums = false;
    for (PhoneBrandEnums phoneBrandEnums : PhoneBrandEnums.values()) {
        if (phoneBrandEnums.getCode().equals(user.getPhoneBrand())) {
            inEnums = true;
            break;
        }
    }
    if (!inEnums) {
        return "手机品牌需符合枚举";
    }
    return "success";
}
```

显然，没有使用参数校验开发者会写大量的校验代码，场景越复杂，需要考虑非空判断的地方也就越多，很容易写出高复杂度的代码，增加后期维护的难度，难以通过代码检查工具的扫描。而使用参数校验能够极大地减轻开发者的校验压力，校验与实体绑定，`Controller`逻辑更加简洁、清晰。

## 全局异常-快速开始

上文中JSR303校验方法的引入有一个缺点，即错误信息仅体现在控制台日志中，无法反馈给前端。我们希望将错误信息包装在统一的返回体中，此时便需要定义全局异常。`全局异常+自定义异常+参数校验+统一返回体`组合是互联网中Java开发规范、使用代码扫描工具后的**必然落地方式**。

全局异常的好处在于：

1. 天生适配异常情况下统一返回体的需求，让优雅的参数校验更加易用
2. 结合Http Code释放前、后端代码压力，减轻前后端对接业务code沟通成本。促进前端请求/处理数据代码和后端返回代码模板化。无论代码层级多深，轻松实现统一返回，彻底告别系统内部除RPC接口，仍然需要包装统一返回体，手动一层一层返回的情况，减少系统内非必要判空和传输体体积
3. 精简代码，降低大量try catch
4. 全局兜底日志，结合唯一请求等信息，不再出现忘记打印日志，难以排查问题的情况
5. 配合自定义异常，做到抛特定异常=打特定日志=返回对应Http Code+统一返回体，全面覆盖通用场景

### 异常捕获

#### Web Controller

#### Dubbo RPC

### 统一返回体

### 异常使用

### 实践对比





### 参考文章

[^1]: https://jcp.org/en/jsr/detail?id=303
[^2]: https://beanvalidation.org/
[^3]: https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#validator-gettingstarted
[^4]: https://www.toutiao.com/article/7158309490746589727/?upstream_biz=toutiao_pc&_share_channel=wechat&source=m_redirect&wid=1667972352288
[^5]: https://docs.spring.io/spring-framework/docs/6.0.0-RC2/javadoc-api/org/springframework/http/ProblemDetail.html
[^6]: https://segmentfault.com/a/1190000023471742
[^7]: https://cn.dubbo.apache.org/zh/docs/advanced/parameter-validation/

