---
title: 优雅的参数校验与全局异常
date: 2023-01-31 11:30:04
categories: 
  - 开源项目
  - Rpamis
  - Exception
  - Dubbo
  - Spring
tags: 
  - Exception
  - 返回体
  - 优雅校验
  - Validated
  - Valid
  - Advice
  - Dubbo
  - Filter
  - Http
author: 
  name: benym
  link: https://github.com/benym
---

## 背景

数据的正确性校验是研发过程中不可或缺的步骤，开发者需要保证数据在进入系统后的基本正确性。

在通常的开发过程中前端可以帮助校验用户的数据请求，为了保证服务端数据的安全，避免非法请求绕过前端，直接采用脚本等方式向服务端发起请求。服务端同样需要进行数据校验。

根据校验先后的不同可以选择的方法也可以不同，比如在`Controller`前的`@Valid`和`@Validated`校验，这类校验通常用于实体、字段的校验规则，如非空判断、长度判断、正则匹配、el表达式判断等。再者就是复杂业务或网关层面的校验，通常会使用`责任链模式`进行特定实现。当不使用该两种方法时，开发者通常会使用`if else`语法进行校验，但当校验过多且复杂时，成片的`if else`会造成代码臃肿，可复用性差的问题，导致研发效率的低下。

针对这一问题，本文主要描述业界常用的基于`@Valid`和`@Validated`的前置校验，结合全局异常，帮助读者理解高效、优雅的参数校验方式，及通用场景下的全局异常机制。

## JSR303规范及主流实现

JSR(Java Specification Requests)是Java规范的提案，JSR-303[^1]是JavaEE6中的一项子规范，叫做Bean Validation[^2]，该提案于2009年正式面向公众，后续的JSR-349、JSR-380均在此提案上进行增强。该规范只提供了校验的注解，位于`javax.validation.constraints`包下，在官网指定的实现贡献者有3个

::: center
![Contributions](https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/hi-contribution.png)
:::

其中`Hibernate Validator`使用最为广泛。

这里列出一些基本的constraint，在最新的hibernate validator中包括但不限于以下注解，更多实现可直达官网[^3]了解。

Bean Validation中内置的constraint

::: center

![Bean Validation constraint](https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/BeanValidator.png):::

Hibernate Validator附加的constraint

::: center

![Hibernate Validator](https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/hibernate-validator.png)

:::

## 参数校验-快速开始

SpringBoot项目无需引入额外依赖，自带所需依赖，非SpringBoot项目需要引入如下2个依赖，参数校验依赖于get/set方法

```java
<dependency>
    <groupId>javax.validation</groupId>
    <artifactId>validation-api</artifactId>
    <version>2.0.1.Final</version>
</dependency>
<dependency>
    <groupId>org.hibernate.validator</groupId>
    <artifactId>hibernate-validator</artifactId>
    <version>6.1.5.Final</version>
</dependency>
```

### 基本校验

以一个`User`实体为例

```java
public class User {

    @NotNull(message = "用户名不能为空")
    private String userName;

    @NotNull(message = "密码不能为空")
    @Pattern(regexp = "^[a-zA-Z0-9|_]+$", message = "密码必须由字母、数字、下划线组成")
    @Size(min = 6, max = 12, message = "密码长度必须在6-12字符之间")
    private String passWord;

    @Range(min = 1, max = 150, message = "年龄必须在1-150区间")
    private Integer age;
    
    @NotEmpty(message = "用户的兴趣不能为空")
    private List<String> interest;
    
    // 省略get/set

}
```

假设要求传入的Json字段(@RequestBody)中，用户名、密码、年龄都有特定的规则

对应的`Controller`应该为

```java
@RestController
@RequestMapping("/test")
public class TestController {

    @PostMapping("/validate")
    public String test(@Valid @RequestBody User user) {
        System.out.println(1);
        return "success";
    }

    @PostMapping("/validate2")
    public String test2(@Validated @RequestBody User user) {
        System.out.println(1);
        return "success";
    }
}
```

使用`@Valid`或`@Validated`均可

此时当Postman参数传递不符合预期时，将无法进入Controller中(前置拦截，体现在Debug时，进不到test方法体内System.out行)，同时接口返回400，带Spring封装的基础返回体

::: center

![](https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/validate-return-spring.png)

:::

控制台抛出对应异常

::: center

![](https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/console-validate.png)

:::



结合上图结果和代码我们可以观察到，Spring自带的基础返回体没有将我们想要的message显示出来，仅仅是在控制台有日志打印，只有显示指定@NotNull、@NotBlank、@NotEmpty等非空注解时，参数才为必传。在本例中age字段虽然有@Range，但他不是必传的选项。只有当入参json包含age字段时，@Range才会生效。

由于参数校验结果的特点以及各公司对返回体的定制化需求，参数校验通常与统一返回体、全局异常处理结合。

::: tip

最新的Spring6、SpringBoot3中，已提供了`org.springframework.http.ProblemDetail`来实现Http错误的返回信息和问题细节，避免自定义新的错误返回格式，可参考文章4[^4]和文章5[^5]。

:::

### 嵌套校验

嵌套校验支持用户将`@Valid`和`@Validated`混合使用，可用于更复杂的校验

还是以`User`为例，新增一个`friends`字段，代表用户的朋友们，同时加上`@Valid`注解代表如果`friends`入参有传，则需要对`Friend`类的内部字段进行校验，如果没有传递则无需校验。

```java
public class User {

    @NotNull(message = "用户名不能为空")
    private String userName;

    @NotNull(message = "密码不能为空")
    @Pattern(regexp = "^[a-zA-Z0-9|_]+$", message = "密码必须由字母、数字、下划线组成")
    @Size(min = 6, max = 12, message = "密码长度必须在6-12字符之间")
    private String passWord;

    @Range(min = 1, max = 150, message = "年龄必须在1-150区间")
    private Integer age;

    @Valid
    private List<Friend> friends;
    
    // 省略get/set
}
```

`Friend`类

```java
public class Friend {

    @NotNull(message = "朋友名称不能为空")
    private String userName;

    @Range(min = 1, max = 150, message = "年龄必须在1-150区间")
    private Integer age;
    
    // 省略get/set
}
```

假设此时参数传递为

```json
{
    "userName" : "11",
    "passWord" : "test123_2",
    "age" : 11,
    "friends" : [
        {
            "age" : "22"
        },
        {
            "userName" : "33"
        }
    ]
}
```

表示该用户有2个`friend`，其中一个只写了名字，其中一个只写了年龄，由代码可知年龄是非必填字段，对应的控制台日志为

::: center

![](https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/validandvalidated.png)

:::

符合校验预期，当此时`friend`字段没有传递时，则不进行校验

###分组校验

分组校验是`Spring Validation`的特性，校验时在`Controller层`对实体的书写必须使用`@Validated`，分组校验提高了实体校验注解的可复用能力，只需要指定校验分组即可让同一实体适配多种场景。

```
@RestController
@RequestMapping("/test")
public class TestController {

    @PostMapping("/validate2")
    public String test2(@Validated @RequestBody User user) {
        System.out.println(1);
        return "success";
    }
}
```

首先需要定义常见的CRUD分组场景，取任意名字均可，接口无需实现

```java
public class ValidatedAction {
    
    public interface Insert {
    }

    public interface Update {
    }

    public interface Search {
    }

    public interface Delete {
    }
}
```

为刚才的`User`内的字段增加分组，如在新增时需要填写用户名、密码，在删除时需要填写id和密码

```java
public class User {

    @NotNull(message = "id不能为空", groups = {ValidatedAction.Delete.class})
    private String id;

    @NotNull(message = "用户名不能为空", groups = {ValidatedAction.Insert.class})
    private String userName;

    @NotNull(message = "密码不能为空", groups = {ValidatedAction.Insert.class, ValidatedAction.Delete.class})
    @Pattern(regexp = "^[a-zA-Z0-9|_]+$", message = "密码必须由字母、数字、下划线组成")
    @Size(min = 6, max = 12, message = "密码长度必须在6-12字符之间")
    private String passWord;

    @Range(min = 1, max = 150, message = "年龄必须在1-150区间")
    private Integer age;

    @Valid
    private List<Friend> friends;
    
    // 省略get/set
}
```

修改`Controller`接口，指定校验分组，一个为新增分组校验，一个为删除分组校验，同时需要加上`javax`中自带的`Default`分组，避免实体中没有写group的注解失效

```java
@RestController
@RequestMapping("/test")
public class TestController {

    @PostMapping("/validate")
    public String test(@Validated({ValidatedAction.Insert.class, Default.class}) @RequestBody User user) {
        System.out.println(1);
        return "success";
    }

    @PostMapping("/validateDelete")
    public String test2(@Validated({ValidatedAction.Delete.class, Default.class}) @RequestBody User user) {
        System.out.println(1);
        return "success";
    }
}
```

新增时Postman传参为

::: center

![](https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/validated-insert.png)

:::

由于新增时，非空参数仅有用户名和密码，所以正常返回，此时分组为Delete的id并没有参与非空校验

删除时Postman传参为

::: center

![](https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/validated-delete.png)

:::

由于删除时，非空参数包含id，此时传参中没有id则会在控制台输出对应提示

::: center

![](https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/validated-delete-console.png)

:::

### 自定义校验

### Spring Validation与Dubbo Validation

### 实践对比

## 全局异常-快速开始

### 异常捕获

#### Web Controller

#### Dubbo RPC

### 统一返回体

### 异常使用

### 实践对比





### 参考文章

[^1]: https://jcp.org/en/jsr/detail?id=303
[^2]: https://beanvalidation.org/
[^3]: https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#validator-gettingstarted
[^4]: https://www.toutiao.com/article/7158309490746589727/?upstream_biz=toutiao_pc&_share_channel=wechat&source=m_redirect&wid=1667972352288
[^5]: https://docs.spring.io/spring-framework/docs/6.0.0-RC2/javadoc-api/org/springframework/http/ProblemDetail.html
[^]: 