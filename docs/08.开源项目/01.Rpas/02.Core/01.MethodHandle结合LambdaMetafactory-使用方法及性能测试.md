---
title: MethodHandle结合LambdaMetafactory-使用方法及性能测试
date: 2022-12-27 14:23:30
categories: 
  - 开源项目
  - Rpas
tags: 
  - MethodHandles
  - LambdaMetafactory
  - 压测
  - 反射
author: 
  name: benym
  link: https://github.com/benym
permalink: /pages/b127c7/
---

## 背景
在进行实例的动态推断和构建时，我们会经常使用到反射这一技巧，然而在某些场景中反射的效率显得有些力不从心。从JDK7开始，MethodHandle被推出，用于解决反射的效率问题。在JDK8，MethodHandle又与Lambda进行深度结合，成为Lambda的最底层调用方式。在JDK9，MethodHandle又被进一步增强。
在开源项目中，Mybatis Mapper的动态代理实现则运用了MethodHandle。

## MethodHandle是什么
MethodHandle直译为方法句柄，调用时采用invokedynamic，直接调用native方法，引用JDK中的说明
::: tip
A method handle is a typed, directly executable reference to an underlying method, constructor, field, or similar low-level operation, with optional transformations of arguments or return values.
:::
方法句柄是一个有类型的，可以直接执行的指向底层方法、构造器、field等的引用，可以简单理解为函数指针，它是一种更加底层的查找、调整和调用方法的机制。
一个简单的使用方法为
step1: 创建mh lookup、根据访问权限任选其一即可
```java
//仅访问public方法
MethodHandles.Lookup publicLookup = MethodHandles.publicLookup();
//访问public、private、protected方法
MethodHandles.Lookup allLookup = MethodHandles.lookup();
```
step2: 创建MethodType，它用来描述被访问的方法的参数类型、返回值类型，JVM强制要求声明的Method Type与实际调用方法的参数类型必须匹配
```java
MethodType methodType = MethodType.methodType(void.class, String.class); // 即入参为String、返回为void类型
```
step3: 通过mh lookup和MethodType获取对应方法MethodHandle并执行，下例为通过Test.class字节码，找到类Test中以String为入参，void为返回值的构造方法、并进行invoke赋值，返回赋值后的Test实体类
```java
MethodHandle methodHandle = publicLookup.findConstructor(Test.class, methodType);
Object invoke = methodHandle.invoke("赋值Test消息");
```
其中step2为可选，根据step3使用方法的不同入参不同，step3还可以为：通过MethodHandle访问普通方法、访问静态方法、访问构造函数、访问私有方法、访问公有成员等。
最终执行，按照对参数数目、参数类型的要求限制不同，分为三类`invokeWithArguments()`,`invoke()`,`invokeExact()`
- invokeWithArguments要求接收变长参数，允许参数拆装箱类型转换
- invoke要求接收固定的参数列表，允许参拆装箱，类型转换
- invokeExact要求最严格，参数类型不匹配会报错
这里不再对MethodHandle各个用例的使用进行展开。

## MethodHandle性能测试

参考stackoverflow[^1]和外网论坛[^2]对MethodHandle的测试结果，大多数情况下，mh的执行效率接近原生，但随着JDK对反射的优化，反射的效率也没有想象中的特别慢。

在上述引文的第2篇，**非静态化的mh甚至比反射效率更低**，这迫使开发者采用其他方法增强mh，该文章的结论表示，想要做到具有通用性、且高效的Methodhandle需要结合LambdaMetafactory；如果不会使用LambdaMetafactory、在字段不多的情况下选择static化的mh同样是选择，而采用java编译器去动态生成代码的方式，虽然效率上达到原生，但写的很不方便。


### 参考文章

[^1]: <https://stackoverflow.com/questions/19557829/faster-alternatives-to-javas-reflection>
[^2]: <https://www.optaplanner.org/blog/2018/01/09/JavaReflectionButMuchFaster.html>