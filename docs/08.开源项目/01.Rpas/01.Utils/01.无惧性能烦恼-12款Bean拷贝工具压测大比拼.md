---
title: 无惧性能烦恼-12款Bean拷贝工具压测大比拼
date: 2022-11-17 23:06:41
categories: 
  - 开源项目
  - Rpas
tags: 
  - 工具类
  - BeanUtil
  - 压测
  - JMH
permalink: /pages/3147fe/
author: 
  name: benym
  link: https://github.com/benym
---

## 背景

在开发过程中，我们通常会用到DO、DTO、VO、PO等对象，一般来说这些对象之间的字段具有一定的相似性。在进行对象转换时，除了手动get/set之外，开发者大概率会使用到类似BeanUtils等对象拷贝工具类。由于许多拷贝工具类性能低下，开发者经常在工具类没有进行选型的情况下引入项目，造成了开发社区或公司对这类工具类使用时有了更多的性能担忧。在前期的调研当中，也有类似于本文的比较，大多数使用循环/StopWatch/计算执行时间等形式衡量，少数文章采用了压测的方法。这类评价方式，能反应出一定的性能问题，但通常实验做的不够严谨准确。

本文将对比市面上10款常见拷贝工具+1款基本封装的个人工具+1原生get/set方法，采用JMH进行公平性压测比较。以此让我们对工具类有一个清晰的对比，选择出合适的工具类。

实验代码 [https://github.com/benym/benchmark-test](https://github.com/benym/benchmark-test)

## 对比方法

 - `get/set`: 原生get/set
 - `RpasBeanUtils`: 基于Cglib BeanCopier+ConcurrentReferenceHashMap封装、基于ASM字节码拷贝原理
 - `MapStruct`: 编译器生成get/set
 - `BeanCopier`: 原生Cglib BeanCopier、基于ASM字节码拷贝原理
 - `JackSon`: Spring官方JackSon序列化工具ObjectMapper
 - `FastJson`: Alibaba Json序列化工具
 - `Hutool BeanUtil`: Hutool提供的BeanUtil工具
 - `Hutool CglibUtil`: Hutool提供的Cglib工具、基于Cglib BeanCopier、ASM字节码拷贝
 - `Spring BeanUtils`: Spring官方提供的BeanUtils、基于反射
 - `Apache BeanUtils`: 基于反射
 - `Orkia`: 基于javassist类库生成Bean映射的字节码
 - `Dozer`: 基于反射、定制化属性映射、XML映射

## 实验设置

本次实验只针对各工具类最核心接口，为了进行公平性比较，测试时将对需要动态根据source、target创建拷贝对象的工具类(RpasBeanUtils、MapStruct、BeanCopier、Jackson、Hutool BeanUtil、Hutool CglibUtil、Orkia、Dozer)进行实例缓存、同时对源数据进行缓存，尽可能展示核心拷贝接口的性能。实际上在日常开发过程中，开发者对于经常使用的工具类也会选择用static final修饰，或采用诸如Map等进行实例缓存。或许是碍于需要每个给对比工具类增加缓存操作的工作量，**在调研的文章中很少有考虑对实例进行缓存的操作**，造成比如BeanCopier实验效果和MapStruct差异过大等问题。

在JMH中我们可以通过`@State(Scope.Benchmark)`+`@Setup(Level.Trial)`注解轻松实现在基准测试开始前的缓存初始化

### 基准参数设置
实验环境

::: tip
实验过程中应确保CPU拉满切避免发生降频现象导致实验结果不准确
:::

 - `jmhVersion` : `1.29`
 - `IntelliJ IDEA 2021.2.2`
 - `jdkVersion` : `1.8.0_351`
 - `CPU` : `Intel(R) Core(TM) i5-10600KF CPU @ 4.10GHz`
 - `Fork` : `1`, 对于每个Benchmark Fork出一个线程，避免实验数据倾斜
 - `BenchmarkModel` : `Mode.Throughput`, 采用吞吐量作为衡量指标
 - `Warmup` : `3`, JIT预热3次之后进入正式测试
 - `Measurement` : `iterations=10、time=5`, 每个Benchmark迭代10次，每次迭代5秒
 - `OutputTimeUnit` : `TimeUnit.MILLISECONDS`, 吞吐量时间单位ops/ms
 - `Threads` : `10`, 生成10个线程进行发压

### 实验对象

本次实验有2组对象
 - 简单类型对象DataBaseDO、DataBaseVO，简单类型仅有5个字段；
 - 复杂类型对象DbDO、DbVo、MockOne、MockTwo，复杂类型对象中包含108个字段，且字段中存在MockOne、MockTwo对象，在MockOne中包含其自身的嵌套子集`List<MockOne>`

## 实验结果

结果中Score表示测试的吞吐量，Error表示测试结果的平均差

 1. 程序运行结果
```java
简单对象
        
Benchmark                                 Mode  Cnt       Score     Error   Units
BenchmarkTestSimple.testApacheBeanUtils  thrpt   10    1014.681 ±   5.442  ops/ms
BenchmarkTestSimple.testBeanCopier       thrpt   10  341581.539 ± 668.458  ops/ms
BenchmarkTestSimple.testDozerMapping     thrpt   10    1444.746 ±   6.486  ops/ms
BenchmarkTestSimple.testFastJson         thrpt   10    9816.492 ±  64.882  ops/ms
BenchmarkTestSimple.testGetSet           thrpt   10  341429.391 ± 407.244  ops/ms
BenchmarkTestSimple.testHutoolBeanUtil   thrpt   10    1201.178 ±  14.053  ops/ms
BenchmarkTestSimple.testHutoolCglibUtil  thrpt   10  340730.983 ± 757.836  ops/ms
BenchmarkTestSimple.testJackSon          thrpt   10    7333.661 ±  36.987  ops/ms
BenchmarkTestSimple.testMapStruct        thrpt   10  341577.692 ± 487.573  ops/ms
BenchmarkTestSimple.testOrikaMapper      thrpt   10    2377.357 ±   3.422  ops/ms
BenchmarkTestSimple.testRpasBeanUtils    thrpt   10  340737.565 ± 774.559  ops/ms
BenchmarkTestSimple.testSpringBeanUtils  thrpt   10    1949.802 ±   2.807  ops/ms
```

```java
复杂对象

Benchmark                                  Mode  Cnt      Score     Error   Units
BenchmarkTestComplex.testApacheBeanUtils  thrpt   10     34.609 ±   0.405  ops/ms
BenchmarkTestComplex.testBeanCopier       thrpt   10  24113.092 ± 127.129  ops/ms
BenchmarkTestComplex.testDozerMapping     thrpt   10     96.133 ±   0.676  ops/ms
BenchmarkTestComplex.testFastJson         thrpt   10    226.692 ±   1.215  ops/ms
BenchmarkTestComplex.testGetSet           thrpt   10  24200.668 ±  43.997  ops/ms
BenchmarkTestComplex.testHutoolBeanUtil   thrpt   10     68.630 ±   0.161  ops/ms
BenchmarkTestComplex.testHutoolCglibUtil  thrpt   10  24147.446 ±  80.792  ops/ms
BenchmarkTestComplex.testJackSon          thrpt   10    256.080 ±   2.660  ops/ms
BenchmarkTestComplex.testMapStruct        thrpt   10  24111.832 ± 100.456  ops/ms
BenchmarkTestComplex.testOrikaMapper      thrpt   10   1775.526 ±   1.818  ops/ms
BenchmarkTestComplex.testRpasBeanUtils    thrpt   10  24109.377 ± 160.851  ops/ms
BenchmarkTestComplex.testSpringBeanUtils  thrpt   10     94.354 ±   0.694  ops/ms
```
 2. 数值可视化 

简单对象
::: center
![image-20221117225232188](https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/rpas/image-20221117225232188.png)
:::

从实验结果中我们可以看出`BeanCopier`、`MapStruct`和原生`get/set`效率类似，吞吐量都很接近。

对于本文封装的`RpasBeanUtils`以及热门的`Hutool CglibUtil`，两者效率近似，同时也离`get/set`很接近，本质上这两款均基于BeanCopier封装，其主要性能损耗在弱引用的`Map`缓存上。

同时以上4款工具，在平均差的表现也相对稳定。

对于知名的2组JSON工具类，由于其本身定位不为高频Bean拷贝而设计，所以2者的效率对比前者差出好几倍。`FastJson`在这种场景下也明显快于`Jackson`。

`Orika`虽然采用了字节码技术，但由于其是深拷贝，需要创建新对象的原因，其效率也不尽人意。

其余的知名解决方案`SpringBeanUtils`、`Dozer`、`ApacheBeanUtils`由于采用反射+深拷贝的原因，其效率严重低下。

`Hutool`零依赖自研的`BeanUtil`，在本轮测试结果中同样也存在效率低下的问题。

复杂对象

::: center
![image-20221117225323448](https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/rpas/image-20221117225323448.png)
:::

不同于简单对象测试，对于复杂对象的拷贝尤其考验拷贝工具类的性能，毕竟在拷贝场景中，我们不仅仅只有简单的对象。更有嵌套、多字段、多类型等复杂情况。

从实验结果中可以看出在简单对象排名前5的工具，在复杂对象的拷贝场景下依旧经受住了考验，这5个之间的排名波动可以理解为测试结果的误差性。

继续往下观察，我们可以发现在上一轮实验中，表现比其他好的2组JSON工具类性能出现了明显的下滑，原本高于`JackSon`吞吐量的`FastJson`，在本轮测试中屈居后位。

而`Orika`却在复杂对象拷贝中稳定住了他的位置。

排名最后的4个工具依旧如简单对象拷贝排名类似，性能均很差。
 3. CPU频率图
::: center
![cpu](https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/rpas/cpu.png)
:::

## 结论

通过两组不同类型的对象，我们对12款工具进行了压测实验，最后结果表示`BeanCopier`和`MapStruct`依旧是市场中最顶级的两款工具类，两者均拥有相同于原生`get/set`的性能，在使用时需要考虑使用缓存，两者均是高频Bean拷贝的工具首选。`Hutool CglibUtil`提供了开箱即用的基于`BeanCopier`的拷贝工具，如果没有特殊需求，又不想自己写工具类代码，也是强力的候选工具。如果`Hutool`提供的工具类满足不了项目，可以选择本文中`RpasBeanUtils`，基于`Spring`的弱引用`ConcurrentReferenceHashMap`map，和缓存`Cglib BeanCopier`或`MapStruct`构建工具类，基于巨人的肩膀上，开发者也能快速的构建出适配项目且高性能的工具。同时在该场景下，我们应该避免使用其余基于反射、序列化等技术做出的工具，即使他们已经很出名。

## 附录

1. 如果你的拷贝类中`get/set`含有特殊操作，以上主流的5款高性能的拷贝工具均会无法拷贝对应字段的值，其本质上是由于拷贝本身依赖于干净的`get/set`方法。此时基于反射的工具，例如`SpringBeanUtils`能够对这种特殊操作的实体进行拷贝，本质上是因为反射拷贝不需要依赖`get/set`只需要反射获取字段动态赋值即可，但代价是性能十分低下。建议实体对象中，尽量不修改原始`get/set`，如有实体类特殊需求，采用和`get/set`生成方法不重名方法。 
2. 高性能拷贝的基石是浅拷贝，请确保拷贝后不再对源对象`source`进行修改，即**拷贝时机发生在必要的转换时**，如Controller层返回给前端VO，数据库层对象DO出库给各个接口使用返回DTO，因为源对象`source`的赋值改变会引起目标对象`target`的值变化，拷贝时本身是传递实体引用，如有特殊深拷贝需要可以了解`MapStruct`的`@DeepClone`
3. BeanCopier和MapStruct都是顶尖的工具，在源对象`source`和目标对象`target`字段类型不同，但字段名相同时。可以采用BeanCopier的`Converter`定义转换规则，或采用MapStruct的`@mapping`注解。通常而言MapStruct更为强大，编译期生成get/set让人更加放心，但缺点就是基本的转换也需要写`interface`，而BeanCopier不需要这点，仅在特殊转换时需要写`Converter`。
