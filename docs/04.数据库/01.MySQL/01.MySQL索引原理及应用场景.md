---
title: MySQL索引原理及应用场景
description: MySQL索引总结
categories: 
  - MySQL
tags: 
  - MySQL
  - 索引
  - B+树
keywords: MySQL,索引,B+树
date: 2022-08-02 18:56:07
permalink: /pages/0f7e8e/
---

## 什么是索引

在工作当中，涉及到MySQL的查询，我们经常会遇到给某个表某个字段加索引的诉求，加上索引能够让我们的sql得到查询速度上的提升。但索引的原理是什么呢，他又是怎么工作的，需要开发者对基础知识有一定的了解。

## 索引分类

索引通过特定的一些数据结构，将数据组织有序，将随机I/O变为顺序I/O，有效减少查询一条数据所需要扫描的数据量，加快查询的速度。

从使用者的角度而言，MySQL索引主要为以下几种。

**主键索引**

根据数据表主键建立的索引，不允许重复和空值。主键索引列全表唯一

```sql
alter table 'table_name' add primary key pk_index_name('col_name');
```

**唯一索引**

用于确保建立索引列内的值是唯一的，允许空值。比如同样为age字段，不能出现2个age为10的数据

```sql
alter table 'table_name' add unique unique_index_name('col_name');
```

**普通索引**

用于表中的普通列构建的索引，没有特殊限制

```sql
alter table 'table_name' add index index_name('col_name');
```

**联合索引**

采用多个列组合构建的索引，用于组合搜索

```sql
alter table 'table_name' add index index_name('col1_name','col2_name');
```

**全文索引**

用于大文本对象的列构建索引

```sql
alter table 'table_name' add fulltext index full_index_name('col_name');
```

**空间索引**

用于GIS地图数据的索引，MySQL中的空间数据类型有GEOMETRY、POINT、LINESTRING、POLYGON

```sql
alter table 'table_name' add spatial index spa_index_name('col_name');
```

## 索引数据结构

根据数据结构的不同，MySQL的索引可分为`哈希索引`、`BTree索引`、`B+Tree索引`。

**哈希索引**

哈希索引通过hash表实现，通过将hash函数计算出的hash值存储在索引中，来完成key-value的快速查询

![](https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/mysql-hash.png)

通常而言当发生hash碰撞之后(即两个key在经过hash函数之后值为同一个)，采用链地址法解决冲突，如上图中小刘到小王的连接线，获取key找到索引地址之后，顺序遍历地址内的链表，获得最终结果。

哈希索引的特点和hashmap类似，适合于精确查找，但不适合范围查找，hash码并不具有规律性，所以存储hash索引时顺序性是无法保障的。

**BTree索引**

关于平衡二叉搜索树的概念和意义可以详见我的另一篇文章👉[二叉搜索树及AVL树详解](https://cloud.benym.cn/benym-book/pages/2efaaf/)。

BTree实际上是一棵多叉平衡搜索树。其具有以下特点

::: note

根节点左侧数值小于根节点，根节点右侧数值大于根节点

每个叶子节点高度一致

指针p存储节点的地址信息

非叶子节点为[key,data]二元组，其中key表示作为索引的键，data为key值所在行的数据

:::

BTree的结构如下图所示

![](https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/mysql-btree.png)

在BTree的结构图中，可以发现每个节点不仅仅包含数据的Key值，还有data值。

而每页的存储空间是有限的，如果data比较大，会导致每个节点的Key存储较少。

当数据量扩大时，B树只能往下进行分裂，导致树深的增高，增加了磁盘I/O的次数，影响查询效率。

**B+Tree索引**

为了解决BTree的效率问题，B+Tree做了如下改进

::: note

非叶子节点只存储键值信息，不再存储数据

所有叶子节点之间都有一个链指针，指向下一个叶子节点

数据都存放在叶子节点中

:::

B+Tree的结构如下图所示

![](https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/mysql-b%2Btree.png)

为了更详细的描述B+Tree，图中的指针写明了存储的磁盘块名称，最底下一层含有数据的磁盘块被称为**数据页**，数据页之间通过双向链表进行连接，非叶子节点的磁盘块被称为**索引页**

将上图中磁盘块2与磁盘块5、6、7拿出来进行细分，我们展开各磁盘块，查看单个磁盘块内数据的排列方式

![](https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/mysql-b%2Btree-data.png)

MySQL在存储数据时以数据页为最小单位，且数据在数据页中的存储是**连续**的，数据页中的数据是按照主键排序(如没有主键则由MySQL自身维护的ROW_ID排序)，而数据页与数据页之间则采用**双向链表**关联，数据与数据之间通过**单向链表**关联。

在每个数据页中，必然存在最小主键，每个数据页的最小主键+磁盘块地址会形成一个主键目录，多个主键目录会形成一个索引页(如磁盘块2结构所示)。

::: tip

索引页的出现就是为了解决数据页记录过多，导致主键目录特别大，影响二分查找效率的问题。

与数据页类似，如果一张数据页/索引页存储空间不够，则继续分裂到下一张，即结构图中展示的磁盘块1、2、3、4均为索引页

:::

**那么索引页和数据页到底是多大的大小呢**？

引用一下网络中的解释

> 计算机在存储数据的时候，最小存储单元是扇区，一个扇区的大小是 512 字节，而文件系统（例如 XFS/EXT4）最小单元是块，一个块的大小是 4KB。InnoDB 引擎存储数据的时候，是以页为单位的，每个数据页的大小默认是 16KB，即四个块。

基于该理论，我们可以大致算出B+Tree能够存储的数据。

假设数据库中一条记录是`1KB`，那么一个页就可以存`16`条数据（叶子结点）；对于非叶子结点存储的则是键值+指针，在InnoDB中，一个指针的大小是`6`个字节，假设我们的主键是bigint ，那么主键占`8`个字节，忽略一些其他的头信息大小，大致计算可以得到：

::: center
`16*1024/(8+6)=1170`
:::

即一个非叶子节点可以指向1170个页，那么一个三层的B+Tree可以存储的数据量为：

::: center
`1170*1170*16=21902400`
:::

大约2100万条数据。

在InnoDB存储引擎中，B+Tree的高度一般为2-4 层，这就可以满足千万级的数据的存储，查找数据的时候，一次页的查找代表一次I/O，那我们通过主键索引查询的时候，其实最多只需要2-4次I/O操作就可以了。

## B+Tree的查询过程

还是基于B+Tree的结构图

假设我们要查询`key=16`的数据，通过最顶层索引页的条件，我们知道需要从磁盘块2的索引页进行查询。

依次比较磁盘块2中的`key`值，能够知道`key>=12`的数据均在`p6`指针指向的磁盘块内。

于是我们可以定位到磁盘块7对应的数据页，通过顺序遍历数据页内的单向链表，最终找到`key=16`对应的`data`数据行。

## 聚簇索引与非聚簇索引

作为非常高频的知识点，这两种索引通常会有如下解释

::: note

聚簇索引的叶子节点存储的是键值对应的数据本身

非聚簇索引的叶子节点存储的是键值对应的数据的主键键值

:::

在Innodb中聚簇索引一般默认以主键建立，也称为**主键索引**

非聚簇索引则以其他非主键字段建立，也称为**辅助索引**

以下列数据表为例
::: center
![](https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/mysql-table.png)
:::

如果采用聚簇索引的存储方式(主键为ID)，则对应的索引结构为

![](https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/mysql-clus.png)

可以看出**聚簇索引的数据和索引存储在一起**，根据Id索引能够找到对应的数据行，比如`where Id = 7`这样的条件，聚簇索引能够查到对应主键，获得对应的叶子节点上的行数据。

如果以Name字段建立索引，则对应的辅助索引结构为

![](https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/mysql-noclus.png)

可以看出**非聚簇索引的数据和索引，并非存储在一起**，根据Name索引只能找到Name对应的主键Id，比如`where Name = 张三`，非聚簇索引需要通过**两个步骤**才能获取行数据。

- 第一步，在非聚簇索引的B+Tree中查询对应Name，获得叶子节点上匹配的Name的主键。

- 第二步，根据匹配的主键Id在聚簇索引B+Tree上再执行一次检索，获取叶子节点上的行数据。

整个过程可如下图所示

![](https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/mysql-search.png)

两者的主要区别在于**非聚簇索引会多一次查询聚簇索引的过程**

## 索引优化
### 回表

**回表是什么**？

假设有如下Sql执行

```sql
select * from student where name = '张三';
```

由于查询键为name，所以查询时走辅助索引树，很快就定位到了`Name=张三`的叶子节点，但由于查询条件为`select *`，辅助索引树中并没有包含全表字段，所以会再次根据`Name=张三`的主键Id查询主键索引树。

这个过程和刚才非聚簇索引的查询过程相同，通过辅助索引查询到字段，但仍需要走主键索引补全select信息的过程，叫做**回表**。





