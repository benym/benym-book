---
title: MySQL索引原理及应用场景
description: MySQL索引总结
categories: 
  - MySQL
tags: 
  - MySQL
  - 索引
  - B+树
keywords: MySQL,索引,B+树
date: 2022-08-02 18:56:07
permalink: /pages/0f7e8e/
---

## 什么是索引

在工作当中，涉及到MySQL的查询，我们经常会遇到给某个表某个字段加索引的诉求，加上索引能够让我们的sql得到查询速度上的提升。但索引的原理是什么呢，他又是怎么工作的，需要开发者对基础知识有一定的了解。

## 索引分类

索引通过特定的一些数据结构，将数据组织有序，将随机I/O变为顺序I/O，有效减少查询一条数据所需要扫描的数据量，加快查询的速度。

从使用者的角度而言，MySQL索引主要为以下几种。

**主键索引**

根据数据表主键建立的索引，不允许重复和空值。主键索引列全表唯一

```sql
alter table 'table_name' add primary key pk_index_name('col_name');
```

**唯一索引**

用于确保建立索引列内的值是唯一的，允许空值。比如同样为age字段，不能出现2个age为10的数据

```sql
alter table 'table_name' add unique unique_index_name('col_name');
```

**普通索引**

用于表中的普通列构建的索引，没有特殊限制

```sql
alter table 'table_name' add index index_name('col_name');
```

**联合索引**

采用多个列组合构建的索引，用于组合搜索

```sql
alter table 'table_name' add index index_name('col1_name','col2_name');
```

**全文索引**

用于大文本对象的列构建索引

```sql
alter table 'table_name' add fulltext index full_index_name('col_name');
```

**空间索引**

用于GIS地图数据的索引，MySQL中的空间数据类型有GEOMETRY、POINT、LINESTRING、POLYGON

```sql
alter table 'table_name' add spatial index spa_index_name('col_name');
```

## 索引数据结构

根据数据结构的不同，MySQL的索引可分为`哈希索引`、`BTree索引`、`B+Tree索引`。

**哈希索引**

哈希索引通过hash表实现，通过将hash函数计算出的hash值存储在索引中，来完成key-value的快速查询

![](https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/mysql-hash.png)

通常而言当发生hash碰撞之后(即两个key在经过hash函数之后值为同一个)，采用链地址法解决冲突，如上图中小刘到小王的连接线，获取key找到索引地址之后，顺序遍历地址内的链表，获得最终结果。

哈希索引的特点和hashmap类似，适合于精确查找，但不适合范围查找，hash码并不具有规律性，所以存储hash索引时顺序性是无法保障的。

**BTree索引**

关于平衡二叉搜索树的概念和意义可以详见我的另一篇文章👉[二叉搜索树及AVL树详解](https://cloud.benym.cn/benym-book/pages/2efaaf/)。

B树实际上是一棵多叉平衡搜索树。其具有以下特点

::: note

根节点左侧数值小于根节点，根节点右侧数值大于根节点

每个叶子节点高度一致

指针p存储节点的地址信息

非叶子节点为[key,data]二元组，其中key表示作为索引的键，data为key值所在行的数据

:::

B树的结构如下图所示

![](https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/mysql-btree.png)

在B树的结构图中，可以发现每个节点不仅仅包含数据的Key值，还有data值。

而每页的存储空间是有限的，如果data比较大，会导致每个节点的Key存储较少。

当数据量扩大时，B树只能往下进行分裂，导致树深的增高，增加了磁盘I/O的次数，影响查询效率。

**B+Tree索引**

为了解决B树的效率问题，B+树做了如下改进

::: note

非叶子节点只存储键值信息，不再存储数据

所有叶子节点之间都有一个链指针，指向下一个叶子节点

数据都存放在叶子节点中

:::

B+树的结构如下图所示

![](https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/mysql-b%2Btree.png)

为了更详细的描述B+树，图中的指针写明了存储的磁盘块名称，最底下一层含有数据的磁盘块被称为**数据页**，数据页之间通过双向链表进行连接，非叶子节点的磁盘块被称为**索引页**

将上图中磁盘块2与磁盘块5、6、7拿出来进行细分，我们展开各磁盘块，查看单个磁盘块内数据的排列方式

![](https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/mysql-b%2Btree-data.png)

MySQL在存储数据时以数据页为最小单位，且数据在数据页中的存储是**连续**的，数据页中的数据是按照主键排序(如没有主键则由MySQL自身维护的ROW_ID排序)，而数据页与数据页之间则采用**双向链表**关联，数据与数据之间通过**单向链表**关联。

在每个数据页中，必然存在最小主键，每个数据页的最小主键+磁盘块地址会形成一个主键目录，多个主键目录会形成一个索引页(如磁盘块2结构所示)。

::: tip

索引页的出现就是为了解决数据页记录过多，导致主键目录特别大，影响二分查找效率的问题。

与数据页类似，如果一张数据页/索引页存储空间不够，则继续分裂到下一张，即结构图中展示的磁盘块1、2、3、4均为索引页

:::

**那么索引页和数据页到底是多大的大小呢**？

引用一下网络中的解释

> 计算机在存储数据的时候，最小存储单元是扇区，一个扇区的大小是 512 字节，而文件系统（例如 XFS/EXT4）最小单元是块，一个块的大小是 4KB。InnoDB 引擎存储数据的时候，是以页为单位的，每个数据页的大小默认是 16KB，即四个块。

基于该理论，我们可以大致算出B+树能够存储的数据。

假设数据库中一条记录是`1KB`，那么一个页就可以存`16`条数据（叶子结点）；对于非叶子结点存储的则是键值+指针，在InnoDB中，一个指针的大小是`6`个字节，假设我们的主键是bigint ，那么主键占`8`个字节，忽略一些其他的头信息大小，大致计算可以得到：

::: center
`16*1024/(8+6)=1170`
:::

即一个非叶子节点可以指向1170个页，那么一个三层的B+树可以存储的数据量为：

::: center
`1170*1170*16=21902400`
:::

大约2100万条数据。

在InnoDB存储引擎中，B+树的高度一般为2-4 层，这就可以满足千万级的数据的存储，查找数据的时候，一次页的查找代表一次I/O，那我们通过主键索引查询的时候，其实最多只需要2-4次I/O操作就可以了。

## B+Tree的查询过程

还是基于B+树的结构图

假设我们要查询`key=16`的数据，通过最顶层索引页的条件，我们知道需要从磁盘块2的索引页进行查询。

依次比较磁盘块2中的`key`值，能够知道`key>=12`的数据均在`p6`指针指向的磁盘块内。

于是我们可以定位到磁盘块7对应的数据页，通过顺序遍历数据页内的单向链表，最终找到`key=16`对应的`data`数据行。

## 聚簇索引与非聚簇索引

作为非常高频的知识点，这两种索引通常会有如下解释

::: note

聚簇索引的叶子节点存储的是键值对应的数据本身

非聚簇索引的叶子节点存储的是键值对应的数据的主键键值

:::

在Innodb中聚簇索引一般默认以主键建立，也称为**主键索引**

非聚簇索引则以其他非主键字段建立，也称为**辅助索引**

以下列数据表为例
::: center
![](https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/mysql-table.png)
:::

如果采用聚簇索引的存储方式(主键为ID)，则对应的索引结构为

![](https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/mysql-clus.png)

可以看出**聚簇索引的数据和索引存储在一起**，根据Id索引能够找到对应的数据行，比如`where Id = 7`这样的条件，聚簇索引能够查到对应主键，获得对应的叶子节点上的行数据。

如果以Name字段建立索引，则对应的辅助索引结构为

![](https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/mysql-noclus.png)

可以看出**非聚簇索引的数据和索引，并非存储在一起**，根据Name索引只能找到Name对应的主键Id，比如`where Name = 张三`，非聚簇索引需要通过**两个步骤**才能获取行数据。

- 第一步，在非聚簇索引的B+树中查询对应Name，获得叶子节点上匹配的Name的主键。

- 第二步，根据匹配的主键Id在聚簇索引B+树上再执行一次检索，获取叶子节点上的行数据。

整个过程可如下图所示

![](https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/mysql-search.png)

两者的主要区别在于**非聚簇索引会多一次查询聚簇索引的过程**

## 索引优化
### 回表

**回表是什么**？

假设有如下Sql执行

```sql
select * from student where name = '张三';
```

由于查询键为name，所以查询时走辅助索引树，很快就定位到了`Name=张三`的叶子节点，但由于查询条件为`select *`，辅助索引树中并没有包含全表字段，所以会再次根据`Name=张三`的主键Id查询主键索引树。

这个过程和刚才非聚簇索引的查询过程相同，通过辅助索引查询到字段，但仍需要走主键索引补全select信息的过程，叫做**回表**。

### 索引覆盖

索引覆盖就是执行的sql查询的字段刚好可以命中索引，不需要额外回表

例如

```sql
select id from student where id = 123
```

这样的查询能够命中索引，且索引字段和查询字段匹配

而例如

```sql
select id, name from student where id = 123
```

这样的查询则会回表

### 联合索引

作为下文的基础，这里先说一下联合索引。

假设现在有如下场景，按照市民的身份证号去查询他的家庭地址，这个查询需求在业务中出现的概率不高，但我们也不能让他直接走全表扫描。

如果单独的为一个不频繁的查询请求创建一个索引，感觉又有点浪费资源，这时候就可以通过建立联合索引，减少开销。

假设以数据库的`a`字段和`b`字段建立联合索引，`a`和`b`均为`int`类型字段

```sql
alter table 'table_name' add index index_name('a','b');
```

则生成的联合索引B+树会以联合索引字段共同建立，即联合索引的键值对大于1个

::: center
![](https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/mysql-unindex.png)
:::

将索引的叶子节点按照字段拿出来进行分析，从左至右

a的顺序为: 1, 1, 2, 2, 3, 3

b的顺序为: 1, 2, 1, 4, 1, 2

大家可以发现`a`字段是有序排列，`b`字段是无序排列(因为B+树只能选择一个字段来构建有序的树)

同时通过观察还可以发现，**在a相等的情况下，b字段是有序的**，即此时`a=1`时，`b=1，2`，b保持相对有序。

在平时的sql中，我们经常会有个共识，当要对两个字段进行排序时，首先会按照第一个字段排序，如果第一个字段相等，则用第二个字段排序。

这种共识的原理就是因为，联合多字段建树时B+树的独特构建方式。

### 最左前缀原则

有了联合索引的概念，最左前缀原则就好理解了，由于B+树的建树方式，只有叶子节点存储数据，且叶子节点从左往右排序保持顺序，是最左前缀匹配的根本原因。

如果要查询`a`字段所有以`1`开头的数据，则对应的`sql`条件为`where a like '1%'`。这个时候索引能够用上，查找到第一个符合条件的记录为`ID-1`,然后一直向后遍历，直到不满足条件为止。

再举一个能走联合索引的例子，如`select * from student where a=1 and b=2`。

- 首先a字段在B+树上是有序的，所以我们通过二分查找来定位到a=1的位置，其次在a确定的情况下，b是相对有序的。因为有序，所以我们同样可以通过二分查找找到b=2的位置。此时索引是有效的。


再举一个不能走联合索引的例子，如`select * from student where b=2`。

- b字段有序的前提是：在a确定的情况下，现在查询条件中并没有规定a的范围，所以也无法确定b的顺序，在一棵无序的B+树上是无法用二分查找来定位到b字段的，这个时候索引失效。


### 索引下推

最左前缀可以用在索引中定位记录，那么那些不符合最左前缀的部分会怎么样呢？

还是以联合索引(a, b)为例，假设现在表内有`a,b,c,d...`多个字段，如果现在有一个需求：检索出表中a字段第一个数字为1，且b字段为2，c字段为3的所有数据。那么这条Sql语句则是这么写的：

```sql
select * from student where a like '1%' and b=2 and c=3;
```

根据前缀规则，这个语句在搜索索引树时，只能用`1`，找到第一个满足条件的记录`ID-1`。

之后则需要判断其他条件是否满足。在MySQL5.6之前，只能从ID1开始一个个回表。到主键索引上找出数据行，再对比字段值。

而MySQL5.6引入的索引下推优化(index condition pushdown)，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

这两个过程可如下图所示。

无索引下推过程，均需要回表

::: center
![](https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/mysql-nounder.png)
:::

索引下推过程

::: center
![](https://image-1-1257237419.cos.ap-chongqing.myqcloud.com/img/mysql-under.png)
:::

在这两个图中，每个箭头表示回表一次

在无索引下推过程中，InnoDB只需要观察`a`字段的值，按顺序把`a`字段第一个数值为`1`的记录一条条取出来进行回表，所以总计需要回表2次。

索引下推过程的区别在于，InnoDB在(a, b)索引内部就判断了`b`字段是否等于2，对于不等于2的记录，直接判断并跳过。在这个例子中，只需要对ID-2这一条记录回表取数据判断，只需要回表1次。

### 索引分析

### 索引失效场景

## 参考文章

> 《MySQL45讲》
>
> https://www.cnblogs.com/aaabbbcccddd/p/14864982.html
>
> https://www.jb51.net/article/229580.htm
>
> https://mp.weixin.qq.com/s/SSHWKcuGK5x4Uf7ZBC7stQ
>
> <https://blog.csdn.net/q736317048/article/details/114415571>
>
> <https://www.cnblogs.com/heishuichenzhou/p/10813463.html>
>
> https://mp.weixin.qq.com/s/tD_yDXBYfmLqN3BHmhOnfQ


